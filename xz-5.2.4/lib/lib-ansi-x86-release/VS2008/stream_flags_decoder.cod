; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\stream_flags_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_decoder.c
;	COMDAT _stream_flags_decode
_TEXT	SEGMENT
_options$ = 8						; size = 4
_in$ = 12						; size = 4
_stream_flags_decode PROC				; COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	// Reserved bits must be unset.
; 20   : 	if (in[0] != 0x00 || (in[1] & 0xF0))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00006	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00009	85 c9		 test	 ecx, ecx
  0000b	75 0e		 jne	 SHORT $LN1@stream_fla
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00010	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00014	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00019	74 04		 je	 SHORT $LN2@stream_fla
$LN1@stream_fla:

; 21   : 		return true;

  0001b	b0 01		 mov	 al, 1
  0001d	eb 1b		 jmp	 SHORT $LN3@stream_fla
$LN2@stream_fla:

; 22   : 
; 23   : 	options->version = 0;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00022	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 24   : 	options->check = in[1] & 0x0F;

  00028	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0002b	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0002f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00035	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 25   : 
; 26   : 	return false;

  00038	32 c0		 xor	 al, al
$LN3@stream_fla:

; 27   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_stream_flags_decode ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT _read32le
_TEXT	SEGMENT
_num$ = -4						; size = 4
_buf$ = 8						; size = 4
_read32le PROC						; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 221  : 	uint32_t num = *(const uint32_t *)buf;

  00004	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _num$[ebp], ecx

; 222  : 	return conv32le(num);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _num$[ebp]

; 223  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_read32le ENDP
PUBLIC	_lzma_stream_footer_decode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_decoder.c
;	COMDAT _lzma_stream_footer_decode
_TEXT	SEGMENT
_num$35898 = -12					; size = 4
_num$35894 = -8						; size = 4
_crc$32245 = -4						; size = 4
_options$ = 8						; size = 4
_in$ = 12						; size = 4
_lzma_stream_footer_decode PROC				; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 64   : 	// Magic
; 65   : 	if (memcmp(in + sizeof(uint32_t) * 2 + LZMA_STREAM_FLAGS_SIZE,
; 66   : 			lzma_footer_magic, sizeof(lzma_footer_magic)) != 0)

  00006	6a 02		 push	 2
  00008	68 00 00 00 00	 push	 OFFSET _lzma_footer_magic
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00010	83 c0 0a	 add	 eax, 10			; 0000000aH
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memcmp
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN3@lzma_strea

; 67   : 		return LZMA_FORMAT_ERROR;

  00020	b8 07 00 00 00	 mov	 eax, 7
  00025	e9 8a 00 00 00	 jmp	 $LN4@lzma_strea
$LN3@lzma_strea:

; 68   : 
; 69   : 	// CRC32
; 70   :   {
; 71   : 	const uint32_t crc = lzma_crc32(in + sizeof(uint32_t),
; 72   : 			sizeof(uint32_t) + LZMA_STREAM_FLAGS_SIZE, 0);

  0002a	6a 00		 push	 0
  0002c	6a 06		 push	 6
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  00031	83 c1 04	 add	 ecx, 4
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _lzma_crc32
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	89 45 fc	 mov	 DWORD PTR _crc$32245[ebp], eax

; 73   : 	if (crc != unaligned_read32le(in))

  00040	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	89 45 f8	 mov	 DWORD PTR _num$35894[ebp], eax
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _crc$32245[ebp]
  0004b	3b 4d f8	 cmp	 ecx, DWORD PTR _num$35894[ebp]
  0004e	74 07		 je	 SHORT $LN2@lzma_strea

; 74   : 		return LZMA_DATA_ERROR;

  00050	b8 09 00 00 00	 mov	 eax, 9
  00055	eb 5d		 jmp	 SHORT $LN4@lzma_strea
$LN2@lzma_strea:

; 75   :   }
; 76   : 
; 77   : 	// Stream Flags
; 78   : 	if (stream_flags_decode(options, in + sizeof(uint32_t) * 2))

  00057	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0005a	83 c2 08	 add	 edx, 8
  0005d	52		 push	 edx
  0005e	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _stream_flags_decode
  00067	83 c4 08	 add	 esp, 8
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 07		 je	 SHORT $LN1@lzma_strea

; 79   : 		return LZMA_OPTIONS_ERROR;

  00071	b8 08 00 00 00	 mov	 eax, 8
  00076	eb 3c		 jmp	 SHORT $LN4@lzma_strea
$LN1@lzma_strea:

; 80   : 
; 81   : 	// Backward Size
; 82   : 	options->backward_size = unaligned_read32le(in + sizeof(uint32_t));

  00078	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0007b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007e	89 45 f4	 mov	 DWORD PTR _num$35898[ebp], eax
  00081	8b 4d f4	 mov	 ecx, DWORD PTR _num$35898[ebp]
  00084	33 d2		 xor	 edx, edx
  00086	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00089	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 83   : 	options->backward_size = (options->backward_size + 1) * 4;

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00092	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00095	83 c2 01	 add	 edx, 1
  00098	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0009b	83 d0 00	 adc	 eax, 0
  0009e	6a 00		 push	 0
  000a0	6a 04		 push	 4
  000a2	50		 push	 eax
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 __allmul
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  000ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000af	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 84   : 
; 85   : 	return LZMA_OK;

  000b2	33 c0		 xor	 eax, eax
$LN4@lzma_strea:

; 86   : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_lzma_stream_footer_decode ENDP
_TEXT	ENDS
PUBLIC	_lzma_stream_header_decode
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_header_decode
_TEXT	SEGMENT
_num$35903 = -8						; size = 4
_crc$32235 = -4						; size = 4
_options$ = 8						; size = 4
_in$ = 12						; size = 4
_lzma_stream_header_decode PROC				; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 33   : 	// Magic
; 34   : 	if (memcmp(in, lzma_header_magic, sizeof(lzma_header_magic)) != 0)

  00006	6a 06		 push	 6
  00008	68 00 00 00 00	 push	 OFFSET _lzma_header_magic
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memcmp
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN3@lzma_strea@2

; 35   : 		return LZMA_FORMAT_ERROR;

  0001d	b8 07 00 00 00	 mov	 eax, 7
  00022	eb 62		 jmp	 SHORT $LN4@lzma_strea@2
$LN3@lzma_strea@2:

; 36   : 
; 37   : 	// Verify the CRC32 so we can distinguish between corrupt
; 38   : 	// and unsupported files.
; 39   :   {
; 40   : 	const uint32_t crc = lzma_crc32(in + sizeof(lzma_header_magic),
; 41   : 			LZMA_STREAM_FLAGS_SIZE, 0);

  00024	6a 00		 push	 0
  00026	6a 02		 push	 2
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  0002b	83 c1 06	 add	 ecx, 6
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _lzma_crc32
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	89 45 fc	 mov	 DWORD PTR _crc$32235[ebp], eax

; 42   : 	if (crc != unaligned_read32le(in + sizeof(lzma_header_magic)
; 43   : 			+ LZMA_STREAM_FLAGS_SIZE))

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	89 45 f8	 mov	 DWORD PTR _num$35903[ebp], eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _crc$32235[ebp]
  00046	3b 4d f8	 cmp	 ecx, DWORD PTR _num$35903[ebp]
  00049	74 07		 je	 SHORT $LN2@lzma_strea@2

; 44   : 		return LZMA_DATA_ERROR;

  0004b	b8 09 00 00 00	 mov	 eax, 9
  00050	eb 34		 jmp	 SHORT $LN4@lzma_strea@2
$LN2@lzma_strea@2:

; 45   :   }
; 46   : 
; 47   : 	// Stream Flags
; 48   : 	if (stream_flags_decode(options, in + sizeof(lzma_header_magic)))

  00052	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00055	83 c2 06	 add	 edx, 6
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _stream_flags_decode
  00062	83 c4 08	 add	 esp, 8
  00065	0f b6 c8	 movzx	 ecx, al
  00068	85 c9		 test	 ecx, ecx
  0006a	74 07		 je	 SHORT $LN1@lzma_strea@2

; 49   : 		return LZMA_OPTIONS_ERROR;

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	eb 13		 jmp	 SHORT $LN4@lzma_strea@2
$LN1@lzma_strea@2:

; 50   : 
; 51   : 	// Set Backward Size to indicate unknown value. That way
; 52   : 	// lzma_stream_flags_compare() can be used to compare Stream Header
; 53   : 	// and Stream Footer while keeping it useful also for comparing
; 54   : 	// two Stream Footers.
; 55   : 	options->backward_size = LZMA_VLI_UNKNOWN;

  00073	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00076	c7 42 08 ff ff
	ff ff		 mov	 DWORD PTR [edx+8], -1
  0007d	c7 42 0c ff ff
	ff ff		 mov	 DWORD PTR [edx+12], -1

; 56   : 
; 57   : 	return LZMA_OK;

  00084	33 c0		 xor	 eax, eax
$LN4@lzma_strea@2:

; 58   : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_lzma_stream_header_decode ENDP
END
