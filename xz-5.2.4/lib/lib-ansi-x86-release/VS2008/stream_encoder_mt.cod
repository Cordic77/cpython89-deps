; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\stream_encoder_mt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__beginthreadex:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
?in_chunk_max@?9??worker_encode@@9@9 DD 04000H		; `worker_encode'::`10'::in_chunk_max
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\outqueue.h
;	COMDAT _lzma_outq_is_empty
_TEXT	SEGMENT
_outq$ = 8						; size = 4
_lzma_outq_is_empty PROC				; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  : 	return outq->bufs_used == 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000c	0f 94 c1	 sete	 cl
  0000f	8a c1		 mov	 al, cl

; 156  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_lzma_outq_is_empty ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lzma_outq_has_buf
_TEXT	SEGMENT
_outq$ = 8						; size = 4
_lzma_outq_has_buf PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  : 	return outq->bufs_used < outq->bufs_allocated;

  00003	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00009	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000c	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax

; 148  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_lzma_outq_has_buf ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
_TEXT	ENDS
;	COMDAT _mythread_condtime_set
_TEXT	SEGMENT
_condtime$ = 8						; size = 4
_cond$ = 12						; size = 4
_timeout$ = 16						; size = 4
_mythread_condtime_set PROC				; COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 	(void)cond;
; 519  : 	condtime->start = GetTickCount();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _condtime$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 520  : 	condtime->timeout = timeout;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _condtime$[ebp]
  00011	8b 45 10	 mov	 eax, DWORD PTR _timeout$[ebp]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 521  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_mythread_condtime_set ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_cond_timedwait
_TEXT	SEGMENT
tv71 = -16						; size = 4
_timeout$31131 = -12					; size = 4
_ret$31132 = -8						; size = 4
_elapsed$31130 = -4					; size = 4
_cond$ = 8						; size = 4
_mutex$ = 12						; size = 4
_condtime$ = 16						; size = 4
_mythread_cond_timedwait PROC				; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 490  : #ifdef MYTHREAD_WIN95
; 491  : 	LeaveCriticalSection(mutex);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _mutex$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 492  : #endif
; 493  : 
; 494  :   {
; 495  : 	DWORD elapsed = GetTickCount() - condtime->start;

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _condtime$[ebp]
  00019	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001b	89 45 fc	 mov	 DWORD PTR _elapsed$31130[ebp], eax

; 496  : 	DWORD timeout = elapsed >= condtime->timeout
; 497  : 			? 0 : condtime->timeout - elapsed;

  0001e	8b 55 10	 mov	 edx, DWORD PTR _condtime$[ebp]
  00021	8b 45 fc	 mov	 eax, DWORD PTR _elapsed$31130[ebp]
  00024	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00027	72 09		 jb	 SHORT $LN3@mythread_c
  00029	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00030	eb 0c		 jmp	 SHORT $LN4@mythread_c
$LN3@mythread_c:
  00032	8b 4d 10	 mov	 ecx, DWORD PTR _condtime$[ebp]
  00035	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00038	2b 55 fc	 sub	 edx, DWORD PTR _elapsed$31130[ebp]
  0003b	89 55 f0	 mov	 DWORD PTR tv71[ebp], edx
$LN4@mythread_c:
  0003e	8b 45 f0	 mov	 eax, DWORD PTR tv71[ebp]
  00041	89 45 f4	 mov	 DWORD PTR _timeout$31131[ebp], eax

; 498  : 
; 499  : #ifdef MYTHREAD_WIN95
; 500  : 	DWORD ret = WaitForSingleObject(*cond, timeout);

  00044	8b 4d f4	 mov	 ecx, DWORD PTR _timeout$31131[ebp]
  00047	51		 push	 ecx
  00048	8b 55 08	 mov	 edx, DWORD PTR _cond$[ebp]
  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00054	89 45 f8	 mov	 DWORD PTR _ret$31132[ebp], eax

; 501  : 	assert(ret == WAIT_OBJECT_0 || ret == WAIT_TIMEOUT);
; 502  : 
; 503  : 	EnterCriticalSection(mutex);

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _mutex$[ebp]
  0005a	51		 push	 ecx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 504  : 
; 505  : 	return ret == WAIT_TIMEOUT;

  00061	33 c0		 xor	 eax, eax
  00063	81 7d f8 02 01
	00 00		 cmp	 DWORD PTR _ret$31132[ebp], 258 ; 00000102H
  0006a	0f 94 c0	 sete	 al

; 506  : #else
; 507  : 	BOOL ret = SleepConditionVariableCS(cond, mutex, timeout);
; 508  : 	assert(ret || GetLastError() == ERROR_TIMEOUT);
; 509  : 	return !ret;
; 510  : #endif
; 511  :   }
; 512  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_mythread_cond_timedwait ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_cond_wait
_TEXT	SEGMENT
_cond$ = 8						; size = 4
_mutex$ = 12						; size = 4
_mythread_cond_wait PROC				; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 475  : #ifdef MYTHREAD_WIN95
; 476  : 	LeaveCriticalSection(mutex);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mutex$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 477  : 	WaitForSingleObject(*cond, INFINITE);

  0000d	6a ff		 push	 -1
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _cond$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 478  : 	EnterCriticalSection(mutex);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _mutex$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 479  : #else
; 480  : 	BOOL ret = SleepConditionVariableCS(cond, mutex, INFINITE);
; 481  : 	assert(ret);
; 482  : 	(void)ret;
; 483  : #endif
; 484  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_mythread_cond_wait ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_cond_signal
_TEXT	SEGMENT
_cond$ = 8						; size = 4
_mythread_cond_signal PROC				; COMDAT

; 464  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 465  : #ifdef MYTHREAD_WIN95
; 466  : 	SetEvent(*cond);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cond$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 467  : #else
; 468  : 	WakeConditionVariable(cond);
; 469  : #endif
; 470  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mythread_cond_signal ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_cond_destroy
_TEXT	SEGMENT
_cond$ = 8						; size = 4
_mythread_cond_destroy PROC				; COMDAT

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 455  : #ifdef MYTHREAD_WIN95
; 456  : 	CloseHandle(*cond);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cond$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 457  : #else
; 458  : 	(void)cond;
; 459  : #endif
; 460  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mythread_cond_destroy ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_cond_init
_TEXT	SEGMENT
_cond$ = 8						; size = 4
_mythread_cond_init PROC				; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : #ifdef MYTHREAD_WIN95
; 444  : 	*cond = CreateEvent(NULL, FALSE, FALSE, NULL);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _cond$[ebp]
  00014	89 01		 mov	 DWORD PTR [ecx], eax

; 445  : 	return *cond == NULL ? -1 : 0;

  00016	8b 55 08	 mov	 edx, DWORD PTR _cond$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	f7 d8		 neg	 eax
  00021	83 e8 01	 sub	 eax, 1

; 446  : #else
; 447  : 	InitializeConditionVariable(cond);
; 448  : 	return 0;
; 449  : #endif
; 450  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_mythread_cond_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_mutex_unlock
_TEXT	SEGMENT
_mutex$ = 8						; size = 4
_mythread_mutex_unlock PROC				; COMDAT

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 436  : 	LeaveCriticalSection(mutex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _mutex$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 437  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_mythread_mutex_unlock ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_mutex_lock
_TEXT	SEGMENT
_mutex$ = 8						; size = 4
_mythread_mutex_lock PROC				; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 430  : 	EnterCriticalSection(mutex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _mutex$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 431  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_mythread_mutex_lock ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_mutex_destroy
_TEXT	SEGMENT
_mutex$ = 8						; size = 4
_mythread_mutex_destroy PROC				; COMDAT

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 424  : 	DeleteCriticalSection(mutex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _mutex$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 425  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_mythread_mutex_destroy ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_mutex_init
_TEXT	SEGMENT
_mutex$ = 8						; size = 4
_mythread_mutex_init PROC				; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  : 	InitializeCriticalSection(mutex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _mutex$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 418  : 	return 0;

  0000d	33 c0		 xor	 eax, eax

; 419  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mythread_mutex_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_join
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_thread$ = 8						; size = 4
_mythread_join PROC					; COMDAT

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 402  : 	int ret = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 403  : 
; 404  : 	if (WaitForSingleObject(thread, INFINITE) != WAIT_OBJECT_0)

  0000b	6a ff		 push	 -1
  0000d	8b 45 08	 mov	 eax, DWORD PTR _thread$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN2@mythread_j

; 405  : 		ret = -1;

  0001b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN2@mythread_j:

; 406  : 
; 407  : 	if (!CloseHandle(thread))

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _thread$[ebp]
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0002c	85 c0		 test	 eax, eax
  0002e	75 07		 jne	 SHORT $LN1@mythread_j

; 408  : 		ret = -1;

  00030	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN1@mythread_j:

; 409  : 
; 410  : 	return ret;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 411  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_mythread_join ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mythread_create
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_thread$ = 8						; size = 4
_func$ = 12						; size = 4
_arg$ = 16						; size = 4
_mythread_create PROC					; COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 391  : 	uintptr_t ret = _beginthreadex(NULL, 0, func, arg, 0, NULL);

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	8b 45 10	 mov	 eax, DWORD PTR _arg$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  0000f	51		 push	 ecx
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	e8 00 00 00 00	 call	 __beginthreadex
  00019	83 c4 18	 add	 esp, 24			; 00000018H
  0001c	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 392  : 	if (ret == 0)

  0001f	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00023	75 05		 jne	 SHORT $LN1@mythread_c@2

; 393  : 		return -1;

  00025	83 c8 ff	 or	 eax, -1
  00028	eb 0a		 jmp	 SHORT $LN2@mythread_c@2
$LN1@mythread_c@2:

; 394  : 
; 395  : 	*thread = (HANDLE)ret;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _thread$[ebp]
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax

; 396  : 	return 0;

  00032	33 c0		 xor	 eax, eax
$LN2@mythread_c@2:

; 397  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_mythread_create ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
;	COMDAT _get_progress
_TEXT	SEGMENT
tv88 = -40						; size = 4
tv69 = -36						; size = 4
$T78255 = -32						; size = 4
$T78251 = -28						; size = 4
_mythread_j_970$32799 = -24				; size = 4
_mythread_i_970$32798 = -20				; size = 4
_i$32794 = -16						; size = 4
_coder$ = -12						; size = 4
_mythread_i_964$ = -8					; size = 4
_mythread_j_964$ = -4					; size = 4
_coder_ptr$ = 8						; size = 4
_progress_in$ = 12					; size = 4
_progress_out$ = 16					; size = 4
_get_progress PROC					; COMDAT

; 959  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 960  : 	lzma_stream_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 f4	 mov	 DWORD PTR _coder$[ebp], eax

; 961  : 
; 962  : 	// Lock coder->mutex to prevent finishing threads from moving their
; 963  : 	// progress info from the worker_thread structure to lzma_stream_coder.
; 964  : 	mythread_sync(coder->mutex) {

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_964$[ebp], 0
  00014	eb 07		 jmp	 SHORT $LN15@get_progre
$LN14@get_progre:
  00016	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_964$[ebp], 1
$LN15@get_progre:
  0001d	83 7d f8 00	 cmp	 DWORD PTR _mythread_i_964$[ebp], 0
  00021	74 19		 je	 SHORT $LN18@get_progre
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00026	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00033	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0003a	eb 17		 jmp	 SHORT $LN19@get_progre
$LN18@get_progre:
  0003c	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0003f	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0004c	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$LN19@get_progre:
  00053	83 7d dc 00	 cmp	 DWORD PTR tv69[ebp], 0
  00057	0f 84 64 01 00
	00		 je	 $LN16@get_progre
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mythread_j_964$[ebp], 0
  00064	eb 07		 jmp	 SHORT $LN12@get_progre
$LN11@get_progre:
  00066	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _mythread_j_964$[ebp], 1
$LN12@get_progre:
  0006d	83 7d fc 00	 cmp	 DWORD PTR _mythread_j_964$[ebp], 0
  00071	0f 85 45 01 00
	00		 jne	 $LN10@get_progre

; 965  : 		*progress_in = coder->progress_in;

  00077	8b 45 0c	 mov	 eax, DWORD PTR _progress_in$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007d	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [ecx+272]
  00083	89 10		 mov	 DWORD PTR [eax], edx
  00085	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [ecx+276]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 966  : 		*progress_out = coder->progress_out;

  0008e	8b 55 10	 mov	 edx, DWORD PTR _progress_out$[ebp]
  00091	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00094	8b 88 18 01 00
	00		 mov	 ecx, DWORD PTR [eax+280]
  0009a	89 0a		 mov	 DWORD PTR [edx], ecx
  0009c	8b 80 1c 01 00
	00		 mov	 eax, DWORD PTR [eax+284]
  000a2	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 967  : 
; 968  :       { size_t i;
; 969  : 		for (i = 0; i < coder->threads_initialized; ++i) {

  000a5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$32794[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN9@get_progre
$LN8@get_progre:
  000ae	8b 4d f0	 mov	 ecx, DWORD PTR _i$32794[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d f0	 mov	 DWORD PTR _i$32794[ebp], ecx
$LN9@get_progre:
  000b7	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  000ba	8b 45 f0	 mov	 eax, DWORD PTR _i$32794[ebp]
  000bd	3b 82 04 01 00
	00		 cmp	 eax, DWORD PTR [edx+260]
  000c3	0f 83 ee 00 00
	00		 jae	 $LN7@get_progre

; 970  : 			mythread_sync(coder->threads[i].mutex) {

  000c9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_i_970$32798[ebp], 0
  000d0	eb 07		 jmp	 SHORT $LN6@get_progre
$LN5@get_progre:
  000d2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_i_970$32798[ebp], 1
$LN6@get_progre:
  000d9	83 7d ec 00	 cmp	 DWORD PTR _mythread_i_970$32798[ebp], 0
  000dd	74 2f		 je	 SHORT $LN20@get_progre
  000df	8b 4d f0	 mov	 ecx, DWORD PTR _i$32794[ebp]
  000e2	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  000e8	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  000eb	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  000f1	8d 8c 08 1c 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+284]
  000f8	89 4d e4	 mov	 DWORD PTR $T78251[ebp], ecx
  000fb	8b 55 e4	 mov	 edx, DWORD PTR $T78251[ebp]
  000fe	52		 push	 edx
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00105	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
  0010c	eb 2d		 jmp	 SHORT $LN21@get_progre
$LN20@get_progre:
  0010e	8b 45 f0	 mov	 eax, DWORD PTR _i$32794[ebp]
  00111	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  00117	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  0011a	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00120	8d 84 02 1c 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+284]
  00127	89 45 e0	 mov	 DWORD PTR $T78255[ebp], eax
  0012a	8b 4d e0	 mov	 ecx, DWORD PTR $T78255[ebp]
  0012d	51		 push	 ecx
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00134	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$LN21@get_progre:
  0013b	83 7d d8 00	 cmp	 DWORD PTR tv88[ebp], 0
  0013f	74 71		 je	 SHORT $LN4@get_progre
  00141	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mythread_j_970$32799[ebp], 0
  00148	eb 07		 jmp	 SHORT $LN3@get_progre
$LN2@get_progre:
  0014a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _mythread_j_970$32799[ebp], 1
$LN3@get_progre:
  00151	83 7d e8 00	 cmp	 DWORD PTR _mythread_j_970$32799[ebp], 0
  00155	75 56		 jne	 SHORT $LN1@get_progre

; 971  : 				*progress_in += coder->threads[i].progress_in;

  00157	8b 55 f0	 mov	 edx, DWORD PTR _i$32794[ebp]
  0015a	69 d2 40 01 00
	00		 imul	 edx, 320		; 00000140H
  00160	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00163	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  00169	8b 45 0c	 mov	 eax, DWORD PTR _progress_in$[ebp]
  0016c	8b 30		 mov	 esi, DWORD PTR [eax]
  0016e	03 74 11 18	 add	 esi, DWORD PTR [ecx+edx+24]
  00172	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00175	13 44 11 1c	 adc	 eax, DWORD PTR [ecx+edx+28]
  00179	8b 4d 0c	 mov	 ecx, DWORD PTR _progress_in$[ebp]
  0017c	89 31		 mov	 DWORD PTR [ecx], esi
  0017e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 972  : 				*progress_out += coder->threads[i]
; 973  : 						.progress_out;

  00181	8b 55 f0	 mov	 edx, DWORD PTR _i$32794[ebp]
  00184	69 d2 40 01 00
	00		 imul	 edx, 320		; 00000140H
  0018a	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0018d	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  00193	8b 45 10	 mov	 eax, DWORD PTR _progress_out$[ebp]
  00196	8b 30		 mov	 esi, DWORD PTR [eax]
  00198	03 74 11 20	 add	 esi, DWORD PTR [ecx+edx+32]
  0019c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019f	13 44 11 24	 adc	 eax, DWORD PTR [ecx+edx+36]
  001a3	8b 4d 10	 mov	 ecx, DWORD PTR _progress_out$[ebp]
  001a6	89 31		 mov	 DWORD PTR [ecx], esi
  001a8	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001ab	eb 9d		 jmp	 SHORT $LN2@get_progre
$LN1@get_progre:

; 974  : 			}

  001ad	e9 20 ff ff ff	 jmp	 $LN5@get_progre
$LN4@get_progre:

; 975  :         }

  001b2	e9 f7 fe ff ff	 jmp	 $LN8@get_progre
$LN7@get_progre:

; 976  :       }
; 977  : 	}

  001b7	e9 aa fe ff ff	 jmp	 $LN11@get_progre
$LN10@get_progre:
  001bc	e9 55 fe ff ff	 jmp	 $LN14@get_progre
$LN16@get_progre:

; 978  : 
; 979  : 	return;
; 980  : }

  001c1	5e		 pop	 esi
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
_get_progress ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_options
_TEXT	SEGMENT
tv187 = -16						; size = 4
tv166 = -12						; size = 4
tv144 = -8						; size = 4
tv139 = -4						; size = 4
_options$ = 8						; size = 4
_opt_easy$ = 12						; size = 4
_filters$ = 16						; size = 4
_block_size$ = 20					; size = 4
_outbuf_size_max$ = 24					; size = 4
_get_options PROC					; COMDAT

; 911  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 912  : 	// Validate some of the options.
; 913  : 	if (options == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _options$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN11@get_option@2

; 914  : 		return LZMA_PROG_ERROR;

  0000c	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00011	e9 1e 01 00 00	 jmp	 $LN12@get_option@2
$LN11@get_option@2:

; 915  : 
; 916  : 	if (options->flags != 0 || options->threads == 0
; 917  : 			|| options->threads > LZMA_THREADS_MAX)

  00016	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00019	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001c	75 15		 jne	 SHORT $LN9@get_option@2
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00021	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00025	74 0c		 je	 SHORT $LN9@get_option@2
  00027	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0002a	81 7a 04 00 40
	00 00		 cmp	 DWORD PTR [edx+4], 16384 ; 00004000H
  00031	76 0a		 jbe	 SHORT $LN10@get_option@2
$LN9@get_option@2:

; 918  : 		return LZMA_OPTIONS_ERROR;

  00033	b8 08 00 00 00	 mov	 eax, 8
  00038	e9 f7 00 00 00	 jmp	 $LN12@get_option@2
$LN10@get_option@2:

; 919  : 
; 920  : 	if (options->filters != NULL) {

  0003d	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00040	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00044	74 0d		 je	 SHORT $LN8@get_option@2

; 921  : 		// Filter chain was given, use it as is.
; 922  : 		*filters = options->filters;

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0004c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax

; 923  : 	} else {

  00051	eb 2c		 jmp	 SHORT $LN7@get_option@2
$LN8@get_option@2:

; 924  : 		// Use a preset.
; 925  : 		if (lzma_easy_preset(opt_easy, options->preset))

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00056	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00059	52		 push	 edx
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _opt_easy$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _lzma_easy_preset
  00063	83 c4 08	 add	 esp, 8
  00066	0f b6 c8	 movzx	 ecx, al
  00069	85 c9		 test	 ecx, ecx
  0006b	74 0a		 je	 SHORT $LN6@get_option@2

; 926  : 			return LZMA_OPTIONS_ERROR;

  0006d	b8 08 00 00 00	 mov	 eax, 8
  00072	e9 bd 00 00 00	 jmp	 $LN12@get_option@2
$LN6@get_option@2:

; 927  : 
; 928  : 		*filters = opt_easy->filters;

  00077	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  0007a	8b 45 0c	 mov	 eax, DWORD PTR _opt_easy$[ebp]
  0007d	89 02		 mov	 DWORD PTR [edx], eax
$LN7@get_option@2:

; 929  : 	}
; 930  : 
; 931  : 	// Block size
; 932  : 	if (options->block_size > 0) {

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00082	89 4d fc	 mov	 DWORD PTR tv139[ebp], ecx
  00085	8b 55 fc	 mov	 edx, DWORD PTR tv139[ebp]
  00088	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0008c	77 09		 ja	 SHORT $LN14@get_option@2
  0008e	8b 45 fc	 mov	 eax, DWORD PTR tv139[ebp]
  00091	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00095	76 37		 jbe	 SHORT $LN5@get_option@2
$LN14@get_option@2:

; 933  : 		if (options->block_size > BLOCK_SIZE_MAX)

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0009a	89 4d f8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 f8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	81 7a 0c ff ff
	03 00		 cmp	 DWORD PTR [edx+12], 262143 ; 0003ffffH
  000a7	72 12		 jb	 SHORT $LN4@get_option@2
  000a9	77 09		 ja	 SHORT $LN15@get_option@2
  000ab	8b 45 f8	 mov	 eax, DWORD PTR tv144[ebp]
  000ae	83 78 08 ff	 cmp	 DWORD PTR [eax+8], -1
  000b2	76 07		 jbe	 SHORT $LN4@get_option@2
$LN15@get_option@2:

; 934  : 			return LZMA_OPTIONS_ERROR;

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	eb 79		 jmp	 SHORT $LN12@get_option@2
$LN4@get_option@2:

; 935  : 
; 936  : 		*block_size = options->block_size;

  000bb	8b 4d 14	 mov	 ecx, DWORD PTR _block_size$[ebp]
  000be	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  000c1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c4	89 01		 mov	 DWORD PTR [ecx], eax
  000c6	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000c9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 937  : 	} else {

  000cc	eb 30		 jmp	 SHORT $LN3@get_option@2
$LN5@get_option@2:

; 938  : 		// Determine the Block size from the filter chain.
; 939  : 		*block_size = lzma_mt_block_size(*filters);

  000ce	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _lzma_mt_block_size
  000d9	83 c4 04	 add	 esp, 4
  000dc	8b 4d 14	 mov	 ecx, DWORD PTR _block_size$[ebp]
  000df	89 01		 mov	 DWORD PTR [ecx], eax
  000e1	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 940  : 		if (*block_size == 0)

  000e4	8b 55 14	 mov	 edx, DWORD PTR _block_size$[ebp]
  000e7	89 55 f4	 mov	 DWORD PTR tv166[ebp], edx
  000ea	8b 45 f4	 mov	 eax, DWORD PTR tv166[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR tv166[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	0b 51 04	 or	 edx, DWORD PTR [ecx+4]
  000f5	75 07		 jne	 SHORT $LN3@get_option@2

; 941  : 			return LZMA_OPTIONS_ERROR;

  000f7	b8 08 00 00 00	 mov	 eax, 8
  000fc	eb 36		 jmp	 SHORT $LN12@get_option@2
$LN3@get_option@2:

; 942  : 
; 943  : 		assert(*block_size <= BLOCK_SIZE_MAX);
; 944  : 	}
; 945  : 
; 946  : 	// Calculate the maximum amount output that a single output buffer
; 947  : 	// may need to hold. This is the same as the maximum total size of
; 948  : 	// a Block.
; 949  : 	*outbuf_size_max = lzma_block_buffer_bound64(*block_size);

  000fe	8b 45 14	 mov	 eax, DWORD PTR _block_size$[ebp]
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	51		 push	 ecx
  00105	8b 10		 mov	 edx, DWORD PTR [eax]
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _lzma_block_buffer_bound64
  0010d	83 c4 08	 add	 esp, 8
  00110	8b 4d 18	 mov	 ecx, DWORD PTR _outbuf_size_max$[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
  00115	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 950  : 	if (*outbuf_size_max == 0)

  00118	8b 55 18	 mov	 edx, DWORD PTR _outbuf_size_max$[ebp]
  0011b	89 55 f0	 mov	 DWORD PTR tv187[ebp], edx
  0011e	8b 45 f0	 mov	 eax, DWORD PTR tv187[ebp]
  00121	8b 4d f0	 mov	 ecx, DWORD PTR tv187[ebp]
  00124	8b 10		 mov	 edx, DWORD PTR [eax]
  00126	0b 51 04	 or	 edx, DWORD PTR [ecx+4]
  00129	75 07		 jne	 SHORT $LN1@get_option@2

; 951  : 		return LZMA_MEM_ERROR;

  0012b	b8 05 00 00 00	 mov	 eax, 5
  00130	eb 02		 jmp	 SHORT $LN12@get_option@2
$LN1@get_option@2:

; 952  : 
; 953  : 	return LZMA_OK;

  00132	33 c0		 xor	 eax, eax
$LN12@get_option@2:

; 954  : }

  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
_get_options ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _wait_for_work
_TEXT	SEGMENT
tv78 = -40						; size = 4
$T78282 = -36						; size = 4
$T78275 = -20						; size = 4
$T78265 = -16						; size = 4
_mythread_j_676$32655 = -12				; size = 4
_mythread_i_676$32654 = -8				; size = 4
_timed_out$32653 = -1					; size = 1
_coder$ = 8						; size = 4
_wait_abs$ = 12						; size = 4
_has_blocked$ = 16					; size = 4
_has_input$ = 20					; size = 1
_wait_for_work PROC					; COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 659  : 	if (coder->timeout != 0 && !*has_blocked) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  00010	74 30		 je	 SHORT $LN12@wait_for_w
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _has_blocked$[ebp]
  00015	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00018	85 d2		 test	 edx, edx
  0001a	75 26		 jne	 SHORT $LN12@wait_for_w

; 660  : 		// Every time when stream_encode_mt() is called via
; 661  : 		// lzma_code(), *has_blocked starts as false. We set it
; 662  : 		// to true here and calculate the absolute time when
; 663  : 		// we must return if there's nothing to do.
; 664  : 		//
; 665  : 		// The idea of *has_blocked is to avoid unneeded calls
; 666  : 		// to mythread_condtime_set(), which may do a syscall
; 667  : 		// depending on the operating system.
; 668  : 		*has_blocked = true;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _has_blocked$[ebp]
  0001f	c6 00 01	 mov	 BYTE PTR [eax], 1

; 669  : 		mythread_condtime_set(wait_abs, &coder->cond, coder->timeout);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00025	8b 91 f4 00 00
	00		 mov	 edx, DWORD PTR [ecx+244]
  0002b	89 55 f0	 mov	 DWORD PTR $T78265[ebp], edx
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _wait_abs$[ebp]
  00037	89 01		 mov	 DWORD PTR [ecx], eax
  00039	8b 55 0c	 mov	 edx, DWORD PTR _wait_abs$[ebp]
  0003c	8b 45 f0	 mov	 eax, DWORD PTR $T78265[ebp]
  0003f	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN12@wait_for_w:

; 670  : 	}
; 671  : 
; 672  :   {
; 673  : 	bool timed_out = false;

  00042	c6 45 ff 00	 mov	 BYTE PTR _timed_out$32653[ebp], 0

; 674  : 
; 675  :   {
; 676  : 	mythread_sync(coder->mutex) {

  00046	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_676$32654[ebp], 0
  0004d	eb 07		 jmp	 SHORT $LN11@wait_for_w
$LN10@wait_for_w:
  0004f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_676$32654[ebp], 1
$LN11@wait_for_w:
  00056	83 7d f8 00	 cmp	 DWORD PTR _mythread_i_676$32654[ebp], 0
  0005a	74 19		 je	 SHORT $LN15@wait_for_w
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005f	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00065	51		 push	 ecx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0006c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00073	eb 17		 jmp	 SHORT $LN16@wait_for_w
$LN15@wait_for_w:
  00075	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00078	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  0007e	52		 push	 edx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00085	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN16@wait_for_w:
  0008c	83 7d d8 00	 cmp	 DWORD PTR tv78[ebp], 0
  00090	0f 84 fd 00 00
	00		 je	 $LN9@wait_for_w
  00096	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mythread_j_676$32655[ebp], 0
  0009d	eb 07		 jmp	 SHORT $LN8@wait_for_w
$LN7@wait_for_w:
  0009f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _mythread_j_676$32655[ebp], 1
$LN8@wait_for_w:
  000a6	83 7d f4 00	 cmp	 DWORD PTR _mythread_j_676$32655[ebp], 0
  000aa	0f 85 de 00 00
	00		 jne	 $LN6@wait_for_w
$LN5@wait_for_w:

; 677  : 		// There are four things that we wait. If one of them
; 678  : 		// becomes possible, we return.
; 679  : 		//  - If there is input left, we need to get a free
; 680  : 		//    worker thread and an output buffer for it.
; 681  : 		//  - Data ready to be read from the output queue.
; 682  : 		//  - A worker thread indicates an error.
; 683  : 		//  - Time out occurs.
; 684  : 		while ((!has_input || coder->threads_free == NULL
; 685  : 					|| !lzma_outq_has_buf(&coder->outq))
; 686  : 				&& !lzma_outq_is_readable(&coder->outq)
; 687  : 				&& coder->thread_error == LZMA_OK
; 688  : 				&& !timed_out) {

  000b0	0f b6 45 14	 movzx	 eax, BYTE PTR _has_input$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 33		 je	 SHORT $LN3@wait_for_w
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000bb	83 b9 08 01 00
	00 00		 cmp	 DWORD PTR [ecx+264], 0
  000c2	74 27		 je	 SHORT $LN3@wait_for_w
  000c4	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000c7	81 c2 d8 00 00
	00		 add	 edx, 216		; 000000d8H
  000cd	89 55 ec	 mov	 DWORD PTR $T78275[ebp], edx
  000d0	8b 45 ec	 mov	 eax, DWORD PTR $T78275[ebp]
  000d3	8b 4d ec	 mov	 ecx, DWORD PTR $T78275[ebp]
  000d6	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000d9	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000dc	1b c0		 sbb	 eax, eax
  000de	f7 d8		 neg	 eax
  000e0	0f b6 c8	 movzx	 ecx, al
  000e3	85 c9		 test	 ecx, ecx
  000e5	0f 85 9e 00 00
	00		 jne	 $LN4@wait_for_w
$LN3@wait_for_w:
  000eb	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ee	81 c2 d8 00 00
	00		 add	 edx, 216		; 000000d8H
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _lzma_outq_is_readable
  000fa	83 c4 04	 add	 esp, 4
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	0f 85 81 00 00
	00		 jne	 $LN4@wait_for_w
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0010b	83 b9 f8 00 00
	00 00		 cmp	 DWORD PTR [ecx+248], 0
  00112	75 75		 jne	 SHORT $LN4@wait_for_w
  00114	0f b6 55 ff	 movzx	 edx, BYTE PTR _timed_out$32653[ebp]
  00118	85 d2		 test	 edx, edx
  0011a	75 6d		 jne	 SHORT $LN4@wait_for_w

; 689  : 			if (coder->timeout != 0)

  0011c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0011f	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  00126	74 2a		 je	 SHORT $LN2@wait_for_w

; 690  : 				timed_out = mythread_cond_timedwait(
; 691  : 						&coder->cond, &coder->mutex,
; 692  : 						wait_abs) != 0;

  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _wait_abs$[ebp]
  0012b	51		 push	 ecx
  0012c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0012f	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  00135	52		 push	 edx
  00136	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00139	05 38 01 00 00	 add	 eax, 312		; 00000138H
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _mythread_cond_timedwait
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	f7 d8		 neg	 eax
  00149	1b c0		 sbb	 eax, eax
  0014b	f7 d8		 neg	 eax
  0014d	88 45 ff	 mov	 BYTE PTR _timed_out$32653[ebp], al

; 693  : 			else

  00150	eb 32		 jmp	 SHORT $LN1@wait_for_w
$LN2@wait_for_w:

; 694  : 				mythread_cond_wait(&coder->cond,
; 695  : 						&coder->mutex);

  00152	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00155	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  0015b	89 4d dc	 mov	 DWORD PTR $T78282[ebp], ecx
  0015e	8b 55 dc	 mov	 edx, DWORD PTR $T78282[ebp]
  00161	52		 push	 edx
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00168	6a ff		 push	 -1
  0016a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0016d	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [eax+312]
  00173	51		 push	 ecx
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0017a	8b 55 dc	 mov	 edx, DWORD PTR $T78282[ebp]
  0017d	52		 push	 edx
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
$LN1@wait_for_w:

; 696  : 		}

  00184	e9 27 ff ff ff	 jmp	 $LN5@wait_for_w
$LN4@wait_for_w:

; 697  : 	}

  00189	e9 11 ff ff ff	 jmp	 $LN7@wait_for_w
$LN6@wait_for_w:
  0018e	e9 bc fe ff ff	 jmp	 $LN10@wait_for_w
$LN9@wait_for_w:

; 698  :   }
; 699  : 
; 700  : 	return timed_out;

  00193	8a 45 ff	 mov	 al, BYTE PTR _timed_out$32653[ebp]

; 701  :   }
; 702  : }

  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
_wait_for_work ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _threads_end
_TEXT	SEGMENT
tv78 = -40						; size = 4
$T78304 = -36						; size = 4
_ret$78300 = -32					; size = 4
$T78297 = -28						; size = 4
$T78293 = -24						; size = 4
$T78289 = -20						; size = 4
_ret$32541 = -16					; size = 4
_mythread_j_477$32531 = -12				; size = 4
_mythread_i_477$32530 = -8				; size = 4
_i$ = -4						; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_threads_end PROC					; COMDAT

; 474  : { uint32_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 475  : 
; 476  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN12@threads_en
$LN11@threads_en:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN12@threads_en:
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0001e	3b 91 04 01 00
	00		 cmp	 edx, DWORD PTR [ecx+260]
  00024	0f 83 db 00 00
	00		 jae	 $LN10@threads_en

; 477  : 		mythread_sync(coder->threads[i].mutex) {

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_477$32530[ebp], 0
  00031	eb 07		 jmp	 SHORT $LN9@threads_en
$LN8@threads_en:
  00033	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_477$32530[ebp], 1
$LN9@threads_en:
  0003a	83 7d f8 00	 cmp	 DWORD PTR _mythread_i_477$32530[ebp], 0
  0003e	74 2f		 je	 SHORT $LN15@threads_en
  00040	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00043	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004c	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00052	8d 84 02 1c 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+284]
  00059	89 45 ec	 mov	 DWORD PTR $T78289[ebp], eax
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR $T78289[ebp]
  0005f	51		 push	 ecx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00066	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  0006d	eb 2d		 jmp	 SHORT $LN16@threads_en
$LN15@threads_en:
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00072	69 d2 40 01 00
	00		 imul	 edx, 320		; 00000140H
  00078	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0007b	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  00081	8d 94 11 1c 01
	00 00		 lea	 edx, DWORD PTR [ecx+edx+284]
  00088	89 55 e8	 mov	 DWORD PTR $T78293[ebp], edx
  0008b	8b 45 e8	 mov	 eax, DWORD PTR $T78293[ebp]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00095	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN16@threads_en:
  0009c	83 7d d8 00	 cmp	 DWORD PTR tv78[ebp], 0
  000a0	74 5e		 je	 SHORT $LN7@threads_en
  000a2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mythread_j_477$32531[ebp], 0
  000a9	eb 07		 jmp	 SHORT $LN6@threads_en
$LN5@threads_en:
  000ab	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _mythread_j_477$32531[ebp], 1
$LN6@threads_en:
  000b2	83 7d f4 00	 cmp	 DWORD PTR _mythread_j_477$32531[ebp], 0
  000b6	75 43		 jne	 SHORT $LN4@threads_en

; 478  : 			coder->threads[i].state = THR_EXIT;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bb	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  000c1	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000c4	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  000ca	c7 04 01 04 00
	00 00		 mov	 DWORD PTR [ecx+eax], 4

; 479  : 			mythread_cond_signal(&coder->threads[i].cond);

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d4	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  000da	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000dd	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  000e3	8d 8c 08 34 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+308]
  000ea	89 4d e4	 mov	 DWORD PTR $T78297[ebp], ecx
  000ed	8b 55 e4	 mov	 edx, DWORD PTR $T78297[ebp]
  000f0	8b 02		 mov	 eax, DWORD PTR [edx]
  000f2	50		 push	 eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 480  : 		}

  000f9	eb b0		 jmp	 SHORT $LN5@threads_en
$LN4@threads_en:
  000fb	e9 33 ff ff ff	 jmp	 $LN8@threads_en
$LN7@threads_en:

; 481  : 	}

  00100	e9 0a ff ff ff	 jmp	 $LN11@threads_en
$LN10@threads_en:

; 482  : 
; 483  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0010c	eb 09		 jmp	 SHORT $LN3@threads_en
$LN2@threads_en:
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00111	83 c1 01	 add	 ecx, 1
  00114	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@threads_en:
  00117	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0011a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	3b 82 04 01 00
	00		 cmp	 eax, DWORD PTR [edx+260]
  00123	73 57		 jae	 SHORT $LN1@threads_en

; 484  : 		int ret = mythread_join(coder->threads[i].thread_id);

  00125	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00128	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  0012e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00131	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00137	8b 8c 08 38 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+312]
  0013e	89 4d dc	 mov	 DWORD PTR $T78304[ebp], ecx
  00141	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ret$78300[ebp], 0
  00148	6a ff		 push	 -1
  0014a	8b 55 dc	 mov	 edx, DWORD PTR $T78304[ebp]
  0014d	52		 push	 edx
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00154	85 c0		 test	 eax, eax
  00156	74 07		 je	 SHORT $LN24@threads_en
  00158	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _ret$78300[ebp], -1
$LN24@threads_en:
  0015f	8b 45 dc	 mov	 eax, DWORD PTR $T78304[ebp]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00169	85 c0		 test	 eax, eax
  0016b	75 07		 jne	 SHORT $LN25@threads_en
  0016d	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _ret$78300[ebp], -1
$LN25@threads_en:
  00174	8b 4d e0	 mov	 ecx, DWORD PTR _ret$78300[ebp]
  00177	89 4d f0	 mov	 DWORD PTR _ret$32541[ebp], ecx

; 485  : 		assert(ret == 0);
; 486  : 		(void)ret;
; 487  : 	}

  0017a	eb 92		 jmp	 SHORT $LN2@threads_en
$LN1@threads_en:

; 488  : 
; 489  : 	lzma_free(coder->threads, allocator);

  0017c	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0017f	52		 push	 edx
  00180	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00183	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 _lzma_free
  0018f	83 c4 08	 add	 esp, 8

; 490  : 	return;
; 491  : }

  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
_threads_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _threads_stop
_TEXT	SEGMENT
tv137 = -56						; size = 4
tv78 = -52						; size = 4
$T78334 = -48						; size = 4
$T78333 = -44						; size = 4
$T78329 = -40						; size = 4
$T78325 = -36						; size = 4
$T78321 = -32						; size = 4
$T78317 = -28						; size = 4
$T78313 = -24						; size = 4
_mythread_i_459$32509 = -20				; size = 4
_mythread_j_459$32510 = -16				; size = 4
_mythread_i_448$32497 = -12				; size = 4
_mythread_j_448$32498 = -8				; size = 4
_i$ = -4						; size = 4
_coder$ = 8						; size = 4
_wait_for_threads$ = 12					; size = 1
_threads_stop PROC					; COMDAT

; 444  : { uint32_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 445  : 
; 446  : 	// Tell the threads to stop.
; 447  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN21@threads_st
$LN20@threads_st:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN21@threads_st:
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0001e	3b 91 04 01 00
	00		 cmp	 edx, DWORD PTR [ecx+260]
  00024	0f 83 db 00 00
	00		 jae	 $LN19@threads_st

; 448  : 		mythread_sync(coder->threads[i].mutex) {

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mythread_i_448$32497[ebp], 0
  00031	eb 07		 jmp	 SHORT $LN18@threads_st
$LN17@threads_st:
  00033	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _mythread_i_448$32497[ebp], 1
$LN18@threads_st:
  0003a	83 7d f4 00	 cmp	 DWORD PTR _mythread_i_448$32497[ebp], 0
  0003e	74 2f		 je	 SHORT $LN24@threads_st
  00040	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00043	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004c	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00052	8d 84 02 1c 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+284]
  00059	89 45 e8	 mov	 DWORD PTR $T78313[ebp], eax
  0005c	8b 4d e8	 mov	 ecx, DWORD PTR $T78313[ebp]
  0005f	51		 push	 ecx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00066	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  0006d	eb 2d		 jmp	 SHORT $LN25@threads_st
$LN24@threads_st:
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00072	69 d2 40 01 00
	00		 imul	 edx, 320		; 00000140H
  00078	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0007b	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  00081	8d 94 11 1c 01
	00 00		 lea	 edx, DWORD PTR [ecx+edx+284]
  00088	89 55 e4	 mov	 DWORD PTR $T78317[ebp], edx
  0008b	8b 45 e4	 mov	 eax, DWORD PTR $T78317[ebp]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00095	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN25@threads_st:
  0009c	83 7d cc 00	 cmp	 DWORD PTR tv78[ebp], 0
  000a0	74 5e		 je	 SHORT $LN16@threads_st
  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_j_448$32498[ebp], 0
  000a9	eb 07		 jmp	 SHORT $LN15@threads_st
$LN14@threads_st:
  000ab	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_j_448$32498[ebp], 1
$LN15@threads_st:
  000b2	83 7d f8 00	 cmp	 DWORD PTR _mythread_j_448$32498[ebp], 0
  000b6	75 43		 jne	 SHORT $LN13@threads_st

; 449  : 			coder->threads[i].state = THR_STOP;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bb	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  000c1	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000c4	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  000ca	c7 04 01 03 00
	00 00		 mov	 DWORD PTR [ecx+eax], 3

; 450  : 			mythread_cond_signal(&coder->threads[i].cond);

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d4	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  000da	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000dd	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  000e3	8d 8c 08 34 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+308]
  000ea	89 4d e0	 mov	 DWORD PTR $T78321[ebp], ecx
  000ed	8b 55 e0	 mov	 edx, DWORD PTR $T78321[ebp]
  000f0	8b 02		 mov	 eax, DWORD PTR [edx]
  000f2	50		 push	 eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 451  : 		}

  000f9	eb b0		 jmp	 SHORT $LN14@threads_st
$LN13@threads_st:
  000fb	e9 33 ff ff ff	 jmp	 $LN17@threads_st
$LN16@threads_st:

; 452  : 	}

  00100	e9 0a ff ff ff	 jmp	 $LN20@threads_st
$LN19@threads_st:

; 453  : 
; 454  : 	if (!wait_for_threads)

  00105	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _wait_for_threads$[ebp]
  00109	85 c9		 test	 ecx, ecx
  0010b	75 05		 jne	 SHORT $LN12@threads_st

; 455  : 		return;

  0010d	e9 39 01 00 00	 jmp	 $LN22@threads_st
$LN12@threads_st:

; 456  : 
; 457  : 	// Wait for the threads to settle in the idle state.
; 458  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  00112	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00119	eb 09		 jmp	 SHORT $LN11@threads_st
$LN10@threads_st:
  0011b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0011e	83 c2 01	 add	 edx, 1
  00121	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN11@threads_st:
  00124	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0012a	3b 88 04 01 00
	00		 cmp	 ecx, DWORD PTR [eax+260]
  00130	0f 83 15 01 00
	00		 jae	 $LN22@threads_st

; 459  : 		mythread_sync(coder->threads[i].mutex) {

  00136	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_i_459$32509[ebp], 0
  0013d	eb 07		 jmp	 SHORT $LN8@threads_st
$LN7@threads_st:
  0013f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_i_459$32509[ebp], 1
$LN8@threads_st:
  00146	83 7d ec 00	 cmp	 DWORD PTR _mythread_i_459$32509[ebp], 0
  0014a	74 2f		 je	 SHORT $LN26@threads_st
  0014c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0014f	69 d2 40 01 00
	00		 imul	 edx, 320		; 00000140H
  00155	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00158	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  0015e	8d 94 11 1c 01
	00 00		 lea	 edx, DWORD PTR [ecx+edx+284]
  00165	89 55 dc	 mov	 DWORD PTR $T78325[ebp], edx
  00168	8b 45 dc	 mov	 eax, DWORD PTR $T78325[ebp]
  0016b	50		 push	 eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00172	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  00179	eb 2d		 jmp	 SHORT $LN27@threads_st
$LN26@threads_st:
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017e	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  00184	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00187	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  0018d	8d 8c 08 1c 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+284]
  00194	89 4d d8	 mov	 DWORD PTR $T78329[ebp], ecx
  00197	8b 55 d8	 mov	 edx, DWORD PTR $T78329[ebp]
  0019a	52		 push	 edx
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001a1	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
$LN27@threads_st:
  001a8	83 7d c8 00	 cmp	 DWORD PTR tv137[ebp], 0
  001ac	0f 84 94 00 00
	00		 je	 $LN6@threads_st
  001b2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mythread_j_459$32510[ebp], 0
  001b9	eb 07		 jmp	 SHORT $LN5@threads_st
$LN4@threads_st:
  001bb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mythread_j_459$32510[ebp], 1
$LN5@threads_st:
  001c2	83 7d f0 00	 cmp	 DWORD PTR _mythread_j_459$32510[ebp], 0
  001c6	75 79		 jne	 SHORT $LN3@threads_st
$LN2@threads_st:

; 460  : 			while (coder->threads[i].state != THR_IDLE)

  001c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001cb	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001d4	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  001da	83 3c 10 00	 cmp	 DWORD PTR [eax+edx], 0
  001de	74 5c		 je	 SHORT $LN1@threads_st

; 461  : 				mythread_cond_wait(&coder->threads[i].cond,
; 462  : 						&coder->threads[i].mutex);

  001e0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001e3	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ec	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  001f2	8d 84 02 1c 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+284]
  001f9	89 45 d0	 mov	 DWORD PTR $T78334[ebp], eax
  001fc	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001ff	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  00205	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00208	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  0020e	8d 8c 08 34 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+308]
  00215	89 4d d4	 mov	 DWORD PTR $T78333[ebp], ecx
  00218	8b 55 d0	 mov	 edx, DWORD PTR $T78334[ebp]
  0021b	52		 push	 edx
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00222	6a ff		 push	 -1
  00224	8b 45 d4	 mov	 eax, DWORD PTR $T78333[ebp]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	51		 push	 ecx
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00230	8b 55 d0	 mov	 edx, DWORD PTR $T78334[ebp]
  00233	52		 push	 edx
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0023a	eb 8c		 jmp	 SHORT $LN2@threads_st
$LN1@threads_st:

; 463  : 		}

  0023c	e9 7a ff ff ff	 jmp	 $LN4@threads_st
$LN3@threads_st:
  00241	e9 f9 fe ff ff	 jmp	 $LN7@threads_st
$LN6@threads_st:

; 464  : 	}

  00246	e9 d0 fe ff ff	 jmp	 $LN10@threads_st
$LN22@threads_st:

; 465  : 
; 466  : 	return;
; 467  : }

  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
_threads_stop ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _worker_error
_TEXT	SEGMENT
tv71 = -24						; size = 4
$T78349 = -20						; size = 4
$T78345 = -16						; size = 4
$T78341 = -12						; size = 4
_mythread_j_188$32377 = -8				; size = 4
_mythread_i_188$32376 = -4				; size = 4
_thr$ = 8						; size = 4
_ret$ = 12						; size = 4
_worker_error PROC					; COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 184  : 	assert(ret != LZMA_OK);
; 185  : 	assert(ret != LZMA_STREAM_END);
; 186  : 
; 187  :   {
; 188  : 	mythread_sync(thr->coder->mutex) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mythread_i_188$32376[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN7@worker_err
$LN6@worker_err:
  0000f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _mythread_i_188$32376[ebp], 1
$LN7@worker_err:
  00016	83 7d fc 00	 cmp	 DWORD PTR _mythread_i_188$32376[ebp], 0
  0001a	74 22		 je	 SHORT $LN10@worker_err
  0001c	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0001f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00022	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00028	89 4d f4	 mov	 DWORD PTR $T78341[ebp], ecx
  0002b	8b 55 f4	 mov	 edx, DWORD PTR $T78341[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00035	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0003c	eb 20		 jmp	 SHORT $LN11@worker_err
$LN10@worker_err:
  0003e	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00041	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00044	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  0004a	89 4d f0	 mov	 DWORD PTR $T78345[ebp], ecx
  0004d	8b 55 f0	 mov	 edx, DWORD PTR $T78345[ebp]
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00057	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN11@worker_err:
  0005e	83 7d e8 00	 cmp	 DWORD PTR tv71[ebp], 0
  00062	74 55		 je	 SHORT $LN8@worker_err
  00064	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_j_188$32377[ebp], 0
  0006b	eb 07		 jmp	 SHORT $LN4@worker_err
$LN3@worker_err:
  0006d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_j_188$32377[ebp], 1
$LN4@worker_err:
  00074	83 7d f8 00	 cmp	 DWORD PTR _mythread_j_188$32377[ebp], 0
  00078	75 3a		 jne	 SHORT $LN2@worker_err

; 189  : 		if (thr->coder->thread_error == LZMA_OK)

  0007a	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0007d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00080	83 b9 f8 00 00
	00 00		 cmp	 DWORD PTR [ecx+248], 0
  00087	75 0f		 jne	 SHORT $LN1@worker_err

; 190  : 			thr->coder->thread_error = ret;

  00089	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  0008c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  00092	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx
$LN1@worker_err:

; 191  : 
; 192  : 		mythread_cond_signal(&thr->coder->cond);

  00098	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  0009b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  000a3	89 45 ec	 mov	 DWORD PTR $T78349[ebp], eax
  000a6	8b 4d ec	 mov	 ecx, DWORD PTR $T78349[ebp]
  000a9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ab	52		 push	 edx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 193  : 	}

  000b2	eb b9		 jmp	 SHORT $LN3@worker_err
$LN2@worker_err:
  000b4	e9 56 ff ff ff	 jmp	 $LN6@worker_err
$LN8@worker_err:

; 194  :   }
; 195  : 
; 196  : 	return;
; 197  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_worker_error ENDP
PUBLIC	_lzma_stream_encoder_mt_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_encoder_mt_memusage
_TEXT	SEGMENT
tv247 = -256						; size = 8
tv228 = -248						; size = 8
tv209 = -240						; size = 8
_total_memusage$32905 = -232				; size = 8
_outq_memusage$32903 = -224				; size = 8
_filters_memusage$32901 = -216				; size = 8
_inbuf_memusage$32900 = -208				; size = 8
_easy$ = -200						; size = 176
_block_size$ = -24					; size = 8
_outbuf_size_max$ = -16					; size = 8
_filters$ = -4						; size = 4
_options$ = 8						; size = 4
_lzma_stream_encoder_mt_memusage PROC			; COMDAT

; 1147 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H

; 1148 : 	lzma_options_easy easy;
; 1149 : 	const lzma_filter *filters;
; 1150 : 	uint64_t block_size;
; 1151 : 	uint64_t outbuf_size_max;
; 1152 : 
; 1153 : 	if (get_options(options, &easy, &filters, &block_size,
; 1154 : 			&outbuf_size_max) != LZMA_OK)

  00009	8d 45 f0	 lea	 eax, DWORD PTR _outbuf_size_max$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d e8	 lea	 ecx, DWORD PTR _block_size$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 fc	 lea	 edx, DWORD PTR _filters$[ebp]
  00014	52		 push	 edx
  00015	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _easy$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _get_options
  00025	83 c4 14	 add	 esp, 20			; 00000014H
  00028	85 c0		 test	 eax, eax
  0002a	74 0b		 je	 SHORT $LN6@lzma_strea@6

; 1155 : 		return UINT64_MAX;

  0002c	83 c8 ff	 or	 eax, -1
  0002f	83 ca ff	 or	 edx, -1
  00032	e9 1a 02 00 00	 jmp	 $LN7@lzma_strea@6
$LN6@lzma_strea@6:

; 1156 : 
; 1157 : 	// Memory usage of the input buffers
; 1158 :   {
; 1159 : 	const uint64_t inbuf_memusage = options->threads * block_size;

  00037	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	33 c9		 xor	 ecx, ecx
  0003f	8b 55 ec	 mov	 edx, DWORD PTR _block_size$[ebp+4]
  00042	52		 push	 edx
  00043	8b 55 e8	 mov	 edx, DWORD PTR _block_size$[ebp]
  00046	52		 push	 edx
  00047	51		 push	 ecx
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 __allmul
  0004e	89 85 30 ff ff
	ff		 mov	 DWORD PTR _inbuf_memusage$32900[ebp], eax
  00054	89 95 34 ff ff
	ff		 mov	 DWORD PTR _inbuf_memusage$32900[ebp+4], edx

; 1160 : 
; 1161 : 	// Memory usage of the filter encoders
; 1162 : 	uint64_t filters_memusage = lzma_raw_encoder_memusage(filters);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _filters$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _lzma_raw_encoder_memusage
  00063	83 c4 04	 add	 esp, 4
  00066	89 85 28 ff ff
	ff		 mov	 DWORD PTR _filters_memusage$32901[ebp], eax
  0006c	89 95 2c ff ff
	ff		 mov	 DWORD PTR _filters_memusage$32901[ebp+4], edx

; 1163 : 	if (filters_memusage == UINT64_MAX)

  00072	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _filters_memusage$32901[ebp]
  00078	23 8d 2c ff ff
	ff		 and	 ecx, DWORD PTR _filters_memusage$32901[ebp+4]
  0007e	83 f9 ff	 cmp	 ecx, -1
  00081	75 0b		 jne	 SHORT $LN5@lzma_strea@6

; 1164 : 		return UINT64_MAX;

  00083	83 c8 ff	 or	 eax, -1
  00086	83 ca ff	 or	 edx, -1
  00089	e9 c3 01 00 00	 jmp	 $LN7@lzma_strea@6
$LN5@lzma_strea@6:

; 1165 : 
; 1166 : 	filters_memusage *= options->threads;

  0008e	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00091	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00094	33 c9		 xor	 ecx, ecx
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _filters_memusage$32901[ebp+4]
  0009e	52		 push	 edx
  0009f	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _filters_memusage$32901[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 __allmul
  000ab	89 85 28 ff ff
	ff		 mov	 DWORD PTR _filters_memusage$32901[ebp], eax
  000b1	89 95 2c ff ff
	ff		 mov	 DWORD PTR _filters_memusage$32901[ebp+4], edx

; 1167 : 
; 1168 : 	// Memory usage of the output queue
; 1169 :   {
; 1170 : 	const uint64_t outq_memusage = lzma_outq_memusage(
; 1171 : 			outbuf_size_max, options->threads);

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  000ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bd	52		 push	 edx
  000be	8b 45 f4	 mov	 eax, DWORD PTR _outbuf_size_max$[ebp+4]
  000c1	50		 push	 eax
  000c2	8b 4d f0	 mov	 ecx, DWORD PTR _outbuf_size_max$[ebp]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _lzma_outq_memusage
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	89 85 20 ff ff
	ff		 mov	 DWORD PTR _outq_memusage$32903[ebp], eax
  000d4	89 95 24 ff ff
	ff		 mov	 DWORD PTR _outq_memusage$32903[ebp+4], edx

; 1172 : 	if (outq_memusage == UINT64_MAX)

  000da	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _outq_memusage$32903[ebp]
  000e0	23 95 24 ff ff
	ff		 and	 edx, DWORD PTR _outq_memusage$32903[ebp+4]
  000e6	83 fa ff	 cmp	 edx, -1
  000e9	75 0b		 jne	 SHORT $LN4@lzma_strea@6

; 1173 : 		return UINT64_MAX;

  000eb	83 c8 ff	 or	 eax, -1
  000ee	83 ca ff	 or	 edx, -1
  000f1	e9 5b 01 00 00	 jmp	 $LN7@lzma_strea@6
$LN4@lzma_strea@6:

; 1174 : 
; 1175 : 	// Sum them with overflow checking.
; 1176 :   {
; 1177 : 	uint64_t total_memusage = LZMA_MEMUSAGE_BASE
; 1178 : 			+ sizeof(lzma_stream_coder)
; 1179 : 			+ options->threads * sizeof(worker_thread);

  000f6	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  000f9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fc	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  00102	33 d2		 xor	 edx, edx
  00104	81 c1 40 81 00
	00		 add	 ecx, 33088		; 00008140H
  0010a	83 d2 00	 adc	 edx, 0
  0010d	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp], ecx
  00113	89 95 1c ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp+4], edx

; 1180 : 
; 1181 : 	if (UINT64_MAX - total_memusage < inbuf_memusage)

  00119	83 c8 ff	 or	 eax, -1
  0011c	2b 85 18 ff ff
	ff		 sub	 eax, DWORD PTR _total_memusage$32905[ebp]
  00122	b9 ff ff ff ff	 mov	 ecx, -1
  00127	1b 8d 1c ff ff
	ff		 sbb	 ecx, DWORD PTR _total_memusage$32905[ebp+4]
  0012d	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  00133	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv209[ebp+4], ecx
  00139	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv209[ebp+4]
  0013f	3b 95 34 ff ff
	ff		 cmp	 edx, DWORD PTR _inbuf_memusage$32900[ebp+4]
  00145	77 1b		 ja	 SHORT $LN3@lzma_strea@6
  00147	72 0e		 jb	 SHORT $LN9@lzma_strea@6
  00149	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv209[ebp]
  0014f	3b 85 30 ff ff
	ff		 cmp	 eax, DWORD PTR _inbuf_memusage$32900[ebp]
  00155	73 0b		 jae	 SHORT $LN3@lzma_strea@6
$LN9@lzma_strea@6:

; 1182 : 		return UINT64_MAX;

  00157	83 c8 ff	 or	 eax, -1
  0015a	83 ca ff	 or	 edx, -1
  0015d	e9 ef 00 00 00	 jmp	 $LN7@lzma_strea@6
$LN3@lzma_strea@6:

; 1183 : 
; 1184 : 	total_memusage += inbuf_memusage;

  00162	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _total_memusage$32905[ebp]
  00168	03 8d 30 ff ff
	ff		 add	 ecx, DWORD PTR _inbuf_memusage$32900[ebp]
  0016e	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _total_memusage$32905[ebp+4]
  00174	13 95 34 ff ff
	ff		 adc	 edx, DWORD PTR _inbuf_memusage$32900[ebp+4]
  0017a	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp], ecx
  00180	89 95 1c ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp+4], edx

; 1185 : 
; 1186 : 	if (UINT64_MAX - total_memusage < filters_memusage)

  00186	83 c8 ff	 or	 eax, -1
  00189	2b 85 18 ff ff
	ff		 sub	 eax, DWORD PTR _total_memusage$32905[ebp]
  0018f	b9 ff ff ff ff	 mov	 ecx, -1
  00194	1b 8d 1c ff ff
	ff		 sbb	 ecx, DWORD PTR _total_memusage$32905[ebp+4]
  0019a	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv228[ebp], eax
  001a0	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv228[ebp+4], ecx
  001a6	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv228[ebp+4]
  001ac	3b 95 2c ff ff
	ff		 cmp	 edx, DWORD PTR _filters_memusage$32901[ebp+4]
  001b2	77 1b		 ja	 SHORT $LN2@lzma_strea@6
  001b4	72 0e		 jb	 SHORT $LN10@lzma_strea@6
  001b6	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv228[ebp]
  001bc	3b 85 28 ff ff
	ff		 cmp	 eax, DWORD PTR _filters_memusage$32901[ebp]
  001c2	73 0b		 jae	 SHORT $LN2@lzma_strea@6
$LN10@lzma_strea@6:

; 1187 : 		return UINT64_MAX;

  001c4	83 c8 ff	 or	 eax, -1
  001c7	83 ca ff	 or	 edx, -1
  001ca	e9 82 00 00 00	 jmp	 $LN7@lzma_strea@6
$LN2@lzma_strea@6:

; 1188 : 
; 1189 : 	total_memusage += filters_memusage;

  001cf	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _total_memusage$32905[ebp]
  001d5	03 8d 28 ff ff
	ff		 add	 ecx, DWORD PTR _filters_memusage$32901[ebp]
  001db	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _total_memusage$32905[ebp+4]
  001e1	13 95 2c ff ff
	ff		 adc	 edx, DWORD PTR _filters_memusage$32901[ebp+4]
  001e7	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp], ecx
  001ed	89 95 1c ff ff
	ff		 mov	 DWORD PTR _total_memusage$32905[ebp+4], edx

; 1190 : 
; 1191 : 	if (UINT64_MAX - total_memusage < outq_memusage)

  001f3	83 c8 ff	 or	 eax, -1
  001f6	2b 85 18 ff ff
	ff		 sub	 eax, DWORD PTR _total_memusage$32905[ebp]
  001fc	b9 ff ff ff ff	 mov	 ecx, -1
  00201	1b 8d 1c ff ff
	ff		 sbb	 ecx, DWORD PTR _total_memusage$32905[ebp+4]
  00207	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv247[ebp], eax
  0020d	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv247[ebp+4], ecx
  00213	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv247[ebp+4]
  00219	3b 95 24 ff ff
	ff		 cmp	 edx, DWORD PTR _outq_memusage$32903[ebp+4]
  0021f	77 18		 ja	 SHORT $LN1@lzma_strea@6
  00221	72 0e		 jb	 SHORT $LN11@lzma_strea@6
  00223	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv247[ebp]
  00229	3b 85 20 ff ff
	ff		 cmp	 eax, DWORD PTR _outq_memusage$32903[ebp]
  0022f	73 08		 jae	 SHORT $LN1@lzma_strea@6
$LN11@lzma_strea@6:

; 1192 : 		return UINT64_MAX;

  00231	83 c8 ff	 or	 eax, -1
  00234	83 ca ff	 or	 edx, -1
  00237	eb 18		 jmp	 SHORT $LN7@lzma_strea@6
$LN1@lzma_strea@6:

; 1193 : 
; 1194 : 	return total_memusage + outq_memusage;

  00239	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _total_memusage$32905[ebp]
  0023f	03 85 20 ff ff
	ff		 add	 eax, DWORD PTR _outq_memusage$32903[ebp]
  00245	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _total_memusage$32905[ebp+4]
  0024b	13 95 24 ff ff
	ff		 adc	 edx, DWORD PTR _outq_memusage$32903[ebp+4]
$LN7@lzma_strea@6:

; 1195 :   }}}
; 1196 : }

  00251	8b e5		 mov	 esp, ebp
  00253	5d		 pop	 ebp
  00254	c3		 ret	 0
_lzma_stream_encoder_mt_memusage ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_encoder_mt_end
_TEXT	SEGMENT
tv133 = -16						; size = 4
tv132 = -12						; size = 4
_i$32747 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_stream_encoder_mt_end PROC				; COMDAT

; 881  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 882  : 	lzma_stream_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 883  : 
; 884  : 	// Threads must be killed before the output queue can be freed.
; 885  : 	threads_end(coder, allocator);

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _threads_end
  0001a	83 c4 08	 add	 esp, 8

; 886  : 	lzma_outq_end(&coder->outq, allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _lzma_outq_end
  00030	83 c4 08	 add	 esp, 8

; 887  : 
; 888  :   { size_t i;
; 889  : 
; 890  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$32747[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN3@stream_enc@2
$LN2@stream_enc@2:
  0003c	8b 55 f8	 mov	 edx, DWORD PTR _i$32747[ebp]
  0003f	83 c2 01	 add	 edx, 1
  00042	89 55 f8	 mov	 DWORD PTR _i$32747[ebp], edx
$LN3@stream_enc@2:
  00045	8b 45 f8	 mov	 eax, DWORD PTR _i$32747[ebp]
  00048	c1 e0 04	 shl	 eax, 4
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004e	89 4d f4	 mov	 DWORD PTR tv132[ebp], ecx
  00051	89 45 f0	 mov	 DWORD PTR tv133[ebp], eax
  00054	8b 55 f0	 mov	 edx, DWORD PTR tv133[ebp]
  00057	8b 45 f4	 mov	 eax, DWORD PTR tv132[ebp]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR tv133[ebp]
  0005d	8b 75 f4	 mov	 esi, DWORD PTR tv132[ebp]
  00060	8b 54 10 08	 mov	 edx, DWORD PTR [eax+edx+8]
  00064	23 54 0e 0c	 and	 edx, DWORD PTR [esi+ecx+12]
  00068	83 fa ff	 cmp	 edx, -1
  0006b	74 1c		 je	 SHORT $LN1@stream_enc@2

; 891  : 		lzma_free(coder->filters[i].options, allocator);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _i$32747[ebp]
  00074	c1 e1 04	 shl	 ecx, 4
  00077	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0007a	8b 44 0a 10	 mov	 eax, DWORD PTR [edx+ecx+16]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _lzma_free
  00084	83 c4 08	 add	 esp, 8
  00087	eb b3		 jmp	 SHORT $LN2@stream_enc@2
$LN1@stream_enc@2:

; 892  :   }
; 893  : 
; 894  : 	lzma_next_end(&coder->index_encoder, allocator);

  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00090	83 c2 60	 add	 edx, 96			; 00000060H
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _lzma_next_end
  00099	83 c4 08	 add	 esp, 8

; 895  : 	lzma_index_end(coder->index, allocator);

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a3	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _lzma_index_end
  000ac	83 c4 08	 add	 esp, 8

; 896  : 
; 897  : 	mythread_cond_destroy(&coder->cond);

  000af	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000b2	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [eax+312]
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 898  : 	mythread_mutex_destroy(&coder->mutex);

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000c2	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  000c8	52		 push	 edx
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 899  : 
; 900  : 	lzma_free(coder, allocator);

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 _lzma_free
  000dc	83 c4 08	 add	 esp, 8

; 901  : 	return;
; 902  : }

  000df	5e		 pop	 esi
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_stream_encoder_mt_end ENDP
; Function compile flags: /Odtp
;	COMDAT _worker_encode
_TEXT	SEGMENT
tv201 = -60						; size = 4
tv186 = -56						; size = 4
tv141 = -52						; size = 4
$T79956 = -48						; size = 4
$T79946 = -44						; size = 4
_mythread_j_320$32430 = -40				; size = 4
_mythread_i_320$32429 = -36				; size = 4
_in_limit$32418 = -32					; size = 4
_action$32415 = -28					; size = 4
_mythread_i_254$32403 = -24				; size = 4
_mythread_j_254$32404 = -20				; size = 4
_out_size$32399 = -16					; size = 4
_in_pos$32397 = -12					; size = 4
_in_size$32398 = -8					; size = 4
_ret$32394 = -4						; size = 4
_thr$ = 8						; size = 4
_state$ = 12						; size = 4
_worker_encode PROC					; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 203  : 	assert(thr->progress_in == 0);
; 204  : 	assert(thr->progress_out == 0);
; 205  : 
; 206  : 	// Set the Block options.
; 207  :   /*
; 208  : 	thr->block_options = (lzma_block){
; 209  : 		.version = 0,
; 210  : 		.check = thr->coder->stream_flags.check,
; 211  : 		.compressed_size = thr->coder->outq.buf_size_max,
; 212  : 		.uncompressed_size = thr->coder->block_size,
; 213  : 
; 214  : 		// TODO: To allow changing the filter chain, the filters
; 215  : 		// array must be copied to each worker_thread.
; 216  : 		.filters = thr->coder->filters,
; 217  : 	};
; 218  :   */
; 219  :   memset (&thr->block_options, 0, sizeof(lzma_block));

  00006	68 c0 00 00 00	 push	 192			; 000000c0H
  0000b	6a 00		 push	 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00010	83 c0 58	 add	 eax, 88			; 00000058H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  :   thr->block_options.version = 0;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  0001f	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 221  :   thr->block_options.check = thr->coder->stream_flags.check;

  00026	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00029	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  0002f	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00035	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 222  :   thr->block_options.compressed_size = thr->coder->outq.buf_size_max;

  00038	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0003b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003e	8b 91 e0 00 00
	00		 mov	 edx, DWORD PTR [ecx+224]
  00044	33 c0		 xor	 eax, eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00049	89 51 68	 mov	 DWORD PTR [ecx+104], edx
  0004c	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 223  :   thr->block_options.uncompressed_size = thr->coder->block_size;

  0004f	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00052	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	33 d2		 xor	 edx, edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0005d	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  00060	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 224  :   thr->block_options.filters = thr->coder->filters;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00066	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00069	83 c2 08	 add	 edx, 8
  0006c	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0006f	89 50 78	 mov	 DWORD PTR [eax+120], edx

; 225  : 
; 226  : 	// Calculate maximum size of the Block Header. This amount is
; 227  : 	// reserved in the beginning of the buffer so that Block Header
; 228  : 	// along with Compressed Size and Uncompressed Size can be
; 229  : 	// written there.
; 230  :   {
; 231  : 	lzma_ret ret = lzma_block_header_size(&thr->block_options);

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00075	83 c1 58	 add	 ecx, 88			; 00000058H
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _lzma_block_header_size
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 fc	 mov	 DWORD PTR _ret$32394[ebp], eax

; 232  : 	if (ret != LZMA_OK) {

  00084	83 7d fc 00	 cmp	 DWORD PTR _ret$32394[ebp], 0
  00088	74 1a		 je	 SHORT $LN32@worker_enc@2

; 233  : 		worker_error(thr, ret);

  0008a	8b 55 fc	 mov	 edx, DWORD PTR _ret$32394[ebp]
  0008d	52		 push	 edx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _worker_error
  00097	83 c4 08	 add	 esp, 8

; 234  : 		return THR_STOP;

  0009a	b8 03 00 00 00	 mov	 eax, 3
  0009f	e9 be 03 00 00	 jmp	 $LN33@worker_enc@2
$LN32@worker_enc@2:

; 235  : 	}
; 236  : 
; 237  : 	// Initialize the Block encoder.
; 238  : 	ret = lzma_block_encoder_init(&thr->block_encoder,
; 239  : 			thr->allocator, &thr->block_options);

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  000a7	83 c1 58	 add	 ecx, 88			; 00000058H
  000aa	51		 push	 ecx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  000ae	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000b1	50		 push	 eax
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  000b5	83 c1 28	 add	 ecx, 40			; 00000028H
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _lzma_block_encoder_init
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 45 fc	 mov	 DWORD PTR _ret$32394[ebp], eax

; 240  : 	if (ret != LZMA_OK) {

  000c4	83 7d fc 00	 cmp	 DWORD PTR _ret$32394[ebp], 0
  000c8	74 1a		 je	 SHORT $LN31@worker_enc@2

; 241  : 		worker_error(thr, ret);

  000ca	8b 55 fc	 mov	 edx, DWORD PTR _ret$32394[ebp]
  000cd	52		 push	 edx
  000ce	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _worker_error
  000d7	83 c4 08	 add	 esp, 8

; 242  : 		return THR_STOP;

  000da	b8 03 00 00 00	 mov	 eax, 3
  000df	e9 7e 03 00 00	 jmp	 $LN33@worker_enc@2
$LN31@worker_enc@2:

; 243  : 	}
; 244  : 
; 245  :   {
; 246  : 	size_t in_pos = 0;

  000e4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _in_pos$32397[ebp], 0

; 247  : 	size_t in_size = 0;

  000eb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _in_size$32398[ebp], 0

; 248  : 
; 249  : 	thr->outbuf->size = thr->block_options.header_size;

  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  000f5	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000f8	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  000fb	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000fe	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 250  :   {
; 251  : 	const size_t out_size = thr->coder->outq.buf_size_max;

  00101	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00104	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00107	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0010d	89 4d f0	 mov	 DWORD PTR _out_size$32399[ebp], ecx
$LN30@worker_enc@2:

; 252  : 
; 253  : 	do {
; 254  : 		mythread_sync(thr->mutex) {

  00110	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_254$32403[ebp], 0
  00117	eb 07		 jmp	 SHORT $LN27@worker_enc@2
$LN26@worker_enc@2:
  00119	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_254$32403[ebp], 1
$LN27@worker_enc@2:
  00120	83 7d e8 00	 cmp	 DWORD PTR _mythread_i_254$32403[ebp], 0
  00124	74 19		 je	 SHORT $LN35@worker_enc@2
  00126	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00129	81 c2 1c 01 00
	00		 add	 edx, 284		; 0000011cH
  0012f	52		 push	 edx
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00136	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  0013d	eb 16		 jmp	 SHORT $LN36@worker_enc@2
$LN35@worker_enc@2:
  0013f	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00142	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  00147	50		 push	 eax
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0014e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
$LN36@worker_enc@2:
  00155	83 7d cc 00	 cmp	 DWORD PTR tv141[ebp], 0
  00159	0f 84 99 00 00
	00		 je	 $LN25@worker_enc@2
  0015f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_j_254$32404[ebp], 0
  00166	eb 07		 jmp	 SHORT $LN24@worker_enc@2
$LN23@worker_enc@2:
  00168	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_j_254$32404[ebp], 1
$LN24@worker_enc@2:
  0016f	83 7d ec 00	 cmp	 DWORD PTR _mythread_j_254$32404[ebp], 0
  00173	75 7e		 jne	 SHORT $LN22@worker_enc@2

; 255  : 			// Store in_pos and out_pos into *thr so that
; 256  : 			// an application may read them via
; 257  : 			// lzma_get_progress() to get progress information.
; 258  : 			//
; 259  : 			// NOTE: These aren't updated when the encoding
; 260  : 			// finishes. Instead, the final values are taken
; 261  : 			// later from thr->outbuf.
; 262  : 			thr->progress_in = in_pos;

  00175	8b 4d f4	 mov	 ecx, DWORD PTR _in_pos$32397[ebp]
  00178	33 d2		 xor	 edx, edx
  0017a	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0017d	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00180	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 263  : 			thr->progress_out = thr->outbuf->size;

  00183	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00186	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00189	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018c	33 c9		 xor	 ecx, ecx
  0018e	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00191	89 42 20	 mov	 DWORD PTR [edx+32], eax
  00194	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$LN21@worker_enc@2:

; 264  : 
; 265  : 			while (in_size == thr->in_size
; 266  : 					&& thr->state == THR_RUN)

  00197	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _in_size$32398[ebp]
  0019d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  001a0	75 3b		 jne	 SHORT $LN20@worker_enc@2
  001a2	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  001a5	83 3a 01	 cmp	 DWORD PTR [edx], 1
  001a8	75 33		 jne	 SHORT $LN20@worker_enc@2

; 267  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  001aa	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  001ad	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  001b2	89 45 d4	 mov	 DWORD PTR $T79946[ebp], eax
  001b5	8b 4d d4	 mov	 ecx, DWORD PTR $T79946[ebp]
  001b8	51		 push	 ecx
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001bf	6a ff		 push	 -1
  001c1	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  001c4	8b 82 34 01 00
	00		 mov	 eax, DWORD PTR [edx+308]
  001ca	50		 push	 eax
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  001d1	8b 4d d4	 mov	 ecx, DWORD PTR $T79946[ebp]
  001d4	51		 push	 ecx
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001db	eb ba		 jmp	 SHORT $LN21@worker_enc@2
$LN20@worker_enc@2:

; 268  : 
; 269  : 			state = thr->state;

  001dd	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  001e0	8b 02		 mov	 eax, DWORD PTR [edx]
  001e2	89 45 0c	 mov	 DWORD PTR _state$[ebp], eax

; 270  : 			in_size = thr->in_size;

  001e5	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  001e8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001eb	89 55 f8	 mov	 DWORD PTR _in_size$32398[ebp], edx
  001ee	e9 75 ff ff ff	 jmp	 $LN23@worker_enc@2
$LN22@worker_enc@2:

; 271  : 		}

  001f3	e9 21 ff ff ff	 jmp	 $LN26@worker_enc@2
$LN25@worker_enc@2:

; 272  : 
; 273  : 		// Return if we were asked to stop or exit.
; 274  : 		if (state >= THR_STOP)

  001f8	83 7d 0c 03	 cmp	 DWORD PTR _state$[ebp], 3
  001fc	7c 08		 jl	 SHORT $LN19@worker_enc@2

; 275  : 			return state;

  001fe	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00201	e9 5c 02 00 00	 jmp	 $LN33@worker_enc@2
$LN19@worker_enc@2:

; 276  : 
; 277  :     {
; 278  : 		lzma_action action = state == THR_FINISH
; 279  : 				? LZMA_FINISH : LZMA_RUN;

  00206	33 c0		 xor	 eax, eax
  00208	83 7d 0c 02	 cmp	 DWORD PTR _state$[ebp], 2
  0020c	0f 95 c0	 setne	 al
  0020f	83 e8 01	 sub	 eax, 1
  00212	83 e0 03	 and	 eax, 3
  00215	89 45 e4	 mov	 DWORD PTR _action$32415[ebp], eax

; 280  : 
; 281  : 		// Limit the amount of input given to the Block encoder
; 282  : 		// at once. This way this thread can react fairly quickly
; 283  : 		// if the main thread wants us to stop or exit.
; 284  : 		static const size_t in_chunk_max = 16384;
; 285  : 		size_t in_limit = in_size;

  00218	8b 4d f8	 mov	 ecx, DWORD PTR _in_size$32398[ebp]
  0021b	89 4d e0	 mov	 DWORD PTR _in_limit$32418[ebp], ecx

; 286  : 		if (in_size - in_pos > in_chunk_max) {

  0021e	8b 55 f8	 mov	 edx, DWORD PTR _in_size$32398[ebp]
  00221	2b 55 f4	 sub	 edx, DWORD PTR _in_pos$32397[ebp]
  00224	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?in_chunk_max@?9??worker_encode@@9@9
  0022a	76 13		 jbe	 SHORT $LN18@worker_enc@2

; 287  : 			in_limit = in_pos + in_chunk_max;

  0022c	8b 45 f4	 mov	 eax, DWORD PTR _in_pos$32397[ebp]
  0022f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?in_chunk_max@?9??worker_encode@@9@9
  00235	89 45 e0	 mov	 DWORD PTR _in_limit$32418[ebp], eax

; 288  : 			action = LZMA_RUN;

  00238	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _action$32415[ebp], 0
$LN18@worker_enc@2:

; 289  : 		}
; 290  : 
; 291  : 		ret = thr->block_encoder.code(
; 292  : 				thr->block_encoder.coder, thr->allocator,
; 293  : 				thr->in, &in_pos, in_limit, thr->outbuf->buf,
; 294  : 				&thr->outbuf->size, out_size, action);

  0023f	8b 4d e4	 mov	 ecx, DWORD PTR _action$32415[ebp]
  00242	51		 push	 ecx
  00243	8b 55 f0	 mov	 edx, DWORD PTR _out_size$32399[ebp]
  00246	52		 push	 edx
  00247	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0024a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0024d	83 c1 04	 add	 ecx, 4
  00250	51		 push	 ecx
  00251	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00254	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00257	8b 08		 mov	 ecx, DWORD PTR [eax]
  00259	51		 push	 ecx
  0025a	8b 55 e0	 mov	 edx, DWORD PTR _in_limit$32418[ebp]
  0025d	52		 push	 edx
  0025e	8d 45 f4	 lea	 eax, DWORD PTR _in_pos$32397[ebp]
  00261	50		 push	 eax
  00262	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00265	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00268	52		 push	 edx
  00269	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0026c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0026f	51		 push	 ecx
  00270	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00273	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00276	50		 push	 eax
  00277	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  0027a	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0027d	ff d2		 call	 edx
  0027f	83 c4 24	 add	 esp, 36			; 00000024H
  00282	89 45 fc	 mov	 DWORD PTR _ret$32394[ebp], eax

; 295  :     }
; 296  : 	} while (ret == LZMA_OK && thr->outbuf->size < out_size);

  00285	83 7d fc 00	 cmp	 DWORD PTR _ret$32394[ebp], 0
  00289	75 12		 jne	 SHORT $LN28@worker_enc@2
  0028b	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0028e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00291	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00294	3b 55 f0	 cmp	 edx, DWORD PTR _out_size$32399[ebp]
  00297	0f 82 73 fe ff
	ff		 jb	 $LN30@worker_enc@2
$LN28@worker_enc@2:

; 297  : 
; 298  : 	switch (ret) {

  0029d	8b 45 fc	 mov	 eax, DWORD PTR _ret$32394[ebp]
  002a0	89 45 c8	 mov	 DWORD PTR tv186[ebp], eax
  002a3	83 7d c8 00	 cmp	 DWORD PTR tv186[ebp], 0
  002a7	74 4b		 je	 SHORT $LN12@worker_enc@2
  002a9	83 7d c8 01	 cmp	 DWORD PTR tv186[ebp], 1
  002ad	74 05		 je	 SHORT $LN14@worker_enc@2
  002af	e9 62 01 00 00	 jmp	 $LN1@worker_enc@2
$LN14@worker_enc@2:

; 299  : 	case LZMA_STREAM_END:
; 300  : 		assert(state == THR_FINISH);
; 301  : 
; 302  : 		// Encode the Block Header. By doing it after
; 303  : 		// the compression, we can store the Compressed Size
; 304  : 		// and Uncompressed Size fields.
; 305  : 		ret = lzma_block_header_encode(&thr->block_options,
; 306  : 				thr->outbuf->buf);

  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  002b7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002ba	8b 02		 mov	 eax, DWORD PTR [edx]
  002bc	50		 push	 eax
  002bd	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  002c0	83 c1 58	 add	 ecx, 88			; 00000058H
  002c3	51		 push	 ecx
  002c4	e8 00 00 00 00	 call	 _lzma_block_header_encode
  002c9	83 c4 08	 add	 esp, 8
  002cc	89 45 fc	 mov	 DWORD PTR _ret$32394[ebp], eax

; 307  : 		if (ret != LZMA_OK) {

  002cf	83 7d fc 00	 cmp	 DWORD PTR _ret$32394[ebp], 0
  002d3	74 1a		 je	 SHORT $LN13@worker_enc@2

; 308  : 			worker_error(thr, ret);

  002d5	8b 55 fc	 mov	 edx, DWORD PTR _ret$32394[ebp]
  002d8	52		 push	 edx
  002d9	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  002dc	50		 push	 eax
  002dd	e8 00 00 00 00	 call	 _worker_error
  002e2	83 c4 08	 add	 esp, 8

; 309  : 			return THR_STOP;

  002e5	b8 03 00 00 00	 mov	 eax, 3
  002ea	e9 73 01 00 00	 jmp	 $LN33@worker_enc@2
$LN13@worker_enc@2:

; 310  : 		}
; 311  : 
; 312  : 		break;

  002ef	e9 39 01 00 00	 jmp	 $LN15@worker_enc@2
$LN12@worker_enc@2:

; 313  : 
; 314  : 	case LZMA_OK:
; 315  : 		// The data was incompressible. Encode it using uncompressed
; 316  : 		// LZMA2 chunks.
; 317  : 		//
; 318  : 		// First wait that we have gotten all the input.
; 319  :     {
; 320  : 		mythread_sync(thr->mutex) {

  002f4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _mythread_i_320$32429[ebp], 0
  002fb	eb 07		 jmp	 SHORT $LN11@worker_enc@2
$LN10@worker_enc@2:
  002fd	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _mythread_i_320$32429[ebp], 1
$LN11@worker_enc@2:
  00304	83 7d dc 00	 cmp	 DWORD PTR _mythread_i_320$32429[ebp], 0
  00308	74 19		 je	 SHORT $LN37@worker_enc@2
  0030a	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  0030d	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00313	51		 push	 ecx
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0031a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv201[ebp], 0
  00321	eb 17		 jmp	 SHORT $LN38@worker_enc@2
$LN37@worker_enc@2:
  00323	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  00326	81 c2 1c 01 00
	00		 add	 edx, 284		; 0000011cH
  0032c	52		 push	 edx
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00333	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
$LN38@worker_enc@2:
  0033a	83 7d c4 00	 cmp	 DWORD PTR tv201[ebp], 0
  0033e	74 6a		 je	 SHORT $LN9@worker_enc@2
  00340	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _mythread_j_320$32430[ebp], 0
  00347	eb 07		 jmp	 SHORT $LN8@worker_enc@2
$LN7@worker_enc@2:
  00349	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _mythread_j_320$32430[ebp], 1
$LN8@worker_enc@2:
  00350	83 7d d8 00	 cmp	 DWORD PTR _mythread_j_320$32430[ebp], 0
  00354	75 4f		 jne	 SHORT $LN6@worker_enc@2
$LN5@worker_enc@2:

; 321  : 			while (thr->state == THR_RUN)

  00356	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00359	83 38 01	 cmp	 DWORD PTR [eax], 1
  0035c	75 34		 jne	 SHORT $LN4@worker_enc@2

; 322  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  0035e	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00361	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00367	89 4d d0	 mov	 DWORD PTR $T79956[ebp], ecx
  0036a	8b 55 d0	 mov	 edx, DWORD PTR $T79956[ebp]
  0036d	52		 push	 edx
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00374	6a ff		 push	 -1
  00376	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00379	8b 88 34 01 00
	00		 mov	 ecx, DWORD PTR [eax+308]
  0037f	51		 push	 ecx
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00386	8b 55 d0	 mov	 edx, DWORD PTR $T79956[ebp]
  00389	52		 push	 edx
  0038a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00390	eb c4		 jmp	 SHORT $LN5@worker_enc@2
$LN4@worker_enc@2:

; 323  : 
; 324  : 			state = thr->state;

  00392	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  00395	8b 08		 mov	 ecx, DWORD PTR [eax]
  00397	89 4d 0c	 mov	 DWORD PTR _state$[ebp], ecx

; 325  : 			in_size = thr->in_size;

  0039a	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  0039d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003a0	89 45 f8	 mov	 DWORD PTR _in_size$32398[ebp], eax
  003a3	eb a4		 jmp	 SHORT $LN7@worker_enc@2
$LN6@worker_enc@2:

; 326  : 		}

  003a5	e9 53 ff ff ff	 jmp	 $LN10@worker_enc@2
$LN9@worker_enc@2:

; 327  :     }
; 328  : 
; 329  : 		if (state >= THR_STOP)

  003aa	83 7d 0c 03	 cmp	 DWORD PTR _state$[ebp], 3
  003ae	7c 08		 jl	 SHORT $LN3@worker_enc@2

; 330  : 			return state;

  003b0	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003b3	e9 aa 00 00 00	 jmp	 $LN33@worker_enc@2
$LN3@worker_enc@2:

; 331  : 
; 332  : 		// Do the encoding. This takes care of the Block Header too.
; 333  : 		thr->outbuf->size = 0;

  003b8	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  003bb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003be	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 334  : 		ret = lzma_block_uncomp_encode(&thr->block_options,
; 335  : 				thr->in, in_size, thr->outbuf->buf,
; 336  : 				&thr->outbuf->size, out_size);

  003c5	8b 45 f0	 mov	 eax, DWORD PTR _out_size$32399[ebp]
  003c8	50		 push	 eax
  003c9	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  003cc	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003cf	83 c2 04	 add	 edx, 4
  003d2	52		 push	 edx
  003d3	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  003d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  003db	52		 push	 edx
  003dc	8b 45 f8	 mov	 eax, DWORD PTR _in_size$32398[ebp]
  003df	50		 push	 eax
  003e0	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  003e3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003e6	52		 push	 edx
  003e7	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  003ea	83 c0 58	 add	 eax, 88			; 00000058H
  003ed	50		 push	 eax
  003ee	e8 00 00 00 00	 call	 _lzma_block_uncomp_encode
  003f3	83 c4 18	 add	 esp, 24			; 00000018H
  003f6	89 45 fc	 mov	 DWORD PTR _ret$32394[ebp], eax

; 337  : 
; 338  : 		// It shouldn't fail.
; 339  : 		if (ret != LZMA_OK) {

  003f9	83 7d fc 00	 cmp	 DWORD PTR _ret$32394[ebp], 0
  003fd	74 15		 je	 SHORT $LN2@worker_enc@2

; 340  : 			worker_error(thr, LZMA_PROG_ERROR);

  003ff	6a 0b		 push	 11			; 0000000bH
  00401	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00404	51		 push	 ecx
  00405	e8 00 00 00 00	 call	 _worker_error
  0040a	83 c4 08	 add	 esp, 8

; 341  : 			return THR_STOP;

  0040d	b8 03 00 00 00	 mov	 eax, 3
  00412	eb 4e		 jmp	 SHORT $LN33@worker_enc@2
$LN2@worker_enc@2:

; 342  : 		}
; 343  : 
; 344  : 		break;

  00414	eb 17		 jmp	 SHORT $LN15@worker_enc@2
$LN1@worker_enc@2:

; 345  : 
; 346  : 	default:
; 347  : 		worker_error(thr, ret);

  00416	8b 55 fc	 mov	 edx, DWORD PTR _ret$32394[ebp]
  00419	52		 push	 edx
  0041a	8b 45 08	 mov	 eax, DWORD PTR _thr$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 _worker_error
  00423	83 c4 08	 add	 esp, 8

; 348  : 		return THR_STOP;

  00426	b8 03 00 00 00	 mov	 eax, 3
  0042b	eb 35		 jmp	 SHORT $LN33@worker_enc@2
$LN15@worker_enc@2:

; 349  :   }
; 350  :   }}}
; 351  : 
; 352  : 	// Set the size information that will be read by the main thread
; 353  : 	// to write the Index field.
; 354  : 	thr->outbuf->unpadded_size
; 355  : 			= lzma_block_unpadded_size(&thr->block_options);

  0042d	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00430	83 c1 58	 add	 ecx, 88			; 00000058H
  00433	51		 push	 ecx
  00434	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  00439	83 c4 04	 add	 esp, 4
  0043c	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  0043f	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00442	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00445	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 356  : 	assert(thr->outbuf->unpadded_size != 0);
; 357  : 	thr->outbuf->uncompressed_size = thr->block_options.uncompressed_size;

  00448	8b 55 08	 mov	 edx, DWORD PTR _thr$[ebp]
  0044b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0044e	8b 4d 08	 mov	 ecx, DWORD PTR _thr$[ebp]
  00451	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00454	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00457	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  0045a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 358  : 
; 359  : 	return THR_FINISH;

  0045d	b8 02 00 00 00	 mov	 eax, 2
$LN33@worker_enc@2:

; 360  : }

  00462	8b e5		 mov	 esp, ebp
  00464	5d		 pop	 ebp
  00465	c3		 ret	 0
_worker_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _worker_start@4
_TEXT	SEGMENT
tv137 = -60						; size = 4
tv92 = -56						; size = 4
tv70 = -52						; size = 4
$T80221 = -48						; size = 4
$T80217 = -44						; size = 4
$T80213 = -40						; size = 4
$T80200 = -36						; size = 4
_mythread_j_410$32480 = -32				; size = 4
_mythread_i_410$32479 = -28				; size = 4
_mythread_i_401$32470 = -24				; size = 4
_mythread_j_401$32471 = -20				; size = 4
_mythread_j_371$32454 = -16				; size = 4
_mythread_i_371$32453 = -12				; size = 4
_state$ = -8						; size = 4
_thr$ = -4						; size = 4
_thr_ptr$ = 8						; size = 4
_worker_start@4 PROC					; COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 366  : 	worker_thread *thr = thr_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _thr_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _thr$[ebp], eax

; 367  : 	worker_state state = THR_IDLE; // Init to silence a warning

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _state$[ebp], 0
$LN27@worker_sta:

; 368  : 
; 369  : 	while (true) {

  00013	b9 01 00 00 00	 mov	 ecx, 1
  00018	85 c9		 test	 ecx, ecx
  0001a	0f 84 e2 02 00
	00		 je	 $LN26@worker_sta

; 370  : 		// Wait for work.
; 371  : 		mythread_sync(thr->mutex) {

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mythread_i_371$32453[ebp], 0
  00027	eb 07		 jmp	 SHORT $LN25@worker_sta
$LN24@worker_sta:
  00029	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _mythread_i_371$32453[ebp], 1
$LN25@worker_sta:
  00030	83 7d f4 00	 cmp	 DWORD PTR _mythread_i_371$32453[ebp], 0
  00034	74 19		 je	 SHORT $LN30@worker_sta
  00036	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00039	81 c2 1c 01 00
	00		 add	 edx, 284		; 0000011cH
  0003f	52		 push	 edx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00046	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0004d	eb 16		 jmp	 SHORT $LN31@worker_sta
$LN30@worker_sta:
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00052	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0005e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN31@worker_sta:
  00065	83 7d cc 00	 cmp	 DWORD PTR tv70[ebp], 0
  00069	0f 84 8b 00 00
	00		 je	 $LN23@worker_sta
  0006f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mythread_j_371$32454[ebp], 0
  00076	eb 07		 jmp	 SHORT $LN22@worker_sta
$LN21@worker_sta:
  00078	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mythread_j_371$32454[ebp], 1
$LN22@worker_sta:
  0007f	83 7d f0 00	 cmp	 DWORD PTR _mythread_j_371$32454[ebp], 0
  00083	75 70		 jne	 SHORT $LN20@worker_sta
$LN19@worker_sta:

; 372  : 			while (true) {

  00085	b9 01 00 00 00	 mov	 ecx, 1
  0008a	85 c9		 test	 ecx, ecx
  0008c	74 65		 je	 SHORT $LN18@worker_sta

; 373  : 				// The thread is already idle so if we are
; 374  : 				// requested to stop, just set the state.
; 375  : 				if (thr->state == THR_STOP) {

  0008e	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00091	83 3a 03	 cmp	 DWORD PTR [edx], 3
  00094	75 19		 jne	 SHORT $LN17@worker_sta

; 376  : 					thr->state = THR_IDLE;

  00096	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00099	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 377  : 					mythread_cond_signal(&thr->cond);

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  000a2	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN17@worker_sta:

; 378  : 				}
; 379  : 
; 380  : 				state = thr->state;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d f8	 mov	 DWORD PTR _state$[ebp], ecx

; 381  : 				if (state != THR_IDLE)

  000b7	83 7d f8 00	 cmp	 DWORD PTR _state$[ebp], 0
  000bb	74 02		 je	 SHORT $LN16@worker_sta

; 382  : 					break;

  000bd	eb 34		 jmp	 SHORT $LN18@worker_sta
$LN16@worker_sta:

; 383  : 
; 384  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  000c2	81 c2 1c 01 00
	00		 add	 edx, 284		; 0000011cH
  000c8	89 55 dc	 mov	 DWORD PTR $T80200[ebp], edx
  000cb	8b 45 dc	 mov	 eax, DWORD PTR $T80200[ebp]
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000d5	6a ff		 push	 -1
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  000da	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  000e0	52		 push	 edx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  000e7	8b 45 dc	 mov	 eax, DWORD PTR $T80200[ebp]
  000ea	50		 push	 eax
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 385  : 			}

  000f1	eb 92		 jmp	 SHORT $LN19@worker_sta
$LN18@worker_sta:

; 386  : 		}

  000f3	eb 83		 jmp	 SHORT $LN21@worker_sta
$LN20@worker_sta:
  000f5	e9 2f ff ff ff	 jmp	 $LN24@worker_sta
$LN23@worker_sta:

; 387  : 
; 388  : 		assert(state != THR_IDLE);
; 389  : 		assert(state != THR_STOP);
; 390  : 
; 391  : 		if (state <= THR_FINISH)

  000fa	83 7d f8 02	 cmp	 DWORD PTR _state$[ebp], 2
  000fe	7f 13		 jg	 SHORT $LN15@worker_sta

; 392  : 			state = worker_encode(thr, state);

  00100	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00103	51		 push	 ecx
  00104	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _worker_encode
  0010d	83 c4 08	 add	 esp, 8
  00110	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax
$LN15@worker_sta:

; 393  : 
; 394  : 		if (state == THR_EXIT)

  00113	83 7d f8 04	 cmp	 DWORD PTR _state$[ebp], 4
  00117	75 05		 jne	 SHORT $LN14@worker_sta

; 395  : 			break;

  00119	e9 e4 01 00 00	 jmp	 $LN26@worker_sta
$LN14@worker_sta:

; 396  : 
; 397  : 		// Mark the thread as idle unless the main thread has
; 398  : 		// told us to exit. Signal is needed for the case
; 399  : 		// where the main thread is waiting for the threads to stop.
; 400  :     {
; 401  : 		mythread_sync(thr->mutex) {

  0011e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_401$32470[ebp], 0
  00125	eb 07		 jmp	 SHORT $LN13@worker_sta
$LN12@worker_sta:
  00127	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_401$32470[ebp], 1
$LN13@worker_sta:
  0012e	83 7d e8 00	 cmp	 DWORD PTR _mythread_i_401$32470[ebp], 0
  00132	74 18		 je	 SHORT $LN32@worker_sta
  00134	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00137	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  0013c	50		 push	 eax
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00143	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  0014a	eb 17		 jmp	 SHORT $LN33@worker_sta
$LN32@worker_sta:
  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  0014f	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00155	51		 push	 ecx
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0015c	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
$LN33@worker_sta:
  00163	83 7d c8 00	 cmp	 DWORD PTR tv92[ebp], 0
  00167	74 3b		 je	 SHORT $LN11@worker_sta
  00169	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_j_401$32471[ebp], 0
  00170	eb 07		 jmp	 SHORT $LN10@worker_sta
$LN9@worker_sta:
  00172	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_j_401$32471[ebp], 1
$LN10@worker_sta:
  00179	83 7d ec 00	 cmp	 DWORD PTR _mythread_j_401$32471[ebp], 0
  0017d	75 23		 jne	 SHORT $LN8@worker_sta

; 402  : 			if (thr->state != THR_EXIT) {

  0017f	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00182	83 3a 04	 cmp	 DWORD PTR [edx], 4
  00185	74 19		 je	 SHORT $LN7@worker_sta

; 403  : 				thr->state = THR_IDLE;

  00187	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  0018a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 404  : 				mythread_cond_signal(&thr->cond);

  00190	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00193	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  00199	52		 push	 edx
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN7@worker_sta:

; 405  : 			}

  001a0	eb d0		 jmp	 SHORT $LN9@worker_sta
$LN8@worker_sta:

; 406  : 		}

  001a2	eb 83		 jmp	 SHORT $LN12@worker_sta
$LN11@worker_sta:

; 407  :     }
; 408  : 
; 409  :     {
; 410  : 		mythread_sync(thr->coder->mutex) {

  001a4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _mythread_i_410$32479[ebp], 0
  001ab	eb 07		 jmp	 SHORT $LN6@worker_sta
$LN5@worker_sta:
  001ad	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _mythread_i_410$32479[ebp], 1
$LN6@worker_sta:
  001b4	83 7d e4 00	 cmp	 DWORD PTR _mythread_i_410$32479[ebp], 0
  001b8	74 22		 je	 SHORT $LN34@worker_sta
  001ba	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  001bd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001c0	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  001c6	89 4d d8	 mov	 DWORD PTR $T80213[ebp], ecx
  001c9	8b 55 d8	 mov	 edx, DWORD PTR $T80213[ebp]
  001cc	52		 push	 edx
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001d3	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  001da	eb 20		 jmp	 SHORT $LN35@worker_sta
$LN34@worker_sta:
  001dc	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  001df	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001e2	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  001e8	89 4d d4	 mov	 DWORD PTR $T80217[ebp], ecx
  001eb	8b 55 d4	 mov	 edx, DWORD PTR $T80217[ebp]
  001ee	52		 push	 edx
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001f5	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
$LN35@worker_sta:
  001fc	83 7d c4 00	 cmp	 DWORD PTR tv137[ebp], 0
  00200	0f 84 f7 00 00
	00		 je	 $LN4@worker_sta
  00206	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _mythread_j_410$32480[ebp], 0
  0020d	eb 07		 jmp	 SHORT $LN3@worker_sta
$LN2@worker_sta:
  0020f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _mythread_j_410$32480[ebp], 1
$LN3@worker_sta:
  00216	83 7d e0 00	 cmp	 DWORD PTR _mythread_j_410$32480[ebp], 0
  0021a	0f 85 d8 00 00
	00		 jne	 $LN1@worker_sta

; 411  : 			// Mark the output buffer as finished if
; 412  : 			// no errors occurred.
; 413  : 			thr->outbuf->finished = state == THR_FINISH;

  00220	33 c0		 xor	 eax, eax
  00222	83 7d f8 02	 cmp	 DWORD PTR _state$[ebp], 2
  00226	0f 94 c0	 sete	 al
  00229	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  0022c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0022f	88 42 18	 mov	 BYTE PTR [edx+24], al

; 414  : 
; 415  : 			// Update the main progress info.
; 416  : 			thr->coder->progress_in
; 417  : 					+= thr->outbuf->uncompressed_size;

  00232	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00235	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00238	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  0023b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0023e	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [ecx+272]
  00244	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00247	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [ecx+276]
  0024d	13 48 14	 adc	 ecx, DWORD PTR [eax+20]
  00250	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00253	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00256	89 90 10 01 00
	00		 mov	 DWORD PTR [eax+272], edx
  0025c	89 88 14 01 00
	00		 mov	 DWORD PTR [eax+276], ecx

; 418  : 			thr->coder->progress_out += thr->outbuf->size;

  00262	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00265	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00268	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  0026b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0026e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00271	33 c9		 xor	 ecx, ecx
  00273	03 82 18 01 00
	00		 add	 eax, DWORD PTR [edx+280]
  00279	8b 92 1c 01 00
	00		 mov	 edx, DWORD PTR [edx+284]
  0027f	13 d1		 adc	 edx, ecx
  00281	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00284	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00287	89 81 18 01 00
	00		 mov	 DWORD PTR [ecx+280], eax
  0028d	89 91 1c 01 00
	00		 mov	 DWORD PTR [ecx+284], edx

; 419  : 			thr->progress_in = 0;

  00293	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00296	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
  0029d	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 420  : 			thr->progress_out = 0;

  002a4	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  002a7	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  002ae	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 421  : 
; 422  : 			// Return this thread to the stack of free threads.
; 423  : 			thr->next = thr->coder->threads_free;

  002b5	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  002b8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002bb	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  002be	8b 8a 08 01 00
	00		 mov	 ecx, DWORD PTR [edx+264]
  002c4	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx

; 424  : 			thr->coder->threads_free = thr;

  002ca	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  002cd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  002d3	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx

; 425  : 
; 426  : 			mythread_cond_signal(&thr->coder->cond);

  002d9	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  002dc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002df	05 38 01 00 00	 add	 eax, 312		; 00000138H
  002e4	89 45 d0	 mov	 DWORD PTR $T80221[ebp], eax
  002e7	8b 4d d0	 mov	 ecx, DWORD PTR $T80221[ebp]
  002ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ec	52		 push	 edx
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 427  : 		}

  002f3	e9 17 ff ff ff	 jmp	 $LN2@worker_sta
$LN1@worker_sta:
  002f8	e9 b0 fe ff ff	 jmp	 $LN5@worker_sta
$LN4@worker_sta:

; 428  :     }
; 429  : 	}

  002fd	e9 11 fd ff ff	 jmp	 $LN27@worker_sta
$LN26@worker_sta:

; 430  : 
; 431  : 	// Exiting, free the resources.
; 432  : 	mythread_mutex_destroy(&thr->mutex);

  00302	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00305	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  0030a	50		 push	 eax
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 433  : 	mythread_cond_destroy(&thr->cond);

  00311	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00314	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  0031a	52		 push	 edx
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 434  : 
; 435  : 	lzma_next_end(&thr->block_encoder, thr->allocator);

  00321	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00324	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00327	51		 push	 ecx
  00328	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  0032b	83 c2 28	 add	 edx, 40			; 00000028H
  0032e	52		 push	 edx
  0032f	e8 00 00 00 00	 call	 _lzma_next_end
  00334	83 c4 08	 add	 esp, 8

; 436  : 	lzma_free(thr->in, thr->allocator);

  00337	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  0033a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0033d	51		 push	 ecx
  0033e	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  00341	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 _lzma_free
  0034a	83 c4 08	 add	 esp, 8

; 437  : 	return MYTHREAD_RET_VALUE;

  0034d	33 c0		 xor	 eax, eax

; 438  : }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c2 04 00	 ret	 4
_worker_start@4 ENDP
; Function compile flags: /Odtp
;	COMDAT _initialize_new_thread
_TEXT	SEGMENT
$T80456 = -16						; size = 4
_ret$80453 = -12					; size = 4
$T80450 = -8						; size = 4
_thr$ = -4						; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_initialize_new_thread PROC				; COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 499  : 	worker_thread *thr = &coder->threads[coder->threads_initialized];

  00008	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0000b	8b 88 04 01 00
	00		 mov	 ecx, DWORD PTR [eax+260]
  00011	69 c9 40 01 00
	00		 imul	 ecx, 320		; 00000140H
  00017	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0001a	03 8a fc 00 00
	00		 add	 ecx, DWORD PTR [edx+252]
  00020	89 4d fc	 mov	 DWORD PTR _thr$[ebp], ecx

; 500  : 
; 501  : 	thr->in = lzma_alloc(coder->block_size, allocator);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _lzma_alloc
  00033	83 c4 08	 add	 esp, 8
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00039	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 502  : 	if (thr->in == NULL)

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  0003f	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00043	75 0a		 jne	 SHORT $LN4@initialize

; 503  : 		return LZMA_MEM_ERROR;

  00045	b8 05 00 00 00	 mov	 eax, 5
  0004a	e9 3d 01 00 00	 jmp	 $LN5@initialize
$LN4@initialize:

; 504  : 
; 505  : 	if (mythread_mutex_init(&thr->mutex))

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00052	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  0005e	33 c9		 xor	 ecx, ecx
  00060	74 05		 je	 SHORT $LN3@initialize

; 506  : 		goto error_mutex;

  00062	e9 0d 01 00 00	 jmp	 $error_mutex$32554
$LN3@initialize:

; 507  : 
; 508  : 	if (mythread_cond_init(&thr->cond))

  00067	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  0006a	81 c2 34 01 00
	00		 add	 edx, 308		; 00000134H
  00070	89 55 f8	 mov	 DWORD PTR $T80450[ebp], edx
  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00081	8b 4d f8	 mov	 ecx, DWORD PTR $T80450[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax
  00086	8b 55 f8	 mov	 edx, DWORD PTR $T80450[ebp]
  00089	8b 02		 mov	 eax, DWORD PTR [edx]
  0008b	f7 d8		 neg	 eax
  0008d	1b c0		 sbb	 eax, eax
  0008f	f7 d8		 neg	 eax
  00091	83 e8 01	 sub	 eax, 1
  00094	74 05		 je	 SHORT $LN2@initialize

; 509  : 		goto error_cond;

  00096	e9 ca 00 00 00	 jmp	 $error_cond$32556
$LN2@initialize:

; 510  : 
; 511  : 	thr->state = THR_IDLE;

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  0009e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 512  : 	thr->allocator = allocator;

  000a4	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000aa	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 513  : 	thr->coder = coder;

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  000b0	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000b3	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 514  : 	thr->progress_in = 0;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  000b9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  000c0	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 515  : 	thr->progress_out = 0;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  000ca	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  000d1	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 516  : 	thr->block_encoder = LZMA_NEXT_CODER_INIT;

  000d8	8b 7d fc	 mov	 edi, DWORD PTR _thr$[ebp]
  000db	83 c7 28	 add	 edi, 40			; 00000028H
  000de	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000e3	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000e8	f3 a5		 rep movsd

; 517  : 
; 518  : 	if (mythread_create(&thr->thread_id, &worker_start, thr))

  000ea	6a 00		 push	 0
  000ec	6a 00		 push	 0
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  000f1	52		 push	 edx
  000f2	68 00 00 00 00	 push	 OFFSET _worker_start@4
  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	e8 00 00 00 00	 call	 __beginthreadex
  00100	83 c4 18	 add	 esp, 24			; 00000018H
  00103	89 45 f4	 mov	 DWORD PTR _ret$80453[ebp], eax
  00106	83 7d f4 00	 cmp	 DWORD PTR _ret$80453[ebp], 0
  0010a	75 09		 jne	 SHORT $LN11@initialize
  0010c	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR $T80456[ebp], -1
  00113	eb 13		 jmp	 SHORT $LN12@initialize
$LN11@initialize:
  00115	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _ret$80453[ebp]
  0011b	89 88 38 01 00
	00		 mov	 DWORD PTR [eax+312], ecx
  00121	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T80456[ebp], 0
$LN12@initialize:
  00128	83 7d f0 00	 cmp	 DWORD PTR $T80456[ebp], 0
  0012c	74 02		 je	 SHORT $LN1@initialize

; 519  : 		goto error_thread;

  0012e	eb 25		 jmp	 SHORT $error_thread$32558
$LN1@initialize:

; 520  : 
; 521  : 	++coder->threads_initialized;

  00130	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00133	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  00139	83 c0 01	 add	 eax, 1
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013f	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 522  : 	coder->thr = thr;

  00145	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00148	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  0014b	89 82 0c 01 00
	00		 mov	 DWORD PTR [edx+268], eax

; 523  : 
; 524  : 	return LZMA_OK;

  00151	33 c0		 xor	 eax, eax
  00153	eb 37		 jmp	 SHORT $LN5@initialize
$error_thread$32558:

; 525  : 
; 526  : error_thread:
; 527  : 	mythread_cond_destroy(&thr->cond);

  00155	8b 4d fc	 mov	 ecx, DWORD PTR _thr$[ebp]
  00158	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  0015e	52		 push	 edx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$error_cond$32556:

; 528  : 
; 529  : error_cond:
; 530  : 	mythread_mutex_destroy(&thr->mutex);

  00165	8b 45 fc	 mov	 eax, DWORD PTR _thr$[ebp]
  00168	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  0016d	50		 push	 eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$error_mutex$32554:

; 531  : 
; 532  : error_mutex:
; 533  : 	lzma_free(thr->in, allocator);

  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00177	51		 push	 ecx
  00178	8b 55 fc	 mov	 edx, DWORD PTR _thr$[ebp]
  0017b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 _lzma_free
  00184	83 c4 08	 add	 esp, 8

; 534  : 	return LZMA_MEM_ERROR;

  00187	b8 05 00 00 00	 mov	 eax, 5
$LN5@initialize:

; 535  : }

  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
_initialize_new_thread ENDP
; Function compile flags: /Odtp
;	COMDAT _get_thread
_TEXT	SEGMENT
tv133 = -44						; size = 4
tv74 = -40						; size = 4
$T80577 = -36						; size = 4
$T80573 = -32						; size = 4
$T80569 = -28						; size = 4
$T80559 = -24						; size = 4
_mythread_j_568$32585 = -20				; size = 4
_mythread_i_568$32584 = -16				; size = 4
_ret_$32582 = -12					; size = 4
_mythread_i_548$32566 = -8				; size = 4
_mythread_j_548$32567 = -4				; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_get_thread PROC					; COMDAT

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 541  : 	// If there are no free output subqueues, there is no
; 542  : 	// point to try getting a thread.
; 543  : 	if (!lzma_outq_has_buf(&coder->outq))

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	05 d8 00 00 00	 add	 eax, 216		; 000000d8H
  0000e	89 45 e8	 mov	 DWORD PTR $T80559[ebp], eax
  00011	8b 4d e8	 mov	 ecx, DWORD PTR $T80559[ebp]
  00014	8b 55 e8	 mov	 edx, DWORD PTR $T80559[ebp]
  00017	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0001a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0001d	1b c9		 sbb	 ecx, ecx
  0001f	f7 d9		 neg	 ecx
  00021	0f b6 d1	 movzx	 edx, cl
  00024	85 d2		 test	 edx, edx
  00026	75 07		 jne	 SHORT $LN20@get_thread

; 544  : 		return LZMA_OK;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 c5 01 00 00	 jmp	 $LN21@get_thread
$LN20@get_thread:

; 545  : 
; 546  : 	// If there is a free structure on the stack, use it.
; 547  :   {
; 548  : 	mythread_sync(coder->mutex) {

  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_548$32566[ebp], 0
  00036	eb 07		 jmp	 SHORT $LN19@get_thread
$LN18@get_thread:
  00038	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_548$32566[ebp], 1
$LN19@get_thread:
  0003f	83 7d f8 00	 cmp	 DWORD PTR _mythread_i_548$32566[ebp], 0
  00043	74 18		 je	 SHORT $LN23@get_thread
  00045	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00048	05 20 01 00 00	 add	 eax, 288		; 00000120H
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00054	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0005b	eb 17		 jmp	 SHORT $LN24@get_thread
$LN23@get_thread:
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00060	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00066	51		 push	 ecx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0006d	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN24@get_thread:
  00074	83 7d d8 00	 cmp	 DWORD PTR tv74[ebp], 0
  00078	74 53		 je	 SHORT $LN17@get_thread
  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mythread_j_548$32567[ebp], 0
  00081	eb 07		 jmp	 SHORT $LN16@get_thread
$LN15@get_thread:
  00083	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _mythread_j_548$32567[ebp], 1
$LN16@get_thread:
  0008a	83 7d fc 00	 cmp	 DWORD PTR _mythread_j_548$32567[ebp], 0
  0008e	75 38		 jne	 SHORT $LN14@get_thread

; 549  : 		if (coder->threads_free != NULL) {

  00090	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00093	83 ba 08 01 00
	00 00		 cmp	 DWORD PTR [edx+264], 0
  0009a	74 2a		 je	 SHORT $LN13@get_thread

; 550  : 			coder->thr = coder->threads_free;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a2	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  000a8	89 90 0c 01 00
	00		 mov	 DWORD PTR [eax+268], edx

; 551  : 			coder->threads_free = coder->threads_free->next;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000b1	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  000b7	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ba	8b 81 18 01 00
	00		 mov	 eax, DWORD PTR [ecx+280]
  000c0	89 82 08 01 00
	00		 mov	 DWORD PTR [edx+264], eax
$LN13@get_thread:

; 552  : 		}

  000c6	eb bb		 jmp	 SHORT $LN15@get_thread
$LN14@get_thread:

; 553  : 	}

  000c8	e9 6b ff ff ff	 jmp	 $LN18@get_thread
$LN17@get_thread:

; 554  :   }
; 555  : 
; 556  : 	if (coder->thr == NULL) {

  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d0	83 b9 0c 01 00
	00 00		 cmp	 DWORD PTR [ecx+268], 0
  000d7	75 40		 jne	 SHORT $LN12@get_thread

; 557  : 		// If there are no uninitialized structures left, return.
; 558  : 		if (coder->threads_initialized == coder->threads_max)

  000d9	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000dc	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000df	8b 8a 04 01 00
	00		 mov	 ecx, DWORD PTR [edx+260]
  000e5	3b 88 00 01 00
	00		 cmp	 ecx, DWORD PTR [eax+256]
  000eb	75 07		 jne	 SHORT $LN10@get_thread

; 559  : 			return LZMA_OK;

  000ed	33 c0		 xor	 eax, eax
  000ef	e9 00 01 00 00	 jmp	 $LN21@get_thread
$LN10@get_thread:

; 560  : 
; 561  : 		// Initialize a new thread.
; 562  : 		return_if_error(initialize_new_thread(coder, allocator));

  000f4	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000f7	52		 push	 edx
  000f8	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _initialize_new_thread
  00101	83 c4 08	 add	 esp, 8
  00104	89 45 f4	 mov	 DWORD PTR _ret_$32582[ebp], eax
  00107	83 7d f4 00	 cmp	 DWORD PTR _ret_$32582[ebp], 0
  0010b	74 08		 je	 SHORT $LN9@get_thread
  0010d	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32582[ebp]
  00110	e9 df 00 00 00	 jmp	 $LN21@get_thread
$LN9@get_thread:
  00115	33 c9		 xor	 ecx, ecx
  00117	75 db		 jne	 SHORT $LN10@get_thread
$LN12@get_thread:

; 563  : 	}
; 564  : 
; 565  : 	// Reset the parts of the thread state that have to be done
; 566  : 	// in the main thread.
; 567  :   {
; 568  : 	mythread_sync(coder->thr->mutex) {

  00119	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mythread_i_568$32584[ebp], 0
  00120	eb 07		 jmp	 SHORT $LN6@get_thread
$LN5@get_thread:
  00122	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mythread_i_568$32584[ebp], 1
$LN6@get_thread:
  00129	83 7d f0 00	 cmp	 DWORD PTR _mythread_i_568$32584[ebp], 0
  0012d	74 24		 je	 SHORT $LN25@get_thread
  0012f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00132	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  00138	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  0013d	89 45 e4	 mov	 DWORD PTR $T80569[ebp], eax
  00140	8b 4d e4	 mov	 ecx, DWORD PTR $T80569[ebp]
  00143	51		 push	 ecx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0014a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  00151	eb 22		 jmp	 SHORT $LN26@get_thread
$LN25@get_thread:
  00153	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00156	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  0015c	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  00161	89 45 e0	 mov	 DWORD PTR $T80573[ebp], eax
  00164	8b 4d e0	 mov	 ecx, DWORD PTR $T80573[ebp]
  00167	51		 push	 ecx
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0016e	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
$LN26@get_thread:
  00175	83 7d d4 00	 cmp	 DWORD PTR tv133[ebp], 0
  00179	74 77		 je	 SHORT $LN4@get_thread
  0017b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_j_568$32585[ebp], 0
  00182	eb 07		 jmp	 SHORT $LN3@get_thread
$LN2@get_thread:
  00184	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_j_568$32585[ebp], 1
$LN3@get_thread:
  0018b	83 7d ec 00	 cmp	 DWORD PTR _mythread_j_568$32585[ebp], 0
  0018f	75 5c		 jne	 SHORT $LN1@get_thread

; 569  : 		coder->thr->state = THR_RUN;

  00191	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00194	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  0019a	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 570  : 		coder->thr->in_size = 0;

  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001a3	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  001a9	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 571  : 		coder->thr->outbuf = lzma_outq_get_buf(&coder->outq);

  001b0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001b3	05 d8 00 00 00	 add	 eax, 216		; 000000d8H
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 _lzma_outq_get_buf
  001be	83 c4 04	 add	 esp, 4
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c4	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  001ca	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 572  : 		mythread_cond_signal(&coder->thr->cond);

  001cd	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001d0	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  001d6	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  001dc	89 4d dc	 mov	 DWORD PTR $T80577[ebp], ecx
  001df	8b 55 dc	 mov	 edx, DWORD PTR $T80577[ebp]
  001e2	8b 02		 mov	 eax, DWORD PTR [edx]
  001e4	50		 push	 eax
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 573  : 	}

  001eb	eb 97		 jmp	 SHORT $LN2@get_thread
$LN1@get_thread:
  001ed	e9 30 ff ff ff	 jmp	 $LN5@get_thread
$LN4@get_thread:

; 574  :   }
; 575  : 
; 576  : 	return LZMA_OK;

  001f2	33 c0		 xor	 eax, eax
$LN21@get_thread:

; 577  : }

  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
_get_thread ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_encode_in
_TEXT	SEGMENT
tv153 = -56						; size = 4
tv131 = -52						; size = 4
tv90 = -48						; size = 4
$T80644 = -44						; size = 4
$T80640 = -40						; size = 4
$T80636 = -36						; size = 4
_mythread_j_636$32633 = -32				; size = 4
_mythread_i_636$32632 = -28				; size = 4
_ret$32631 = -24					; size = 4
_mythread_j_613$32620 = -20				; size = 4
_mythread_i_613$32619 = -16				; size = 4
_block_error$32618 = -10				; size = 1
_finish$32617 = -9					; size = 1
_thr_in_size$32616 = -8					; size = 4
_ret$32613 = -4						; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_action$ = 28						; size = 4
_stream_encode_in PROC					; COMDAT

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
$LN22@stream_enc@6:

; 585  : 	while (*in_pos < in_size
; 586  : 			|| (coder->thr != NULL && action != LZMA_RUN)) {

  00006	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  0000e	72 1a		 jb	 SHORT $LN20@stream_enc@6
  00010	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00013	83 ba 0c 01 00
	00 00		 cmp	 DWORD PTR [edx+268], 0
  0001a	0f 84 1e 02 00
	00		 je	 $LN21@stream_enc@6
  00020	83 7d 1c 00	 cmp	 DWORD PTR _action$[ebp], 0
  00024	0f 84 14 02 00
	00		 je	 $LN21@stream_enc@6
$LN20@stream_enc@6:

; 587  : 		if (coder->thr == NULL) {

  0002a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002d	83 b8 0c 01 00
	00 00		 cmp	 DWORD PTR [eax+268], 0
  00034	75 27		 jne	 SHORT $LN19@stream_enc@6

; 588  : 			// Get a new thread.
; 589  : 			const lzma_ret ret = get_thread(coder, allocator);

  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _get_thread
  00043	83 c4 08	 add	 esp, 8
  00046	89 45 fc	 mov	 DWORD PTR _ret$32613[ebp], eax

; 590  : 			if (coder->thr == NULL)

  00049	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0004c	83 b8 0c 01 00
	00 00		 cmp	 DWORD PTR [eax+268], 0
  00053	75 08		 jne	 SHORT $LN19@stream_enc@6

; 591  : 				return ret;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _ret$32613[ebp]
  00058	e9 e3 01 00 00	 jmp	 $LN23@stream_enc@6
$LN19@stream_enc@6:

; 592  : 		}
; 593  : 
; 594  : 		// Copy the input data to thread's buffer.
; 595  :     {
; 596  : 		size_t thr_in_size = coder->thr->in_size;

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00060	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  00066	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00069	89 45 f8	 mov	 DWORD PTR _thr_in_size$32616[ebp], eax

; 597  : 		lzma_bufcpy(in, in_pos, in_size, coder->thr->in,
; 598  : 				&thr_in_size, coder->block_size);

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00072	52		 push	 edx
  00073	8d 45 f8	 lea	 eax, DWORD PTR _thr_in_size$32616[ebp]
  00076	50		 push	 eax
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007a	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  00080	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00083	50		 push	 eax
  00084	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _lzma_bufcpy
  00095	83 c4 18	 add	 esp, 24			; 00000018H

; 599  : 
; 600  : 		// Tell the Block encoder to finish if
; 601  : 		//  - it has got block_size bytes of input; or
; 602  : 		//  - all input was used and LZMA_FINISH, LZMA_FULL_FLUSH,
; 603  : 		//    or LZMA_FULL_BARRIER was used.
; 604  : 		//
; 605  : 		// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
; 606  :     {
; 607  : 		const bool finish = thr_in_size == coder->block_size
; 608  : 				|| (*in_pos == in_size && action != LZMA_RUN);

  00098	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0009b	8b 55 f8	 mov	 edx, DWORD PTR _thr_in_size$32616[ebp]
  0009e	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000a1	74 19		 je	 SHORT $LN26@stream_enc@6
  000a3	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  000ab	75 06		 jne	 SHORT $LN25@stream_enc@6
  000ad	83 7d 1c 00	 cmp	 DWORD PTR _action$[ebp], 0
  000b1	75 09		 jne	 SHORT $LN26@stream_enc@6
$LN25@stream_enc@6:
  000b3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  000ba	eb 07		 jmp	 SHORT $LN27@stream_enc@6
$LN26@stream_enc@6:
  000bc	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
$LN27@stream_enc@6:
  000c3	8a 55 d0	 mov	 dl, BYTE PTR tv90[ebp]
  000c6	88 55 f7	 mov	 BYTE PTR _finish$32617[ebp], dl

; 609  : 
; 610  : 		bool block_error = false;

  000c9	c6 45 f6 00	 mov	 BYTE PTR _block_error$32618[ebp], 0

; 611  : 
; 612  :     {
; 613  : 		mythread_sync(coder->thr->mutex) {

  000cd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mythread_i_613$32619[ebp], 0
  000d4	eb 07		 jmp	 SHORT $LN17@stream_enc@6
$LN16@stream_enc@6:
  000d6	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _mythread_i_613$32619[ebp], 1
$LN17@stream_enc@6:
  000dd	83 7d f0 00	 cmp	 DWORD PTR _mythread_i_613$32619[ebp], 0
  000e1	74 25		 je	 SHORT $LN28@stream_enc@6
  000e3	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000e6	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  000ec	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  000f2	89 4d dc	 mov	 DWORD PTR $T80636[ebp], ecx
  000f5	8b 55 dc	 mov	 edx, DWORD PTR $T80636[ebp]
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000ff	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  00106	eb 23		 jmp	 SHORT $LN29@stream_enc@6
$LN28@stream_enc@6:
  00108	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0010b	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  00111	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00117	89 4d d8	 mov	 DWORD PTR $T80640[ebp], ecx
  0011a	8b 55 d8	 mov	 edx, DWORD PTR $T80640[ebp]
  0011d	52		 push	 edx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00124	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
$LN29@stream_enc@6:
  0012b	83 7d cc 00	 cmp	 DWORD PTR tv131[ebp], 0
  0012f	74 74		 je	 SHORT $LN15@stream_enc@6
  00131	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mythread_j_613$32620[ebp], 0
  00138	eb 07		 jmp	 SHORT $LN14@stream_enc@6
$LN13@stream_enc@6:
  0013a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mythread_j_613$32620[ebp], 1
$LN14@stream_enc@6:
  00141	83 7d ec 00	 cmp	 DWORD PTR _mythread_j_613$32620[ebp], 0
  00145	75 59		 jne	 SHORT $LN12@stream_enc@6

; 614  : 			if (coder->thr->state == THR_IDLE) {

  00147	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0014a	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  00150	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00153	75 06		 jne	 SHORT $LN11@stream_enc@6

; 615  : 				// Something has gone wrong with the Block
; 616  : 				// encoder. It has set coder->thread_error
; 617  : 				// which we will read a few lines later.
; 618  : 				block_error = true;

  00155	c6 45 f6 01	 mov	 BYTE PTR _block_error$32618[ebp], 1

; 619  : 			} else {

  00159	eb 43		 jmp	 SHORT $LN10@stream_enc@6
$LN11@stream_enc@6:

; 620  : 				// Tell the Block encoder its new amount
; 621  : 				// of input and update the state if needed.
; 622  : 				coder->thr->in_size = thr_in_size;

  0015b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0015e	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _thr_in_size$32616[ebp]
  00167	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 623  : 
; 624  : 				if (finish)

  0016a	0f b6 55 f7	 movzx	 edx, BYTE PTR _finish$32617[ebp]
  0016e	85 d2		 test	 edx, edx
  00170	74 0f		 je	 SHORT $LN9@stream_enc@6

; 625  : 					coder->thr->state = THR_FINISH;

  00172	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00175	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  0017b	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN9@stream_enc@6:

; 626  : 
; 627  : 				mythread_cond_signal(&coder->thr->cond);

  00181	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00184	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR [edx+268]
  0018a	05 34 01 00 00	 add	 eax, 308		; 00000134H
  0018f	89 45 d4	 mov	 DWORD PTR $T80644[ebp], eax
  00192	8b 4d d4	 mov	 ecx, DWORD PTR $T80644[ebp]
  00195	8b 11		 mov	 edx, DWORD PTR [ecx]
  00197	52		 push	 edx
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN10@stream_enc@6:

; 628  : 			}

  0019e	eb 9a		 jmp	 SHORT $LN13@stream_enc@6
$LN12@stream_enc@6:

; 629  : 		}

  001a0	e9 31 ff ff ff	 jmp	 $LN16@stream_enc@6
$LN15@stream_enc@6:

; 630  :     }
; 631  : 
; 632  : 		if (block_error) {

  001a5	0f b6 45 f6	 movzx	 eax, BYTE PTR _block_error$32618[ebp]
  001a9	85 c0		 test	 eax, eax
  001ab	74 77		 je	 SHORT $LN8@stream_enc@6

; 633  : 			lzma_ret ret;
; 634  : 
; 635  :       {
; 636  : 			mythread_sync(coder->mutex) {

  001ad	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _mythread_i_636$32632[ebp], 0
  001b4	eb 07		 jmp	 SHORT $LN7@stream_enc@6
$LN6@stream_enc@6:
  001b6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _mythread_i_636$32632[ebp], 1
$LN7@stream_enc@6:
  001bd	83 7d e4 00	 cmp	 DWORD PTR _mythread_i_636$32632[ebp], 0
  001c1	74 19		 je	 SHORT $LN30@stream_enc@6
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c6	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  001cc	51		 push	 ecx
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001d3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv153[ebp], 0
  001da	eb 17		 jmp	 SHORT $LN31@stream_enc@6
$LN30@stream_enc@6:
  001dc	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001df	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  001e5	52		 push	 edx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001ec	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv153[ebp], 1
$LN31@stream_enc@6:
  001f3	83 7d c8 00	 cmp	 DWORD PTR tv153[ebp], 0
  001f7	74 26		 je	 SHORT $LN5@stream_enc@6
  001f9	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _mythread_j_636$32633[ebp], 0
  00200	eb 07		 jmp	 SHORT $LN4@stream_enc@6
$LN3@stream_enc@6:
  00202	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _mythread_j_636$32633[ebp], 1
$LN4@stream_enc@6:
  00209	83 7d e0 00	 cmp	 DWORD PTR _mythread_j_636$32633[ebp], 0
  0020d	75 0e		 jne	 SHORT $LN2@stream_enc@6

; 637  : 				ret = coder->thread_error;

  0020f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00212	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  00218	89 4d e8	 mov	 DWORD PTR _ret$32631[ebp], ecx
  0021b	eb e5		 jmp	 SHORT $LN3@stream_enc@6
$LN2@stream_enc@6:

; 638  : 			}

  0021d	eb 97		 jmp	 SHORT $LN6@stream_enc@6
$LN5@stream_enc@6:

; 639  :       }
; 640  : 
; 641  : 			return ret;

  0021f	8b 45 e8	 mov	 eax, DWORD PTR _ret$32631[ebp]
  00222	eb 1c		 jmp	 SHORT $LN23@stream_enc@6
$LN8@stream_enc@6:

; 642  : 		}
; 643  : 
; 644  : 		if (finish)

  00224	0f b6 55 f7	 movzx	 edx, BYTE PTR _finish$32617[ebp]
  00228	85 d2		 test	 edx, edx
  0022a	74 0d		 je	 SHORT $LN1@stream_enc@6

; 645  : 			coder->thr = NULL;

  0022c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0022f	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0
$LN1@stream_enc@6:

; 646  :     }}
; 647  :   }

  00239	e9 c8 fd ff ff	 jmp	 $LN22@stream_enc@6
$LN21@stream_enc@6:

; 648  : 
; 649  : 	return LZMA_OK;

  0023e	33 c0		 xor	 eax, eax
$LN23@stream_enc@6:

; 650  : }

  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c3		 ret	 0
_stream_encode_in ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_encode_mt
_TEXT	SEGMENT
tv82 = -60						; size = 4
tv64 = -56						; size = 4
_ret$32733 = -52					; size = 4
_ret_$32730 = -48					; size = 4
_mythread_j_737$32706 = -44				; size = 4
_mythread_i_737$32705 = -40				; size = 4
_ret$32699 = -36					; size = 4
_uncompressed_size$32698 = -32				; size = 8
_unpadded_size$32697 = -24				; size = 8
_wait_abs$32701 = -16					; size = 8
_has_blocked$32700 = -5					; size = 1
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_stream_encode_mt PROC					; COMDAT

; 710  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 711  : 	lzma_stream_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 712  : 
; 713  : 	switch (coder->sequence) {

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 c8	 mov	 DWORD PTR tv64[ebp], edx
  00014	83 7d c8 03	 cmp	 DWORD PTR tv64[ebp], 3
  00018	0f 87 99 03 00
	00		 ja	 $LN33@stream_enc@7
  0001e	8b 45 c8	 mov	 eax, DWORD PTR tv64[ebp]
  00021	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@stream_enc@7[eax*4]
$LN32@stream_enc@7:

; 714  : 	case SEQ_STREAM_HEADER:
; 715  : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 716  : 				sizeof(coder->header),
; 717  : 				out, out_pos, out_size);

  00028	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00033	50		 push	 eax
  00034	6a 0c		 push	 12			; 0000000cH
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00039	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0003f	51		 push	 ecx
  00040	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00043	81 c2 c8 00 00
	00		 add	 edx, 200		; 000000c8H
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _lzma_bufcpy
  0004f	83 c4 18	 add	 esp, 24			; 00000018H

; 718  : 		if (coder->header_pos < sizeof(coder->header))

  00052	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00055	83 b8 d4 00 00
	00 0c		 cmp	 DWORD PTR [eax+212], 12	; 0000000cH
  0005c	73 07		 jae	 SHORT $LN31@stream_enc@7

; 719  : 			return LZMA_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 57 03 00 00	 jmp	 $LN35@stream_enc@7
$LN31@stream_enc@7:

; 720  : 
; 721  : 		coder->header_pos = 0;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00068	c7 81 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+212], 0

; 722  : 		coder->sequence = SEQ_BLOCK;

  00072	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00075	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN30@stream_enc@7:

; 723  : 
; 724  : 	// Fall through
; 725  : 
; 726  : 	case SEQ_BLOCK: {
; 727  : 		// Initialized to silence warnings.
; 728  : 		lzma_vli unpadded_size = 0;

  0007b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _unpadded_size$32697[ebp], 0
  00082	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _unpadded_size$32697[ebp+4], 0

; 729  : 		lzma_vli uncompressed_size = 0;

  00089	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _uncompressed_size$32698[ebp], 0
  00090	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _uncompressed_size$32698[ebp+4], 0

; 730  : 		lzma_ret ret = LZMA_OK;

  00097	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ret$32699[ebp], 0

; 731  : 
; 732  : 		// These are for wait_for_work().
; 733  : 		bool has_blocked = false;

  0009e	c6 45 fb 00	 mov	 BYTE PTR _has_blocked$32700[ebp], 0
$LN29@stream_enc@7:

; 734  : 		mythread_condtime wait_abs;
; 735  : 
; 736  : 		while (true) {

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	85 c0		 test	 eax, eax
  000a9	0f 84 d9 01 00
	00		 je	 $LN8@stream_enc@7

; 737  : 			mythread_sync(coder->mutex) {

  000af	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _mythread_i_737$32705[ebp], 0
  000b6	eb 07		 jmp	 SHORT $LN27@stream_enc@7
$LN26@stream_enc@7:
  000b8	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _mythread_i_737$32705[ebp], 1
$LN27@stream_enc@7:
  000bf	83 7d d8 00	 cmp	 DWORD PTR _mythread_i_737$32705[ebp], 0
  000c3	74 19		 je	 SHORT $LN37@stream_enc@7
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000c8	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  000ce	51		 push	 ecx
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000d5	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
  000dc	eb 17		 jmp	 SHORT $LN38@stream_enc@7
$LN37@stream_enc@7:
  000de	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000e1	81 c2 20 01 00
	00		 add	 edx, 288		; 00000120H
  000e7	52		 push	 edx
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  000ee	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
$LN38@stream_enc@7:
  000f5	83 7d c4 00	 cmp	 DWORD PTR tv82[ebp], 0
  000f9	74 5a		 je	 SHORT $LN25@stream_enc@7
  000fb	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _mythread_j_737$32706[ebp], 0
  00102	eb 07		 jmp	 SHORT $LN24@stream_enc@7
$LN23@stream_enc@7:
  00104	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _mythread_j_737$32706[ebp], 1
$LN24@stream_enc@7:
  0010b	83 7d d4 00	 cmp	 DWORD PTR _mythread_j_737$32706[ebp], 0
  0010f	75 3f		 jne	 SHORT $LN22@stream_enc@7

; 738  : 				// Check for Block encoder errors.
; 739  : 				ret = coder->thread_error;

  00111	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00114	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  0011a	89 4d dc	 mov	 DWORD PTR _ret$32699[ebp], ecx

; 740  : 				if (ret != LZMA_OK) {

  0011d	83 7d dc 00	 cmp	 DWORD PTR _ret$32699[ebp], 0
  00121	74 02		 je	 SHORT $LN21@stream_enc@7

; 741  : 					assert(ret != LZMA_STREAM_END);
; 742  : 					break;

  00123	eb 2b		 jmp	 SHORT $LN22@stream_enc@7
$LN21@stream_enc@7:

; 743  : 				}
; 744  : 
; 745  : 				// Try to read compressed data to out[].
; 746  : 				ret = lzma_outq_read(&coder->outq,
; 747  : 						out, out_pos, out_size,
; 748  : 						&unpadded_size,
; 749  : 						&uncompressed_size);

  00125	8d 55 e0	 lea	 edx, DWORD PTR _uncompressed_size$32698[ebp]
  00128	52		 push	 edx
  00129	8d 45 e8	 lea	 eax, DWORD PTR _unpadded_size$32697[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00130	51		 push	 ecx
  00131	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00134	52		 push	 edx
  00135	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00138	50		 push	 eax
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013c	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 _lzma_outq_read
  00148	83 c4 18	 add	 esp, 24			; 00000018H
  0014b	89 45 dc	 mov	 DWORD PTR _ret$32699[ebp], eax
  0014e	eb b4		 jmp	 SHORT $LN23@stream_enc@7
$LN22@stream_enc@7:

; 750  : 			}

  00150	e9 63 ff ff ff	 jmp	 $LN26@stream_enc@7
$LN25@stream_enc@7:

; 751  : 
; 752  : 			if (ret == LZMA_STREAM_END) {

  00155	83 7d dc 01	 cmp	 DWORD PTR _ret$32699[ebp], 1
  00159	75 35		 jne	 SHORT $LN20@stream_enc@7

; 753  : 				// End of Block. Add it to the Index.
; 754  : 				ret = lzma_index_append(coder->index,
; 755  : 						allocator, unpadded_size,
; 756  : 						uncompressed_size);

  0015b	8b 55 e4	 mov	 edx, DWORD PTR _uncompressed_size$32698[ebp+4]
  0015e	52		 push	 edx
  0015f	8b 45 e0	 mov	 eax, DWORD PTR _uncompressed_size$32698[ebp]
  00162	50		 push	 eax
  00163	8b 4d ec	 mov	 ecx, DWORD PTR _unpadded_size$32697[ebp+4]
  00166	51		 push	 ecx
  00167	8b 55 e8	 mov	 edx, DWORD PTR _unpadded_size$32697[ebp]
  0016a	52		 push	 edx
  0016b	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00172	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 _lzma_index_append
  0017b	83 c4 18	 add	 esp, 24			; 00000018H
  0017e	89 45 dc	 mov	 DWORD PTR _ret$32699[ebp], eax

; 757  : 
; 758  : 				// If we didn't fill the output buffer yet,
; 759  : 				// try to read more data. Maybe the next
; 760  : 				// outbuf has been finished already too.
; 761  : 				if (*out_pos < out_size)

  00181	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00184	8b 08		 mov	 ecx, DWORD PTR [eax]
  00186	3b 4d 24	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  00189	73 05		 jae	 SHORT $LN20@stream_enc@7

; 762  : 					continue;

  0018b	e9 12 ff ff ff	 jmp	 $LN29@stream_enc@7
$LN20@stream_enc@7:

; 763  : 			}
; 764  : 
; 765  : 			if (ret != LZMA_OK) {

  00190	83 7d dc 00	 cmp	 DWORD PTR _ret$32699[ebp], 0
  00194	74 16		 je	 SHORT $LN18@stream_enc@7

; 766  : 				// coder->thread_error was set or
; 767  : 				// lzma_index_append() failed.
; 768  : 				threads_stop(coder, false);

  00196	6a 00		 push	 0
  00198	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _threads_stop
  001a1	83 c4 08	 add	 esp, 8

; 769  : 				return ret;

  001a4	8b 45 dc	 mov	 eax, DWORD PTR _ret$32699[ebp]
  001a7	e9 10 02 00 00	 jmp	 $LN35@stream_enc@7
$LN18@stream_enc@7:

; 770  : 			}
; 771  : 
; 772  : 			// Try to give uncompressed data to a worker thread.
; 773  : 			ret = stream_encode_in(coder, allocator,
; 774  : 					in, in_pos, in_size, action);

  001ac	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  001af	50		 push	 eax
  001b0	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  001b3	51		 push	 ecx
  001b4	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  001b7	52		 push	 edx
  001b8	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  001bb	50		 push	 eax
  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  001bf	51		 push	 ecx
  001c0	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001c3	52		 push	 edx
  001c4	e8 00 00 00 00	 call	 _stream_encode_in
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	89 45 dc	 mov	 DWORD PTR _ret$32699[ebp], eax

; 775  : 			if (ret != LZMA_OK) {

  001cf	83 7d dc 00	 cmp	 DWORD PTR _ret$32699[ebp], 0
  001d3	74 16		 je	 SHORT $LN17@stream_enc@7

; 776  : 				threads_stop(coder, false);

  001d5	6a 00		 push	 0
  001d7	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _threads_stop
  001e0	83 c4 08	 add	 esp, 8

; 777  : 				return ret;

  001e3	8b 45 dc	 mov	 eax, DWORD PTR _ret$32699[ebp]
  001e6	e9 d1 01 00 00	 jmp	 $LN35@stream_enc@7
$LN17@stream_enc@7:

; 778  : 			}
; 779  : 
; 780  : 			// See if we should wait or return.
; 781  : 			//
; 782  : 			// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
; 783  : 			if (*in_pos == in_size) {

  001eb	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  001ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f0	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  001f3	75 4b		 jne	 SHORT $LN16@stream_enc@7

; 784  : 				// LZMA_RUN: More data is probably coming
; 785  : 				// so return to let the caller fill the
; 786  : 				// input buffer.
; 787  : 				if (action == LZMA_RUN)

  001f5	83 7d 28 00	 cmp	 DWORD PTR _action$[ebp], 0
  001f9	75 07		 jne	 SHORT $LN15@stream_enc@7

; 788  : 					return LZMA_OK;

  001fb	33 c0		 xor	 eax, eax
  001fd	e9 ba 01 00 00	 jmp	 $LN35@stream_enc@7
$LN15@stream_enc@7:

; 789  : 
; 790  : 				// LZMA_FULL_BARRIER: The same as with
; 791  : 				// LZMA_RUN but tell the caller that the
; 792  : 				// barrier was completed.
; 793  : 				if (action == LZMA_FULL_BARRIER)

  00202	83 7d 28 04	 cmp	 DWORD PTR _action$[ebp], 4
  00206	75 0a		 jne	 SHORT $LN43@stream_enc@7

; 794  : 					return LZMA_STREAM_END;

  00208	b8 01 00 00 00	 mov	 eax, 1
  0020d	e9 aa 01 00 00	 jmp	 $LN35@stream_enc@7

; 795  : 
; 796  : 				// Finishing or flushing isn't completed until
; 797  : 				// all input data has been encoded and copied
; 798  : 				// to the output buffer.
; 799  : 				if (lzma_outq_is_empty(&coder->outq)) {

$LN43@stream_enc@7:
  00212	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00215	33 c9		 xor	 ecx, ecx
  00217	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [eax+236], 0
  0021e	0f 94 c1	 sete	 cl
  00221	0f b6 d1	 movzx	 edx, cl
  00224	85 d2		 test	 edx, edx
  00226	74 18		 je	 SHORT $LN16@stream_enc@7

; 800  : 					// LZMA_FINISH: Continue to encode
; 801  : 					// the Index field.
; 802  : 					if (action == LZMA_FINISH)

  00228	83 7d 28 03	 cmp	 DWORD PTR _action$[ebp], 3
  0022c	75 02		 jne	 SHORT $LN12@stream_enc@7

; 803  : 						break;

  0022e	eb 58		 jmp	 SHORT $LN8@stream_enc@7
$LN12@stream_enc@7:

; 804  : 
; 805  : 					// LZMA_FULL_FLUSH: Return to tell
; 806  : 					// the caller that flushing was
; 807  : 					// completed.
; 808  : 					if (action == LZMA_FULL_FLUSH)

  00230	83 7d 28 02	 cmp	 DWORD PTR _action$[ebp], 2
  00234	75 0a		 jne	 SHORT $LN16@stream_enc@7

; 809  : 						return LZMA_STREAM_END;

  00236	b8 01 00 00 00	 mov	 eax, 1
  0023b	e9 7c 01 00 00	 jmp	 $LN35@stream_enc@7
$LN16@stream_enc@7:

; 810  : 				}
; 811  : 			}
; 812  : 
; 813  : 			// Return if there is no output space left.
; 814  : 			// This check must be done after testing the input
; 815  : 			// buffer, because we might want to use a different
; 816  : 			// return code.
; 817  : 			if (*out_pos == out_size)

  00240	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00243	8b 08		 mov	 ecx, DWORD PTR [eax]
  00245	3b 4d 24	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  00248	75 07		 jne	 SHORT $LN10@stream_enc@7

; 818  : 				return LZMA_OK;

  0024a	33 c0		 xor	 eax, eax
  0024c	e9 6b 01 00 00	 jmp	 $LN35@stream_enc@7
$LN10@stream_enc@7:

; 819  : 
; 820  : 			// Neither in nor out has been used completely.
; 821  : 			// Wait until there's something we can do.
; 822  : 			if (wait_for_work(coder, &wait_abs, &has_blocked,
; 823  : 					*in_pos < in_size))

  00251	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00254	8b 02		 mov	 eax, DWORD PTR [edx]
  00256	3b 45 18	 cmp	 eax, DWORD PTR _in_size$[ebp]
  00259	1b c9		 sbb	 ecx, ecx
  0025b	f7 d9		 neg	 ecx
  0025d	51		 push	 ecx
  0025e	8d 55 fb	 lea	 edx, DWORD PTR _has_blocked$32700[ebp]
  00261	52		 push	 edx
  00262	8d 45 f0	 lea	 eax, DWORD PTR _wait_abs$32701[ebp]
  00265	50		 push	 eax
  00266	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00269	51		 push	 ecx
  0026a	e8 00 00 00 00	 call	 _wait_for_work
  0026f	83 c4 10	 add	 esp, 16			; 00000010H
  00272	0f b6 d0	 movzx	 edx, al
  00275	85 d2		 test	 edx, edx
  00277	74 0a		 je	 SHORT $LN9@stream_enc@7

; 824  : 				return LZMA_TIMED_OUT;

  00279	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0027e	e9 39 01 00 00	 jmp	 $LN35@stream_enc@7
$LN9@stream_enc@7:

; 825  : 		}

  00283	e9 1a fe ff ff	 jmp	 $LN29@stream_enc@7
$LN8@stream_enc@7:

; 826  : 
; 827  : 		// All Blocks have been encoded and the threads have stopped.
; 828  : 		// Prepare to encode the Index field.
; 829  : 		return_if_error(lzma_index_encoder_init(
; 830  : 				&coder->index_encoder, allocator,
; 831  : 				coder->index));

  00288	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0028b	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0028e	51		 push	 ecx
  0028f	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00292	52		 push	 edx
  00293	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00296	83 c0 60	 add	 eax, 96			; 00000060H
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 _lzma_index_encoder_init
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a2	89 45 d0	 mov	 DWORD PTR _ret_$32730[ebp], eax
  002a5	83 7d d0 00	 cmp	 DWORD PTR _ret_$32730[ebp], 0
  002a9	74 08		 je	 SHORT $LN7@stream_enc@7
  002ab	8b 45 d0	 mov	 eax, DWORD PTR _ret_$32730[ebp]
  002ae	e9 09 01 00 00	 jmp	 $LN35@stream_enc@7
$LN7@stream_enc@7:
  002b3	33 c9		 xor	 ecx, ecx
  002b5	75 d1		 jne	 SHORT $LN8@stream_enc@7

; 832  : 		coder->sequence = SEQ_INDEX;

  002b7	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002ba	c7 02 02 00 00
	00		 mov	 DWORD PTR [edx], 2

; 833  : 
; 834  : 		// Update the progress info to take the Index and
; 835  : 		// Stream Footer into account. Those are very fast to encode
; 836  : 		// so in terms of progress information they can be thought
; 837  : 		// to be ready to be copied out.
; 838  : 		coder->progress_out += lzma_index_size(coder->index)
; 839  : 				+ LZMA_STREAM_HEADER_SIZE;

  002c0	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002c3	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 _lzma_index_size
  002cc	83 c4 04	 add	 esp, 4
  002cf	83 c0 0c	 add	 eax, 12			; 0000000cH
  002d2	83 d2 00	 adc	 edx, 0
  002d5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002d8	03 81 18 01 00
	00		 add	 eax, DWORD PTR [ecx+280]
  002de	8b 89 1c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+284]
  002e4	13 ca		 adc	 ecx, edx
  002e6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002e9	89 82 18 01 00
	00		 mov	 DWORD PTR [edx+280], eax
  002ef	89 8a 1c 01 00
	00		 mov	 DWORD PTR [edx+284], ecx
$LN4@stream_enc@7:

; 840  : 	}
; 841  : 
; 842  : 	// Fall through
; 843  : 
; 844  : 	case SEQ_INDEX: {
; 845  : 		// Call the Index encoder. It doesn't take any input, so
; 846  : 		// those pointers can be NULL.
; 847  : 		const lzma_ret ret = coder->index_encoder.code(
; 848  : 				coder->index_encoder.coder, allocator,
; 849  : 				NULL, NULL, 0,
; 850  : 				out, out_pos, out_size, LZMA_RUN);

  002f5	6a 00		 push	 0
  002f7	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  002fa	50		 push	 eax
  002fb	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  002fe	51		 push	 ecx
  002ff	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  00302	52		 push	 edx
  00303	6a 00		 push	 0
  00305	6a 00		 push	 0
  00307	6a 00		 push	 0
  00309	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0030c	50		 push	 eax
  0030d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00310	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00313	52		 push	 edx
  00314	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00317	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0031a	ff d1		 call	 ecx
  0031c	83 c4 24	 add	 esp, 36			; 00000024H
  0031f	89 45 cc	 mov	 DWORD PTR _ret$32733[ebp], eax

; 851  : 		if (ret != LZMA_STREAM_END)

  00322	83 7d cc 01	 cmp	 DWORD PTR _ret$32733[ebp], 1
  00326	74 08		 je	 SHORT $LN3@stream_enc@7

; 852  : 			return ret;

  00328	8b 45 cc	 mov	 eax, DWORD PTR _ret$32733[ebp]
  0032b	e9 8c 00 00 00	 jmp	 $LN35@stream_enc@7
$LN3@stream_enc@7:

; 853  : 
; 854  : 		// Encode the Stream Footer into coder->buffer.
; 855  : 		coder->stream_flags.backward_size
; 856  : 				= lzma_index_size(coder->index);

  00330	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00333	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 _lzma_index_size
  0033c	83 c4 04	 add	 esp, 4
  0033f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00342	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
  00348	89 91 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], edx

; 857  : 		if (lzma_stream_footer_encode(&coder->stream_flags,
; 858  : 				coder->header) != LZMA_OK)

  0034e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00351	81 c2 c8 00 00
	00		 add	 edx, 200		; 000000c8H
  00357	52		 push	 edx
  00358	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0035b	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00360	50		 push	 eax
  00361	e8 00 00 00 00	 call	 _lzma_stream_footer_encode
  00366	83 c4 08	 add	 esp, 8
  00369	85 c0		 test	 eax, eax
  0036b	74 07		 je	 SHORT $LN2@stream_enc@7

; 859  : 			return LZMA_PROG_ERROR;

  0036d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00372	eb 48		 jmp	 SHORT $LN35@stream_enc@7
$LN2@stream_enc@7:

; 860  : 
; 861  : 		coder->sequence = SEQ_STREAM_FOOTER;

  00374	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00377	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3
$LN1@stream_enc@7:

; 862  : 	}
; 863  : 
; 864  : 	// Fall through
; 865  : 
; 866  : 	case SEQ_STREAM_FOOTER:
; 867  : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 868  : 				sizeof(coder->header),
; 869  : 				out, out_pos, out_size);

  0037d	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00380	52		 push	 edx
  00381	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00384	50		 push	 eax
  00385	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00388	51		 push	 ecx
  00389	6a 0c		 push	 12			; 0000000cH
  0038b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0038e	81 c2 d4 00 00
	00		 add	 edx, 212		; 000000d4H
  00394	52		 push	 edx
  00395	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00398	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0039d	50		 push	 eax
  0039e	e8 00 00 00 00	 call	 _lzma_bufcpy
  003a3	83 c4 18	 add	 esp, 24			; 00000018H

; 870  : 		return coder->header_pos < sizeof(coder->header)
; 871  : 				? LZMA_OK : LZMA_STREAM_END;

  003a6	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  003a9	83 b9 d4 00 00
	00 0c		 cmp	 DWORD PTR [ecx+212], 12	; 0000000cH
  003b0	1b c0		 sbb	 eax, eax
  003b2	83 c0 01	 add	 eax, 1
  003b5	eb 05		 jmp	 SHORT $LN35@stream_enc@7
$LN33@stream_enc@7:

; 872  : 	}
; 873  : 
; 874  : 	assert(0);
; 875  : 	return LZMA_PROG_ERROR;

  003b7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN35@stream_enc@7:

; 876  : }

  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c3		 ret	 0
$LN46@stream_enc@7:
  003c0	00 00 00 00	 DD	 $LN32@stream_enc@7
  003c4	00 00 00 00	 DD	 $LN30@stream_enc@7
  003c8	00 00 00 00	 DD	 $LN4@stream_enc@7
  003cc	00 00 00 00	 DD	 $LN1@stream_enc@7
_stream_encode_mt ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _stream_encoder_mt_init
_TEXT	SEGMENT
tv352 = -244						; size = 4
tv351 = -240						; size = 4
tv257 = -236						; size = 8
$T80683 = -228						; size = 4
_ret_$32875 = -224					; size = 4
_ret_$32868 = -220					; size = 4
_i$32861 = -216						; size = 4
_ret_$32859 = -212					; size = 4
_coder$32834 = -208					; size = 4
_ret_$32827 = -204					; size = 4
_easy$32820 = -200					; size = 176
_block_size$32822 = -24					; size = 8
_outbuf_size_max$32823 = -16				; size = 8
_filters$32821 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_stream_encoder_mt_init PROC				; COMDAT

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	56		 push	 esi
  0000a	57		 push	 edi
$LN35@stream_enc@8:

; 987  : 	lzma_next_coder_init(&stream_encoder_mt_init, next, allocator);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000e	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _stream_encoder_mt_init
  00015	74 10		 je	 SHORT $LN32@stream_enc@8
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _lzma_next_end
  00024	83 c4 08	 add	 esp, 8
$LN32@stream_enc@8:
  00027	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0002a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _stream_encoder_mt_init
  00031	33 c9		 xor	 ecx, ecx
  00033	75 d6		 jne	 SHORT $LN35@stream_enc@8
$LN31@stream_enc@8:

; 988  : 
; 989  : 	// Get the filter chain.
; 990  :   {
; 991  : 	lzma_options_easy easy;
; 992  : 	const lzma_filter *filters;
; 993  : 	uint64_t block_size;
; 994  : 	uint64_t outbuf_size_max;
; 995  : 	return_if_error(get_options(options, &easy, &filters,
; 996  : 			&block_size, &outbuf_size_max));

  00035	8d 55 f0	 lea	 edx, DWORD PTR _outbuf_size_max$32823[ebp]
  00038	52		 push	 edx
  00039	8d 45 e8	 lea	 eax, DWORD PTR _block_size$32822[ebp]
  0003c	50		 push	 eax
  0003d	8d 4d fc	 lea	 ecx, DWORD PTR _filters$32821[ebp]
  00040	51		 push	 ecx
  00041	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR _easy$32820[ebp]
  00047	52		 push	 edx
  00048	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _get_options
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	89 85 34 ff ff
	ff		 mov	 DWORD PTR _ret_$32827[ebp], eax
  0005a	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32827[ebp], 0
  00061	74 0b		 je	 SHORT $LN30@stream_enc@8
  00063	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32827[ebp]
  00069	e9 12 05 00 00	 jmp	 $LN36@stream_enc@8
$LN30@stream_enc@8:
  0006e	33 c9		 xor	 ecx, ecx
  00070	75 c3		 jne	 SHORT $LN31@stream_enc@8

; 997  : 
; 998  : #if SIZE_MAX < UINT64_MAX
; 999  : 	if (block_size > SIZE_MAX)

  00072	83 7d ec 00	 cmp	 DWORD PTR _block_size$32822[ebp+4], 0
  00076	77 06		 ja	 SHORT $LN44@stream_enc@8
  00078	83 7d e8 ff	 cmp	 DWORD PTR _block_size$32822[ebp], -1
  0007c	76 0a		 jbe	 SHORT $LN27@stream_enc@8
$LN44@stream_enc@8:

; 1000 : 		return LZMA_MEM_ERROR;

  0007e	b8 05 00 00 00	 mov	 eax, 5
  00083	e9 f8 04 00 00	 jmp	 $LN36@stream_enc@8
$LN27@stream_enc@8:

; 1001 : #endif
; 1002 : 
; 1003 : 	// Validate the filter chain so that we can give an error in this
; 1004 : 	// function instead of delaying it to the first call to lzma_code().
; 1005 : 	// The memory usage calculation verifies the filter chain as
; 1006 : 	// a side effect so we take advatange of that.
; 1007 : 	if (lzma_raw_encoder_memusage(filters) == UINT64_MAX)

  00088	8b 55 fc	 mov	 edx, DWORD PTR _filters$32821[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 _lzma_raw_encoder_memusage
  00091	83 c4 04	 add	 esp, 4
  00094	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv257[ebp], eax
  0009a	89 95 18 ff ff
	ff		 mov	 DWORD PTR tv257[ebp+4], edx
  000a0	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv257[ebp]
  000a6	23 85 18 ff ff
	ff		 and	 eax, DWORD PTR tv257[ebp+4]
  000ac	83 f8 ff	 cmp	 eax, -1
  000af	75 0a		 jne	 SHORT $LN26@stream_enc@8

; 1008 : 		return LZMA_OPTIONS_ERROR;

  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	e9 c5 04 00 00	 jmp	 $LN36@stream_enc@8
$LN26@stream_enc@8:

; 1009 : 
; 1010 : 	// Validate the Check ID.
; 1011 : 	if ((unsigned int)(options->check) > LZMA_CHECK_ID_MAX)

  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  000be	83 79 1c 0f	 cmp	 DWORD PTR [ecx+28], 15	; 0000000fH
  000c2	76 0a		 jbe	 SHORT $LN25@stream_enc@8

; 1012 : 		return LZMA_PROG_ERROR;

  000c4	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000c9	e9 b2 04 00 00	 jmp	 $LN36@stream_enc@8
$LN25@stream_enc@8:

; 1013 : 
; 1014 : 	if (!lzma_check_is_supported(options->check))

  000ce	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  000d1	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _lzma_check_is_supported
  000da	83 c4 04	 add	 esp, 4
  000dd	0f b6 c8	 movzx	 ecx, al
  000e0	85 c9		 test	 ecx, ecx
  000e2	75 0a		 jne	 SHORT $LN24@stream_enc@8

; 1015 : 		return LZMA_UNSUPPORTED_CHECK;

  000e4	b8 03 00 00 00	 mov	 eax, 3
  000e9	e9 92 04 00 00	 jmp	 $LN36@stream_enc@8
$LN24@stream_enc@8:

; 1016 : 
; 1017 : 	// Allocate and initialize the base structure if needed.
; 1018 :   { lzma_stream_coder *coder = next->coder;

  000ee	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  000f1	8b 02		 mov	 eax, DWORD PTR [edx]
  000f3	89 85 30 ff ff
	ff		 mov	 DWORD PTR _coder$32834[ebp], eax

; 1019 : 	if (coder == NULL) {

  000f9	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR _coder$32834[ebp], 0
  00100	0f 85 82 01 00
	00		 jne	 $LN23@stream_enc@8

; 1020 : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  00106	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00109	51		 push	 ecx
  0010a	68 40 01 00 00	 push	 320			; 00000140H
  0010f	e8 00 00 00 00	 call	 _lzma_alloc
  00114	83 c4 08	 add	 esp, 8
  00117	89 85 30 ff ff
	ff		 mov	 DWORD PTR _coder$32834[ebp], eax

; 1021 : 		if (coder == NULL)

  0011d	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR _coder$32834[ebp], 0
  00124	75 0a		 jne	 SHORT $LN22@stream_enc@8

; 1022 : 			return LZMA_MEM_ERROR;

  00126	b8 05 00 00 00	 mov	 eax, 5
  0012b	e9 50 04 00 00	 jmp	 $LN36@stream_enc@8
$LN22@stream_enc@8:

; 1023 : 
; 1024 : 		next->coder = coder;

  00130	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00133	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  00139	89 02		 mov	 DWORD PTR [edx], eax

; 1025 : 
; 1026 : 		// For the mutex and condition variable initializations
; 1027 : 		// the error handling has to be done here because
; 1028 : 		// stream_encoder_mt_end() doesn't know if they have
; 1029 : 		// already been initialized or not.
; 1030 : 		if (mythread_mutex_init(&coder->mutex)) {

  0013b	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  00141	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00147	51		 push	 ecx
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  0014e	33 d2		 xor	 edx, edx
  00150	74 26		 je	 SHORT $LN21@stream_enc@8

; 1031 : 			lzma_free(coder, allocator);

  00152	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00155	50		 push	 eax
  00156	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _lzma_free
  00162	83 c4 08	 add	 esp, 8

; 1032 : 			next->coder = NULL;

  00165	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00168	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1033 : 			return LZMA_MEM_ERROR;

  0016e	b8 05 00 00 00	 mov	 eax, 5
  00173	e9 08 04 00 00	 jmp	 $LN36@stream_enc@8
$LN21@stream_enc@8:

; 1034 : 		}
; 1035 : 
; 1036 : 		if (mythread_cond_init(&coder->cond)) {

  00178	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  0017e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00183	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T80683[ebp], eax
  00189	6a 00		 push	 0
  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	6a 00		 push	 0
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00197	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR $T80683[ebp]
  0019d	89 01		 mov	 DWORD PTR [ecx], eax
  0019f	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR $T80683[ebp]
  001a5	8b 02		 mov	 eax, DWORD PTR [edx]
  001a7	f7 d8		 neg	 eax
  001a9	1b c0		 sbb	 eax, eax
  001ab	f7 d8		 neg	 eax
  001ad	83 e8 01	 sub	 eax, 1
  001b0	74 39		 je	 SHORT $LN20@stream_enc@8

; 1037 : 			mythread_mutex_destroy(&coder->mutex);

  001b2	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  001b8	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  001be	51		 push	 ecx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 1038 : 			lzma_free(coder, allocator);

  001c5	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  001c8	52		 push	 edx
  001c9	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _lzma_free
  001d5	83 c4 08	 add	 esp, 8

; 1039 : 			next->coder = NULL;

  001d8	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  001db	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1040 : 			return LZMA_MEM_ERROR;

  001e1	b8 05 00 00 00	 mov	 eax, 5
  001e6	e9 95 03 00 00	 jmp	 $LN36@stream_enc@8
$LN20@stream_enc@8:

; 1041 : 		}
; 1042 : 
; 1043 : 		next->code = &stream_encode_mt;

  001eb	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  001ee	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _stream_encode_mt

; 1044 : 		next->end = &stream_encoder_mt_end;

  001f5	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  001f8	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _stream_encoder_mt_end

; 1045 : 		next->get_progress = &get_progress;

  001ff	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00202	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _get_progress

; 1046 : // 		next->update = &stream_encoder_mt_update;
; 1047 : 
; 1048 : 		coder->filters[0].id = LZMA_VLI_UNKNOWN;

  00209	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  0020f	c7 42 08 ff ff
	ff ff		 mov	 DWORD PTR [edx+8], -1
  00216	c7 42 0c ff ff
	ff ff		 mov	 DWORD PTR [edx+12], -1

; 1049 : 		coder->index_encoder = LZMA_NEXT_CODER_INIT;

  0021d	8b bd 30 ff ff
	ff		 mov	 edi, DWORD PTR _coder$32834[ebp]
  00223	83 c7 60	 add	 edi, 96			; 00000060H
  00226	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0022b	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00230	f3 a5		 rep movsd

; 1050 : 		coder->index = NULL;

  00232	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  00238	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 1051 : 		memzero(&coder->outq, sizeof(coder->outq));

  0023f	6a 1c		 push	 28			; 0000001cH
  00241	6a 00		 push	 0
  00243	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  00249	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  0024f	51		 push	 ecx
  00250	e8 00 00 00 00	 call	 _memset
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1052 : 		coder->threads = NULL;

  00258	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  0025e	c7 82 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+252], 0

; 1053 : 		coder->threads_max = 0;

  00268	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  0026e	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 1054 : 		coder->threads_initialized = 0;

  00278	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  0027e	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0
$LN23@stream_enc@8:

; 1055 : 	}
; 1056 : 
; 1057 : 	// Basic initializations
; 1058 : 	coder->sequence = SEQ_STREAM_HEADER;

  00288	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  0028e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1059 : 	coder->block_size = (size_t)(block_size);

  00294	8b 45 e8	 mov	 eax, DWORD PTR _block_size$32822[ebp]
  00297	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  0029d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1060 : 	coder->thread_error = LZMA_OK;

  002a0	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  002a6	c7 82 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+248], 0

; 1061 : 	coder->thr = NULL;

  002b0	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  002b6	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0

; 1062 : 
; 1063 : 	// Allocate the thread-specific base structures.
; 1064 : 	assert(options->threads > 0);
; 1065 : 	if (coder->threads_max != options->threads) {

  002c0	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  002c6	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  002c9	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [ecx+256]
  002cf	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  002d2	0f 84 a5 00 00
	00		 je	 $LN19@stream_enc@8

; 1066 : 		threads_end(coder, allocator);

  002d8	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  002db	51		 push	 ecx
  002dc	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  002e2	52		 push	 edx
  002e3	e8 00 00 00 00	 call	 _threads_end
  002e8	83 c4 08	 add	 esp, 8

; 1067 : 
; 1068 : 		coder->threads = NULL;

  002eb	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  002f1	c7 80 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+252], 0

; 1069 : 		coder->threads_max = 0;

  002fb	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  00301	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0

; 1070 : 
; 1071 : 		coder->threads_initialized = 0;

  0030b	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  00311	c7 82 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+260], 0

; 1072 : 		coder->threads_free = NULL;

  0031b	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  00321	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+264], 0

; 1073 : 
; 1074 : 		coder->threads = lzma_alloc(
; 1075 : 				options->threads * sizeof(worker_thread),
; 1076 : 				allocator);

  0032b	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0032e	51		 push	 ecx
  0032f	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00332	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00335	69 c0 40 01 00
	00		 imul	 eax, 320		; 00000140H
  0033b	50		 push	 eax
  0033c	e8 00 00 00 00	 call	 _lzma_alloc
  00341	83 c4 08	 add	 esp, 8
  00344	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  0034a	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 1077 : 		if (coder->threads == NULL)

  00350	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  00356	83 ba fc 00 00
	00 00		 cmp	 DWORD PTR [edx+252], 0
  0035d	75 0a		 jne	 SHORT $LN18@stream_enc@8

; 1078 : 			return LZMA_MEM_ERROR;

  0035f	b8 05 00 00 00	 mov	 eax, 5
  00364	e9 17 02 00 00	 jmp	 $LN36@stream_enc@8
$LN18@stream_enc@8:

; 1079 : 
; 1080 : 		coder->threads_max = options->threads;

  00369	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  0036f	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00372	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00375	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx

; 1081 : 	} else {

  0037b	eb 11		 jmp	 SHORT $LN16@stream_enc@8
$LN19@stream_enc@8:

; 1082 : 		// Reuse the old structures and threads. Tell the running
; 1083 : 		// threads to stop and wait until they have stopped.
; 1084 : 		threads_stop(coder, true);

  0037d	6a 01		 push	 1
  0037f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 _threads_stop
  0038b	83 c4 08	 add	 esp, 8
$LN16@stream_enc@8:

; 1085 : 	}
; 1086 : 
; 1087 : 	// Output queue
; 1088 : 	return_if_error(lzma_outq_init(&coder->outq, allocator,
; 1089 : 			outbuf_size_max, options->threads));

  0038e	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00391	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00394	52		 push	 edx
  00395	8b 45 f4	 mov	 eax, DWORD PTR _outbuf_size_max$32823[ebp+4]
  00398	50		 push	 eax
  00399	8b 4d f0	 mov	 ecx, DWORD PTR _outbuf_size_max$32823[ebp]
  0039c	51		 push	 ecx
  0039d	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  003a0	52		 push	 edx
  003a1	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  003a7	05 d8 00 00 00	 add	 eax, 216		; 000000d8H
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 _lzma_outq_init
  003b2	83 c4 14	 add	 esp, 20			; 00000014H
  003b5	89 85 2c ff ff
	ff		 mov	 DWORD PTR _ret_$32859[ebp], eax
  003bb	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32859[ebp], 0
  003c2	74 0b		 je	 SHORT $LN15@stream_enc@8
  003c4	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32859[ebp]
  003ca	e9 b1 01 00 00	 jmp	 $LN36@stream_enc@8
$LN15@stream_enc@8:
  003cf	33 c9		 xor	 ecx, ecx
  003d1	75 bb		 jne	 SHORT $LN16@stream_enc@8

; 1090 : 
; 1091 : 	// Timeout
; 1092 : 	coder->timeout = options->timeout;

  003d3	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  003d9	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  003dc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003df	89 8a f4 00 00
	00		 mov	 DWORD PTR [edx+244], ecx

; 1093 : 
; 1094 : 	// Free the old filter chain and copy the new one.
; 1095 :   { size_t i;
; 1096 : 
; 1097 : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  003e5	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$32861[ebp], 0
  003ef	eb 0f		 jmp	 SHORT $LN12@stream_enc@8
$LN11@stream_enc@8:
  003f1	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _i$32861[ebp]
  003f7	83 c2 01	 add	 edx, 1
  003fa	89 95 28 ff ff
	ff		 mov	 DWORD PTR _i$32861[ebp], edx
$LN12@stream_enc@8:
  00400	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _i$32861[ebp]
  00406	c1 e0 04	 shl	 eax, 4
  00409	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  0040f	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv351[ebp], ecx
  00415	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv352[ebp], eax
  0041b	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv352[ebp]
  00421	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv351[ebp]
  00427	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv352[ebp]
  0042d	8b b5 10 ff ff
	ff		 mov	 esi, DWORD PTR tv351[ebp]
  00433	8b 54 10 08	 mov	 edx, DWORD PTR [eax+edx+8]
  00437	23 54 0e 0c	 and	 edx, DWORD PTR [esi+ecx+12]
  0043b	83 fa ff	 cmp	 edx, -1
  0043e	74 22		 je	 SHORT $LN9@stream_enc@8

; 1098 : 		lzma_free(coder->filters[i].options, allocator);

  00440	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00443	50		 push	 eax
  00444	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _i$32861[ebp]
  0044a	c1 e1 04	 shl	 ecx, 4
  0044d	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  00453	8b 44 0a 10	 mov	 eax, DWORD PTR [edx+ecx+16]
  00457	50		 push	 eax
  00458	e8 00 00 00 00	 call	 _lzma_free
  0045d	83 c4 08	 add	 esp, 8
  00460	eb 8f		 jmp	 SHORT $LN11@stream_enc@8
$LN9@stream_enc@8:

; 1099 :   }
; 1100 : 
; 1101 : 	return_if_error(lzma_filters_copy(
; 1102 : 			filters, coder->filters, allocator));

  00462	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00465	51		 push	 ecx
  00466	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  0046c	83 c2 08	 add	 edx, 8
  0046f	52		 push	 edx
  00470	8b 45 fc	 mov	 eax, DWORD PTR _filters$32821[ebp]
  00473	50		 push	 eax
  00474	e8 00 00 00 00	 call	 _lzma_filters_copy
  00479	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047c	89 85 24 ff ff
	ff		 mov	 DWORD PTR _ret_$32868[ebp], eax
  00482	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32868[ebp], 0
  00489	74 0b		 je	 SHORT $LN8@stream_enc@8
  0048b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32868[ebp]
  00491	e9 ea 00 00 00	 jmp	 $LN36@stream_enc@8
$LN8@stream_enc@8:
  00496	33 c9		 xor	 ecx, ecx
  00498	75 c8		 jne	 SHORT $LN9@stream_enc@8

; 1103 : 
; 1104 : 	// Index
; 1105 : 	lzma_index_end(coder->index, allocator);

  0049a	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0049d	52		 push	 edx
  0049e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  004a4	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  004a7	51		 push	 ecx
  004a8	e8 00 00 00 00	 call	 _lzma_index_end
  004ad	83 c4 08	 add	 esp, 8

; 1106 : 	coder->index = lzma_index_init(allocator);

  004b0	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  004b3	52		 push	 edx
  004b4	e8 00 00 00 00	 call	 _lzma_index_init
  004b9	83 c4 04	 add	 esp, 4
  004bc	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  004c2	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 1107 : 	if (coder->index == NULL)

  004c5	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  004cb	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  004cf	75 0a		 jne	 SHORT $LN5@stream_enc@8

; 1108 : 		return LZMA_MEM_ERROR;

  004d1	b8 05 00 00 00	 mov	 eax, 5
  004d6	e9 a5 00 00 00	 jmp	 $LN36@stream_enc@8
$LN5@stream_enc@8:

; 1109 : 
; 1110 : 	// Stream Header
; 1111 : 	coder->stream_flags.version = 0;

  004db	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  004e1	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 1112 : 	coder->stream_flags.check = options->check;

  004eb	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  004f1	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  004f4	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  004f7	89 81 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], eax
$LN4@stream_enc@8:

; 1113 : 	return_if_error(lzma_stream_header_encode(
; 1114 : 			&coder->stream_flags, coder->header));

  004fd	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  00503	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00509	51		 push	 ecx
  0050a	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  00510	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  00516	52		 push	 edx
  00517	e8 00 00 00 00	 call	 _lzma_stream_header_encode
  0051c	83 c4 08	 add	 esp, 8
  0051f	89 85 20 ff ff
	ff		 mov	 DWORD PTR _ret_$32875[ebp], eax
  00525	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32875[ebp], 0
  0052c	74 08		 je	 SHORT $LN3@stream_enc@8
  0052e	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32875[ebp]
  00534	eb 4a		 jmp	 SHORT $LN36@stream_enc@8
$LN3@stream_enc@8:
  00536	33 c0		 xor	 eax, eax
  00538	75 c3		 jne	 SHORT $LN4@stream_enc@8

; 1115 : 
; 1116 : 	coder->header_pos = 0;

  0053a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _coder$32834[ebp]
  00540	c7 81 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+212], 0

; 1117 : 
; 1118 : 	// Progress info
; 1119 : 	coder->progress_in = 0;

  0054a	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _coder$32834[ebp]
  00550	c7 82 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+272], 0
  0055a	c7 82 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+276], 0

; 1120 : 	coder->progress_out = LZMA_STREAM_HEADER_SIZE;

  00564	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _coder$32834[ebp]
  0056a	c7 80 18 01 00
	00 0c 00 00 00	 mov	 DWORD PTR [eax+280], 12	; 0000000cH
  00574	c7 80 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+284], 0

; 1121 :   }}
; 1122 : 
; 1123 : 	return LZMA_OK;

  0057e	33 c0		 xor	 eax, eax
$LN36@stream_enc@8:

; 1124 : }

  00580	5f		 pop	 edi
  00581	5e		 pop	 esi
  00582	8b e5		 mov	 esp, ebp
  00584	5d		 pop	 ebp
  00585	c3		 ret	 0
_stream_encoder_mt_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_stream_encoder_mt
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_encoder_mt
_TEXT	SEGMENT
_ret_$32890 = -8					; size = 4
_ret_$32888 = -4					; size = 4
_strm$ = 8						; size = 4
_options$ = 12						; size = 4
_lzma_stream_encoder_mt PROC				; COMDAT

; 1129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_strea@10:

; 1130 : 	lzma_next_strm_init(stream_encoder_mt_init, strm, options);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32888[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32888[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_strea@10
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32888[ebp]
  0001e	eb 66		 jmp	 SHORT $LN9@lzma_strea@10
$LN4@lzma_strea@10:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_strea@10
  00024	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _stream_encoder_mt_init
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	89 45 f8	 mov	 DWORD PTR _ret_$32890[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _ret_$32890[ebp], 0
  00045	74 11		 je	 SHORT $LN7@lzma_strea@10
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _lzma_end
  00050	83 c4 04	 add	 esp, 4
  00053	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32890[ebp]
  00056	eb 2e		 jmp	 SHORT $LN9@lzma_strea@10
$LN7@lzma_strea@10:
  00058	33 d2		 xor	 edx, edx
  0005a	75 aa		 jne	 SHORT $LN5@lzma_strea@10

; 1131 : 
; 1132 : 	strm->internal->supported_actions[LZMA_RUN] = true;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00062	c6 41 38 01	 mov	 BYTE PTR [ecx+56], 1

; 1133 : // 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;
; 1134 : 	strm->internal->supported_actions[LZMA_FULL_FLUSH] = true;

  00066	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00069	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006c	c6 40 3a 01	 mov	 BYTE PTR [eax+58], 1

; 1135 : 	strm->internal->supported_actions[LZMA_FULL_BARRIER] = true;

  00070	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00073	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00076	c6 42 3c 01	 mov	 BYTE PTR [edx+60], 1

; 1136 : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0007d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00080	c6 41 3b 01	 mov	 BYTE PTR [ecx+59], 1

; 1137 : 
; 1138 : 	return LZMA_OK;

  00084	33 c0		 xor	 eax, eax
$LN9@lzma_strea@10:

; 1139 : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_lzma_stream_encoder_mt ENDP
_TEXT	ENDS
END
