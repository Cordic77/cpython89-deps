; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\common\tuklib_cpucores.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzmatuklib_cpucores
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_cpucores.c
;	COMDAT _lzmatuklib_cpucores
_TEXT	SEGMENT
_ret$ = -40						; size = 4
_sysinfo$ = -36						; size = 36
_lzmatuklib_cpucores PROC				; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 49   : 	uint32_t ret = 0;

  00006	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 50   : 
; 51   : #if defined(_WIN32) || defined(__CYGWIN__)
; 52   : 	SYSTEM_INFO sysinfo;
; 53   : 	GetSystemInfo(&sysinfo);

  0000d	8d 45 dc	 lea	 eax, DWORD PTR _sysinfo$[ebp]
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 54   : 	ret = sysinfo.dwNumberOfProcessors;

  00017	8b 4d f0	 mov	 ecx, DWORD PTR _sysinfo$[ebp+20]
  0001a	89 4d d8	 mov	 DWORD PTR _ret$[ebp], ecx

; 55   : 
; 56   : #elif defined(TUKLIB_CPUCORES_SCHED_GETAFFINITY)
; 57   : 	cpu_set_t cpu_mask;
; 58   : 	if (sched_getaffinity(0, sizeof(cpu_mask), &cpu_mask) == 0)
; 59   : 		ret = CPU_COUNT(&cpu_mask);
; 60   : 
; 61   : #elif defined(TUKLIB_CPUCORES_CPUSET)
; 62   : 	cpuset_t set;
; 63   : 	if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,
; 64   : 			sizeof(set), &set) == 0) {
; 65   : #	ifdef CPU_COUNT
; 66   : 		ret = CPU_COUNT(&set);
; 67   : #	else
; 68   : 		for (unsigned i = 0; i < CPU_SETSIZE; ++i)
; 69   : 			if (CPU_ISSET(i, &set))
; 70   : 				++ret;
; 71   : #	endif
; 72   : 	}
; 73   : 
; 74   : #elif defined(TUKLIB_CPUCORES_SYSCTL)
; 75   : 	int name[2] = { CTL_HW, HW_NCPU };
; 76   : 	int cpus;
; 77   : 	size_t cpus_size = sizeof(cpus);
; 78   : 	if (sysctl(name, 2, &cpus, &cpus_size, NULL, 0) != -1
; 79   : 			&& cpus_size == sizeof(cpus) && cpus > 0)
; 80   : 		ret = cpus;
; 81   : 
; 82   : #elif defined(TUKLIB_CPUCORES_SYSCONF)
; 83   : #	ifdef _SC_NPROCESSORS_ONLN
; 84   : 	// Most systems
; 85   : 	const long cpus = sysconf(_SC_NPROCESSORS_ONLN);
; 86   : #	else
; 87   : 	// IRIX
; 88   : 	const long cpus = sysconf(_SC_NPROC_ONLN);
; 89   : #	endif
; 90   : 	if (cpus > 0)
; 91   : 		ret = cpus;
; 92   : 
; 93   : #elif defined(TUKLIB_CPUCORES_PSTAT_GETDYNAMIC)
; 94   : 	struct pst_dynamic pst;
; 95   : 	if (pstat_getdynamic(&pst, sizeof(pst), 1, 0) != -1)
; 96   : 		ret = pst.psd_proc_cnt;
; 97   : #endif
; 98   : 
; 99   : 	return ret;

  0001d	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]

; 100  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_lzmatuklib_cpucores ENDP
END
