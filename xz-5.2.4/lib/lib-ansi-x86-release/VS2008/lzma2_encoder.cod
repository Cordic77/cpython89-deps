; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_lzma2_props_encode
PUBLIC	_lzma_lzma2_block_size
PUBLIC	_lzma_lzma2_encoder_memusage
PUBLIC	_lzma_lzma2_encoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
;	COMDAT _lzma_lzma2_block_size
_TEXT	SEGMENT
tv69 = -20						; size = 8
tv81 = -12						; size = 8
_opt$ = -4						; size = 4
_options$ = 8						; size = 4
_lzma_lzma2_block_size PROC				; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 417  : 	const lzma_options_lzma *const opt = options;

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _opt$[ebp], eax

; 418  : 
; 419  : 	// Use at least 1 MiB to keep compression ratio better.
; 420  : 	return my_max((uint64_t)(opt->dict_size) * 3, UINT64_C(1) << 20);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _opt$[ebp]
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	ba 03 00 00 00	 mov	 edx, 3
  00016	f7 e2		 mul	 edx
  00018	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0001b	89 55 f8	 mov	 DWORD PTR tv81[ebp+4], edx
  0001e	83 7d f8 00	 cmp	 DWORD PTR tv81[ebp+4], 0
  00022	77 09		 ja	 SHORT $LN5@lzma_lzma2
  00024	81 7d f4 00 00
	10 00		 cmp	 DWORD PTR tv81[ebp], 1048576 ; 00100000H
  0002b	76 14		 jbe	 SHORT $LN3@lzma_lzma2
$LN5@lzma_lzma2:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _opt$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	b9 03 00 00 00	 mov	 ecx, 3
  00037	f7 e1		 mul	 ecx
  00039	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  0003c	89 55 f0	 mov	 DWORD PTR tv69[ebp+4], edx
  0003f	eb 0e		 jmp	 SHORT $LN4@lzma_lzma2
$LN3@lzma_lzma2:
  00041	c7 45 ec 00 00
	10 00		 mov	 DWORD PTR tv69[ebp], 1048576 ; 00100000H
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp+4], 0
$LN4@lzma_lzma2:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR tv69[ebp]
  00052	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp+4]

; 421  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_lzma_lzma2_block_size ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lzma2_encoder_options_update
_TEXT	SEGMENT
_opt$32591 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_filter$ = 12						; size = 4
_lzma2_encoder_options_update PROC			; COMDAT

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 287  : 	lzma_lzma2_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 288  : 
; 289  : 	// New options can be set only when there is no incomplete chunk.
; 290  : 	// This is the case at the beginning of the raw stream and right
; 291  : 	// after LZMA_SYNC_FLUSH.
; 292  : 	if (filter->options == NULL || coder->sequence != SEQ_INIT)

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _filter$[ebp]
  0000f	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00013	74 08		 je	 SHORT $LN5@lzma2_enco
  00015	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00018	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001b	74 0a		 je	 SHORT $LN6@lzma2_enco
$LN5@lzma2_enco:

; 293  : 		return LZMA_PROG_ERROR;

  0001d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00022	e9 9a 00 00 00	 jmp	 $LN7@lzma2_enco
$LN6@lzma2_enco:

; 294  : 
; 295  : 	// Look if there are new options. At least for now,
; 296  : 	// only lc/lp/pb can be changed.
; 297  :   { const lzma_options_lzma *opt = filter->options;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	89 4d f8	 mov	 DWORD PTR _opt$32591[ebp], ecx

; 298  : 	if (coder->opt_cur.lc != opt->lc || coder->opt_cur.lp != opt->lp
; 299  : 			|| coder->opt_cur.pb != opt->pb) {

  00030	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00033	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00036	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00039	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0003c	75 1c		 jne	 SHORT $LN3@lzma2_enco
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00041	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00044	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00047	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0004a	75 0e		 jne	 SHORT $LN3@lzma2_enco
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00052	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00055	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00058	74 65		 je	 SHORT $LN4@lzma2_enco
$LN3@lzma2_enco:

; 300  : 		// Validate the options.
; 301  : 		if (opt->lc > LZMA_LCLP_MAX || opt->lp > LZMA_LCLP_MAX
; 302  : 				|| opt->lc + opt->lp > LZMA_LCLP_MAX
; 303  : 				|| opt->pb > LZMA_PB_MAX)

  0005a	8b 55 f8	 mov	 edx, DWORD PTR _opt$32591[ebp]
  0005d	83 7a 0c 04	 cmp	 DWORD PTR [edx+12], 4
  00061	77 23		 ja	 SHORT $LN1@lzma2_enco
  00063	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00066	83 78 10 04	 cmp	 DWORD PTR [eax+16], 4
  0006a	77 1a		 ja	 SHORT $LN1@lzma2_enco
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _opt$32591[ebp]
  0006f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00072	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00075	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00078	83 fa 04	 cmp	 edx, 4
  0007b	77 09		 ja	 SHORT $LN1@lzma2_enco
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _opt$32591[ebp]
  00080	83 79 14 04	 cmp	 DWORD PTR [ecx+20], 4
  00084	76 07		 jbe	 SHORT $LN2@lzma2_enco
$LN1@lzma2_enco:

; 304  : 			return LZMA_OPTIONS_ERROR;

  00086	b8 08 00 00 00	 mov	 eax, 8
  0008b	eb 34		 jmp	 SHORT $LN7@lzma2_enco
$LN2@lzma2_enco:

; 305  : 
; 306  : 		// The new options will be used when the encoder starts
; 307  : 		// a new LZMA2 chunk.
; 308  : 		coder->opt_cur.lc = opt->lc;

  0008d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00090	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  00093	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00096	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 309  : 		coder->opt_cur.lp = opt->lp;

  00099	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  0009f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000a2	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 310  : 		coder->opt_cur.pb = opt->pb;

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _opt$32591[ebp]
  000ab	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ae	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 311  : 		coder->need_properties = true;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000b4	c6 42 68 01	 mov	 BYTE PTR [edx+104], 1

; 312  : 		coder->need_state_reset = true;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000bb	c6 40 69 01	 mov	 BYTE PTR [eax+105], 1
$LN4@lzma2_enco:

; 313  : 	}
; 314  :   }
; 315  : 
; 316  : 	return LZMA_OK;

  000bf	33 c0		 xor	 eax, eax
$LN7@lzma2_enco:

; 317  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_lzma2_encoder_options_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lzma2_header_uncompressed
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_lzma2_header_uncompressed PROC				; COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 119  : 	assert(coder->uncompressed_size > 0);
; 120  : 	assert(coder->uncompressed_size <= LZMA2_CHUNK_MAX);
; 121  : 
; 122  : 	// If this is the first chunk, we need to include dictionary
; 123  : 	// reset indicator.
; 124  : 	if (coder->need_dictionary_reset)

  00003	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00006	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 09		 je	 SHORT $LN2@lzma2_head

; 125  : 		coder->buf[0] = 1;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	c6 42 78 01	 mov	 BYTE PTR [edx+120], 1

; 126  : 	else

  00015	eb 07		 jmp	 SHORT $LN1@lzma2_head
$LN2@lzma2_head:

; 127  : 		coder->buf[0] = 2;

  00017	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001a	c6 40 78 02	 mov	 BYTE PTR [eax+120], 2
$LN1@lzma2_head:

; 128  : 
; 129  : 	coder->need_dictionary_reset = false;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	c6 41 6a 00	 mov	 BYTE PTR [ecx+106], 0

; 130  : 
; 131  : 	// "Compressed" size
; 132  : 	coder->buf[1] = (uint8_t)((coder->uncompressed_size - 1) >> 8);

  00025	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00028	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0002b	83 e8 01	 sub	 eax, 1
  0002e	c1 e8 08	 shr	 eax, 8
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00034	88 41 79	 mov	 BYTE PTR [ecx+121], al

; 133  : 	coder->buf[2] = (coder->uncompressed_size - 1) & 0xFF;

  00037	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003a	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0003d	83 e8 01	 sub	 eax, 1
  00040	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00048	88 41 7a	 mov	 BYTE PTR [ecx+122], al

; 134  : 
; 135  : 	// Set the start position for copying.
; 136  : 	coder->buf_pos = 0;

  0004b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004e	c7 42 74 00 00
	00 00		 mov	 DWORD PTR [edx+116], 0

; 137  : 	return;
; 138  : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_lzma2_header_uncompressed ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT _get_dist_slot
_TEXT	SEGMENT
_dist$ = 8						; size = 4
_get_dist_slot PROC					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00003	81 7d 08 00 20
	00 00		 cmp	 DWORD PTR _dist$[ebp], 8192 ; 00002000H
  0000a	73 0c		 jae	 SHORT $LN2@get_dist_s@3

; 114  : 		return lzma_fastpos[dist];

  0000c	8b 45 08	 mov	 eax, DWORD PTR _dist$[ebp]
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[eax]
  00016	eb 2b		 jmp	 SHORT $LN3@get_dist_s@3
$LN2@get_dist_s@3:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  00018	81 7d 08 00 00
	00 02		 cmp	 DWORD PTR _dist$[ebp], 33554432 ; 02000000H
  0001f	73 12		 jae	 SHORT $LN1@get_dist_s@3

; 117  : 		return fastpos_result(dist, 0, 1);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _dist$[ebp]
  00024	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00027	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[ecx]
  0002e	83 c0 18	 add	 eax, 24			; 00000018H
  00031	eb 10		 jmp	 SHORT $LN3@get_dist_s@3
$LN1@get_dist_s@3:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00033	8b 55 08	 mov	 edx, DWORD PTR _dist$[ebp]
  00036	c1 ea 18	 shr	 edx, 24			; 00000018H
  00039	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  00040	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@3:

; 120  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_get_dist_slot ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT _mf_read
_TEXT	SEGMENT
tv66 = -12						; size = 4
_copy_size$ = -8					; size = 4
_out_avail$ = -4					; size = 4
_mf$ = 8						; size = 4
_out$ = 12						; size = 4
_out_pos$ = 16						; size = 4
_out_size$ = 20						; size = 4
_left$ = 24						; size = 4
_mf_read PROC						; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 282  : 	const size_t out_avail = out_size - *out_pos;

  00006	8b 45 10	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00009	8b 4d 14	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0000c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _out_avail$[ebp], ecx

; 283  : 	const size_t copy_size = my_min(out_avail, *left);

  00011	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _out_avail$[ebp]
  00017	3b 02		 cmp	 eax, DWORD PTR [edx]
  00019	73 08		 jae	 SHORT $LN3@mf_read
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _out_avail$[ebp]
  0001e	89 4d f4	 mov	 DWORD PTR tv66[ebp], ecx
  00021	eb 08		 jmp	 SHORT $LN4@mf_read
$LN3@mf_read:
  00023	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
$LN4@mf_read:
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  0002e	89 4d f8	 mov	 DWORD PTR _copy_size$[ebp], ecx

; 284  : 
; 285  : 	assert(mf->read_ahead == 0);
; 286  : 	assert(mf->read_pos >= *left);
; 287  : 
; 288  : 	memcpy(out + *out_pos, mf->buffer + mf->read_pos - *left,
; 289  : 			copy_size);

  00031	8b 55 f8	 mov	 edx, DWORD PTR _copy_size$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  00040	8b 45 18	 mov	 eax, DWORD PTR _left$[ebp]
  00043	2b 08		 sub	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d 10	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00049	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0004c	03 11		 add	 edx, DWORD PTR [ecx]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memcpy
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : 
; 291  : 	*out_pos += copy_size;

  00057	8b 45 10	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	03 4d f8	 add	 ecx, DWORD PTR _copy_size$[ebp]
  0005f	8b 55 10	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00062	89 0a		 mov	 DWORD PTR [edx], ecx

; 292  : 	*left -= copy_size;

  00064	8b 45 18	 mov	 eax, DWORD PTR _left$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	2b 4d f8	 sub	 ecx, DWORD PTR _copy_size$[ebp]
  0006c	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 293  : 	return;
; 294  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_mf_read ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_unencoded
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_unencoded PROC					; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  : 	return mf->write_pos - mf->read_pos + mf->read_ahead;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00009	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000c	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00012	03 42 18	 add	 eax, DWORD PTR [edx+24]

; 241  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_mf_unencoded ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
;	COMDAT _lzma_lzma2_props_encode
_TEXT	SEGMENT
tv65 = -20						; size = 4
$T77019 = -16						; size = 4
$T77018 = -12						; size = 4
_d$ = -8						; size = 4
_opt$ = -4						; size = 4
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_lzma2_props_encode PROC				; COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 392  : 	const lzma_options_lzma *const opt = options;

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _opt$[ebp], eax

; 393  : 	uint32_t d = my_max(opt->dict_size, LZMA_DICT_SIZE_MIN);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _opt$[ebp]
  0000f	81 39 00 10 00
	00		 cmp	 DWORD PTR [ecx], 4096	; 00001000H
  00015	76 0a		 jbe	 SHORT $LN5@lzma_lzma2@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _opt$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN6@lzma_lzma2@2
$LN5@lzma_lzma2@2:
  00021	c7 45 ec 00 10
	00 00		 mov	 DWORD PTR tv65[ebp], 4096 ; 00001000H
$LN6@lzma_lzma2@2:
  00028	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR _d$[ebp], ecx

; 394  : 
; 395  : 	// Round up to the next 2^n - 1 or 2^n + 2^(n - 1) - 1 depending
; 396  : 	// on which one is the next:
; 397  : 	--d;

  0002e	8b 55 f8	 mov	 edx, DWORD PTR _d$[ebp]
  00031	83 ea 01	 sub	 edx, 1
  00034	89 55 f8	 mov	 DWORD PTR _d$[ebp], edx

; 398  : 	d |= d >> 2;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _d$[ebp]
  0003a	c1 e8 02	 shr	 eax, 2
  0003d	0b 45 f8	 or	 eax, DWORD PTR _d$[ebp]
  00040	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 399  : 	d |= d >> 3;

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _d$[ebp]
  00046	c1 e9 03	 shr	 ecx, 3
  00049	0b 4d f8	 or	 ecx, DWORD PTR _d$[ebp]
  0004c	89 4d f8	 mov	 DWORD PTR _d$[ebp], ecx

; 400  : 	d |= d >> 4;

  0004f	8b 55 f8	 mov	 edx, DWORD PTR _d$[ebp]
  00052	c1 ea 04	 shr	 edx, 4
  00055	0b 55 f8	 or	 edx, DWORD PTR _d$[ebp]
  00058	89 55 f8	 mov	 DWORD PTR _d$[ebp], edx

; 401  : 	d |= d >> 8;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _d$[ebp]
  0005e	c1 e8 08	 shr	 eax, 8
  00061	0b 45 f8	 or	 eax, DWORD PTR _d$[ebp]
  00064	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 402  : 	d |= d >> 16;

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _d$[ebp]
  0006a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0006d	0b 4d f8	 or	 ecx, DWORD PTR _d$[ebp]
  00070	89 4d f8	 mov	 DWORD PTR _d$[ebp], ecx

; 403  : 
; 404  : 	// Get the highest two bits using the proper encoding:
; 405  : 	if (d == UINT32_MAX)

  00073	83 7d f8 ff	 cmp	 DWORD PTR _d$[ebp], -1
  00077	75 08		 jne	 SHORT $LN2@lzma_lzma2@2

; 406  : 		out[0] = 40;

  00079	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0007c	c6 02 28	 mov	 BYTE PTR [edx], 40	; 00000028H

; 407  : 	else

  0007f	eb 5d		 jmp	 SHORT $LN1@lzma_lzma2@2
$LN2@lzma_lzma2@2:

; 408  : 		out[0] = get_dist_slot(d + 1) - 24;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _d$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f4	 mov	 DWORD PTR $T77018[ebp], eax
  0008a	81 7d f4 00 20
	00 00		 cmp	 DWORD PTR $T77018[ebp], 8192 ; 00002000H
  00091	73 0f		 jae	 SHORT $LN8@lzma_lzma2@2
  00093	8b 4d f4	 mov	 ecx, DWORD PTR $T77018[ebp]
  00096	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_fastpos[ecx]
  0009d	89 55 f0	 mov	 DWORD PTR $T77019[ebp], edx
  000a0	eb 31		 jmp	 SHORT $LN9@lzma_lzma2@2
$LN8@lzma_lzma2@2:
  000a2	81 7d f4 00 00
	00 02		 cmp	 DWORD PTR $T77018[ebp], 33554432 ; 02000000H
  000a9	73 15		 jae	 SHORT $LN7@lzma_lzma2@2
  000ab	8b 45 f4	 mov	 eax, DWORD PTR $T77018[ebp]
  000ae	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000b1	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_fastpos[eax]
  000b8	83 c1 18	 add	 ecx, 24			; 00000018H
  000bb	89 4d f0	 mov	 DWORD PTR $T77019[ebp], ecx
  000be	eb 13		 jmp	 SHORT $LN9@lzma_lzma2@2
$LN7@lzma_lzma2@2:
  000c0	8b 55 f4	 mov	 edx, DWORD PTR $T77018[ebp]
  000c3	c1 ea 18	 shr	 edx, 24			; 00000018H
  000c6	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  000cd	83 c0 30	 add	 eax, 48			; 00000030H
  000d0	89 45 f0	 mov	 DWORD PTR $T77019[ebp], eax
$LN9@lzma_lzma2@2:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T77019[ebp]
  000d6	83 e9 18	 sub	 ecx, 24			; 00000018H
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  000dc	88 0a		 mov	 BYTE PTR [edx], cl
$LN1@lzma_lzma2@2:

; 409  : 
; 410  : 	return LZMA_OK;

  000de	33 c0		 xor	 eax, eax

; 411  : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_lzma_lzma2_props_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lzma2_encoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma2_encoder_end PROC					; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 277  : 	lzma_lzma2_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 278  : 	lzma_free(coder->lzma, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _lzma_free
  0001a	83 c4 08	 add	 esp, 8

; 279  : 	lzma_free(coder, allocator);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 _lzma_free
  0002a	83 c4 08	 add	 esp, 8

; 280  : 	return;
; 281  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_lzma2_encoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma2_header_lzma
_TEXT	SEGMENT
_size$32513 = -8					; size = 4
_pos$32506 = -4						; size = 4
_coder$ = 8						; size = 4
_lzma2_header_lzma PROC					; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 57   : 	assert(coder->uncompressed_size > 0);
; 58   : 	assert(coder->uncompressed_size <= LZMA2_UNCOMPRESSED_MAX);
; 59   : 	assert(coder->compressed_size > 0);
; 60   : 	assert(coder->compressed_size <= LZMA2_CHUNK_MAX);
; 61   : 
; 62   :   {
; 63   : 	size_t pos;
; 64   : 
; 65   : 	if (coder->need_properties) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	0f b6 48 68	 movzx	 ecx, BYTE PTR [eax+104]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 2a		 je	 SHORT $LN7@lzma2_head@2

; 66   : 		pos = 0;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pos$32506[ebp], 0

; 67   : 
; 68   : 		if (coder->need_dictionary_reset)

  00018	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0001b	0f b6 42 6a	 movzx	 eax, BYTE PTR [edx+106]
  0001f	85 c0		 test	 eax, eax
  00021	74 0c		 je	 SHORT $LN6@lzma2_head@2

; 69   : 			coder->buf[pos] = 0x80 + (3 << 5);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00026	03 4d fc	 add	 ecx, DWORD PTR _pos$32506[ebp]
  00029	c6 41 78 e0	 mov	 BYTE PTR [ecx+120], 224	; 000000e0H

; 70   : 		else

  0002d	eb 0a		 jmp	 SHORT $LN5@lzma2_head@2
$LN6@lzma2_head@2:

; 71   : 			coder->buf[pos] = 0x80 + (2 << 5);

  0002f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00032	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  00035	c6 42 78 c0	 mov	 BYTE PTR [edx+120], 192	; 000000c0H
$LN5@lzma2_head@2:

; 72   : 	} else {

  00039	eb 28		 jmp	 SHORT $LN4@lzma2_head@2
$LN7@lzma2_head@2:

; 73   : 		pos = 1;

  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _pos$32506[ebp], 1

; 74   : 
; 75   : 		if (coder->need_state_reset)

  00042	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00045	0f b6 48 69	 movzx	 ecx, BYTE PTR [eax+105]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 0c		 je	 SHORT $LN3@lzma2_head@2

; 76   : 			coder->buf[pos] = 0x80 + (1 << 5);

  0004d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00050	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  00053	c6 42 78 a0	 mov	 BYTE PTR [edx+120], 160	; 000000a0H

; 77   : 		else

  00057	eb 0a		 jmp	 SHORT $LN4@lzma2_head@2
$LN3@lzma2_head@2:

; 78   : 			coder->buf[pos] = 0x80;

  00059	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005c	03 45 fc	 add	 eax, DWORD PTR _pos$32506[ebp]
  0005f	c6 40 78 80	 mov	 BYTE PTR [eax+120], 128	; 00000080H
$LN4@lzma2_head@2:

; 79   : 	}
; 80   : 
; 81   : 	// Set the start position for copying.
; 82   : 	coder->buf_pos = pos;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00066	8b 55 fc	 mov	 edx, DWORD PTR _pos$32506[ebp]
  00069	89 51 74	 mov	 DWORD PTR [ecx+116], edx

; 83   : 
; 84   : 	// Uncompressed size
; 85   :   {
; 86   : 	size_t size = coder->uncompressed_size - 1;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0006f	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00072	83 e9 01	 sub	 ecx, 1
  00075	89 4d f8	 mov	 DWORD PTR _size$32513[ebp], ecx

; 87   : //W	coder->buf[pos++] += size >> 16;
; 88   : 	coder->buf[pos] = (uint8_t)(coder->buf[pos] + (size >> 16));

  00078	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0007b	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  0007e	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _size$32513[ebp]
  00085	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00088	03 c1		 add	 eax, ecx
  0008a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0008d	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  00090	88 42 78	 mov	 BYTE PTR [edx+120], al

; 89   :   ++pos;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _pos$32506[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 fc	 mov	 DWORD PTR _pos$32506[ebp], eax

; 90   : 	coder->buf[pos++] = (size >> 8) & 0xFF;

  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _size$32513[ebp]
  0009f	c1 e9 08	 shr	 ecx, 8
  000a2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a8	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ab	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  000ae	88 4a 78	 mov	 BYTE PTR [edx+120], cl
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _pos$32506[ebp]
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 fc	 mov	 DWORD PTR _pos$32506[ebp], eax

; 91   : 	coder->buf[pos++] = size & 0xFF;

  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _size$32513[ebp]
  000bd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c3	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000c6	03 55 fc	 add	 edx, DWORD PTR _pos$32506[ebp]
  000c9	88 4a 78	 mov	 BYTE PTR [edx+120], cl
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _pos$32506[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 fc	 mov	 DWORD PTR _pos$32506[ebp], eax

; 92   : 
; 93   : 	// Compressed size
; 94   : 	size = coder->compressed_size - 1;

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d8	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  000db	83 ea 01	 sub	 edx, 1
  000de	89 55 f8	 mov	 DWORD PTR _size$32513[ebp], edx

; 95   : 	coder->buf[pos++] = (uint8_t)(size >> 8);

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _size$32513[ebp]
  000e4	c1 e8 08	 shr	 eax, 8
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ea	03 4d fc	 add	 ecx, DWORD PTR _pos$32506[ebp]
  000ed	88 41 78	 mov	 BYTE PTR [ecx+120], al
  000f0	8b 55 fc	 mov	 edx, DWORD PTR _pos$32506[ebp]
  000f3	83 c2 01	 add	 edx, 1
  000f6	89 55 fc	 mov	 DWORD PTR _pos$32506[ebp], edx

; 96   : 	coder->buf[pos++] = size & 0xFF;

  000f9	8b 45 f8	 mov	 eax, DWORD PTR _size$32513[ebp]
  000fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00104	03 4d fc	 add	 ecx, DWORD PTR _pos$32506[ebp]
  00107	88 41 78	 mov	 BYTE PTR [ecx+120], al
  0010a	8b 55 fc	 mov	 edx, DWORD PTR _pos$32506[ebp]
  0010d	83 c2 01	 add	 edx, 1
  00110	89 55 fc	 mov	 DWORD PTR _pos$32506[ebp], edx

; 97   :   }
; 98   : 
; 99   : 	// Properties, if needed
; 100  : 	if (coder->need_properties)

  00113	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00116	0f b6 48 68	 movzx	 ecx, BYTE PTR [eax+104]
  0011a	85 c9		 test	 ecx, ecx
  0011c	74 1a		 je	 SHORT $LN1@lzma2_head@2

; 101  : 		lzma_lzma_lclppb_encode(&coder->opt_cur, coder->buf + pos);

  0011e	8b 55 fc	 mov	 edx, DWORD PTR _pos$32506[ebp]
  00121	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00124	8d 4c 10 78	 lea	 ecx, DWORD PTR [eax+edx+120]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0012c	83 c2 08	 add	 edx, 8
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _lzma_lzma_lclppb_encode
  00135	83 c4 08	 add	 esp, 8
$LN1@lzma2_head@2:

; 102  :   }
; 103  : 
; 104  : 	coder->need_properties = false;

  00138	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0013b	c6 40 68 00	 mov	 BYTE PTR [eax+104], 0

; 105  : 	coder->need_state_reset = false;

  0013f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00142	c6 41 69 00	 mov	 BYTE PTR [ecx+105], 0

; 106  : 	coder->need_dictionary_reset = false;

  00146	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00149	c6 42 6a 00	 mov	 BYTE PTR [edx+106], 0

; 107  : 
; 108  : 	// The copying code uses coder->compressed_size to indicate the end
; 109  : 	// of coder->buf[], so we need add the maximum size of the header here.
; 110  : 	coder->compressed_size += LZMA2_HEADER_MAX;

  0014d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00150	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00153	83 c1 06	 add	 ecx, 6
  00156	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00159	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 111  : 
; 112  : 	return;
; 113  : }

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
_lzma2_header_lzma ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma2_encoder_memusage
_TEXT	SEGMENT
_lzma_mem$ = -8						; size = 8
_options$ = 8						; size = 4
_lzma_lzma2_encoder_memusage PROC			; COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 381  : 	const uint64_t lzma_mem = lzma_lzma_encoder_memusage(options);

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_lzma_encoder_memusage
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f8	 mov	 DWORD PTR _lzma_mem$[ebp], eax
  00015	89 55 fc	 mov	 DWORD PTR _lzma_mem$[ebp+4], edx

; 382  : 	if (lzma_mem == UINT64_MAX)

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _lzma_mem$[ebp]
  0001b	23 4d fc	 and	 ecx, DWORD PTR _lzma_mem$[ebp+4]
  0001e	83 f9 ff	 cmp	 ecx, -1
  00021	75 08		 jne	 SHORT $LN1@lzma_lzma2@4

; 383  : 		return UINT64_MAX;

  00023	83 c8 ff	 or	 eax, -1
  00026	83 ca ff	 or	 edx, -1
  00029	eb 0e		 jmp	 SHORT $LN2@lzma_lzma2@4
$LN1@lzma_lzma2@4:

; 384  : 
; 385  : 	return sizeof(lzma_lzma2_coder) + lzma_mem;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _lzma_mem$[ebp]
  0002e	05 80 00 01 00	 add	 eax, 65664		; 00010080H
  00033	8b 55 fc	 mov	 edx, DWORD PTR _lzma_mem$[ebp+4]
  00036	83 d2 00	 adc	 edx, 0
$LN2@lzma_lzma2@4:

; 386  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_lzma_lzma2_encoder_memusage ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma2_encode
_TEXT	SEGMENT
tv200 = -44						; size = 4
tv65 = -40						; size = 4
$T80438 = -36						; size = 4
_copy_size$80437 = -32					; size = 4
_out_avail$80436 = -28					; size = 4
_ret$32562 = -24					; size = 4
_read_start$32561 = -20					; size = 4
_limit$32558 = -16					; size = 4
_left$32556 = -12					; size = 4
_ret_$32553 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_mf$ = 12						; size = 4
_out$ = 16						; size = 4
_out_pos$ = 20						; size = 4
_out_size$ = 24						; size = 4
_lzma2_encode PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 146  : 	lzma_lzma2_coder *restrict coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN23@lzma2_enco@2:

; 147  : 
; 148  : 	while (*out_pos < out_size)

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 18	 cmp	 edx, DWORD PTR _out_size$[ebp]
  00014	0f 83 cc 02 00
	00		 jae	 $LN22@lzma2_enco@2

; 149  : 	switch (coder->sequence) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d d8	 mov	 DWORD PTR tv65[ebp], ecx
  00022	83 7d d8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00026	0f 87 b5 02 00
	00		 ja	 $LN20@lzma2_enco@2
  0002c	8b 55 d8	 mov	 edx, DWORD PTR tv65[ebp]
  0002f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN32@lzma2_enco@2[edx*4]

; 150  : 	case SEQ_INIT:
; 151  : 		// If there's no input left and we are flushing or finishing,
; 152  : 		// don't start a new chunk.
; 153  : 		if (mf_unencoded(mf) == 0) {

$LN26@lzma2_enco@2:
  00036	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0003c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0003f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00045	03 50 18	 add	 edx, DWORD PTR [eax+24]
  00048	75 33		 jne	 SHORT $LN18@lzma2_enco@2

; 154  : 			// Write end of payload marker if finishing.
; 155  : 			if (mf->action == LZMA_FINISH)

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0004d	83 79 50 03	 cmp	 DWORD PTR [ecx+80], 3
  00051	75 19		 jne	 SHORT $LN17@lzma2_enco@2

; 156  : 				out[(*out_pos)++] = 0;

  00053	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  0005b	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0005f	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	83 c0 01	 add	 eax, 1
  00067	8b 4d 14	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0006a	89 01		 mov	 DWORD PTR [ecx], eax
$LN17@lzma2_enco@2:

; 157  : 
; 158  : 			return mf->action == LZMA_RUN
; 159  : 					? LZMA_OK : LZMA_STREAM_END;

  0006c	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0006f	33 c0		 xor	 eax, eax
  00071	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  00075	0f 95 c0	 setne	 al
  00078	e9 6b 02 00 00	 jmp	 $LN24@lzma2_enco@2
$LN18@lzma2_enco@2:

; 160  : 		}
; 161  : 
; 162  : 		if (coder->need_state_reset)

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00080	0f b6 48 69	 movzx	 ecx, BYTE PTR [eax+105]
  00084	85 c9		 test	 ecx, ecx
  00086	74 2b		 je	 SHORT $LN16@lzma2_enco@2
$LN15@lzma2_enco@2:

; 163  : 			return_if_error(lzma_lzma_encoder_reset(
; 164  : 					coder->lzma, &coder->opt_cur));

  00088	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0008b	83 c2 08	 add	 edx, 8
  0008e	52		 push	 edx
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _lzma_lzma_encoder_reset
  0009b	83 c4 08	 add	 esp, 8
  0009e	89 45 f8	 mov	 DWORD PTR _ret_$32553[ebp], eax
  000a1	83 7d f8 00	 cmp	 DWORD PTR _ret_$32553[ebp], 0
  000a5	74 08		 je	 SHORT $LN14@lzma2_enco@2
  000a7	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32553[ebp]
  000aa	e9 39 02 00 00	 jmp	 $LN24@lzma2_enco@2
$LN14@lzma2_enco@2:
  000af	33 d2		 xor	 edx, edx
  000b1	75 d5		 jne	 SHORT $LN15@lzma2_enco@2
$LN16@lzma2_enco@2:

; 165  : 
; 166  : 		coder->uncompressed_size = 0;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000b6	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 167  : 		coder->compressed_size = 0;

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000c0	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0

; 168  : 		coder->sequence = SEQ_LZMA_ENCODE;

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000ca	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN11@lzma2_enco@2:

; 169  : 
; 170  : 	// Fall through
; 171  : 
; 172  : 	case SEQ_LZMA_ENCODE: {
; 173  : 		// Calculate how much more uncompressed data this chunk
; 174  : 		// could accept.
; 175  : 		const uint32_t left = (const uint32_t)(LZMA2_UNCOMPRESSED_MAX
; 176  : 				- coder->uncompressed_size);

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000d3	b9 00 00 20 00	 mov	 ecx, 2097152		; 00200000H
  000d8	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  000db	89 4d f4	 mov	 DWORD PTR _left$32556[ebp], ecx

; 177  : 		uint32_t limit;
; 178  : 
; 179  : 		if (left < mf->match_len_max) {

  000de	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _left$32556[ebp]
  000e4	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  000e7	73 09		 jae	 SHORT $LN10@lzma2_enco@2

; 180  : 			// Must flush immediately since the next LZMA symbol
; 181  : 			// could make the uncompressed size of the chunk too
; 182  : 			// big.
; 183  : 			limit = 0;

  000e9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _limit$32558[ebp], 0

; 184  : 		} else {

  000f0	eb 18		 jmp	 SHORT $LN9@lzma2_enco@2
$LN10@lzma2_enco@2:

; 185  : 			// Calculate maximum read_limit that is OK from point
; 186  : 			// of view of LZMA2 chunk size.
; 187  : 			limit = mf->read_pos - mf->read_ahead
; 188  : 					+ left - mf->match_len_max;

  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f5	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  000f8	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  000fb	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  000fe	03 45 f4	 add	 eax, DWORD PTR _left$32556[ebp]
  00101	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00104	2b 41 4c	 sub	 eax, DWORD PTR [ecx+76]
  00107	89 45 f0	 mov	 DWORD PTR _limit$32558[ebp], eax
$LN9@lzma2_enco@2:

; 189  : 		}
; 190  : 
; 191  : 		// Save the start position so that we can update
; 192  : 		// coder->uncompressed_size.
; 193  : 	  {
; 194  : 		const uint32_t read_start = mf->read_pos - mf->read_ahead;

  0010a	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0010d	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00110	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00113	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00116	89 4d ec	 mov	 DWORD PTR _read_start$32561[ebp], ecx

; 195  : 
; 196  : 		// Call the LZMA encoder until the chunk is finished.
; 197  : 		const lzma_ret ret = lzma_lzma_encode(coder->lzma, mf,
; 198  : 				coder->buf + LZMA2_HEADER_MAX,
; 199  : 				&coder->compressed_size,
; 200  : 				LZMA2_CHUNK_MAX, limit);

  00119	8b 55 f0	 mov	 edx, DWORD PTR _limit$32558[ebp]
  0011c	52		 push	 edx
  0011d	68 00 00 01 00	 push	 65536			; 00010000H
  00122	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00125	83 c0 70	 add	 eax, 112		; 00000070H
  00128	50		 push	 eax
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0012c	83 c1 7e	 add	 ecx, 126		; 0000007eH
  0012f	51		 push	 ecx
  00130	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00133	52		 push	 edx
  00134	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00137	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _lzma_lzma_encode
  00140	83 c4 18	 add	 esp, 24			; 00000018H
  00143	89 45 e8	 mov	 DWORD PTR _ret$32562[ebp], eax

; 201  : 
; 202  : 		coder->uncompressed_size += mf->read_pos - mf->read_ahead
; 203  : 				- read_start;

  00146	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00149	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0014c	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0014f	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00152	2b 4d ec	 sub	 ecx, DWORD PTR _read_start$32561[ebp]
  00155	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00158	03 4a 6c	 add	 ecx, DWORD PTR [edx+108]
  0015b	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0015e	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 204  : 
; 205  : 		assert(coder->compressed_size <= LZMA2_CHUNK_MAX);
; 206  : 		assert(coder->uncompressed_size <= LZMA2_UNCOMPRESSED_MAX);
; 207  : 
; 208  : 		if (ret != LZMA_STREAM_END)

  00161	83 7d e8 01	 cmp	 DWORD PTR _ret$32562[ebp], 1
  00165	74 07		 je	 SHORT $LN8@lzma2_enco@2

; 209  : 			return LZMA_OK;

  00167	33 c0		 xor	 eax, eax
  00169	e9 7a 01 00 00	 jmp	 $LN24@lzma2_enco@2
$LN8@lzma2_enco@2:

; 210  : 
; 211  : 		// See if the chunk compressed. If it didn't, we encode it
; 212  : 		// as uncompressed chunk. This saves a few bytes of space
; 213  : 		// and makes decoding faster.
; 214  : 		if (coder->compressed_size >= coder->uncompressed_size) {

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00171	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00174	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00177	3b 42 6c	 cmp	 eax, DWORD PTR [edx+108]
  0017a	72 3d		 jb	 SHORT $LN7@lzma2_enco@2

; 215  : 			coder->uncompressed_size += mf->read_ahead;

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0017f	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00182	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00185	03 50 18	 add	 edx, DWORD PTR [eax+24]
  00188	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0018b	89 51 6c	 mov	 DWORD PTR [ecx+108], edx

; 216  : 			assert(coder->uncompressed_size
; 217  : 					<= LZMA2_UNCOMPRESSED_MAX);
; 218  : 			mf->read_ahead = 0;

  0018e	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00191	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 219  : 			lzma2_header_uncompressed(coder);

  00198	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _lzma2_header_uncompressed
  001a1	83 c4 04	 add	 esp, 4

; 220  : 			coder->need_state_reset = true;

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001a7	c6 41 69 01	 mov	 BYTE PTR [ecx+105], 1

; 221  : 			coder->sequence = SEQ_UNCOMPRESSED_HEADER;

  001ab	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001ae	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3

; 222  : 			break;

  001b4	e9 28 01 00 00	 jmp	 $LN20@lzma2_enco@2
$LN7@lzma2_enco@2:

; 223  : 		}
; 224  : 
; 225  : 		// The chunk did compress at least by one byte, so we store
; 226  : 		// the chunk as LZMA.
; 227  : 		lzma2_header_lzma(coder);

  001b9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _lzma2_header_lzma
  001c2	83 c4 04	 add	 esp, 4

; 228  : 
; 229  : 		coder->sequence = SEQ_LZMA_COPY;

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c8	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN6@lzma2_enco@2:

; 230  : 	  }
; 231  : 	}
; 232  : 
; 233  : 	// Fall through
; 234  : 
; 235  : 	case SEQ_LZMA_COPY:
; 236  : 		// Copy the compressed chunk along its headers to the
; 237  : 		// output buffer.
; 238  : 		lzma_bufcpy(coder->buf, &coder->buf_pos,
; 239  : 				coder->compressed_size,
; 240  : 				out, out_pos, out_size);

  001ce	8b 55 18	 mov	 edx, DWORD PTR _out_size$[ebp]
  001d1	52		 push	 edx
  001d2	8b 45 14	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  001d9	51		 push	 ecx
  001da	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001dd	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  001e0	50		 push	 eax
  001e1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001e4	83 c1 74	 add	 ecx, 116		; 00000074H
  001e7	51		 push	 ecx
  001e8	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001eb	83 c2 78	 add	 edx, 120		; 00000078H
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 _lzma_bufcpy
  001f4	83 c4 18	 add	 esp, 24			; 00000018H

; 241  : 		if (coder->buf_pos != coder->compressed_size)

  001f7	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001fd	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  00200	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  00203	74 07		 je	 SHORT $LN5@lzma2_enco@2

; 242  : 			return LZMA_OK;

  00205	33 c0		 xor	 eax, eax
  00207	e9 dc 00 00 00	 jmp	 $LN24@lzma2_enco@2
$LN5@lzma2_enco@2:

; 243  : 
; 244  : 		coder->sequence = SEQ_INIT;

  0020c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0020f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 245  : 		break;

  00215	e9 c7 00 00 00	 jmp	 $LN20@lzma2_enco@2
$LN4@lzma2_enco@2:

; 246  : 
; 247  : 	case SEQ_UNCOMPRESSED_HEADER:
; 248  : 		// Copy the three-byte header to indicate uncompressed chunk.
; 249  : 		lzma_bufcpy(coder->buf, &coder->buf_pos,
; 250  : 				LZMA2_HEADER_UNCOMPRESSED,
; 251  : 				out, out_pos, out_size);

  0021a	8b 4d 18	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0021d	51		 push	 ecx
  0021e	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00221	52		 push	 edx
  00222	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  00225	50		 push	 eax
  00226	6a 03		 push	 3
  00228	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0022b	83 c1 74	 add	 ecx, 116		; 00000074H
  0022e	51		 push	 ecx
  0022f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00232	83 c2 78	 add	 edx, 120		; 00000078H
  00235	52		 push	 edx
  00236	e8 00 00 00 00	 call	 _lzma_bufcpy
  0023b	83 c4 18	 add	 esp, 24			; 00000018H

; 252  : 		if (coder->buf_pos != LZMA2_HEADER_UNCOMPRESSED)

  0023e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00241	83 78 74 03	 cmp	 DWORD PTR [eax+116], 3
  00245	74 07		 je	 SHORT $LN3@lzma2_enco@2

; 253  : 			return LZMA_OK;

  00247	33 c0		 xor	 eax, eax
  00249	e9 9a 00 00 00	 jmp	 $LN24@lzma2_enco@2
$LN3@lzma2_enco@2:

; 254  : 
; 255  : 		coder->sequence = SEQ_UNCOMPRESSED_COPY;

  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00251	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN2@lzma2_enco@2:

; 256  : 
; 257  : 	// Fall through
; 258  : 
; 259  : 	case SEQ_UNCOMPRESSED_COPY:
; 260  : 		// Copy the uncompressed data as is from the dictionary
; 261  : 		// to the output buffer.
; 262  : 		mf_read(mf, out, out_pos, out_size, &coder->uncompressed_size);

  00257	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0025a	83 c2 6c	 add	 edx, 108		; 0000006cH
  0025d	89 55 dc	 mov	 DWORD PTR $T80438[ebp], edx
  00260	8b 45 14	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00263	8b 4d 18	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00266	2b 08		 sub	 ecx, DWORD PTR [eax]
  00268	89 4d e4	 mov	 DWORD PTR _out_avail$80436[ebp], ecx
  0026b	8b 55 dc	 mov	 edx, DWORD PTR $T80438[ebp]
  0026e	8b 45 e4	 mov	 eax, DWORD PTR _out_avail$80436[ebp]
  00271	3b 02		 cmp	 eax, DWORD PTR [edx]
  00273	73 08		 jae	 SHORT $LN30@lzma2_enco@2
  00275	8b 4d e4	 mov	 ecx, DWORD PTR _out_avail$80436[ebp]
  00278	89 4d d4	 mov	 DWORD PTR tv200[ebp], ecx
  0027b	eb 08		 jmp	 SHORT $LN31@lzma2_enco@2
$LN30@lzma2_enco@2:
  0027d	8b 55 dc	 mov	 edx, DWORD PTR $T80438[ebp]
  00280	8b 02		 mov	 eax, DWORD PTR [edx]
  00282	89 45 d4	 mov	 DWORD PTR tv200[ebp], eax
$LN31@lzma2_enco@2:
  00285	8b 4d d4	 mov	 ecx, DWORD PTR tv200[ebp]
  00288	89 4d e0	 mov	 DWORD PTR _copy_size$80437[ebp], ecx
  0028b	8b 55 e0	 mov	 edx, DWORD PTR _copy_size$80437[ebp]
  0028e	52		 push	 edx
  0028f	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00292	8b 08		 mov	 ecx, DWORD PTR [eax]
  00294	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00297	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  0029a	8b 45 dc	 mov	 eax, DWORD PTR $T80438[ebp]
  0029d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0029f	51		 push	 ecx
  002a0	8b 4d 14	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  002a3	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  002a6	03 11		 add	 edx, DWORD PTR [ecx]
  002a8	52		 push	 edx
  002a9	e8 00 00 00 00	 call	 _memcpy
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	8b 45 14	 mov	 eax, DWORD PTR _out_pos$[ebp]
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	03 4d e0	 add	 ecx, DWORD PTR _copy_size$80437[ebp]
  002b9	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  002bc	89 0a		 mov	 DWORD PTR [edx], ecx
  002be	8b 45 dc	 mov	 eax, DWORD PTR $T80438[ebp]
  002c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c3	2b 4d e0	 sub	 ecx, DWORD PTR _copy_size$80437[ebp]
  002c6	8b 55 dc	 mov	 edx, DWORD PTR $T80438[ebp]
  002c9	89 0a		 mov	 DWORD PTR [edx], ecx

; 263  : 		if (coder->uncompressed_size != 0)

  002cb	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002ce	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  002d2	74 04		 je	 SHORT $LN1@lzma2_enco@2

; 264  : 			return LZMA_OK;

  002d4	33 c0		 xor	 eax, eax
  002d6	eb 10		 jmp	 SHORT $LN24@lzma2_enco@2
$LN1@lzma2_enco@2:

; 265  : 
; 266  : 		coder->sequence = SEQ_INIT;

  002d8	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002db	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN20@lzma2_enco@2:

; 267  : 		break;
; 268  : 	}

  002e1	e9 26 fd ff ff	 jmp	 $LN23@lzma2_enco@2
$LN22@lzma2_enco@2:

; 269  : 
; 270  : 	return LZMA_OK;

  002e6	33 c0		 xor	 eax, eax
$LN24@lzma2_enco@2:

; 271  : }

  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c3		 ret	 0
$LN32@lzma2_enco@2:
  002ec	00 00 00 00	 DD	 $LN26@lzma2_enco@2
  002f0	00 00 00 00	 DD	 $LN11@lzma2_enco@2
  002f4	00 00 00 00	 DD	 $LN6@lzma2_enco@2
  002f8	00 00 00 00	 DD	 $LN4@lzma2_enco@2
  002fc	00 00 00 00	 DD	 $LN2@lzma2_enco@2
_lzma2_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma2_encoder_init
_TEXT	SEGMENT
tv83 = -12						; size = 4
_ret_$32620 = -8					; size = 4
_coder$32608 = -4					; size = 4
_lz$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_lz_options$ = 20					; size = 4
_lzma2_encoder_init PROC				; COMDAT

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 324  : 	if (options == NULL)

  00008	83 7d 10 00	 cmp	 DWORD PTR _options$[ebp], 0
  0000c	75 0a		 jne	 SHORT $LN8@lzma2_enco@3

; 325  : 		return LZMA_PROG_ERROR;

  0000e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00013	e9 09 01 00 00	 jmp	 $LN9@lzma2_enco@3
$LN8@lzma2_enco@3:

; 326  : 
; 327  :   {
; 328  : 	lzma_lzma2_coder *coder = lz->coder;

  00018	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 4d fc	 mov	 DWORD PTR _coder$32608[ebp], ecx

; 329  : 	if (coder == NULL) {

  00020	83 7d fc 00	 cmp	 DWORD PTR _coder$32608[ebp], 0
  00024	75 54		 jne	 SHORT $LN7@lzma2_enco@3

; 330  : 		coder = lzma_alloc(sizeof(lzma_lzma2_coder), allocator);

  00026	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00029	52		 push	 edx
  0002a	68 80 00 01 00	 push	 65664			; 00010080H
  0002f	e8 00 00 00 00	 call	 _lzma_alloc
  00034	83 c4 08	 add	 esp, 8
  00037	89 45 fc	 mov	 DWORD PTR _coder$32608[ebp], eax

; 331  : 		if (coder == NULL)

  0003a	83 7d fc 00	 cmp	 DWORD PTR _coder$32608[ebp], 0
  0003e	75 0a		 jne	 SHORT $LN6@lzma2_enco@3

; 332  : 			return LZMA_MEM_ERROR;

  00040	b8 05 00 00 00	 mov	 eax, 5
  00045	e9 d7 00 00 00	 jmp	 $LN9@lzma2_enco@3
$LN6@lzma2_enco@3:

; 333  : 
; 334  : 		lz->coder = coder;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32608[ebp]
  00050	89 08		 mov	 DWORD PTR [eax], ecx

; 335  : 		lz->code = &lzma2_encode;

  00052	8b 55 08	 mov	 edx, DWORD PTR _lz$[ebp]
  00055	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], OFFSET _lzma2_encode

; 336  : 		lz->end = &lzma2_encoder_end;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  0005f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _lzma2_encoder_end

; 337  : 		lz->options_update = &lzma2_encoder_options_update;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _lz$[ebp]
  00069	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _lzma2_encoder_options_update

; 338  : 
; 339  : 		coder->lzma = NULL;

  00070	8b 55 fc	 mov	 edx, DWORD PTR _coder$32608[ebp]
  00073	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN7@lzma2_enco@3:

; 340  : 	}
; 341  : 
; 342  : 	coder->opt_cur = *(const lzma_options_lzma *)(options);

  0007a	8b 75 10	 mov	 esi, DWORD PTR _options$[ebp]
  0007d	8b 7d fc	 mov	 edi, DWORD PTR _coder$32608[ebp]
  00080	83 c7 08	 add	 edi, 8
  00083	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00088	f3 a5		 rep movsd

; 343  : 
; 344  : 	coder->sequence = SEQ_INIT;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _coder$32608[ebp]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 345  : 	coder->need_properties = true;

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32608[ebp]
  00096	c6 41 68 01	 mov	 BYTE PTR [ecx+104], 1

; 346  : 	coder->need_state_reset = false;

  0009a	8b 55 fc	 mov	 edx, DWORD PTR _coder$32608[ebp]
  0009d	c6 42 69 00	 mov	 BYTE PTR [edx+105], 0

; 347  : 	coder->need_dictionary_reset
; 348  : 			= coder->opt_cur.preset_dict == NULL
; 349  : 			|| coder->opt_cur.preset_dict_size == 0;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _coder$32608[ebp]
  000a4	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a8	74 12		 je	 SHORT $LN11@lzma2_enco@3
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32608[ebp]
  000ad	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000b1	74 09		 je	 SHORT $LN11@lzma2_enco@3
  000b3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  000ba	eb 07		 jmp	 SHORT $LN12@lzma2_enco@3
$LN11@lzma2_enco@3:
  000bc	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
$LN12@lzma2_enco@3:
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _coder$32608[ebp]
  000c6	8a 45 f4	 mov	 al, BYTE PTR tv83[ebp]
  000c9	88 42 6a	 mov	 BYTE PTR [edx+106], al
$LN5@lzma2_enco@3:

; 350  : 
; 351  : 	// Initialize LZMA encoder
; 352  : 	return_if_error(lzma_lzma_encoder_create(&coder->lzma, allocator,
; 353  : 			&coder->opt_cur, lz_options));

  000cc	8b 4d 14	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 fc	 mov	 edx, DWORD PTR _coder$32608[ebp]
  000d3	83 c2 08	 add	 edx, 8
  000d6	52		 push	 edx
  000d7	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000da	50		 push	 eax
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32608[ebp]
  000de	83 c1 04	 add	 ecx, 4
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _lzma_lzma_encoder_create
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
  000ea	89 45 f8	 mov	 DWORD PTR _ret_$32620[ebp], eax
  000ed	83 7d f8 00	 cmp	 DWORD PTR _ret_$32620[ebp], 0
  000f1	74 05		 je	 SHORT $LN4@lzma2_enco@3
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32620[ebp]
  000f6	eb 29		 jmp	 SHORT $LN9@lzma2_enco@3
$LN4@lzma2_enco@3:
  000f8	33 d2		 xor	 edx, edx
  000fa	75 d0		 jne	 SHORT $LN5@lzma2_enco@3

; 354  :   }
; 355  : 
; 356  : 	// Make sure that we will always have enough history available in
; 357  : 	// case we need to use uncompressed chunks. They are used when the
; 358  : 	// compressed size of a chunk is not smaller than the uncompressed
; 359  : 	// size, so we need to have at least LZMA2_COMPRESSED_MAX bytes
; 360  : 	// history available.
; 361  : 	if (lz_options->before_size + lz_options->dict_size < LZMA2_CHUNK_MAX)

  000fc	8b 45 14	 mov	 eax, DWORD PTR _lz_options$[ebp]
  000ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00101	8b 55 14	 mov	 edx, DWORD PTR _lz_options$[ebp]
  00104	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00107	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  0010d	73 10		 jae	 SHORT $LN1@lzma2_enco@3

; 362  : 		lz_options->before_size
; 363  : 				= LZMA2_CHUNK_MAX - lz_options->dict_size;

  0010f	8b 45 14	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00112	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00117	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0011a	8b 55 14	 mov	 edx, DWORD PTR _lz_options$[ebp]
  0011d	89 0a		 mov	 DWORD PTR [edx], ecx
$LN1@lzma2_enco@3:

; 364  : 
; 365  : 	return LZMA_OK;

  0011f	33 c0		 xor	 eax, eax
$LN9@lzma2_enco@3:

; 366  : }

  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_lzma2_encoder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma2_encoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_lzma2_encoder_init PROC				; COMDAT

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 373  : 	return lzma_lz_encoder_init(
; 374  : 			next, allocator, filters, &lzma2_encoder_init);

  00003	68 00 00 00 00	 push	 OFFSET _lzma2_encoder_init
  00008	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _lzma_lz_encoder_init
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 375  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_lzma_lzma2_encoder_init ENDP
END
