; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\filter_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_encoders DQ	4000000000000001H
	DD	FLAT:_lzma_lzma_encoder_init
	DD	FLAT:_lzma_lzma_encoder_memusage
	DD	00H
	DD	00H
	DD	05H
	DD	FLAT:_lzma_lzma_props_encode
	DQ	0000000000000021H
	DD	FLAT:_lzma_lzma2_encoder_init
	DD	FLAT:_lzma_lzma2_encoder_memusage
	DD	FLAT:_lzma_lzma2_block_size
	DD	00H
	DD	01H
	DD	FLAT:_lzma_lzma2_props_encode
	DQ	0000000000000004H
	DD	FLAT:_lzma_simple_x86_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000005H
	DD	FLAT:_lzma_simple_powerpc_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000006H
	DD	FLAT:_lzma_simple_ia64_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000007H
	DD	FLAT:_lzma_simple_arm_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000008H
	DD	FLAT:_lzma_simple_armthumb_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000009H
	DD	FLAT:_lzma_simple_sparc_encoder_init
	DD	00H
	DD	00H
	DD	FLAT:_lzma_simple_props_size
	DD	00H
	DD	FLAT:_lzma_simple_props_encode
	DQ	0000000000000003H
	DD	FLAT:_lzma_delta_encoder_init
	DD	FLAT:_lzma_delta_coder_memusage
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_lzma_delta_props_encode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\filter_encoder.c
;	COMDAT _encoder_find
_TEXT	SEGMENT
tv73 = -8						; size = 4
_i$ = -4						; size = 4
_id$ = 8						; size = 8
_encoder_find PROC					; COMDAT

; 266  : {	size_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 267  : 
; 268  : 	for (i = 0; i < ARRAY_SIZE(encoders); ++i)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@encoder_fi
$LN3@encoder_fi:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@encoder_fi:
  00018	83 7d fc 09	 cmp	 DWORD PTR _i$[ebp], 9
  0001c	73 34		 jae	 SHORT $LN2@encoder_fi

; 269  : 		if (encoders[i].id == id)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	c1 e1 05	 shl	 ecx, 5
  00024	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00027	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  0002a	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _encoders[edx]
  00030	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00033	75 1b		 jne	 SHORT $LN1@encoder_fi
  00035	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  00038	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _encoders[ecx+4]
  0003e	3b 55 0c	 cmp	 edx, DWORD PTR _id$[ebp+4]
  00041	75 0d		 jne	 SHORT $LN1@encoder_fi

; 270  : 			return encoders + i;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	c1 e0 05	 shl	 eax, 5
  00049	05 00 00 00 00	 add	 eax, OFFSET _encoders
  0004e	eb 04		 jmp	 SHORT $LN5@encoder_fi
$LN1@encoder_fi:

; 271  : 
; 272  : 	return NULL;

  00050	eb bd		 jmp	 SHORT $LN3@encoder_fi
$LN2@encoder_fi:
  00052	33 c0		 xor	 eax, eax
$LN5@encoder_fi:

; 273  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_encoder_find ENDP
PUBLIC	_lzma_properties_encode
; Function compile flags: /Odtp
;	COMDAT _lzma_properties_encode
_TEXT	SEGMENT
_fe$ = -4						; size = 4
_filter$ = 8						; size = 4
_props$ = 12						; size = 4
_lzma_properties_encode PROC				; COMDAT

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 396  : 	const lzma_filter_encoder *const fe = encoder_find(filter->id);

  00004	8b 45 08	 mov	 eax, DWORD PTR _filter$[ebp]
  00007	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000a	51		 push	 ecx
  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _encoder_find
  00013	83 c4 08	 add	 esp, 8
  00016	89 45 fc	 mov	 DWORD PTR _fe$[ebp], eax

; 397  : 	if (fe == NULL)

  00019	83 7d fc 00	 cmp	 DWORD PTR _fe$[ebp], 0
  0001d	75 07		 jne	 SHORT $LN2@lzma_prope

; 398  : 		return LZMA_PROG_ERROR;

  0001f	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00024	eb 23		 jmp	 SHORT $LN3@lzma_prope
$LN2@lzma_prope:

; 399  : 
; 400  : 	if (fe->props_encode == NULL)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _fe$[ebp]
  00029	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0002d	75 04		 jne	 SHORT $LN1@lzma_prope

; 401  : 		return LZMA_OK;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 16		 jmp	 SHORT $LN3@lzma_prope
$LN1@lzma_prope:

; 402  : 
; 403  : 	return fe->props_encode(filter->options, props);

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _props$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR _filter$[ebp]
  0003a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003d	50		 push	 eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _fe$[ebp]
  00041	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00044	ff d2		 call	 edx
  00046	83 c4 08	 add	 esp, 8
$LN3@lzma_prope:

; 404  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_lzma_properties_encode ENDP
_TEXT	ENDS
PUBLIC	_lzma_properties_size
; Function compile flags: /Odtp
;	COMDAT _lzma_properties_size
_TEXT	SEGMENT
tv68 = -12						; size = 4
tv85 = -8						; size = 4
_fe$ = -4						; size = 4
_size$ = 8						; size = 4
_filter$ = 12						; size = 4
_lzma_properties_size PROC				; COMDAT

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 373  : 	const lzma_filter_encoder *const fe = encoder_find(filter->id);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	51		 push	 ecx
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _encoder_find
  00015	83 c4 08	 add	 esp, 8
  00018	89 45 fc	 mov	 DWORD PTR _fe$[ebp], eax

; 374  : 	if (fe == NULL) {

  0001b	83 7d fc 00	 cmp	 DWORD PTR _fe$[ebp], 0
  0001f	75 31		 jne	 SHORT $LN2@lzma_prope@2

; 375  : 		// Unknown filter - if the Filter ID is a proper VLI,
; 376  : 		// return LZMA_OPTIONS_ERROR instead of LZMA_PROG_ERROR,
; 377  : 		// because it's possible that we just don't have support
; 378  : 		// compiled in for the requested filter.
; 379  : 		return filter->id <= LZMA_VLI_MAX
; 380  : 				? LZMA_OPTIONS_ERROR : LZMA_PROG_ERROR;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  0002a	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  00031	77 13		 ja	 SHORT $LN5@lzma_prope@2
  00033	72 08		 jb	 SHORT $LN7@lzma_prope@2
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00038	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0003b	77 09		 ja	 SHORT $LN5@lzma_prope@2
$LN7@lzma_prope@2:
  0003d	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR tv68[ebp], 8
  00044	eb 07		 jmp	 SHORT $LN6@lzma_prope@2
$LN5@lzma_prope@2:
  00046	c7 45 f4 0b 00
	00 00		 mov	 DWORD PTR tv68[ebp], 11	; 0000000bH
$LN6@lzma_prope@2:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00050	eb 2e		 jmp	 SHORT $LN3@lzma_prope@2
$LN2@lzma_prope@2:

; 381  : 	}
; 382  : 
; 383  : 	if (fe->props_size_get == NULL) {

  00052	8b 45 fc	 mov	 eax, DWORD PTR _fe$[ebp]
  00055	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00059	75 0f		 jne	 SHORT $LN1@lzma_prope@2

; 384  : 		// No props_size_get() function, use props_size_fixed.
; 385  : 		*size = fe->props_size_fixed;

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _fe$[ebp]
  00061	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00064	89 01		 mov	 DWORD PTR [ecx], eax

; 386  : 		return LZMA_OK;

  00066	33 c0		 xor	 eax, eax
  00068	eb 16		 jmp	 SHORT $LN3@lzma_prope@2
$LN1@lzma_prope@2:

; 387  : 	}
; 388  : 
; 389  : 	return fe->props_size_get(size, filter->options);

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _filter$[ebp]
  0006d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00074	50		 push	 eax
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _fe$[ebp]
  00078	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0007b	ff d2		 call	 edx
  0007d	83 c4 08	 add	 esp, 8
$LN3@lzma_prope@2:

; 390  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_lzma_properties_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_mt_block_size
; Function compile flags: /Odtp
;	COMDAT _lzma_mt_block_size
_TEXT	SEGMENT
tv86 = -40						; size = 4
tv85 = -36						; size = 4
_size$32516 = -32					; size = 8
_fe$32513 = -20						; size = 4
_max$ = -16						; size = 8
_i$ = -4						; size = 4
_filters$ = 8						; size = 4
_lzma_mt_block_size PROC				; COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 349  : 	uint64_t max = 0;

  00007	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _max$[ebp], 0
  0000e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _max$[ebp+4], 0

; 350  : 	size_t i;
; 351  : 
; 352  : 	for (i = 0; filters[i].id != LZMA_VLI_UNKNOWN; ++i) {

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001c	eb 09		 jmp	 SHORT $LN6@lzma_mt_bl
$LN5@lzma_mt_bl:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@lzma_mt_bl:
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002a	c1 e1 04	 shl	 ecx, 4
  0002d	8b 55 08	 mov	 edx, DWORD PTR _filters$[ebp]
  00030	89 55 dc	 mov	 DWORD PTR tv85[ebp], edx
  00033	89 4d d8	 mov	 DWORD PTR tv86[ebp], ecx
  00036	8b 45 d8	 mov	 eax, DWORD PTR tv86[ebp]
  00039	8b 4d dc	 mov	 ecx, DWORD PTR tv85[ebp]
  0003c	8b 55 d8	 mov	 edx, DWORD PTR tv86[ebp]
  0003f	8b 75 dc	 mov	 esi, DWORD PTR tv85[ebp]
  00042	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00045	23 44 16 04	 and	 eax, DWORD PTR [esi+edx+4]
  00049	83 f8 ff	 cmp	 eax, -1
  0004c	74 76		 je	 SHORT $LN4@lzma_mt_bl

; 353  : 		const lzma_filter_encoder *const fe
; 354  : 				= encoder_find(filters[i].id);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00051	c1 e1 04	 shl	 ecx, 4
  00054	8b 55 08	 mov	 edx, DWORD PTR _filters$[ebp]
  00057	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0005b	50		 push	 eax
  0005c	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _encoder_find
  00065	83 c4 08	 add	 esp, 8
  00068	89 45 ec	 mov	 DWORD PTR _fe$32513[ebp], eax

; 355  : 		if (fe->block_size != NULL) {

  0006b	8b 55 ec	 mov	 edx, DWORD PTR _fe$32513[ebp]
  0006e	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00072	74 4b		 je	 SHORT $LN3@lzma_mt_bl

; 356  : 			const uint64_t size
; 357  : 					= fe->block_size(filters[i].options);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00077	c1 e0 04	 shl	 eax, 4
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _filters$[ebp]
  0007d	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00081	52		 push	 edx
  00082	8b 45 ec	 mov	 eax, DWORD PTR _fe$32513[ebp]
  00085	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00088	ff d1		 call	 ecx
  0008a	83 c4 04	 add	 esp, 4
  0008d	89 45 e0	 mov	 DWORD PTR _size$32516[ebp], eax
  00090	89 55 e4	 mov	 DWORD PTR _size$32516[ebp+4], edx

; 358  : 			if (size == 0)

  00093	8b 55 e0	 mov	 edx, DWORD PTR _size$32516[ebp]
  00096	0b 55 e4	 or	 edx, DWORD PTR _size$32516[ebp+4]
  00099	75 06		 jne	 SHORT $LN2@lzma_mt_bl

; 359  : 				return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	33 d2		 xor	 edx, edx
  0009f	eb 29		 jmp	 SHORT $LN7@lzma_mt_bl
$LN2@lzma_mt_bl:

; 360  : 
; 361  : 			if (size > max)

  000a1	8b 45 e4	 mov	 eax, DWORD PTR _size$32516[ebp+4]
  000a4	3b 45 f4	 cmp	 eax, DWORD PTR _max$[ebp+4]
  000a7	72 16		 jb	 SHORT $LN3@lzma_mt_bl
  000a9	77 08		 ja	 SHORT $LN9@lzma_mt_bl
  000ab	8b 4d e0	 mov	 ecx, DWORD PTR _size$32516[ebp]
  000ae	3b 4d f0	 cmp	 ecx, DWORD PTR _max$[ebp]
  000b1	76 0c		 jbe	 SHORT $LN3@lzma_mt_bl
$LN9@lzma_mt_bl:

; 362  : 				max = size;

  000b3	8b 55 e0	 mov	 edx, DWORD PTR _size$32516[ebp]
  000b6	89 55 f0	 mov	 DWORD PTR _max$[ebp], edx
  000b9	8b 45 e4	 mov	 eax, DWORD PTR _size$32516[ebp+4]
  000bc	89 45 f4	 mov	 DWORD PTR _max$[ebp+4], eax
$LN3@lzma_mt_bl:

; 363  : 		}
; 364  : 	}

  000bf	e9 5a ff ff ff	 jmp	 $LN5@lzma_mt_bl
$LN4@lzma_mt_bl:

; 365  : 
; 366  : 	return max;

  000c4	8b 45 f0	 mov	 eax, DWORD PTR _max$[ebp]
  000c7	8b 55 f4	 mov	 edx, DWORD PTR _max$[ebp+4]
$LN7@lzma_mt_bl:

; 367  : }

  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_lzma_mt_block_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_raw_encoder_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_raw_encoder_memusage
_TEXT	SEGMENT
_filters$ = 8						; size = 4
_lzma_raw_encoder_memusage PROC				; COMDAT

; 340  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 341  : 	return lzma_raw_coder_memusage(
; 342  : 			(lzma_filter_find)(&encoder_find), filters);

  00003	8b 45 08	 mov	 eax, DWORD PTR _filters$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET _encoder_find
  0000c	e8 00 00 00 00	 call	 _lzma_raw_coder_memusage
  00011	83 c4 08	 add	 esp, 8

; 343  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_lzma_raw_encoder_memusage ENDP
PUBLIC	_lzma_raw_encoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_raw_encoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_lzma_raw_encoder_init PROC				; COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 319  : 	return lzma_raw_coder_init(next, allocator,
; 320  : 			options, (lzma_filter_find)(&encoder_find), true);

  00003	6a 01		 push	 1
  00005	68 00 00 00 00	 push	 OFFSET _encoder_find
  0000a	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _lzma_raw_coder_init
  0001b	83 c4 14	 add	 esp, 20			; 00000014H

; 321  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_lzma_raw_encoder_init ENDP
PUBLIC	_lzma_raw_encoder
; Function compile flags: /Odtp
;	COMDAT _lzma_raw_encoder
_TEXT	SEGMENT
_ret_$32498 = -8					; size = 4
_ret_$32496 = -4					; size = 4
_strm$ = 8						; size = 4
_options$ = 12						; size = 4
_lzma_raw_encoder PROC					; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_raw_e:

; 327  : 	lzma_next_strm_init(lzma_raw_coder_init, strm, options,
; 328  : 			(lzma_filter_find)(&encoder_find), true);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32496[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32496[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_raw_e
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32496[ebp]
  0001e	eb 63		 jmp	 SHORT $LN9@lzma_raw_e
$LN4@lzma_raw_e:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_raw_e
  00024	6a 01		 push	 1
  00026	68 00 00 00 00	 push	 OFFSET _encoder_find
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00032	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00039	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _lzma_raw_coder_init
  00042	83 c4 14	 add	 esp, 20			; 00000014H
  00045	89 45 f8	 mov	 DWORD PTR _ret_$32498[ebp], eax
  00048	83 7d f8 00	 cmp	 DWORD PTR _ret_$32498[ebp], 0
  0004c	74 11		 je	 SHORT $LN7@lzma_raw_e
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _lzma_end
  00057	83 c4 04	 add	 esp, 4
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32498[ebp]
  0005d	eb 24		 jmp	 SHORT $LN9@lzma_raw_e
$LN7@lzma_raw_e:
  0005f	33 d2		 xor	 edx, edx
  00061	75 a3		 jne	 SHORT $LN5@lzma_raw_e

; 329  : 
; 330  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00063	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00066	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00069	c6 41 38 01	 mov	 BYTE PTR [ecx+56], 1

; 331  : 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;

  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00073	c6 40 39 01	 mov	 BYTE PTR [eax+57], 1

; 332  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0007a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007d	c6 42 3b 01	 mov	 BYTE PTR [edx+59], 1

; 333  : 
; 334  : 	return LZMA_OK;

  00081	33 c0		 xor	 eax, eax
$LN9@lzma_raw_e:

; 335  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_lzma_raw_encoder ENDP
END
