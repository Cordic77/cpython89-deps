; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lz\lz_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_LZMA_LZ_DECODER_INIT
_LZMA_LZ_DECODER_INIT DB 014H DUP (?)
PUBLIC	_lzma_lz_decoder_memusage
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.c
;	COMDAT _lzma_lz_decoder_memusage
_TEXT	SEGMENT
_dictionary_size$ = 8					; size = 4
_lzma_lz_decoder_memusage PROC				; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 	return sizeof(lzma_coder) + (uint64_t)(dictionary_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _dictionary_size$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	05 70 10 00 00	 add	 eax, 4208		; 00001070H
  0000d	83 d2 00	 adc	 edx, 0

; 318  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_lzma_lz_decoder_memusage ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lz_decoder_reset
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_lz_decoder_reset PROC					; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	coder->dict.pos = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 69   : 	coder->dict.full = 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00010	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 70   : 	coder->dict.buf[coder->dict.size - 1] = '\0';

  00017	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0001a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	c6 44 10 ff 00	 mov	 BYTE PTR [eax+edx-1], 0

; 71   : 	coder->dict.need_reset = false;

  00027	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002a	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 72   : 	return;
; 73   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_lz_decoder_reset ENDP
; Function compile flags: /Odtp
;	COMDAT _decode_buffer
_TEXT	SEGMENT
tv81 = -16						; size = 4
_copy_size$32394 = -12					; size = 4
_ret$32393 = -8						; size = 4
_dict_start$32392 = -4					; size = 4
_coder$ = 8						; size = 4
_in$ = 12						; size = 4
_in_pos$ = 16						; size = 4
_in_size$ = 20						; size = 4
_out$ = 24						; size = 4
_out_pos$ = 28						; size = 4
_out_size$ = 32						; size = 4
_decode_buffer PROC					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
$LN9@decode_buf@2:

; 82   : 	while (true) {

  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	85 c0		 test	 eax, eax
  0000d	0f 84 16 01 00
	00		 je	 $LN10@decode_buf@2

; 83   : 		// Wrap the dictionary if needed.
; 84   : 		if (coder->dict.pos == coder->dict.size)

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00019	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0001f	75 0a		 jne	 SHORT $LN7@decode_buf@2

; 85   : 			coder->dict.pos = 0;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN7@decode_buf@2:

; 86   : 
; 87   : 		// Store the current dictionary position. It is needed to know
; 88   : 		// where to start copying to the out[] buffer.
; 89   : 	  {
; 90   : 		const size_t dict_start = coder->dict.pos;

  0002b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	89 45 fc	 mov	 DWORD PTR _dict_start$32392[ebp], eax

; 91   : 
; 92   : 		// Calculate how much we allow coder->lz.code() to decode.
; 93   : 		// It must not decode past the end of the dictionary
; 94   : 		// buffer, and we don't want it to decode more than is
; 95   : 		// actually needed to fill the out[] buffer.
; 96   : 		coder->dict.limit = coder->dict.pos
; 97   : 				+ my_min(out_size - *out_pos,
; 98   : 					coder->dict.size - coder->dict.pos);

  00034	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00037	8b 55 20	 mov	 edx, DWORD PTR _out_size$[ebp]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00042	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00045	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00048	3b d0		 cmp	 edx, eax
  0004a	73 0d		 jae	 SHORT $LN12@decode_buf@2
  0004c	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0004f	8b 55 20	 mov	 edx, DWORD PTR _out_size$[ebp]
  00052	2b 11		 sub	 edx, DWORD PTR [ecx]
  00054	89 55 f0	 mov	 DWORD PTR tv81[ebp], edx
  00057	eb 0f		 jmp	 SHORT $LN13@decode_buf@2
$LN12@decode_buf@2:
  00059	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00062	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00065	89 55 f0	 mov	 DWORD PTR tv81[ebp], edx
$LN13@decode_buf@2:
  00068	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	03 4d f0	 add	 ecx, DWORD PTR tv81[ebp]
  00071	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00074	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 99   : 
; 100  : 		// Call the coder->lz.code() to do the actual decoding.
; 101  : 	  {
; 102  : 		const lzma_ret ret = coder->lz.code(
; 103  : 				coder->lz.coder, &coder->dict,
; 104  : 				in, in_pos, in_size);

  00077	8b 45 14	 mov	 eax, DWORD PTR _in_size$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00082	52		 push	 edx
  00083	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0008a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0008d	52		 push	 edx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00091	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00094	ff d1		 call	 ecx
  00096	83 c4 14	 add	 esp, 20			; 00000014H
  00099	89 45 f8	 mov	 DWORD PTR _ret$32393[ebp], eax

; 105  : 
; 106  : 		// Copy the decoded data from the dictionary to the out[]
; 107  : 		// buffer.
; 108  : 		const size_t copy_size = coder->dict.pos - dict_start;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0009f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a2	2b 45 fc	 sub	 eax, DWORD PTR _dict_start$32392[ebp]
  000a5	89 45 f4	 mov	 DWORD PTR _copy_size$32394[ebp], eax

; 109  : 		assert(copy_size <= out_size - *out_pos);
; 110  : 		memcpy(out + *out_pos, coder->dict.buf + dict_start,
; 111  : 				copy_size);

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _copy_size$32394[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	03 45 fc	 add	 eax, DWORD PTR _dict_start$32392[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  000b8	8b 55 18	 mov	 edx, DWORD PTR _out$[ebp]
  000bb	03 11		 add	 edx, DWORD PTR [ecx]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _memcpy
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 		*out_pos += copy_size;

  000c6	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cb	03 4d f4	 add	 ecx, DWORD PTR _copy_size$32394[ebp]
  000ce	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000d1	89 0a		 mov	 DWORD PTR [edx], ecx

; 113  : 
; 114  : 		// Reset the dictionary if so requested by coder->lz.code().
; 115  : 		if (coder->dict.need_reset) {

  000d3	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d6	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  000da	85 c9		 test	 ecx, ecx
  000dc	74 23		 je	 SHORT $LN6@decode_buf@2

; 116  : 			lz_decoder_reset(coder);

  000de	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 _lz_decoder_reset
  000e7	83 c4 04	 add	 esp, 4

; 117  : 
; 118  : 			// Since we reset dictionary, we don't check if
; 119  : 			// dictionary became full.
; 120  : 			if (ret != LZMA_OK || *out_pos == out_size)

  000ea	83 7d f8 00	 cmp	 DWORD PTR _ret$32393[ebp], 0
  000ee	75 0a		 jne	 SHORT $LN4@decode_buf@2
  000f0	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	3b 4d 20	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  000f8	75 05		 jne	 SHORT $LN5@decode_buf@2
$LN4@decode_buf@2:

; 121  : 				return ret;

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _ret$32393[ebp]
  000fd	eb 2a		 jmp	 SHORT $LN10@decode_buf@2
$LN5@decode_buf@2:

; 122  : 		} else {

  000ff	eb 23		 jmp	 SHORT $LN3@decode_buf@2
$LN6@decode_buf@2:

; 123  : 			// Return if everything got decoded or an error
; 124  : 			// occurred, or if there's no more data to decode.
; 125  : 			//
; 126  : 			// Note that detecting if there's something to decode
; 127  : 			// is done by looking if dictionary become full
; 128  : 			// instead of looking if *in_pos == in_size. This
; 129  : 			// is because it is possible that all the input was
; 130  : 			// consumed already but some data is pending to be
; 131  : 			// written to the dictionary.
; 132  : 			if (ret != LZMA_OK || *out_pos == out_size
; 133  : 					|| coder->dict.pos < coder->dict.size)

  00101	83 7d f8 00	 cmp	 DWORD PTR _ret$32393[ebp], 0
  00105	75 18		 jne	 SHORT $LN1@decode_buf@2
  00107	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	3b 45 20	 cmp	 eax, DWORD PTR _out_size$[ebp]
  0010f	74 0e		 je	 SHORT $LN1@decode_buf@2
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00114	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00117	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0011a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0011d	73 05		 jae	 SHORT $LN3@decode_buf@2
$LN1@decode_buf@2:

; 134  : 				return ret;

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _ret$32393[ebp]
  00122	eb 05		 jmp	 SHORT $LN10@decode_buf@2
$LN3@decode_buf@2:

; 135  : 		}
; 136  : 	  }}
; 137  : 	}

  00124	e9 dd fe ff ff	 jmp	 $LN9@decode_buf@2
$LN10@decode_buf@2:

; 138  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_decode_buffer ENDP
; Function compile flags: /Odtp
;	COMDAT _lz_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lz_decoder_end PROC					; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 209  : 	lzma_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 210  : 
; 211  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	83 c2 30	 add	 edx, 48			; 00000030H
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _lzma_next_end
  0001a	83 c4 08	 add	 esp, 8

; 212  : 	lzma_free(coder->dict.buf, allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _lzma_free
  0002c	83 c4 08	 add	 esp, 8

; 213  : 
; 214  : 	if (coder->lz.end != NULL)

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00032	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00036	74 18		 je	 SHORT $LN2@lz_decoder

; 215  : 		coder->lz.end(coder->lz.coder, allocator);

  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0003f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00046	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00049	ff d2		 call	 edx
  0004b	83 c4 08	 add	 esp, 8

; 216  : 	else

  0004e	eb 13		 jmp	 SHORT $LN1@lz_decoder
$LN2@lz_decoder:

; 217  : 		lzma_free(coder->lz.coder, allocator);

  00050	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00057	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _lzma_free
  00060	83 c4 08	 add	 esp, 8
$LN1@lz_decoder:

; 218  : 
; 219  : 	lzma_free(coder, allocator);

  00063	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _lzma_free
  00070	83 c4 08	 add	 esp, 8

; 220  : 	return;
; 221  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_lz_decoder_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lz_decode
_TEXT	SEGMENT
_ret$32437 = -12					; size = 4
_ret$32429 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_lz_decode PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 149  : 	lzma_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 150  : 
; 151  : 	if (coder->next.code == NULL)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  00013	75 29		 jne	 SHORT $LN15@lz_decode

; 152  : 		return decode_buffer(coder, in, in_pos, in_size,
; 153  : 				out, out_pos, out_size);

  00015	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00018	52		 push	 edx
  00019	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  00024	52		 push	 edx
  00025	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _decode_buffer
  00036	83 c4 1c	 add	 esp, 28			; 0000001cH
  00039	e9 44 01 00 00	 jmp	 $LN17@lz_decode
$LN15@lz_decode:

; 154  : 
; 155  : 	// We aren't the last coder in the chain, we need to decode
; 156  : 	// our input to a temporary buffer.
; 157  : 	while (*out_pos < out_size) {

  0003e	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	3b 4d 24	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  00046	0f 83 34 01 00
	00		 jae	 $LN14@lz_decode

; 158  : 		// Fill the temporary buffer if it is empty.
; 159  : 		if (!coder->next_finished
; 160  : 				&& coder->temp.pos == coder->temp.size) {

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0004f	0f b6 42 60	 movzx	 eax, BYTE PTR [edx+96]
  00053	85 c0		 test	 eax, eax
  00055	0f 85 84 00 00
	00		 jne	 $LN13@lz_decode
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00061	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00064	3b 42 68	 cmp	 eax, DWORD PTR [edx+104]
  00067	75 76		 jne	 SHORT $LN13@lz_decode

; 161  : 			coder->temp.pos = 0;

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006c	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 162  : 			coder->temp.size = 0;

  00073	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00076	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 163  : 
; 164  : 		  {
; 165  : 			const lzma_ret ret = coder->next.code(
; 166  : 					coder->next.coder,
; 167  : 					allocator, in, in_pos, in_size,
; 168  : 					coder->temp.buffer, &coder->temp.size,
; 169  : 					LZMA_BUFFER_SIZE, action);

  0007d	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  00080	50		 push	 eax
  00081	68 00 10 00 00	 push	 4096			; 00001000H
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00089	83 c1 68	 add	 ecx, 104		; 00000068H
  0008c	51		 push	 ecx
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00090	83 c2 6c	 add	 edx, 108		; 0000006cH
  00093	52		 push	 edx
  00094	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  0009f	52		 push	 edx
  000a0	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a7	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000aa	52		 push	 edx
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000ae	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000b1	ff d1		 call	 ecx
  000b3	83 c4 24	 add	 esp, 36			; 00000024H
  000b6	89 45 f8	 mov	 DWORD PTR _ret$32429[ebp], eax

; 170  : 
; 171  : 			if (ret == LZMA_STREAM_END)

  000b9	83 7d f8 01	 cmp	 DWORD PTR _ret$32429[ebp], 1
  000bd	75 09		 jne	 SHORT $LN12@lz_decode

; 172  : 				coder->next_finished = true;

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000c2	c6 42 60 01	 mov	 BYTE PTR [edx+96], 1
  000c6	eb 17		 jmp	 SHORT $LN13@lz_decode
$LN12@lz_decode:

; 173  : 			else if (ret != LZMA_OK || coder->temp.size == 0)

  000c8	83 7d f8 00	 cmp	 DWORD PTR _ret$32429[ebp], 0
  000cc	75 09		 jne	 SHORT $LN9@lz_decode
  000ce	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000d1	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  000d5	75 08		 jne	 SHORT $LN13@lz_decode
$LN9@lz_decode:

; 174  : 				return ret;

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _ret$32429[ebp]
  000da	e9 a3 00 00 00	 jmp	 $LN17@lz_decode
$LN13@lz_decode:

; 175  : 		  }
; 176  : 		}
; 177  : 
; 178  : 		if (coder->this_finished) {

  000df	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e2	0f b6 51 61	 movzx	 edx, BYTE PTR [ecx+97]
  000e6	85 d2		 test	 edx, edx
  000e8	74 29		 je	 SHORT $LN8@lz_decode

; 179  : 			if (coder->temp.size != 0)

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000ed	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  000f1	74 0a		 je	 SHORT $LN7@lz_decode

; 180  : 				return LZMA_DATA_ERROR;

  000f3	b8 09 00 00 00	 mov	 eax, 9
  000f8	e9 85 00 00 00	 jmp	 $LN17@lz_decode
$LN7@lz_decode:

; 181  : 
; 182  : 			if (coder->next_finished)

  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00100	0f b6 51 60	 movzx	 edx, BYTE PTR [ecx+96]
  00104	85 d2		 test	 edx, edx
  00106	74 07		 je	 SHORT $LN6@lz_decode

; 183  : 				return LZMA_STREAM_END;

  00108	b8 01 00 00 00	 mov	 eax, 1
  0010d	eb 73		 jmp	 SHORT $LN17@lz_decode
$LN6@lz_decode:

; 184  : 
; 185  : 			return LZMA_OK;

  0010f	33 c0		 xor	 eax, eax
  00111	eb 6f		 jmp	 SHORT $LN17@lz_decode
$LN8@lz_decode:

; 186  : 		}
; 187  : 
; 188  : 	  {
; 189  : 		const lzma_ret ret = decode_buffer(coder, coder->temp.buffer,
; 190  : 				&coder->temp.pos, coder->temp.size,
; 191  : 				out, out_pos, out_size);

  00113	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  00116	50		 push	 eax
  00117	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0011a	51		 push	 ecx
  0011b	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  0011e	52		 push	 edx
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00122	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00125	51		 push	 ecx
  00126	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00129	83 c2 64	 add	 edx, 100		; 00000064H
  0012c	52		 push	 edx
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00130	83 c0 6c	 add	 eax, 108		; 0000006cH
  00133	50		 push	 eax
  00134	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _decode_buffer
  0013d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00140	89 45 f4	 mov	 DWORD PTR _ret$32437[ebp], eax

; 192  : 
; 193  : 		if (ret == LZMA_STREAM_END)

  00143	83 7d f4 01	 cmp	 DWORD PTR _ret$32437[ebp], 1
  00147	75 09		 jne	 SHORT $LN5@lz_decode

; 194  : 			coder->this_finished = true;

  00149	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0014c	c6 42 61 01	 mov	 BYTE PTR [edx+97], 1
  00150	eb 29		 jmp	 SHORT $LN4@lz_decode
$LN5@lz_decode:

; 195  : 		else if (ret != LZMA_OK)

  00152	83 7d f4 00	 cmp	 DWORD PTR _ret$32437[ebp], 0
  00156	74 07		 je	 SHORT $LN3@lz_decode

; 196  : 			return ret;

  00158	8b 45 f4	 mov	 eax, DWORD PTR _ret$32437[ebp]
  0015b	eb 25		 jmp	 SHORT $LN17@lz_decode
  0015d	eb 1c		 jmp	 SHORT $LN4@lz_decode
$LN3@lz_decode:

; 197  : 		else if (coder->next_finished && *out_pos < out_size)

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00162	0f b6 48 60	 movzx	 ecx, BYTE PTR [eax+96]
  00166	85 c9		 test	 ecx, ecx
  00168	74 11		 je	 SHORT $LN4@lz_decode
  0016a	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	3b 45 24	 cmp	 eax, DWORD PTR _out_size$[ebp]
  00172	73 07		 jae	 SHORT $LN4@lz_decode

; 198  : 			return LZMA_DATA_ERROR;

  00174	b8 09 00 00 00	 mov	 eax, 9
  00179	eb 07		 jmp	 SHORT $LN17@lz_decode
$LN4@lz_decode:

; 199  : 	  }
; 200  : 	}

  0017b	e9 be fe ff ff	 jmp	 $LN15@lz_decode
$LN14@lz_decode:

; 201  : 
; 202  : 	return LZMA_OK;

  00180	33 c0		 xor	 eax, eax
$LN17@lz_decode:

; 203  : }

  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_lz_decode ENDP
PUBLIC	_lzma_lz_decoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_lz_decoder_init
_TEXT	SEGMENT
tv132 = -32						; size = 4
_copy_size$32491 = -28					; size = 4
_offset$32492 = -24					; size = 4
_ret_$32481 = -20					; size = 4
_lz_options$32477 = -16					; size = 12
_coder$ = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lz_init$ = 20						; size = 4
_lzma_lz_decoder_init PROC				; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 231  : 	// Allocate the base structure if it isn't already allocated.
; 232  : 	lzma_coder *coder = next->coder;

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _coder$[ebp], ecx

; 233  : 	if (coder == NULL) {

  00010	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00014	0f 85 97 00 00
	00		 jne	 $LN9@lzma_lz_de

; 234  : 		coder = lzma_alloc(sizeof(lzma_coder), allocator);

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001d	52		 push	 edx
  0001e	68 70 10 00 00	 push	 4208			; 00001070H
  00023	e8 00 00 00 00	 call	 _lzma_alloc
  00028	83 c4 08	 add	 esp, 8
  0002b	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 235  : 		if (coder == NULL)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00032	75 0a		 jne	 SHORT $LN10@lzma_lz_de

; 236  : 			return LZMA_MEM_ERROR;

  00034	b8 05 00 00 00	 mov	 eax, 5
  00039	e9 c3 01 00 00	 jmp	 $LN12@lzma_lz_de
$LN10@lzma_lz_de:

; 237  : 
; 238  : 		next->coder = coder;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00044	89 08		 mov	 DWORD PTR [eax], ecx

; 239  : 		next->code = &lz_decode;

  00046	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00049	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _lz_decode

; 240  : 		next->end = &lz_decoder_end;

  00050	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00053	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _lz_decoder_end

; 241  : 
; 242  : 		coder->dict.buf = NULL;

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 243  : 		coder->dict.size = 0;

  00063	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00066	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 244  : 		coder->lz = LZMA_LZ_DECODER_INIT;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00070	83 c0 18	 add	 eax, 24			; 00000018H
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _LZMA_LZ_DECODER_INIT
  00079	89 08		 mov	 DWORD PTR [eax], ecx
  0007b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _LZMA_LZ_DECODER_INIT+4
  00081	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00084	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _LZMA_LZ_DECODER_INIT+8
  0008a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008d	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _LZMA_LZ_DECODER_INIT+12
  00093	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00096	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _LZMA_LZ_DECODER_INIT+16
  0009c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 245  : 		coder->next = LZMA_NEXT_CODER_INIT;

  0009f	8b 7d fc	 mov	 edi, DWORD PTR _coder$[ebp]
  000a2	83 c7 30	 add	 edi, 48			; 00000030H
  000a5	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000aa	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000af	f3 a5		 rep movsd
$LN9@lzma_lz_de:

; 246  : 	}
; 247  : 
; 248  : 	// Allocate and initialize the LZ-based decoder. It will also give
; 249  : 	// us the dictionary size.
; 250  :   {
; 251  : 	lzma_lz_options lz_options;
; 252  : 	return_if_error(lz_init(&coder->lz, allocator,
; 253  : 			filters[0].options, &lz_options));

  000b1	8d 55 f0	 lea	 edx, DWORD PTR _lz_options$32477[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  000b8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bb	51		 push	 ecx
  000bc	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000c3	83 c0 18	 add	 eax, 24			; 00000018H
  000c6	50		 push	 eax
  000c7	ff 55 14	 call	 DWORD PTR _lz_init$[ebp]
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
  000cd	89 45 ec	 mov	 DWORD PTR _ret_$32481[ebp], eax
  000d0	83 7d ec 00	 cmp	 DWORD PTR _ret_$32481[ebp], 0
  000d4	74 08		 je	 SHORT $LN8@lzma_lz_de
  000d6	8b 45 ec	 mov	 eax, DWORD PTR _ret_$32481[ebp]
  000d9	e9 23 01 00 00	 jmp	 $LN12@lzma_lz_de
$LN8@lzma_lz_de:
  000de	33 c9		 xor	 ecx, ecx
  000e0	75 cf		 jne	 SHORT $LN9@lzma_lz_de

; 254  : 
; 255  : 	// If the dictionary size is very small, increase it to 4096 bytes.
; 256  : 	// This is to prevent constant wrapping of the dictionary, which
; 257  : 	// would slow things down. The downside is that since we don't check
; 258  : 	// separately for the real dictionary size, we may happily accept
; 259  : 	// corrupt files.
; 260  : 	if (lz_options.dict_size < 4096)

  000e2	81 7d f0 00 10
	00 00		 cmp	 DWORD PTR _lz_options$32477[ebp], 4096 ; 00001000H
  000e9	73 07		 jae	 SHORT $LN5@lzma_lz_de

; 261  : 		lz_options.dict_size = 4096;

  000eb	c7 45 f0 00 10
	00 00		 mov	 DWORD PTR _lz_options$32477[ebp], 4096 ; 00001000H
$LN5@lzma_lz_de:

; 262  : 
; 263  : 	// Make dictionary size a multipe of 16. Some LZ-based decoders like
; 264  : 	// LZMA use the lowest bits lzma_dict.pos to know the alignment of the
; 265  : 	// data. Aligned buffer is also good when memcpying from the
; 266  : 	// dictionary to the output buffer, since applications are
; 267  : 	// recommended to give aligned buffers to liblzma.
; 268  : 	//
; 269  : 	// Avoid integer overflow.
; 270  : 	if (lz_options.dict_size > SIZE_MAX - 15)

  000f2	83 7d f0 f0	 cmp	 DWORD PTR _lz_options$32477[ebp], -16 ; fffffff0H
  000f6	76 0a		 jbe	 SHORT $LN4@lzma_lz_de

; 271  : 		return LZMA_MEM_ERROR;

  000f8	b8 05 00 00 00	 mov	 eax, 5
  000fd	e9 ff 00 00 00	 jmp	 $LN12@lzma_lz_de
$LN4@lzma_lz_de:

; 272  : 
; 273  : 	lz_options.dict_size = (lz_options.dict_size + 15) & ~((size_t)(15));

  00102	8b 55 f0	 mov	 edx, DWORD PTR _lz_options$32477[ebp]
  00105	83 c2 0f	 add	 edx, 15			; 0000000fH
  00108	83 e2 f0	 and	 edx, -16		; fffffff0H
  0010b	89 55 f0	 mov	 DWORD PTR _lz_options$32477[ebp], edx

; 274  : 
; 275  : 	// Allocate and initialize the dictionary.
; 276  : 	if (coder->dict.size != lz_options.dict_size) {

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00111	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00114	3b 4d f0	 cmp	 ecx, DWORD PTR _lz_options$32477[ebp]
  00117	74 42		 je	 SHORT $LN3@lzma_lz_de

; 277  : 		lzma_free(coder->dict.buf, allocator);

  00119	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0011c	52		 push	 edx
  0011d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00120	8b 08		 mov	 ecx, DWORD PTR [eax]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 _lzma_free
  00128	83 c4 08	 add	 esp, 8

; 278  : 		coder->dict.buf
; 279  : 				= lzma_alloc(lz_options.dict_size, allocator);

  0012b	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0012e	52		 push	 edx
  0012f	8b 45 f0	 mov	 eax, DWORD PTR _lz_options$32477[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _lzma_alloc
  00138	83 c4 08	 add	 esp, 8
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013e	89 01		 mov	 DWORD PTR [ecx], eax

; 280  : 		if (coder->dict.buf == NULL)

  00140	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00143	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00146	75 0a		 jne	 SHORT $LN2@lzma_lz_de

; 281  : 			return LZMA_MEM_ERROR;

  00148	b8 05 00 00 00	 mov	 eax, 5
  0014d	e9 af 00 00 00	 jmp	 $LN12@lzma_lz_de
$LN2@lzma_lz_de:

; 282  : 
; 283  : 		coder->dict.size = lz_options.dict_size;

  00152	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00155	8b 4d f0	 mov	 ecx, DWORD PTR _lz_options$32477[ebp]
  00158	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN3@lzma_lz_de:

; 284  : 	}
; 285  : 
; 286  : 	lz_decoder_reset(next->coder);

  0015b	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _lz_decoder_reset
  00166	83 c4 04	 add	 esp, 4

; 287  : 
; 288  : 	// Use the preset dictionary if it was given to us.
; 289  : 	if (lz_options.preset_dict != NULL
; 290  : 			&& lz_options.preset_dict_size > 0) {

  00169	83 7d f4 00	 cmp	 DWORD PTR _lz_options$32477[ebp+4], 0
  0016d	74 56		 je	 SHORT $LN1@lzma_lz_de
  0016f	83 7d f8 00	 cmp	 DWORD PTR _lz_options$32477[ebp+8], 0
  00173	76 50		 jbe	 SHORT $LN1@lzma_lz_de

; 291  : 		// If the preset dictionary is bigger than the actual
; 292  : 		// dictionary, copy only the tail.
; 293  : 		const size_t copy_size = my_min(lz_options.preset_dict_size,
; 294  : 				lz_options.dict_size);

  00175	8b 4d f8	 mov	 ecx, DWORD PTR _lz_options$32477[ebp+8]
  00178	3b 4d f0	 cmp	 ecx, DWORD PTR _lz_options$32477[ebp]
  0017b	73 08		 jae	 SHORT $LN14@lzma_lz_de
  0017d	8b 55 f8	 mov	 edx, DWORD PTR _lz_options$32477[ebp+8]
  00180	89 55 e0	 mov	 DWORD PTR tv132[ebp], edx
  00183	eb 06		 jmp	 SHORT $LN15@lzma_lz_de
$LN14@lzma_lz_de:
  00185	8b 45 f0	 mov	 eax, DWORD PTR _lz_options$32477[ebp]
  00188	89 45 e0	 mov	 DWORD PTR tv132[ebp], eax
$LN15@lzma_lz_de:
  0018b	8b 4d e0	 mov	 ecx, DWORD PTR tv132[ebp]
  0018e	89 4d e4	 mov	 DWORD PTR _copy_size$32491[ebp], ecx

; 295  : 		const size_t offset = lz_options.preset_dict_size - copy_size;

  00191	8b 55 f8	 mov	 edx, DWORD PTR _lz_options$32477[ebp+8]
  00194	2b 55 e4	 sub	 edx, DWORD PTR _copy_size$32491[ebp]
  00197	89 55 e8	 mov	 DWORD PTR _offset$32492[ebp], edx

; 296  : 		memcpy(coder->dict.buf, lz_options.preset_dict + offset,
; 297  : 				copy_size);

  0019a	8b 45 e4	 mov	 eax, DWORD PTR _copy_size$32491[ebp]
  0019d	50		 push	 eax
  0019e	8b 4d f4	 mov	 ecx, DWORD PTR _lz_options$32477[ebp+4]
  001a1	03 4d e8	 add	 ecx, DWORD PTR _offset$32492[ebp]
  001a4	51		 push	 ecx
  001a5	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001a8	8b 02		 mov	 eax, DWORD PTR [edx]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _memcpy
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 298  : 		coder->dict.pos = copy_size;

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001b6	8b 55 e4	 mov	 edx, DWORD PTR _copy_size$32491[ebp]
  001b9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 299  : 		coder->dict.full = copy_size;

  001bc	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001bf	8b 4d e4	 mov	 ecx, DWORD PTR _copy_size$32491[ebp]
  001c2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN1@lzma_lz_de:

; 300  : 	}
; 301  : 
; 302  : 	// Miscellaneous initializations
; 303  : 	coder->next_finished = false;

  001c5	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001c8	c6 42 60 00	 mov	 BYTE PTR [edx+96], 0

; 304  : 	coder->this_finished = false;

  001cc	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001cf	c6 40 61 00	 mov	 BYTE PTR [eax+97], 0

; 305  : 	coder->temp.pos = 0;

  001d3	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001d6	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 306  : 	coder->temp.size = 0;

  001dd	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001e0	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 307  :   }
; 308  : 
; 309  : 	// Initialize the next filter in the chain, if any.
; 310  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  001e7	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  001ea	83 c0 10	 add	 eax, 16			; 00000010H
  001ed	50		 push	 eax
  001ee	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  001f1	51		 push	 ecx
  001f2	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001f5	83 c2 30	 add	 edx, 48			; 00000030H
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 _lzma_next_filter_init
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@lzma_lz_de:

; 311  : }

  00201	5f		 pop	 edi
  00202	5e		 pop	 esi
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
_lzma_lz_decoder_init ENDP
END
