; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\vli_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_vli_decode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\vli_decoder.c
;	COMDAT _lzma_vli_decode
_TEXT	SEGMENT
tv151 = -16						; size = 8
_byte$32237 = -5					; size = 1
_vli_pos_internal$ = -4					; size = 4
_vli$ = 8						; size = 4
_vli_pos$ = 12						; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_lzma_vli_decode PROC					; COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 21   : 	// If we haven't been given vli_pos, work in single-call mode.
; 22   : 	size_t vli_pos_internal = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _vli_pos_internal$[ebp], 0

; 23   : 	if (vli_pos == NULL) {

  0000d	83 7d 0c 00	 cmp	 DWORD PTR _vli_pos$[ebp], 0
  00011	75 2c		 jne	 SHORT $LN13@lzma_vli_d

; 24   : 		vli_pos = &vli_pos_internal;

  00013	8d 45 fc	 lea	 eax, DWORD PTR _vli_pos_internal$[ebp]
  00016	89 45 0c	 mov	 DWORD PTR _vli_pos$[ebp], eax

; 25   : 		*vli = 0;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _vli$[ebp]
  0001c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00022	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 26   : 
; 27   : 		// If there's no input, use LZMA_DATA_ERROR. This way it is
; 28   : 		// easy to decode VLIs from buffers that have known size,
; 29   : 		// and get the correct error code in case the buffer is
; 30   : 		// too short.
; 31   : 		if (*in_pos >= in_size)

  00029	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	3b 45 18	 cmp	 eax, DWORD PTR _in_size$[ebp]
  00031	72 0a		 jb	 SHORT $LN12@lzma_vli_d

; 32   : 			return LZMA_DATA_ERROR;

  00033	b8 09 00 00 00	 mov	 eax, 9
  00038	e9 14 01 00 00	 jmp	 $LN14@lzma_vli_d
$LN12@lzma_vli_d:

; 33   : 
; 34   : 	} else {

  0003d	eb 61		 jmp	 SHORT $LN6@lzma_vli_d
$LN13@lzma_vli_d:

; 35   : 		// Initialize *vli when starting to decode a new integer.
; 36   : 		if (*vli_pos == 0)

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _vli_pos$[ebp]
  00042	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00045	75 10		 jne	 SHORT $LN10@lzma_vli_d

; 37   : 			*vli = 0;

  00047	8b 55 08	 mov	 edx, DWORD PTR _vli$[ebp]
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00050	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN10@lzma_vli_d:

; 38   : 
; 39   : 		// Validate the arguments.
; 40   : 		if (*vli_pos >= LZMA_VLI_BYTES_MAX
; 41   : 				|| (*vli >> (*vli_pos * 7)) != 0)

  00057	8b 45 0c	 mov	 eax, DWORD PTR _vli_pos$[ebp]
  0005a	83 38 09	 cmp	 DWORD PTR [eax], 9
  0005d	73 23		 jae	 SHORT $LN8@lzma_vli_d
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _vli_pos$[ebp]
  00062	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00064	6b c9 07	 imul	 ecx, 7
  00067	8b 55 08	 mov	 edx, DWORD PTR _vli$[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0006f	e8 00 00 00 00	 call	 __aullshr
  00074	89 45 f0	 mov	 DWORD PTR tv151[ebp], eax
  00077	89 55 f4	 mov	 DWORD PTR tv151[ebp+4], edx
  0007a	8b 45 f0	 mov	 eax, DWORD PTR tv151[ebp]
  0007d	0b 45 f4	 or	 eax, DWORD PTR tv151[ebp+4]
  00080	74 0a		 je	 SHORT $LN9@lzma_vli_d
$LN8@lzma_vli_d:

; 42   : 			return LZMA_PROG_ERROR;;

  00082	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00087	e9 c5 00 00 00	 jmp	 $LN14@lzma_vli_d
$LN9@lzma_vli_d:

; 43   : 
; 44   : 		if (*in_pos >= in_size)

  0008c	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00094	72 0a		 jb	 SHORT $LN6@lzma_vli_d

; 45   : 			return LZMA_BUF_ERROR;

  00096	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0009b	e9 b1 00 00 00	 jmp	 $LN14@lzma_vli_d
$LN6@lzma_vli_d:

; 46   : 	}
; 47   : 
; 48   : 	do {
; 49   : 		// Read the next byte. Use a temporary variable so that we
; 50   : 		// can update *in_pos immediately.
; 51   : 		const uint8_t byte = in[*in_pos];

  000a0	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  000a8	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  000ab	88 45 fb	 mov	 BYTE PTR _byte$32237[ebp], al

; 52   : 		++*in_pos;

  000ae	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  000b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b3	83 c2 01	 add	 edx, 1
  000b6	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  000b9	89 10		 mov	 DWORD PTR [eax], edx

; 53   : 
; 54   : 		// Add the newly read byte to *vli.
; 55   : 		*vli += (lzma_vli)(byte & 0x7F) << (*vli_pos * 7);

  000bb	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte$32237[ebp]
  000bf	83 e0 7f	 and	 eax, 127		; 0000007fH
  000c2	99		 cdq
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _vli_pos$[ebp]
  000c6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c8	6b c9 07	 imul	 ecx, 7
  000cb	e8 00 00 00 00	 call	 __allshl
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _vli$[ebp]
  000d3	03 01		 add	 eax, DWORD PTR [ecx]
  000d5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d8	13 ca		 adc	 ecx, edx
  000da	8b 55 08	 mov	 edx, DWORD PTR _vli$[ebp]
  000dd	89 02		 mov	 DWORD PTR [edx], eax
  000df	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 56   : 		++*vli_pos;

  000e2	8b 45 0c	 mov	 eax, DWORD PTR _vli_pos$[ebp]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	83 c1 01	 add	 ecx, 1
  000ea	8b 55 0c	 mov	 edx, DWORD PTR _vli_pos$[ebp]
  000ed	89 0a		 mov	 DWORD PTR [edx], ecx

; 57   : 
; 58   : 		// Check if this is the last byte of a multibyte integer.
; 59   : 		if ((byte & 0x80) == 0) {

  000ef	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte$32237[ebp]
  000f3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000f8	75 28		 jne	 SHORT $LN3@lzma_vli_d

; 60   : 			// We don't allow using variable-length integers as
; 61   : 			// padding i.e. the encoding must use the most the
; 62   : 			// compact form.
; 63   : 			if (byte == 0x00 && *vli_pos > 1)

  000fa	0f b6 4d fb	 movzx	 ecx, BYTE PTR _byte$32237[ebp]
  000fe	85 c9		 test	 ecx, ecx
  00100	75 0f		 jne	 SHORT $LN2@lzma_vli_d
  00102	8b 55 0c	 mov	 edx, DWORD PTR _vli_pos$[ebp]
  00105	83 3a 01	 cmp	 DWORD PTR [edx], 1
  00108	76 07		 jbe	 SHORT $LN2@lzma_vli_d

; 64   : 				return LZMA_DATA_ERROR;

  0010a	b8 09 00 00 00	 mov	 eax, 9
  0010f	eb 40		 jmp	 SHORT $LN14@lzma_vli_d
$LN2@lzma_vli_d:

; 65   : 
; 66   : 			return vli_pos == &vli_pos_internal
; 67   : 					? LZMA_OK : LZMA_STREAM_END;

  00111	8b 45 0c	 mov	 eax, DWORD PTR _vli_pos$[ebp]
  00114	8d 4d fc	 lea	 ecx, DWORD PTR _vli_pos_internal$[ebp]
  00117	33 d2		 xor	 edx, edx
  00119	3b c1		 cmp	 eax, ecx
  0011b	0f 95 c2	 setne	 dl
  0011e	8b c2		 mov	 eax, edx
  00120	eb 2f		 jmp	 SHORT $LN14@lzma_vli_d
$LN3@lzma_vli_d:

; 68   : 		}
; 69   : 
; 70   : 		// There is at least one more byte coming. If we have already
; 71   : 		// read maximum number of bytes, the integer is considered
; 72   : 		// corrupt.
; 73   : 		//
; 74   : 		// If we need bigger integers in future, old versions liblzma
; 75   : 		// will confusingly indicate the file being corrupt istead of
; 76   : 		// unsupported. I suppose it's still better this way, because
; 77   : 		// in the foreseeable future (writing this in 2008) the only
; 78   : 		// reason why files would appear having over 63-bit integers
; 79   : 		// is that the files are simply corrupt.
; 80   : 		if (*vli_pos == LZMA_VLI_BYTES_MAX)

  00122	8b 45 0c	 mov	 eax, DWORD PTR _vli_pos$[ebp]
  00125	83 38 09	 cmp	 DWORD PTR [eax], 9
  00128	75 07		 jne	 SHORT $LN5@lzma_vli_d

; 81   : 			return LZMA_DATA_ERROR;

  0012a	b8 09 00 00 00	 mov	 eax, 9
  0012f	eb 20		 jmp	 SHORT $LN14@lzma_vli_d
$LN5@lzma_vli_d:

; 82   : 
; 83   : 	} while (*in_pos < in_size);

  00131	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00134	8b 11		 mov	 edx, DWORD PTR [ecx]
  00136	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00139	0f 82 61 ff ff
	ff		 jb	 $LN6@lzma_vli_d

; 84   : 
; 85   : 	return vli_pos == &vli_pos_internal ? LZMA_DATA_ERROR : LZMA_OK;

  0013f	8b 45 0c	 mov	 eax, DWORD PTR _vli_pos$[ebp]
  00142	8d 4d fc	 lea	 ecx, DWORD PTR _vli_pos_internal$[ebp]
  00145	2b c1		 sub	 eax, ecx
  00147	f7 d8		 neg	 eax
  00149	1b c0		 sbb	 eax, eax
  0014b	83 e0 f7	 and	 eax, -9			; fffffff7H
  0014e	83 c0 09	 add	 eax, 9
$LN14@lzma_vli_d:

; 86   : }

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
_lzma_vli_decode ENDP
END
