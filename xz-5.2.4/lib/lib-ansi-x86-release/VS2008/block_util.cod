; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_util.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_block_unpadded_size
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_util.c
;	COMDAT _lzma_block_unpadded_size
_TEXT	SEGMENT
tv154 = -24						; size = 4
tv144 = -20						; size = 4
tv137 = -16						; size = 4
tv131 = -12						; size = 4
_unpadded_size$32267 = -8				; size = 8
_block$ = 8						; size = 4
_lzma_block_unpadded_size PROC				; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 51   : 	// Validate the values that we are interested in i.e. all but
; 52   : 	// Uncompressed Size and the filters.
; 53   : 	//
; 54   : 	// NOTE: This function is used for validation too, so it is
; 55   : 	// essential that these checks are always done even if
; 56   : 	// Compressed Size is unknown.
; 57   : 	if (block == NULL || block->version > 1
; 58   : 			|| block->header_size < LZMA_BLOCK_HEADER_SIZE_MIN
; 59   : 			|| block->header_size > LZMA_BLOCK_HEADER_SIZE_MAX
; 60   : 			|| (block->header_size & 3)
; 61   : 			|| !lzma_vli_is_valid(block->compressed_size)
; 62   : 			|| block->compressed_size == 0
; 63   : 			|| (unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  00008	83 7d 08 00	 cmp	 DWORD PTR _block$[ebp], 0
  0000c	74 79		 je	 SHORT $LN4@lzma_block
  0000e	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00011	83 38 01	 cmp	 DWORD PTR [eax], 1
  00014	77 71		 ja	 SHORT $LN4@lzma_block
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00019	83 79 04 08	 cmp	 DWORD PTR [ecx+4], 8
  0001d	72 68		 jb	 SHORT $LN4@lzma_block
  0001f	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00022	81 7a 04 00 04
	00 00		 cmp	 DWORD PTR [edx+4], 1024	; 00000400H
  00029	77 5c		 ja	 SHORT $LN4@lzma_block
  0002b	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	83 e1 03	 and	 ecx, 3
  00034	75 51		 jne	 SHORT $LN4@lzma_block
  00036	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00039	89 55 f4	 mov	 DWORD PTR tv131[ebp], edx
  0003c	8b 45 f4	 mov	 eax, DWORD PTR tv131[ebp]
  0003f	81 78 14 ff ff
	ff 7f		 cmp	 DWORD PTR [eax+20], 2147483647 ; 7fffffffH
  00046	72 22		 jb	 SHORT $LN3@lzma_block
  00048	77 09		 ja	 SHORT $LN8@lzma_block
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR tv131[ebp]
  0004d	83 79 10 ff	 cmp	 DWORD PTR [ecx+16], -1
  00051	76 17		 jbe	 SHORT $LN3@lzma_block
$LN8@lzma_block:
  00053	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00056	89 55 f0	 mov	 DWORD PTR tv137[ebp], edx
  00059	8b 45 f0	 mov	 eax, DWORD PTR tv137[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR tv137[ebp]
  0005f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00062	23 51 14	 and	 edx, DWORD PTR [ecx+20]
  00065	83 fa ff	 cmp	 edx, -1
  00068	75 1d		 jne	 SHORT $LN4@lzma_block
$LN3@lzma_block:
  0006a	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0006d	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  00070	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00073	8b 55 ec	 mov	 edx, DWORD PTR tv144[ebp]
  00076	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00079	0b 42 14	 or	 eax, DWORD PTR [edx+20]
  0007c	74 09		 je	 SHORT $LN4@lzma_block
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00081	83 79 08 0f	 cmp	 DWORD PTR [ecx+8], 15	; 0000000fH
  00085	76 06		 jbe	 SHORT $LN5@lzma_block
$LN4@lzma_block:

; 64   : 		return 0;

  00087	33 c0		 xor	 eax, eax
  00089	33 d2		 xor	 edx, edx
  0008b	eb 6a		 jmp	 SHORT $LN6@lzma_block
$LN5@lzma_block:

; 65   : 
; 66   : 	// If Compressed Size is unknown, return that we cannot know
; 67   : 	// size of the Block either.
; 68   : 	if (block->compressed_size == LZMA_VLI_UNKNOWN)

  0008d	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00090	89 55 e8	 mov	 DWORD PTR tv154[ebp], edx
  00093	8b 45 e8	 mov	 eax, DWORD PTR tv154[ebp]
  00096	8b 4d e8	 mov	 ecx, DWORD PTR tv154[ebp]
  00099	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0009c	23 51 14	 and	 edx, DWORD PTR [ecx+20]
  0009f	83 fa ff	 cmp	 edx, -1
  000a2	75 08		 jne	 SHORT $LN2@lzma_block

; 69   : 		return LZMA_VLI_UNKNOWN;

  000a4	83 c8 ff	 or	 eax, -1
  000a7	83 ca ff	 or	 edx, -1
  000aa	eb 4b		 jmp	 SHORT $LN6@lzma_block
$LN2@lzma_block:

; 70   : 
; 71   : 	// Calculate Unpadded Size and validate it.
; 72   :   {
; 73   : 	const lzma_vli unpadded_size = block->compressed_size
; 74   : 				+ block->header_size
; 75   : 				+ lzma_check_size(block->check);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000af	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000b2	33 c9		 xor	 ecx, ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  000b7	03 72 10	 add	 esi, DWORD PTR [edx+16]
  000ba	8b 7a 14	 mov	 edi, DWORD PTR [edx+20]
  000bd	13 f9		 adc	 edi, ecx
  000bf	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000c2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _lzma_check_size
  000cb	83 c4 04	 add	 esp, 4
  000ce	33 d2		 xor	 edx, edx
  000d0	03 f0		 add	 esi, eax
  000d2	13 fa		 adc	 edi, edx
  000d4	89 75 f8	 mov	 DWORD PTR _unpadded_size$32267[ebp], esi
  000d7	89 7d fc	 mov	 DWORD PTR _unpadded_size$32267[ebp+4], edi

; 76   : 
; 77   : 	assert(unpadded_size >= UNPADDED_SIZE_MIN);
; 78   : 	if (unpadded_size > UNPADDED_SIZE_MAX)

  000da	81 7d fc ff ff
	ff 7f		 cmp	 DWORD PTR _unpadded_size$32267[ebp+4], 2147483647 ; 7fffffffH
  000e1	72 0e		 jb	 SHORT $LN1@lzma_block
  000e3	77 06		 ja	 SHORT $LN9@lzma_block
  000e5	83 7d f8 fc	 cmp	 DWORD PTR _unpadded_size$32267[ebp], -4 ; fffffffcH
  000e9	76 06		 jbe	 SHORT $LN1@lzma_block
$LN9@lzma_block:

; 79   : 		return 0;

  000eb	33 c0		 xor	 eax, eax
  000ed	33 d2		 xor	 edx, edx
  000ef	eb 06		 jmp	 SHORT $LN6@lzma_block
$LN1@lzma_block:

; 80   : 
; 81   : 	return unpadded_size;

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _unpadded_size$32267[ebp]
  000f4	8b 55 fc	 mov	 edx, DWORD PTR _unpadded_size$32267[ebp+4]
$LN6@lzma_block:

; 82   :   }
; 83   : }

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_lzma_block_unpadded_size ENDP
END
