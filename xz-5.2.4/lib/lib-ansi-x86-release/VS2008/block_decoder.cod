; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_decoder.c
;	COMDAT _is_size_valid
_TEXT	SEGMENT
tv66 = -4						; size = 4
_size$ = 8						; size = 8
_reference$ = 16					; size = 8
_is_size_valid PROC					; COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   : 	return reference == LZMA_VLI_UNKNOWN || reference == size;

  00004	8b 45 10	 mov	 eax, DWORD PTR _reference$[ebp]
  00007	23 45 14	 and	 eax, DWORD PTR _reference$[ebp+4]
  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	74 19		 je	 SHORT $LN3@is_size_va
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _reference$[ebp]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR _size$[ebp]
  00015	75 08		 jne	 SHORT $LN5@is_size_va
  00017	8b 55 14	 mov	 edx, DWORD PTR _reference$[ebp+4]
  0001a	3b 55 0c	 cmp	 edx, DWORD PTR _size$[ebp+4]
  0001d	74 09		 je	 SHORT $LN3@is_size_va
$LN5@is_size_va:
  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00026	eb 07		 jmp	 SHORT $LN4@is_size_va
$LN3@is_size_va:
  00028	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN4@is_size_va:
  0002f	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 73   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_is_size_valid ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _update_size
_TEXT	SEGMENT
tv86 = -12						; size = 8
tv72 = -4						; size = 4
_size$ = 8						; size = 4
_add$ = 12						; size = 8
_limit$ = 20						; size = 8
_update_size PROC					; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 57   : 	if (limit > LZMA_VLI_MAX)

  00006	81 7d 18 ff ff
	ff 7f		 cmp	 DWORD PTR _limit$[ebp+4], 2147483647 ; 7fffffffH
  0000d	72 16		 jb	 SHORT $LN3@update_siz
  0000f	77 06		 ja	 SHORT $LN6@update_siz
  00011	83 7d 14 ff	 cmp	 DWORD PTR _limit$[ebp], -1
  00015	76 0e		 jbe	 SHORT $LN3@update_siz
$LN6@update_siz:

; 58   : 		limit = LZMA_VLI_MAX;

  00017	c7 45 14 ff ff
	ff ff		 mov	 DWORD PTR _limit$[ebp], -1
  0001e	c7 45 18 ff ff
	ff 7f		 mov	 DWORD PTR _limit$[ebp+4], 2147483647 ; 7fffffffH
$LN3@update_siz:

; 59   : 
; 60   : 	if (limit < *size || limit - *size < add)

  00025	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR tv72[ebp]
  0002e	8b 55 18	 mov	 edx, DWORD PTR _limit$[ebp+4]
  00031	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00034	72 32		 jb	 SHORT $LN1@update_siz
  00036	77 0a		 ja	 SHORT $LN7@update_siz
  00038	8b 45 fc	 mov	 eax, DWORD PTR tv72[ebp]
  0003b	8b 4d 14	 mov	 ecx, DWORD PTR _limit$[ebp]
  0003e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00040	72 26		 jb	 SHORT $LN1@update_siz
$LN7@update_siz:
  00042	8b 55 08	 mov	 edx, DWORD PTR _size$[ebp]
  00045	8b 45 14	 mov	 eax, DWORD PTR _limit$[ebp]
  00048	2b 02		 sub	 eax, DWORD PTR [edx]
  0004a	8b 4d 18	 mov	 ecx, DWORD PTR _limit$[ebp+4]
  0004d	1b 4a 04	 sbb	 ecx, DWORD PTR [edx+4]
  00050	89 45 f4	 mov	 DWORD PTR tv86[ebp], eax
  00053	89 4d f8	 mov	 DWORD PTR tv86[ebp+4], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR tv86[ebp+4]
  00059	3b 55 10	 cmp	 edx, DWORD PTR _add$[ebp+4]
  0005c	77 0e		 ja	 SHORT $LN2@update_siz
  0005e	72 08		 jb	 SHORT $LN1@update_siz
  00060	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	3b 45 0c	 cmp	 eax, DWORD PTR _add$[ebp]
  00066	73 04		 jae	 SHORT $LN2@update_siz
$LN1@update_siz:

; 61   : 		return true;

  00068	b0 01		 mov	 al, 1
  0006a	eb 18		 jmp	 SHORT $LN4@update_siz
$LN2@update_siz:

; 62   : 
; 63   : 	*size += add;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0006f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00071	03 55 0c	 add	 edx, DWORD PTR _add$[ebp]
  00074	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00077	13 45 10	 adc	 eax, DWORD PTR _add$[ebp+4]
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0007d	89 11		 mov	 DWORD PTR [ecx], edx
  0007f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 64   : 
; 65   : 	return false;

  00082	32 c0		 xor	 al, al
$LN4@update_siz:

; 66   : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_update_size ENDP
; Function compile flags: /Odtp
;	COMDAT _block_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_block_decoder_end PROC					; COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 184  : 	lzma_block_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 185  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	83 c2 08	 add	 edx, 8
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _lzma_next_end
  0001a	83 c4 08	 add	 esp, 8

; 186  : 	lzma_free(coder, allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _lzma_free
  0002a	83 c4 08	 add	 esp, 8

; 187  : 	return;
; 188  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_block_decoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _block_decode
_TEXT	SEGMENT
tv435 = -144						; size = 8
tv229 = -136						; size = 4
tv409 = -132						; size = 4
tv95 = -128						; size = 4
tv395 = -124						; size = 4
tv363 = -120						; size = 8
tv317 = -112						; size = 4
tv291 = -108						; size = 8
tv277 = -100						; size = 4
tv64 = -96						; size = 4
$T36178 = -92						; size = 8
$T36170 = -84						; size = 8
$T36162 = -73						; size = 1
$T36161 = -72						; size = 8
$T36160 = -64						; size = 8
$T36159 = -56						; size = 4
$T36152 = -49						; size = 1
$T36151 = -48						; size = 8
$T36150 = -40						; size = 8
$T36149 = -32						; size = 4
_check_size$32359 = -28					; size = 4
_in_start$32339 = -24					; size = 4
_ret$32341 = -20					; size = 4
_out_used$32343 = -16					; size = 4
_out_start$32340 = -12					; size = 4
_in_used$32342 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_block_decode PROC					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 82   : 	lzma_block_coder *coder = coder_ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 83   : 
; 84   : 	switch (coder->sequence) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 55 a0	 mov	 DWORD PTR tv64[ebp], edx
  00017	83 7d a0 00	 cmp	 DWORD PTR tv64[ebp], 0
  0001b	74 19		 je	 SHORT $LN17@block_deco
  0001d	83 7d a0 01	 cmp	 DWORD PTR tv64[ebp], 1
  00021	0f 84 06 03 00
	00		 je	 $LN9@block_deco
  00027	83 7d a0 02	 cmp	 DWORD PTR tv64[ebp], 2
  0002b	0f 84 bd 03 00
	00		 je	 $LN3@block_deco
  00031	e9 5b 04 00 00	 jmp	 $LN18@block_deco
$LN17@block_deco:

; 85   : 	case SEQ_CODE: {
; 86   : 		const size_t in_start = *in_pos;

  00036	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d e8	 mov	 DWORD PTR _in_start$32339[ebp], ecx

; 87   : 		const size_t out_start = *out_pos;

  0003e	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	89 45 f4	 mov	 DWORD PTR _out_start$32340[ebp], eax

; 88   : 
; 89   : 		const lzma_ret ret = coder->next.code(coder->next.coder,
; 90   : 				allocator, in, in_pos, in_size,
; 91   : 				out, out_pos, out_size, action);

  00046	8b 4d 28	 mov	 ecx, DWORD PTR _action$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  0004d	52		 push	 edx
  0004e	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  00059	52		 push	 edx
  0005a	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00065	52		 push	 edx
  00066	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00069	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006c	51		 push	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00070	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00073	ff d0		 call	 eax
  00075	83 c4 24	 add	 esp, 36			; 00000024H
  00078	89 45 ec	 mov	 DWORD PTR _ret$32341[ebp], eax

; 92   : 
; 93   : 		const size_t in_used = *in_pos - in_start;

  0007b	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	2b 55 e8	 sub	 edx, DWORD PTR _in_start$32339[ebp]
  00083	89 55 f8	 mov	 DWORD PTR _in_used$32342[ebp], edx

; 94   : 		const size_t out_used = *out_pos - out_start;

  00086	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	2b 4d f4	 sub	 ecx, DWORD PTR _out_start$32340[ebp]
  0008e	89 4d f0	 mov	 DWORD PTR _out_used$32343[ebp], ecx

; 95   : 
; 96   : 		// NOTE: We compare to compressed_limit here, which prevents
; 97   : 		// the total size of the Block growing past LZMA_VLI_MAX.
; 98   : 		if (update_size(&coder->compressed_size, in_used,
; 99   : 					coder->compressed_limit)
; 100  : 				|| update_size(&coder->uncompressed_size,
; 101  : 					out_used,
; 102  : 					coder->block->uncompressed_size))

  00091	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00094	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00097	89 45 d0	 mov	 DWORD PTR $T36151[ebp], eax
  0009a	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  0009d	89 4d d4	 mov	 DWORD PTR $T36151[ebp+4], ecx
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _in_used$32342[ebp]
  000a3	33 c0		 xor	 eax, eax
  000a5	89 55 d8	 mov	 DWORD PTR $T36150[ebp], edx
  000a8	89 45 dc	 mov	 DWORD PTR $T36150[ebp+4], eax
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ae	83 c1 40	 add	 ecx, 64			; 00000040H
  000b1	89 4d e0	 mov	 DWORD PTR $T36149[ebp], ecx
  000b4	81 7d d4 ff ff
	ff 7f		 cmp	 DWORD PTR $T36151[ebp+4], 2147483647 ; 7fffffffH
  000bb	72 16		 jb	 SHORT $LN24@block_deco
  000bd	77 06		 ja	 SHORT $LN40@block_deco
  000bf	83 7d d0 ff	 cmp	 DWORD PTR $T36151[ebp], -1
  000c3	76 0e		 jbe	 SHORT $LN24@block_deco
$LN40@block_deco:
  000c5	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR $T36151[ebp], -1
  000cc	c7 45 d4 ff ff
	ff 7f		 mov	 DWORD PTR $T36151[ebp+4], 2147483647 ; 7fffffffH
$LN24@block_deco:
  000d3	8b 55 e0	 mov	 edx, DWORD PTR $T36149[ebp]
  000d6	89 55 9c	 mov	 DWORD PTR tv277[ebp], edx
  000d9	8b 45 9c	 mov	 eax, DWORD PTR tv277[ebp]
  000dc	8b 4d d4	 mov	 ecx, DWORD PTR $T36151[ebp+4]
  000df	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000e2	72 32		 jb	 SHORT $LN22@block_deco
  000e4	77 0a		 ja	 SHORT $LN41@block_deco
  000e6	8b 55 9c	 mov	 edx, DWORD PTR tv277[ebp]
  000e9	8b 45 d0	 mov	 eax, DWORD PTR $T36151[ebp]
  000ec	3b 02		 cmp	 eax, DWORD PTR [edx]
  000ee	72 26		 jb	 SHORT $LN22@block_deco
$LN41@block_deco:
  000f0	8b 4d e0	 mov	 ecx, DWORD PTR $T36149[ebp]
  000f3	8b 55 d0	 mov	 edx, DWORD PTR $T36151[ebp]
  000f6	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f8	8b 45 d4	 mov	 eax, DWORD PTR $T36151[ebp+4]
  000fb	1b 41 04	 sbb	 eax, DWORD PTR [ecx+4]
  000fe	89 55 94	 mov	 DWORD PTR tv291[ebp], edx
  00101	89 45 98	 mov	 DWORD PTR tv291[ebp+4], eax
  00104	8b 4d 98	 mov	 ecx, DWORD PTR tv291[ebp+4]
  00107	3b 4d dc	 cmp	 ecx, DWORD PTR $T36150[ebp+4]
  0010a	77 10		 ja	 SHORT $LN23@block_deco
  0010c	72 08		 jb	 SHORT $LN22@block_deco
  0010e	8b 55 94	 mov	 edx, DWORD PTR tv291[ebp]
  00111	3b 55 d8	 cmp	 edx, DWORD PTR $T36150[ebp]
  00114	73 06		 jae	 SHORT $LN23@block_deco
$LN22@block_deco:
  00116	c6 45 cf 01	 mov	 BYTE PTR $T36152[ebp], 1
  0011a	eb 1a		 jmp	 SHORT $LN25@block_deco
$LN23@block_deco:
  0011c	8b 45 e0	 mov	 eax, DWORD PTR $T36149[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	03 4d d8	 add	 ecx, DWORD PTR $T36150[ebp]
  00124	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00127	13 55 dc	 adc	 edx, DWORD PTR $T36150[ebp+4]
  0012a	8b 45 e0	 mov	 eax, DWORD PTR $T36149[ebp]
  0012d	89 08		 mov	 DWORD PTR [eax], ecx
  0012f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00132	c6 45 cf 00	 mov	 BYTE PTR $T36152[ebp], 0
$LN25@block_deco:
  00136	0f b6 4d cf	 movzx	 ecx, BYTE PTR $T36152[ebp]
  0013a	85 c9		 test	 ecx, ecx
  0013c	0f 85 b0 00 00
	00		 jne	 $LN15@block_deco
  00142	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00145	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00148	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0014b	89 4d b8	 mov	 DWORD PTR $T36161[ebp], ecx
  0014e	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00151	89 55 bc	 mov	 DWORD PTR $T36161[ebp+4], edx
  00154	8b 45 f0	 mov	 eax, DWORD PTR _out_used$32343[ebp]
  00157	33 c9		 xor	 ecx, ecx
  00159	89 45 c0	 mov	 DWORD PTR $T36160[ebp], eax
  0015c	89 4d c4	 mov	 DWORD PTR $T36160[ebp+4], ecx
  0015f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00162	83 c2 48	 add	 edx, 72			; 00000048H
  00165	89 55 c8	 mov	 DWORD PTR $T36159[ebp], edx
  00168	81 7d bc ff ff
	ff 7f		 cmp	 DWORD PTR $T36161[ebp+4], 2147483647 ; 7fffffffH
  0016f	72 16		 jb	 SHORT $LN29@block_deco
  00171	77 06		 ja	 SHORT $LN43@block_deco
  00173	83 7d b8 ff	 cmp	 DWORD PTR $T36161[ebp], -1
  00177	76 0e		 jbe	 SHORT $LN29@block_deco
$LN43@block_deco:
  00179	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR $T36161[ebp], -1
  00180	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR $T36161[ebp+4], 2147483647 ; 7fffffffH
$LN29@block_deco:
  00187	8b 45 c8	 mov	 eax, DWORD PTR $T36159[ebp]
  0018a	89 45 90	 mov	 DWORD PTR tv317[ebp], eax
  0018d	8b 4d 90	 mov	 ecx, DWORD PTR tv317[ebp]
  00190	8b 55 bc	 mov	 edx, DWORD PTR $T36161[ebp+4]
  00193	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00196	72 32		 jb	 SHORT $LN27@block_deco
  00198	77 0a		 ja	 SHORT $LN44@block_deco
  0019a	8b 45 90	 mov	 eax, DWORD PTR tv317[ebp]
  0019d	8b 4d b8	 mov	 ecx, DWORD PTR $T36161[ebp]
  001a0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001a2	72 26		 jb	 SHORT $LN27@block_deco
$LN44@block_deco:
  001a4	8b 55 c8	 mov	 edx, DWORD PTR $T36159[ebp]
  001a7	8b 45 b8	 mov	 eax, DWORD PTR $T36161[ebp]
  001aa	2b 02		 sub	 eax, DWORD PTR [edx]
  001ac	8b 4d bc	 mov	 ecx, DWORD PTR $T36161[ebp+4]
  001af	1b 4a 04	 sbb	 ecx, DWORD PTR [edx+4]
  001b2	89 45 88	 mov	 DWORD PTR tv363[ebp], eax
  001b5	89 4d 8c	 mov	 DWORD PTR tv363[ebp+4], ecx
  001b8	8b 55 8c	 mov	 edx, DWORD PTR tv363[ebp+4]
  001bb	3b 55 c4	 cmp	 edx, DWORD PTR $T36160[ebp+4]
  001be	77 10		 ja	 SHORT $LN28@block_deco
  001c0	72 08		 jb	 SHORT $LN27@block_deco
  001c2	8b 45 88	 mov	 eax, DWORD PTR tv363[ebp]
  001c5	3b 45 c0	 cmp	 eax, DWORD PTR $T36160[ebp]
  001c8	73 06		 jae	 SHORT $LN28@block_deco
$LN27@block_deco:
  001ca	c6 45 b7 01	 mov	 BYTE PTR $T36162[ebp], 1
  001ce	eb 1a		 jmp	 SHORT $LN30@block_deco
$LN28@block_deco:
  001d0	8b 4d c8	 mov	 ecx, DWORD PTR $T36159[ebp]
  001d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d5	03 55 c0	 add	 edx, DWORD PTR $T36160[ebp]
  001d8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001db	13 45 c4	 adc	 eax, DWORD PTR $T36160[ebp+4]
  001de	8b 4d c8	 mov	 ecx, DWORD PTR $T36159[ebp]
  001e1	89 11		 mov	 DWORD PTR [ecx], edx
  001e3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001e6	c6 45 b7 00	 mov	 BYTE PTR $T36162[ebp], 0
$LN30@block_deco:
  001ea	0f b6 55 b7	 movzx	 edx, BYTE PTR $T36162[ebp]
  001ee	85 d2		 test	 edx, edx
  001f0	74 0a		 je	 SHORT $LN16@block_deco
$LN15@block_deco:

; 103  : 			return LZMA_DATA_ERROR;

  001f2	b8 09 00 00 00	 mov	 eax, 9
  001f7	e9 9a 02 00 00	 jmp	 $LN20@block_deco
$LN16@block_deco:

; 104  : 
; 105  : 		if (!coder->ignore_check)

  001fc	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001ff	0f b6 88 c8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+200]
  00206	85 c9		 test	 ecx, ecx
  00208	75 24		 jne	 SHORT $LN14@block_deco

; 106  : 			lzma_check_update(&coder->check, coder->block->check,
; 107  : 					out + out_start, out_used);

  0020a	8b 55 f0	 mov	 edx, DWORD PTR _out_used$32343[ebp]
  0020d	52		 push	 edx
  0020e	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00211	03 45 f4	 add	 eax, DWORD PTR _out_start$32340[ebp]
  00214	50		 push	 eax
  00215	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00218	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0021b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0021e	50		 push	 eax
  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00222	83 c1 60	 add	 ecx, 96			; 00000060H
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 _lzma_check_update
  0022b	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@block_deco:

; 108  : 
; 109  : 		if (ret != LZMA_STREAM_END)

  0022e	83 7d ec 01	 cmp	 DWORD PTR _ret$32341[ebp], 1
  00232	74 08		 je	 SHORT $LN13@block_deco

; 110  : 			return ret;

  00234	8b 45 ec	 mov	 eax, DWORD PTR _ret$32341[ebp]
  00237	e9 5a 02 00 00	 jmp	 $LN20@block_deco
$LN13@block_deco:

; 111  : 
; 112  : 		// Compressed and Uncompressed Sizes are now at their final
; 113  : 		// values. Verify that they match the values given to us.
; 114  : 		if (!is_size_valid(coder->compressed_size,
; 115  : 					coder->block->compressed_size)
; 116  : 				|| !is_size_valid(coder->uncompressed_size,
; 117  : 					coder->block->uncompressed_size))

  0023c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0023f	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00242	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00245	89 4d ac	 mov	 DWORD PTR $T36170[ebp], ecx
  00248	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0024b	89 55 b0	 mov	 DWORD PTR $T36170[ebp+4], edx
  0024e	8b 45 ac	 mov	 eax, DWORD PTR $T36170[ebp]
  00251	23 45 b0	 and	 eax, DWORD PTR $T36170[ebp+4]
  00254	83 f8 ff	 cmp	 eax, -1
  00257	74 25		 je	 SHORT $LN34@block_deco
  00259	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0025c	89 4d 84	 mov	 DWORD PTR tv395[ebp], ecx
  0025f	8b 55 84	 mov	 edx, DWORD PTR tv395[ebp]
  00262	8b 45 ac	 mov	 eax, DWORD PTR $T36170[ebp]
  00265	3b 42 40	 cmp	 eax, DWORD PTR [edx+64]
  00268	75 0b		 jne	 SHORT $LN46@block_deco
  0026a	8b 4d 84	 mov	 ecx, DWORD PTR tv395[ebp]
  0026d	8b 55 b0	 mov	 edx, DWORD PTR $T36170[ebp+4]
  00270	3b 51 44	 cmp	 edx, DWORD PTR [ecx+68]
  00273	74 09		 je	 SHORT $LN34@block_deco
$LN46@block_deco:
  00275	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  0027c	eb 07		 jmp	 SHORT $LN32@block_deco
$LN34@block_deco:
  0027e	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
$LN32@block_deco:
  00285	0f b6 45 80	 movzx	 eax, BYTE PTR tv95[ebp]
  00289	85 c0		 test	 eax, eax
  0028b	74 63		 je	 SHORT $LN11@block_deco
  0028d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00290	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00293	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00296	89 45 a4	 mov	 DWORD PTR $T36178[ebp], eax
  00299	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0029c	89 4d a8	 mov	 DWORD PTR $T36178[ebp+4], ecx
  0029f	8b 55 a4	 mov	 edx, DWORD PTR $T36178[ebp]
  002a2	23 55 a8	 and	 edx, DWORD PTR $T36178[ebp+4]
  002a5	83 fa ff	 cmp	 edx, -1
  002a8	74 31		 je	 SHORT $LN38@block_deco
  002aa	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002ad	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv409[ebp], eax
  002b3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv409[ebp]
  002b9	8b 55 a4	 mov	 edx, DWORD PTR $T36178[ebp]
  002bc	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  002bf	75 0e		 jne	 SHORT $LN47@block_deco
  002c1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv409[ebp]
  002c7	8b 4d a8	 mov	 ecx, DWORD PTR $T36178[ebp+4]
  002ca	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  002cd	74 0c		 je	 SHORT $LN38@block_deco
$LN47@block_deco:
  002cf	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv229[ebp], 0
  002d9	eb 0a		 jmp	 SHORT $LN36@block_deco
$LN38@block_deco:
  002db	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv229[ebp], 1
$LN36@block_deco:
  002e5	0f b6 95 78 ff
	ff ff		 movzx	 edx, BYTE PTR tv229[ebp]
  002ec	85 d2		 test	 edx, edx
  002ee	75 0a		 jne	 SHORT $LN12@block_deco
$LN11@block_deco:

; 118  : 			return LZMA_DATA_ERROR;

  002f0	b8 09 00 00 00	 mov	 eax, 9
  002f5	e9 9c 01 00 00	 jmp	 $LN20@block_deco
$LN12@block_deco:

; 119  : 
; 120  : 		// Copy the values into coder->block. The caller
; 121  : 		// may use this information to construct Index.
; 122  : 		coder->block->compressed_size = coder->compressed_size;

  002fa	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002fd	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00300	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00303	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00306	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00309	8b 52 44	 mov	 edx, DWORD PTR [edx+68]
  0030c	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 123  : 		coder->block->uncompressed_size = coder->uncompressed_size;

  0030f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00312	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00315	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00318	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0031b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0031e	8b 52 4c	 mov	 edx, DWORD PTR [edx+76]
  00321	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 124  : 
; 125  : 		coder->sequence = SEQ_PADDING;

  00324	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00327	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN9@block_deco:

; 126  : 	}
; 127  : 
; 128  : 	// Fall through
; 129  : 
; 130  : 	case SEQ_PADDING:
; 131  : 		// Compressed Data is padded to a multiple of four bytes.
; 132  : 		while (coder->compressed_size & 3) {

  0032d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00330	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00333	83 e2 03	 and	 edx, 3
  00336	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00339	83 e0 00	 and	 eax, 0
  0033c	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv435[ebp], edx
  00342	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv435[ebp+4], eax
  00348	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv435[ebp]
  0034e	0b 8d 74 ff ff
	ff		 or	 ecx, DWORD PTR tv435[ebp+4]
  00354	74 52		 je	 SHORT $LN8@block_deco

; 133  : 			if (*in_pos >= in_size)

  00356	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00359	8b 02		 mov	 eax, DWORD PTR [edx]
  0035b	3b 45 18	 cmp	 eax, DWORD PTR _in_size$[ebp]
  0035e	72 07		 jb	 SHORT $LN7@block_deco

; 134  : 				return LZMA_OK;

  00360	33 c0		 xor	 eax, eax
  00362	e9 2f 01 00 00	 jmp	 $LN20@block_deco
$LN7@block_deco:

; 135  : 
; 136  : 			// We use compressed_size here just get the Padding
; 137  : 			// right. The actual Compressed Size was stored to
; 138  : 			// coder->block already, and won't be modified by
; 139  : 			// us anymore.
; 140  : 			++coder->compressed_size;

  00367	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0036a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0036d	83 c2 01	 add	 edx, 1
  00370	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00373	83 d0 00	 adc	 eax, 0
  00376	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00379	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  0037c	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 141  : 
; 142  : 			if (in[(*in_pos)++] != 0x00)

  0037f	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00382	8b 02		 mov	 eax, DWORD PTR [edx]
  00384	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00387	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0038b	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	83 c1 01	 add	 ecx, 1
  00393	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00396	89 08		 mov	 DWORD PTR [eax], ecx
  00398	85 d2		 test	 edx, edx
  0039a	74 0a		 je	 SHORT $LN6@block_deco

; 143  : 				return LZMA_DATA_ERROR;

  0039c	b8 09 00 00 00	 mov	 eax, 9
  003a1	e9 f0 00 00 00	 jmp	 $LN20@block_deco
$LN6@block_deco:

; 144  : 		}

  003a6	eb 85		 jmp	 SHORT $LN9@block_deco
$LN8@block_deco:

; 145  : 
; 146  : 		if (coder->block->check == LZMA_CHECK_NONE)

  003a8	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  003ab	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  003ae	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  003b2	75 0a		 jne	 SHORT $LN5@block_deco

; 147  : 			return LZMA_STREAM_END;

  003b4	b8 01 00 00 00	 mov	 eax, 1
  003b9	e9 d8 00 00 00	 jmp	 $LN20@block_deco
$LN5@block_deco:

; 148  : 
; 149  : 		if (!coder->ignore_check)

  003be	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  003c1	0f b6 88 c8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+200]
  003c8	85 c9		 test	 ecx, ecx
  003ca	75 19		 jne	 SHORT $LN4@block_deco

; 150  : 			lzma_check_finish(&coder->check, coder->block->check);

  003cc	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  003cf	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  003d2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003d5	51		 push	 ecx
  003d6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  003d9	83 c2 60	 add	 edx, 96			; 00000060H
  003dc	52		 push	 edx
  003dd	e8 00 00 00 00	 call	 _lzma_check_finish
  003e2	83 c4 08	 add	 esp, 8
$LN4@block_deco:

; 151  : 
; 152  : 		coder->sequence = SEQ_CHECK;

  003e5	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  003e8	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
$LN3@block_deco:

; 153  : 
; 154  : 	// Fall through
; 155  : 
; 156  : 	case SEQ_CHECK: {
; 157  : 		const size_t check_size = lzma_check_size(coder->block->check);

  003ee	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  003f1	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  003f4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003f7	50		 push	 eax
  003f8	e8 00 00 00 00	 call	 _lzma_check_size
  003fd	83 c4 04	 add	 esp, 4
  00400	89 45 e4	 mov	 DWORD PTR _check_size$32359[ebp], eax

; 158  : 		lzma_bufcpy(in, in_pos, in_size, coder->block->raw_check,
; 159  : 				&coder->check_pos, check_size);

  00403	8b 4d e4	 mov	 ecx, DWORD PTR _check_size$32359[ebp]
  00406	51		 push	 ecx
  00407	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0040a	83 c2 58	 add	 edx, 88			; 00000058H
  0040d	52		 push	 edx
  0040e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00411	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00414	83 c1 24	 add	 ecx, 36			; 00000024H
  00417	51		 push	 ecx
  00418	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  0041b	52		 push	 edx
  0041c	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0041f	50		 push	 eax
  00420	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00423	51		 push	 ecx
  00424	e8 00 00 00 00	 call	 _lzma_bufcpy
  00429	83 c4 18	 add	 esp, 24			; 00000018H

; 160  : 		if (coder->check_pos < check_size)

  0042c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0042f	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00432	3b 45 e4	 cmp	 eax, DWORD PTR _check_size$32359[ebp]
  00435	73 04		 jae	 SHORT $LN2@block_deco

; 161  : 			return LZMA_OK;

  00437	33 c0		 xor	 eax, eax
  00439	eb 5b		 jmp	 SHORT $LN20@block_deco
$LN2@block_deco:

; 162  : 
; 163  : 		// Validate the Check only if we support it.
; 164  : 		// coder->check.buffer may be uninitialized
; 165  : 		// when the Check ID is not supported.
; 166  : 		if (!coder->ignore_check
; 167  : 				&& lzma_check_is_supported(coder->block->check)
; 168  : 				&& memcmp(coder->block->raw_check,
; 169  : 					coder->check.buffer.u8,
; 170  : 					check_size) != 0)

  0043b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0043e	0f b6 91 c8 00
	00 00		 movzx	 edx, BYTE PTR [ecx+200]
  00445	85 d2		 test	 edx, edx
  00447	75 41		 jne	 SHORT $LN1@block_deco
  00449	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0044c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0044f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00452	52		 push	 edx
  00453	e8 00 00 00 00	 call	 _lzma_check_is_supported
  00458	83 c4 04	 add	 esp, 4
  0045b	0f b6 c0	 movzx	 eax, al
  0045e	85 c0		 test	 eax, eax
  00460	74 28		 je	 SHORT $LN1@block_deco
  00462	8b 4d e4	 mov	 ecx, DWORD PTR _check_size$32359[ebp]
  00465	51		 push	 ecx
  00466	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00469	83 c2 60	 add	 edx, 96			; 00000060H
  0046c	52		 push	 edx
  0046d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00470	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00473	83 c1 24	 add	 ecx, 36			; 00000024H
  00476	51		 push	 ecx
  00477	e8 00 00 00 00	 call	 _memcmp
  0047c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047f	85 c0		 test	 eax, eax
  00481	74 07		 je	 SHORT $LN1@block_deco

; 171  : 			return LZMA_DATA_ERROR;

  00483	b8 09 00 00 00	 mov	 eax, 9
  00488	eb 0c		 jmp	 SHORT $LN20@block_deco
$LN1@block_deco:

; 172  : 
; 173  : 		return LZMA_STREAM_END;

  0048a	b8 01 00 00 00	 mov	 eax, 1
  0048f	eb 05		 jmp	 SHORT $LN20@block_deco
$LN18@block_deco:

; 174  : 	}
; 175  : 	}
; 176  : 
; 177  : 	return LZMA_PROG_ERROR;

  00491	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN20@block_deco:

; 178  : }

  00496	8b e5		 mov	 esp, ebp
  00498	5d		 pop	 ebp
  00499	c3		 ret	 0
_block_decode ENDP
PUBLIC	_lzma_block_decoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_block_decoder_init
_TEXT	SEGMENT
tv142 = -36						; size = 4
tv132 = -32						; size = 8
tv202 = -24						; size = 4
tv174 = -20						; size = 4
tv168 = -16						; size = 4
tv161 = -12						; size = 8
_coder$32384 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_block$ = 16						; size = 4
_lzma_block_decoder_init PROC				; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN8@lzma_block@3:

; 195  : 	lzma_next_coder_init(&lzma_block_decoder_init, next, allocator);

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _lzma_block_decoder_init
  00012	74 10		 je	 SHORT $LN5@lzma_block@3
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _lzma_next_end
  00021	83 c4 08	 add	 esp, 8
$LN5@lzma_block@3:
  00024	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma_block_decoder_init
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 d6		 jne	 SHORT $LN8@lzma_block@3

; 196  : 
; 197  : 	// Validate the options. lzma_block_unpadded_size() does that for us
; 198  : 	// except for Uncompressed Size and filters. Filters are validated
; 199  : 	// by the raw decoder.
; 200  : 	if (lzma_block_unpadded_size(block) == 0
; 201  : 			|| !lzma_vli_is_valid(block->uncompressed_size))

  00032	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR tv161[ebp], eax
  00041	89 55 f8	 mov	 DWORD PTR tv161[ebp+4], edx
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv161[ebp]
  00047	0b 45 f8	 or	 eax, DWORD PTR tv161[ebp+4]
  0004a	74 34		 je	 SHORT $LN3@lzma_block@3
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _block$[ebp]
  0004f	89 4d f0	 mov	 DWORD PTR tv168[ebp], ecx
  00052	8b 55 f0	 mov	 edx, DWORD PTR tv168[ebp]
  00055	81 7a 1c ff ff
	ff 7f		 cmp	 DWORD PTR [edx+28], 2147483647 ; 7fffffffH
  0005c	72 2c		 jb	 SHORT $LN4@lzma_block@3
  0005e	77 09		 ja	 SHORT $LN15@lzma_block@3
  00060	8b 45 f0	 mov	 eax, DWORD PTR tv168[ebp]
  00063	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  00067	76 21		 jbe	 SHORT $LN4@lzma_block@3
$LN15@lzma_block@3:
  00069	8b 4d 10	 mov	 ecx, DWORD PTR _block$[ebp]
  0006c	89 4d ec	 mov	 DWORD PTR tv174[ebp], ecx
  0006f	8b 55 ec	 mov	 edx, DWORD PTR tv174[ebp]
  00072	8b 45 ec	 mov	 eax, DWORD PTR tv174[ebp]
  00075	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00078	23 48 1c	 and	 ecx, DWORD PTR [eax+28]
  0007b	83 f9 ff	 cmp	 ecx, -1
  0007e	74 0a		 je	 SHORT $LN4@lzma_block@3
$LN3@lzma_block@3:

; 202  : 		return LZMA_PROG_ERROR;

  00080	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00085	e9 60 01 00 00	 jmp	 $LN9@lzma_block@3
$LN4@lzma_block@3:

; 203  : 
; 204  : 	// Allocate *next->coder if needed.
; 205  :   {
; 206  : 	lzma_block_coder *coder = next->coder;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	89 45 fc	 mov	 DWORD PTR _coder$32384[ebp], eax

; 207  : 	if (coder == NULL) {

  00092	83 7d fc 00	 cmp	 DWORD PTR _coder$32384[ebp], 0
  00096	75 52		 jne	 SHORT $LN2@lzma_block@3

; 208  : 		coder = lzma_alloc(sizeof(lzma_block_coder), allocator);

  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0009b	51		 push	 ecx
  0009c	68 d0 00 00 00	 push	 208			; 000000d0H
  000a1	e8 00 00 00 00	 call	 _lzma_alloc
  000a6	83 c4 08	 add	 esp, 8
  000a9	89 45 fc	 mov	 DWORD PTR _coder$32384[ebp], eax

; 209  : 		if (coder == NULL)

  000ac	83 7d fc 00	 cmp	 DWORD PTR _coder$32384[ebp], 0
  000b0	75 0a		 jne	 SHORT $LN1@lzma_block@3

; 210  : 			return LZMA_MEM_ERROR;

  000b2	b8 05 00 00 00	 mov	 eax, 5
  000b7	e9 2e 01 00 00	 jmp	 $LN9@lzma_block@3
$LN1@lzma_block@3:

; 211  : 
; 212  : 		next->coder = coder;

  000bc	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  000c2	89 02		 mov	 DWORD PTR [edx], eax

; 213  : 		next->code = &block_decode;

  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  000c7	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _block_decode

; 214  : 		next->end = &block_decoder_end;

  000ce	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  000d1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _block_decoder_end

; 215  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000d8	8b 7d fc	 mov	 edi, DWORD PTR _coder$32384[ebp]
  000db	83 c7 08	 add	 edi, 8
  000de	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000e3	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000e8	f3 a5		 rep movsd
$LN2@lzma_block@3:

; 216  : 	}
; 217  : 
; 218  : 	// Basic initializations
; 219  : 	coder->sequence = SEQ_CODE;

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  000ed	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 220  : 	coder->block = block;

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32384[ebp]
  000f6	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  000f9	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 221  : 	coder->compressed_size = 0;

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  000ff	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0
  00106	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 222  : 	coder->uncompressed_size = 0;

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32384[ebp]
  00110	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  00117	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 223  : 
; 224  : 	// If Compressed Size is not known, we calculate the maximum allowed
; 225  : 	// value so that encoded size of the Block (including Block Padding)
; 226  : 	// is still a valid VLI and a multiple of four.
; 227  : 	coder->compressed_limit
; 228  : 			= block->compressed_size == LZMA_VLI_UNKNOWN
; 229  : 				? (LZMA_VLI_MAX & ~LZMA_VLI_C(3))
; 230  : 					- block->header_size
; 231  : 					- lzma_check_size(block->check)
; 232  : 				: block->compressed_size;

  0011e	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  00121	89 55 e8	 mov	 DWORD PTR tv202[ebp], edx
  00124	8b 45 e8	 mov	 eax, DWORD PTR tv202[ebp]
  00127	8b 4d e8	 mov	 ecx, DWORD PTR tv202[ebp]
  0012a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0012d	23 51 14	 and	 edx, DWORD PTR [ecx+20]
  00130	83 fa ff	 cmp	 edx, -1
  00133	75 33		 jne	 SHORT $LN11@lzma_block@3
  00135	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	33 d2		 xor	 edx, edx
  0013d	be fc ff ff ff	 mov	 esi, -4			; fffffffcH
  00142	2b f1		 sub	 esi, ecx
  00144	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00149	1b fa		 sbb	 edi, edx
  0014b	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  0014e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _lzma_check_size
  00157	83 c4 04	 add	 esp, 4
  0015a	33 d2		 xor	 edx, edx
  0015c	2b f0		 sub	 esi, eax
  0015e	1b fa		 sbb	 edi, edx
  00160	89 75 e0	 mov	 DWORD PTR tv132[ebp], esi
  00163	89 7d e4	 mov	 DWORD PTR tv132[ebp+4], edi
  00166	eb 0f		 jmp	 SHORT $LN12@lzma_block@3
$LN11@lzma_block@3:
  00168	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  0016b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0016e	89 4d e0	 mov	 DWORD PTR tv132[ebp], ecx
  00171	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00174	89 55 e4	 mov	 DWORD PTR tv132[ebp+4], edx
$LN12@lzma_block@3:
  00177	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  0017a	8b 4d e0	 mov	 ecx, DWORD PTR tv132[ebp]
  0017d	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00180	8b 55 e4	 mov	 edx, DWORD PTR tv132[ebp+4]
  00183	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 233  : 
; 234  : 	// Initialize the check. It's caller's problem if the Check ID is not
; 235  : 	// supported, and the Block decoder cannot verify the Check field.
; 236  : 	// Caller can test lzma_check_is_supported(block->check).
; 237  : 	coder->check_pos = 0;

  00186	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  00189	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 238  : 	lzma_check_init(&coder->check, block->check);

  00190	8b 4d 10	 mov	 ecx, DWORD PTR _block$[ebp]
  00193	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00196	52		 push	 edx
  00197	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  0019a	83 c0 60	 add	 eax, 96			; 00000060H
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _lzma_check_init
  001a3	83 c4 08	 add	 esp, 8

; 239  : 
; 240  : 	coder->ignore_check = block->version >= 1
; 241  : 			? block->ignore_check : false;

  001a6	8b 4d 10	 mov	 ecx, DWORD PTR _block$[ebp]
  001a9	83 39 01	 cmp	 DWORD PTR [ecx], 1
  001ac	72 0f		 jb	 SHORT $LN13@lzma_block@3
  001ae	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  001b1	0f b6 82 b8 00
	00 00		 movzx	 eax, BYTE PTR [edx+184]
  001b8	89 45 dc	 mov	 DWORD PTR tv142[ebp], eax
  001bb	eb 07		 jmp	 SHORT $LN14@lzma_block@3
$LN13@lzma_block@3:
  001bd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$LN14@lzma_block@3:
  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32384[ebp]
  001c7	8a 55 dc	 mov	 dl, BYTE PTR tv142[ebp]
  001ca	88 91 c8 00 00
	00		 mov	 BYTE PTR [ecx+200], dl

; 242  : 
; 243  : 	// Initialize the filter chain.
; 244  : 	return lzma_raw_decoder_init(&coder->next, allocator,
; 245  : 			block->filters);

  001d0	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  001d3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001d6	51		 push	 ecx
  001d7	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  001da	52		 push	 edx
  001db	8b 45 fc	 mov	 eax, DWORD PTR _coder$32384[ebp]
  001de	83 c0 08	 add	 eax, 8
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _lzma_raw_decoder_init
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@lzma_block@3:

; 246  :   }
; 247  : }

  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
_lzma_block_decoder_init ENDP
END
