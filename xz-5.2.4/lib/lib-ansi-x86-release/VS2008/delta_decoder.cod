; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\delta\delta_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_delta_props_decode
PUBLIC	_lzma_delta_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\delta\delta_decoder.c
;	COMDAT _decode_buffer
_TEXT	SEGMENT
_i$32258 = -8						; size = 4
_distance$ = -4						; size = 4
_coder$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_decode_buffer PROC					; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20   : 	const size_t distance = coder->distance;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000c	89 4d fc	 mov	 DWORD PTR _distance$[ebp], ecx

; 21   : 
; 22   :   {
; 23   :   size_t i;
; 24   : 	for (i = 0; i < size; ++i) {

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$32258[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN3@decode_buf
$LN2@decode_buf:
  00018	8b 55 f8	 mov	 edx, DWORD PTR _i$32258[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 f8	 mov	 DWORD PTR _i$32258[ebp], edx
$LN3@decode_buf:
  00021	8b 45 f8	 mov	 eax, DWORD PTR _i$32258[ebp]
  00024	3b 45 10	 cmp	 eax, DWORD PTR _size$[ebp]
  00027	73 56		 jae	 SHORT $LN4@decode_buf

; 25   : 		buffer[i] += coder->history[(distance + coder->pos) & 0xFF];

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0002c	0f b6 51 34	 movzx	 edx, BYTE PTR [ecx+52]
  00030	03 55 fc	 add	 edx, DWORD PTR _distance$[ebp]
  00033	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00039	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003c	0f b6 4c 10 35	 movzx	 ecx, BYTE PTR [eax+edx+53]
  00041	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00044	03 55 f8	 add	 edx, DWORD PTR _i$32258[ebp]
  00047	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0004a	03 c1		 add	 eax, ecx
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0004f	03 4d f8	 add	 ecx, DWORD PTR _i$32258[ebp]
  00052	88 01		 mov	 BYTE PTR [ecx], al

; 26   : 		coder->history[coder->pos-- & 0xFF] = buffer[i];

  00054	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00057	0f b6 42 34	 movzx	 eax, BYTE PTR [edx+52]
  0005b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00063	03 4d f8	 add	 ecx, DWORD PTR _i$32258[ebp]
  00066	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00069	8a 09		 mov	 cl, BYTE PTR [ecx]
  0006b	88 4c 02 35	 mov	 BYTE PTR [edx+eax+53], cl
  0006f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00072	8a 42 34	 mov	 al, BYTE PTR [edx+52]
  00075	2c 01		 sub	 al, 1
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007a	88 41 34	 mov	 BYTE PTR [ecx+52], al

; 27   : 	}

  0007d	eb 99		 jmp	 SHORT $LN2@decode_buf
$LN4@decode_buf:

; 28   :   }
; 29   : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_decode_buffer ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_delta_props_decode
_TEXT	SEGMENT
_opt$32303 = -4						; size = 4
_options$ = 8						; size = 4
_allocator$ = 12					; size = 4
_props$ = 16						; size = 4
_props_size$ = 20					; size = 4
_lzma_delta_props_decode PROC				; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 69   : 	if (props_size != 1)

  00004	83 7d 14 01	 cmp	 DWORD PTR _props_size$[ebp], 1
  00008	74 07		 je	 SHORT $LN2@lzma_delta@2

; 70   : 		return LZMA_OPTIONS_ERROR;

  0000a	b8 08 00 00 00	 mov	 eax, 8
  0000f	eb 40		 jmp	 SHORT $LN3@lzma_delta@2
$LN2@lzma_delta@2:

; 71   : 
; 72   :   { lzma_options_delta *opt
; 73   : 			= lzma_alloc(sizeof(lzma_options_delta), allocator);

  00011	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00014	50		 push	 eax
  00015	6a 20		 push	 32			; 00000020H
  00017	e8 00 00 00 00	 call	 _lzma_alloc
  0001c	83 c4 08	 add	 esp, 8
  0001f	89 45 fc	 mov	 DWORD PTR _opt$32303[ebp], eax

; 74   : 	if (opt == NULL)

  00022	83 7d fc 00	 cmp	 DWORD PTR _opt$32303[ebp], 0
  00026	75 07		 jne	 SHORT $LN1@lzma_delta@2

; 75   : 		return LZMA_MEM_ERROR;

  00028	b8 05 00 00 00	 mov	 eax, 5
  0002d	eb 22		 jmp	 SHORT $LN3@lzma_delta@2
$LN1@lzma_delta@2:

; 76   : 
; 77   : 	opt->type = LZMA_DELTA_TYPE_BYTE;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32303[ebp]
  00032	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 78   : 	opt->dist = props[0] + 1;

  00038	8b 55 10	 mov	 edx, DWORD PTR _props$[ebp]
  0003b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0003e	83 c0 01	 add	 eax, 1
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32303[ebp]
  00044	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 79   : 
; 80   : 	*options = opt;

  00047	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _opt$32303[ebp]
  0004d	89 02		 mov	 DWORD PTR [edx], eax

; 81   :   }
; 82   : 
; 83   : 	return LZMA_OK;

  0004f	33 c0		 xor	 eax, eax
$LN3@lzma_delta@2:

; 84   : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_lzma_delta_props_decode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _delta_decode
_TEXT	SEGMENT
_ret$32285 = -12					; size = 4
_out_start$32284 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_delta_decode PROC					; COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 38   : 	lzma_delta_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 39   : 
; 40   : 	assert(coder->next.code != NULL);
; 41   : 
; 42   :   {
; 43   : 	const size_t out_start = *out_pos;

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f8	 mov	 DWORD PTR _out_start$32284[ebp], edx

; 44   : 
; 45   : 	const lzma_ret ret = coder->next.code(coder->next.coder, allocator,
; 46   : 			in, in_pos, in_size, out, out_pos, out_size,
; 47   : 			action);

  00014	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00040	ff d2		 call	 edx
  00042	83 c4 24	 add	 esp, 36			; 00000024H
  00045	89 45 f4	 mov	 DWORD PTR _ret$32285[ebp], eax

; 48   : 
; 49   : 	decode_buffer(coder, out + out_start, *out_pos - out_start);

  00048	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	2b 4d f8	 sub	 ecx, DWORD PTR _out_start$32284[ebp]
  00050	51		 push	 ecx
  00051	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  00054	03 55 f8	 add	 edx, DWORD PTR _out_start$32284[ebp]
  00057	52		 push	 edx
  00058	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _decode_buffer
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   : 
; 51   : 	return ret;

  00064	8b 45 f4	 mov	 eax, DWORD PTR _ret$32285[ebp]

; 52   :   }
; 53   : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_delta_decode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_delta_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_delta_decoder_init PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	next->code = &delta_decode;

  00003	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00006	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _delta_decode

; 61   : 	return lzma_delta_coder_init(next, allocator, filters);

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _lzma_delta_coder_init
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_lzma_delta_decoder_init ENDP
END
