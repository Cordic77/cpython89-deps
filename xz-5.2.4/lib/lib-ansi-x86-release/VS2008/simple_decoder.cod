; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\simple_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_props_decode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT _read32le
_TEXT	SEGMENT
_num$ = -4						; size = 4
_buf$ = 8						; size = 4
_read32le PROC						; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 221  : 	uint32_t num = *(const uint32_t *)buf;

  00004	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _num$[ebp], ecx

; 222  : 	return conv32le(num);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _num$[ebp]

; 223  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_read32le ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\simple_decoder.c
;	COMDAT _lzma_simple_props_decode
_TEXT	SEGMENT
_num$34892 = -8						; size = 4
_opt$32320 = -4						; size = 4
_options$ = 8						; size = 4
_allocator$ = 12					; size = 4
_props$ = 16						; size = 4
_props_size$ = 20					; size = 4
_lzma_simple_props_decode PROC				; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20   : 	if (props_size == 0)

  00006	83 7d 14 00	 cmp	 DWORD PTR _props_size$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN5@lzma_simpl

; 21   : 		return LZMA_OK;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 5f		 jmp	 SHORT $LN6@lzma_simpl
$LN5@lzma_simpl:

; 22   : 
; 23   : 	if (props_size != 4)

  00010	83 7d 14 04	 cmp	 DWORD PTR _props_size$[ebp], 4
  00014	74 07		 je	 SHORT $LN4@lzma_simpl

; 24   : 		return LZMA_OPTIONS_ERROR;

  00016	b8 08 00 00 00	 mov	 eax, 8
  0001b	eb 52		 jmp	 SHORT $LN6@lzma_simpl
$LN4@lzma_simpl:

; 25   : 
; 26   :   { lzma_options_bcj *opt = lzma_alloc(
; 27   : 			sizeof(lzma_options_bcj), allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	6a 04		 push	 4
  00023	e8 00 00 00 00	 call	 _lzma_alloc
  00028	83 c4 08	 add	 esp, 8
  0002b	89 45 fc	 mov	 DWORD PTR _opt$32320[ebp], eax

; 28   : 	if (opt == NULL)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _opt$32320[ebp], 0
  00032	75 07		 jne	 SHORT $LN3@lzma_simpl

; 29   : 		return LZMA_MEM_ERROR;

  00034	b8 05 00 00 00	 mov	 eax, 5
  00039	eb 34		 jmp	 SHORT $LN6@lzma_simpl
$LN3@lzma_simpl:

; 30   : 
; 31   : 	opt->start_offset = unaligned_read32le(props);

  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _props$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	89 55 f8	 mov	 DWORD PTR _num$34892[ebp], edx
  00043	8b 45 fc	 mov	 eax, DWORD PTR _opt$32320[ebp]
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _num$34892[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 32   : 
; 33   : 	// Don't leave an options structure allocated if start_offset is zero.
; 34   : 	if (opt->start_offset == 0)

  0004b	8b 55 fc	 mov	 edx, DWORD PTR _opt$32320[ebp]
  0004e	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00051	75 12		 jne	 SHORT $LN2@lzma_simpl

; 35   : 		lzma_free(opt, allocator);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00056	50		 push	 eax
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32320[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _lzma_free
  00060	83 c4 08	 add	 esp, 8

; 36   : 	else

  00063	eb 08		 jmp	 SHORT $LN1@lzma_simpl
$LN2@lzma_simpl:

; 37   : 		*options = opt;

  00065	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00068	8b 45 fc	 mov	 eax, DWORD PTR _opt$32320[ebp]
  0006b	89 02		 mov	 DWORD PTR [edx], eax
$LN1@lzma_simpl:

; 38   :   }
; 39   : 
; 40   : 	return LZMA_OK;

  0006d	33 c0		 xor	 eax, eax
$LN6@lzma_simpl:

; 41   : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_lzma_simple_props_decode ENDP
END
