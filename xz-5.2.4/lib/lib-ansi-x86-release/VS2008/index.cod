; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\index.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_index_iter_rewind
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
;	COMDAT _lzma_index_iter_rewind
_TEXT	SEGMENT
_iter$ = 8						; size = 4
_lzma_index_iter_rewind PROC				; COMDAT

; 1126 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1127 : 	iter->internal[ITER_STREAM].p = NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00006	c7 80 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+232], 0

; 1128 : 	iter->internal[ITER_GROUP].p = NULL;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00013	c7 81 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+240], 0

; 1129 : 	iter->internal[ITER_RECORD].s = 0;

  0001d	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00020	c7 82 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+248], 0

; 1130 : 	iter->internal[ITER_METHOD].s = ITER_METHOD_NORMAL;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0002d	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 1131 : 	return;
; 1132 : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_lzma_index_iter_rewind ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_iter_init
; Function compile flags: /Odtp
;	COMDAT _lzma_index_iter_init
_TEXT	SEGMENT
_iter$ = 8						; size = 4
_i$ = 12						; size = 4
_lzma_index_iter_init PROC				; COMDAT

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1118 : 	iter->internal[ITER_INDEX].p = i;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00009	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx

; 1119 : 	lzma_index_iter_rewind(iter);

  0000f	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _lzma_index_iter_rewind
  00018	83 c4 04	 add	 esp, 4

; 1120 : 	return;
; 1121 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_lzma_index_iter_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_checks
; Function compile flags: /Odtp
;	COMDAT _lzma_index_checks
_TEXT	SEGMENT
_checks$ = -8						; size = 4
_s$ = -4						; size = 4
_i$ = 8							; size = 4
_lzma_index_checks PROC					; COMDAT

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 587  : 	uint32_t checks = i->checks;

  00006	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00009	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0000c	89 4d f8	 mov	 DWORD PTR _checks$[ebp], ecx

; 588  : 
; 589  : 	// Get the type of the Check of the last Stream too.
; 590  : 	const index_stream *s = (const index_stream *)(i->streams.rightmost);

  0000f	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 591  : 	if (s->stream_flags.version != UINT32_MAX)

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0001b	83 79 50 ff	 cmp	 DWORD PTR [ecx+80], -1
  0001f	74 13		 je	 SHORT $LN1@lzma_index

; 592  : 		checks |= UINT32_C(1) << s->stream_flags.check;

  00021	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]
  0002c	d3 e0		 shl	 eax, cl
  0002e	0b 45 f8	 or	 eax, DWORD PTR _checks$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _checks$[ebp], eax
$LN1@lzma_index:

; 593  : 
; 594  : 	return checks;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _checks$[ebp]

; 595  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_lzma_index_checks ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_uncompressed_size
; Function compile flags: /Odtp
;	COMDAT _lzma_index_uncompressed_size
_TEXT	SEGMENT
_i$ = 8							; size = 4
_lzma_index_uncompressed_size PROC			; COMDAT

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 580  : 	return i->uncompressed_size;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00009	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]

; 581  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_lzma_index_uncompressed_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_total_size
; Function compile flags: /Odtp
;	COMDAT _lzma_index_total_size
_TEXT	SEGMENT
_i$ = 8							; size = 4
_lzma_index_total_size PROC				; COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 	return i->total_size;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 528  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_lzma_index_total_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_stream_count
; Function compile flags: /Odtp
;	COMDAT _lzma_index_stream_count
_TEXT	SEGMENT
_i$ = 8							; size = 4
_lzma_index_stream_count PROC				; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 	return i->streams.count;

  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00009	33 d2		 xor	 edx, edx

; 514  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_lzma_index_stream_count ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_block_count
; Function compile flags: /Odtp
;	COMDAT _lzma_index_block_count
_TEXT	SEGMENT
_i$ = 8							; size = 4
_lzma_index_block_count PROC				; COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 	return i->record_count;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00006	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00009	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 507  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_lzma_index_block_count ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_index_memusage
_TEXT	SEGMENT
tv237 = -76						; size = 8
tv225 = -68						; size = 8
tv203 = -60						; size = 8
_alloc_overhead$ = -52					; size = 4
_limit$ = -48						; size = 8
_index_base$ = -40					; size = 8
_stream_base$ = -32					; size = 4
_group_base$ = -28					; size = 4
_streams_mem$ = -24					; size = 8
_groups_mem$ = -16					; size = 8
_groups$ = -8						; size = 8
_streams$ = 8						; size = 8
_blocks$ = 16						; size = 8
_lzma_index_memusage PROC				; COMDAT

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 450  : 	// This calculates an upper bound that is only a little bit
; 451  : 	// bigger than the exact maximum memory usage with the given
; 452  : 	// parameters.
; 453  : 
; 454  : 	// Typical malloc() overhead is 2 * sizeof(void *) but we take
; 455  : 	// a little bit extra just in case. Using LZMA_MEMUSAGE_BASE
; 456  : 	// instead would give too inaccurate estimate.
; 457  : 	const size_t alloc_overhead = 4 * sizeof(void *);

  00006	c7 45 cc 10 00
	00 00		 mov	 DWORD PTR _alloc_overhead$[ebp], 16 ; 00000010H

; 458  : 
; 459  : 	// Amount of memory needed for each Stream base structures.
; 460  : 	// We assume that every Stream has at least one Block and
; 461  : 	// thus at least one group.
; 462  : 	const size_t stream_base = sizeof(index_stream)
; 463  : 			+ sizeof(index_group) + 2 * alloc_overhead;

  0000d	8b 45 cc	 mov	 eax, DWORD PTR _alloc_overhead$[ebp]
  00010	8d 8c 00 c0 00
	00 00		 lea	 ecx, DWORD PTR [eax+eax+192]
  00017	89 4d e0	 mov	 DWORD PTR _stream_base$[ebp], ecx

; 464  : 
; 465  : 	// Amount of memory needed per group.
; 466  : 	const size_t group_base = sizeof(index_group)
; 467  : 			+ INDEX_GROUP_SIZE * sizeof(index_record)
; 468  : 			+ alloc_overhead;

  0001a	8b 55 cc	 mov	 edx, DWORD PTR _alloc_overhead$[ebp]
  0001d	81 c2 30 20 00
	00		 add	 edx, 8240		; 00002030H
  00023	89 55 e4	 mov	 DWORD PTR _group_base$[ebp], edx

; 469  : 
; 470  : 	// Number of groups. There may actually be more, but that overhead
; 471  : 	// has been taken into account in stream_base already.
; 472  : 	const lzma_vli groups
; 473  : 			= (blocks + INDEX_GROUP_SIZE - 1) / INDEX_GROUP_SIZE;

  00026	8b 45 10	 mov	 eax, DWORD PTR _blocks$[ebp]
  00029	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _blocks$[ebp+4]
  00031	83 d1 00	 adc	 ecx, 0
  00034	83 e8 01	 sub	 eax, 1
  00037	83 d9 00	 sbb	 ecx, 0
  0003a	6a 00		 push	 0
  0003c	68 00 02 00 00	 push	 512			; 00000200H
  00041	51		 push	 ecx
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 __aulldiv
  00048	89 45 f8	 mov	 DWORD PTR _groups$[ebp], eax
  0004b	89 55 fc	 mov	 DWORD PTR _groups$[ebp+4], edx

; 474  : 
; 475  : 	// Memory used by index_stream and index_group structures.
; 476  : 	const uint64_t streams_mem = streams * stream_base;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR _stream_base$[ebp]
  00051	33 c0		 xor	 eax, eax
  00053	50		 push	 eax
  00054	52		 push	 edx
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _streams$[ebp+4]
  00058	51		 push	 ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _streams$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 __allmul
  00062	89 45 e8	 mov	 DWORD PTR _streams_mem$[ebp], eax
  00065	89 55 ec	 mov	 DWORD PTR _streams_mem$[ebp+4], edx

; 477  : 	const uint64_t groups_mem = groups * group_base;

  00068	8b 45 e4	 mov	 eax, DWORD PTR _group_base$[ebp]
  0006b	33 c9		 xor	 ecx, ecx
  0006d	51		 push	 ecx
  0006e	50		 push	 eax
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _groups$[ebp+4]
  00072	52		 push	 edx
  00073	8b 45 f8	 mov	 eax, DWORD PTR _groups$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 __allmul
  0007c	89 45 f0	 mov	 DWORD PTR _groups_mem$[ebp], eax
  0007f	89 55 f4	 mov	 DWORD PTR _groups_mem$[ebp+4], edx

; 478  : 
; 479  : 	// Memory used by the base structure.
; 480  : 	const uint64_t index_base = sizeof(lzma_index) + alloc_overhead;

  00082	8b 4d cc	 mov	 ecx, DWORD PTR _alloc_overhead$[ebp]
  00085	83 c1 38	 add	 ecx, 56			; 00000038H
  00088	33 d2		 xor	 edx, edx
  0008a	89 4d d8	 mov	 DWORD PTR _index_base$[ebp], ecx
  0008d	89 55 dc	 mov	 DWORD PTR _index_base$[ebp+4], edx

; 481  : 
; 482  : 	// Validate the arguments and catch integer overflows.
; 483  : 	// Maximum number of Streams is "only" UINT32_MAX, because
; 484  : 	// that limit is used by the tree containing the Streams.
; 485  : 	const uint64_t limit = UINT64_MAX - index_base;

  00090	83 c8 ff	 or	 eax, -1
  00093	2b 45 d8	 sub	 eax, DWORD PTR _index_base$[ebp]
  00096	b9 ff ff ff ff	 mov	 ecx, -1
  0009b	1b 4d dc	 sbb	 ecx, DWORD PTR _index_base$[ebp+4]
  0009e	89 45 d0	 mov	 DWORD PTR _limit$[ebp], eax
  000a1	89 4d d4	 mov	 DWORD PTR _limit$[ebp+4], ecx

; 486  : 	if (streams == 0 || streams > UINT32_MAX || blocks > LZMA_VLI_MAX
; 487  : 			|| streams > limit / stream_base
; 488  : 			|| groups > limit / group_base
; 489  : 			|| limit - streams_mem < groups_mem)

  000a4	8b 55 08	 mov	 edx, DWORD PTR _streams$[ebp]
  000a7	0b 55 0c	 or	 edx, DWORD PTR _streams$[ebp+4]
  000aa	0f 84 a7 00 00
	00		 je	 $LN1@lzma_index@2
  000b0	83 7d 0c 00	 cmp	 DWORD PTR _streams$[ebp+4], 0
  000b4	0f 87 9d 00 00
	00		 ja	 $LN1@lzma_index@2
  000ba	72 0a		 jb	 SHORT $LN5@lzma_index@2
  000bc	83 7d 08 ff	 cmp	 DWORD PTR _streams$[ebp], -1
  000c0	0f 87 91 00 00
	00		 ja	 $LN1@lzma_index@2
$LN5@lzma_index@2:
  000c6	81 7d 14 ff ff
	ff 7f		 cmp	 DWORD PTR _blocks$[ebp+4], 2147483647 ; 7fffffffH
  000cd	0f 87 84 00 00
	00		 ja	 $LN1@lzma_index@2
  000d3	72 06		 jb	 SHORT $LN6@lzma_index@2
  000d5	83 7d 10 ff	 cmp	 DWORD PTR _blocks$[ebp], -1
  000d9	77 7c		 ja	 SHORT $LN1@lzma_index@2
$LN6@lzma_index@2:
  000db	8b 45 e0	 mov	 eax, DWORD PTR _stream_base$[ebp]
  000de	33 c9		 xor	 ecx, ecx
  000e0	51		 push	 ecx
  000e1	50		 push	 eax
  000e2	8b 55 d4	 mov	 edx, DWORD PTR _limit$[ebp+4]
  000e5	52		 push	 edx
  000e6	8b 45 d0	 mov	 eax, DWORD PTR _limit$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 __aulldiv
  000ef	89 45 c4	 mov	 DWORD PTR tv203[ebp], eax
  000f2	89 55 c8	 mov	 DWORD PTR tv203[ebp+4], edx
  000f5	8b 4d 0c	 mov	 ecx, DWORD PTR _streams$[ebp+4]
  000f8	3b 4d c8	 cmp	 ecx, DWORD PTR tv203[ebp+4]
  000fb	77 5a		 ja	 SHORT $LN1@lzma_index@2
  000fd	72 08		 jb	 SHORT $LN7@lzma_index@2
  000ff	8b 55 08	 mov	 edx, DWORD PTR _streams$[ebp]
  00102	3b 55 c4	 cmp	 edx, DWORD PTR tv203[ebp]
  00105	77 50		 ja	 SHORT $LN1@lzma_index@2
$LN7@lzma_index@2:
  00107	8b 45 e4	 mov	 eax, DWORD PTR _group_base$[ebp]
  0010a	33 c9		 xor	 ecx, ecx
  0010c	51		 push	 ecx
  0010d	50		 push	 eax
  0010e	8b 55 d4	 mov	 edx, DWORD PTR _limit$[ebp+4]
  00111	52		 push	 edx
  00112	8b 45 d0	 mov	 eax, DWORD PTR _limit$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 __aulldiv
  0011b	89 45 bc	 mov	 DWORD PTR tv225[ebp], eax
  0011e	89 55 c0	 mov	 DWORD PTR tv225[ebp+4], edx
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _groups$[ebp+4]
  00124	3b 4d c0	 cmp	 ecx, DWORD PTR tv225[ebp+4]
  00127	77 2e		 ja	 SHORT $LN1@lzma_index@2
  00129	72 08		 jb	 SHORT $LN8@lzma_index@2
  0012b	8b 55 f8	 mov	 edx, DWORD PTR _groups$[ebp]
  0012e	3b 55 bc	 cmp	 edx, DWORD PTR tv225[ebp]
  00131	77 24		 ja	 SHORT $LN1@lzma_index@2
$LN8@lzma_index@2:
  00133	8b 45 d0	 mov	 eax, DWORD PTR _limit$[ebp]
  00136	2b 45 e8	 sub	 eax, DWORD PTR _streams_mem$[ebp]
  00139	8b 4d d4	 mov	 ecx, DWORD PTR _limit$[ebp+4]
  0013c	1b 4d ec	 sbb	 ecx, DWORD PTR _streams_mem$[ebp+4]
  0013f	89 45 b4	 mov	 DWORD PTR tv237[ebp], eax
  00142	89 4d b8	 mov	 DWORD PTR tv237[ebp+4], ecx
  00145	8b 55 b8	 mov	 edx, DWORD PTR tv237[ebp+4]
  00148	3b 55 f4	 cmp	 edx, DWORD PTR _groups_mem$[ebp+4]
  0014b	77 12		 ja	 SHORT $LN2@lzma_index@2
  0014d	72 08		 jb	 SHORT $LN1@lzma_index@2
  0014f	8b 45 b4	 mov	 eax, DWORD PTR tv237[ebp]
  00152	3b 45 f0	 cmp	 eax, DWORD PTR _groups_mem$[ebp]
  00155	73 08		 jae	 SHORT $LN2@lzma_index@2
$LN1@lzma_index@2:

; 490  : 		return UINT64_MAX;

  00157	83 c8 ff	 or	 eax, -1
  0015a	83 ca ff	 or	 edx, -1
  0015d	eb 12		 jmp	 SHORT $LN3@lzma_index@2
$LN2@lzma_index@2:

; 491  : 
; 492  : 	return index_base + streams_mem + groups_mem;

  0015f	8b 45 d8	 mov	 eax, DWORD PTR _index_base$[ebp]
  00162	03 45 e8	 add	 eax, DWORD PTR _streams_mem$[ebp]
  00165	8b 55 dc	 mov	 edx, DWORD PTR _index_base$[ebp+4]
  00168	13 55 ec	 adc	 edx, DWORD PTR _streams_mem$[ebp+4]
  0016b	03 45 f0	 add	 eax, DWORD PTR _groups_mem$[ebp]
  0016e	13 55 f4	 adc	 edx, DWORD PTR _groups_mem$[ebp+4]
$LN3@lzma_index@2:

; 493  : }

  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
_lzma_index_memusage ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_prealloc
; Function compile flags: /Odtp
;	COMDAT _lzma_index_prealloc
_TEXT	SEGMENT
_i$ = 8							; size = 4
_records$ = 12						; size = 8
_lzma_index_prealloc PROC				; COMDAT

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	if (records > PREALLOC_MAX)

  00003	83 7d 10 00	 cmp	 DWORD PTR _records$[ebp+4], 0
  00007	77 09		 ja	 SHORT $LN4@lzma_index@3
  00009	81 7d 0c fc ff
	ff 0f		 cmp	 DWORD PTR _records$[ebp], 268435452 ; 0ffffffcH
  00010	76 0e		 jbe	 SHORT $LN1@lzma_index@3
$LN4@lzma_index@3:

; 440  : 		records = PREALLOC_MAX;

  00012	c7 45 0c fc ff
	ff 0f		 mov	 DWORD PTR _records$[ebp], 268435452 ; 0ffffffcH
  00019	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _records$[ebp+4], 0
$LN1@lzma_index@3:

; 441  : 
; 442  : 	i->prealloc = (size_t)(records);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _records$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 443  : 	return;
; 444  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_lzma_index_prealloc ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_tree_next
_TEXT	SEGMENT
_node$ = 8						; size = 4
_index_tree_next PROC					; COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 	if (node->right != NULL) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00006	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0000a	74 22		 je	 SHORT $LN2@index_tree

; 301  : 		node = node->right;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  0000f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00012	89 55 08	 mov	 DWORD PTR _node$[ebp], edx
$LN4@index_tree:

; 302  : 		while (node->left != NULL)

  00015	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00018	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0001c	74 0b		 je	 SHORT $LN3@index_tree

; 303  : 			node = node->left;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  00021	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00024	89 55 08	 mov	 DWORD PTR _node$[ebp], edx
  00027	eb ec		 jmp	 SHORT $LN4@index_tree
$LN3@index_tree:

; 304  : 
; 305  : 		return (void *)(node);

  00029	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0002c	eb 28		 jmp	 SHORT $LN6@index_tree
$LN2@index_tree:

; 306  : 	}
; 307  : 
; 308  : 	while (node->parent != NULL && node->parent->right == node)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00031	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00035	74 19		 je	 SHORT $LN1@index_tree
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  0003a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00040	3b 45 08	 cmp	 eax, DWORD PTR _node$[ebp]
  00043	75 0b		 jne	 SHORT $LN1@index_tree

; 309  : 		node = node->parent;

  00045	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 08	 mov	 DWORD PTR _node$[ebp], edx
  0004e	eb de		 jmp	 SHORT $LN2@index_tree
$LN1@index_tree:

; 310  : 
; 311  : 	return (void *)(node->parent);

  00050	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00053	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LN6@index_tree:

; 312  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_index_tree_next ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_tree_node_end
_TEXT	SEGMENT
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_free_func$ = 16					; size = 4
_index_tree_node_end PROC				; COMDAT

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 	// The tree won't ever be very huge, so recursion should be fine.
; 198  : 	// 20 levels in the tree is likely quite a lot already in practice.
; 199  : 	if (node->left != NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00006	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000a	74 17		 je	 SHORT $LN2@index_tree@2

; 200  : 		index_tree_node_end(node->left, allocator, free_func);

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _free_func$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00017	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _index_tree_node_end
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@index_tree@2:

; 201  : 
; 202  : 	if (node->right != NULL)

  00023	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  00026	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0002a	74 17		 je	 SHORT $LN1@index_tree@2

; 203  : 		index_tree_node_end(node->right, allocator, free_func);

  0002c	8b 45 10	 mov	 eax, DWORD PTR _free_func$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  00037	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _index_tree_node_end
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@index_tree@2:

; 204  : 
; 205  : 	free_func(node, allocator);

  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  0004a	52		 push	 edx
  0004b	ff 55 10	 call	 DWORD PTR _free_func$[ebp]
  0004e	83 c4 08	 add	 esp, 8

; 206  : 	return;
; 207  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_index_tree_node_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_tree_init
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_index_tree_init PROC					; COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	tree->root = NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 185  : 	tree->leftmost = NULL;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 186  : 	tree->rightmost = NULL;

  00016	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00019	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 187  : 	tree->count = 0;

  00020	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00023	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 188  : 	return;
; 189  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_index_tree_init ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
_TEXT	ENDS
;	COMDAT _index_size_unpadded
_TEXT	SEGMENT
_count$ = 8						; size = 8
_index_list_size$ = 16					; size = 8
_index_size_unpadded PROC				; COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 50   : 	// Index Indicator + Number of Records + List of Records + CRC32
; 51   : 	return 1 + lzma_vli_size(count) + index_list_size + 4;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp+4]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _count$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _lzma_vli_size
  00010	83 c4 08	 add	 esp, 8
  00013	83 c0 01	 add	 eax, 1
  00016	33 d2		 xor	 edx, edx
  00018	03 45 10	 add	 eax, DWORD PTR _index_list_size$[ebp]
  0001b	13 55 14	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  0001e	83 c0 04	 add	 eax, 4
  00021	83 d2 00	 adc	 edx, 0

; 52   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_index_size_unpadded ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _vli_ceil4
_TEXT	SEGMENT
_vli$ = 8						; size = 8
_vli_ceil4 PROC						; COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : 	assert(vli <= LZMA_VLI_MAX);
; 42   : 	return (vli + 3) & ~LZMA_VLI_C(3);

  00003	8b 45 08	 mov	 eax, DWORD PTR _vli$[ebp]
  00006	83 c0 03	 add	 eax, 3
  00009	8b 55 0c	 mov	 edx, DWORD PTR _vli$[ebp+4]
  0000c	83 d2 00	 adc	 edx, 0
  0000f	83 e0 fc	 and	 eax, -4			; fffffffcH

; 43   : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_vli_ceil4 ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT _ctz32
_TEXT	SEGMENT
_i$ = -4						; size = 4
_n$ = 8							; size = 4
_ctz32	PROC						; COMDAT

; 492  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 493  : #if defined(__INTEL_COMPILER)
; 494  : 	return _bit_scan_forward(n);
; 495  : 
; 496  : #elif TUKLIB_GNUC_REQ(3, 4) && UINT_MAX >= UINT32_MAX
; 497  : 	return __builtin_ctz(n);
; 498  : 
; 499  : #elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
; 500  : 	uint32_t i;
; 501  : 	__asm__("bsfl %1, %0" : "=r" (i) : "rm" (n));
; 502  : 	return i;
; 503  : 
; 504  : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 505  : 	uint32_t i;
; 506  : 	_BitScanForward((DWORD *)&i, n);

  00004	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00007	0f bc c8	 bsf	 ecx, eax
  0000a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 507  : 	return i;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 508  : 
; 509  : #else
; 510  : 	uint32_t i = 0;
; 511  : 
; 512  : 	if ((n & UINT32_C(0x0000FFFF)) == 0) {
; 513  : 		n >>= 16;
; 514  : 		i = 16;
; 515  : 	}
; 516  : 
; 517  : 	if ((n & UINT32_C(0x000000FF)) == 0) {
; 518  : 		n >>= 8;
; 519  : 		i += 8;
; 520  : 	}
; 521  : 
; 522  : 	if ((n & UINT32_C(0x0000000F)) == 0) {
; 523  : 		n >>= 4;
; 524  : 		i += 4;
; 525  : 	}
; 526  : 
; 527  : 	if ((n & UINT32_C(0x00000003)) == 0) {
; 528  : 		n >>= 2;
; 529  : 		i += 2;
; 530  : 	}
; 531  : 
; 532  : 	if ((n & UINT32_C(0x00000001)) == 0)
; 533  : 		++i;
; 534  : 
; 535  : 	return i;
; 536  : #endif
; 537  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_ctz32	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _bsr32
_TEXT	SEGMENT
_i$ = -4						; size = 4
_n$ = 8							; size = 4
_bsr32	PROC						; COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 384  : 	// Check for ICC first, since it tends to define __GNUC__ too.
; 385  : #if defined(__INTEL_COMPILER)
; 386  : 	return _bit_scan_reverse(n);
; 387  : 
; 388  : #elif TUKLIB_GNUC_REQ(3, 4) && UINT_MAX == UINT32_MAX
; 389  : 	// GCC >= 3.4 has __builtin_clz(), which gives good results on
; 390  : 	// multiple architectures. On x86, __builtin_clz() ^ 31U becomes
; 391  : 	// either plain BSR (so the XOR gets optimized away) or LZCNT and
; 392  : 	// XOR (if -march indicates that SSE4a instructions are supported).
; 393  : 	return __builtin_clz(n) ^ 31U;
; 394  : 
; 395  : #elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
; 396  : 	uint32_t i;
; 397  : 	__asm__("bsrl %1, %0" : "=r" (i) : "rm" (n));
; 398  : 	return i;
; 399  : 
; 400  : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 401  : 	// MSVC isn't supported by tuklib, but since this code exists,
; 402  : 	// it doesn't hurt to have it here anyway.
; 403  : 	uint32_t i;
; 404  : 	_BitScanReverse((DWORD *)&i, n);

  00004	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00007	0f bd c8	 bsr	 ecx, eax
  0000a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 405  : 	return i;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 406  : 
; 407  : #else
; 408  : 	uint32_t i = 31;
; 409  : 
; 410  : 	if ((n & UINT32_C(0xFFFF0000)) == 0) {
; 411  : 		n <<= 16;
; 412  : 		i = 15;
; 413  : 	}
; 414  : 
; 415  : 	if ((n & UINT32_C(0xFF000000)) == 0) {
; 416  : 		n <<= 8;
; 417  : 		i -= 8;
; 418  : 	}
; 419  : 
; 420  : 	if ((n & UINT32_C(0xF0000000)) == 0) {
; 421  : 		n <<= 4;
; 422  : 		i -= 4;
; 423  : 	}
; 424  : 
; 425  : 	if ((n & UINT32_C(0xC0000000)) == 0) {
; 426  : 		n <<= 2;
; 427  : 		i -= 2;
; 428  : 	}
; 429  : 
; 430  : 	if ((n & UINT32_C(0x80000000)) == 0)
; 431  : 		--i;
; 432  : 
; 433  : 	return i;
; 434  : #endif
; 435  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_bsr32	ENDP
PUBLIC	_lzma_index_padding_size
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
;	COMDAT _lzma_index_padding_size
_TEXT	SEGMENT
$T78181 = -16						; size = 8
$T78180 = -8						; size = 8
_i$ = 8							; size = 4
_lzma_index_padding_size PROC				; COMDAT

; 600  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 601  : 	return (LZMA_VLI_C(4) - index_size_unpadded(
; 602  : 			i->record_count, i->index_list_size)) & 3;

  00006	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00009	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000c	89 4d f0	 mov	 DWORD PTR $T78181[ebp], ecx
  0000f	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00012	89 55 f4	 mov	 DWORD PTR $T78181[ebp+4], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00018	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001b	89 4d f8	 mov	 DWORD PTR $T78180[ebp], ecx
  0001e	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00021	89 55 fc	 mov	 DWORD PTR $T78180[ebp+4], edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR $T78180[ebp+4]
  00027	50		 push	 eax
  00028	8b 4d f8	 mov	 ecx, DWORD PTR $T78180[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _lzma_vli_size
  00031	83 c4 08	 add	 esp, 8
  00034	83 c0 01	 add	 eax, 1
  00037	33 d2		 xor	 edx, edx
  00039	03 45 f0	 add	 eax, DWORD PTR $T78181[ebp]
  0003c	13 55 f4	 adc	 edx, DWORD PTR $T78181[ebp+4]
  0003f	83 c0 04	 add	 eax, 4
  00042	83 d2 00	 adc	 edx, 0
  00045	b9 04 00 00 00	 mov	 ecx, 4
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 00 00 00 00	 mov	 eax, 0
  00051	1b c2		 sbb	 eax, edx
  00053	83 e1 03	 and	 ecx, 3
  00056	83 e0 00	 and	 eax, 0
  00059	8b c1		 mov	 eax, ecx

; 603  : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_lzma_index_padding_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_memused
; Function compile flags: /Odtp
;	COMDAT _lzma_index_memused
_TEXT	SEGMENT
_i$ = 8							; size = 4
_lzma_index_memused PROC				; COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 499  : 	return lzma_index_memusage(i->streams.count, i->record_count);

  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00009	51		 push	 ecx
  0000a	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000d	52		 push	 edx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	33 d2		 xor	 edx, edx
  00016	52		 push	 edx
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _lzma_index_memusage
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 500  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_lzma_index_memused ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_init_plain
_TEXT	SEGMENT
_i$ = -4						; size = 4
_allocator$ = 8						; size = 4
_index_init_plain PROC					; COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 386  : 	lzma_index *i = lzma_alloc(sizeof(lzma_index), allocator);

  00004	8b 45 08	 mov	 eax, DWORD PTR _allocator$[ebp]
  00007	50		 push	 eax
  00008	6a 38		 push	 56			; 00000038H
  0000a	e8 00 00 00 00	 call	 _lzma_alloc
  0000f	83 c4 08	 add	 esp, 8
  00012	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 387  : 	if (i != NULL) {

  00015	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00019	74 64		 je	 SHORT $LN1@index_init

; 388  : 		index_tree_init(&i->streams);

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _index_tree_init
  00024	83 c4 04	 add	 esp, 4

; 389  : 		i->uncompressed_size = 0;

  00027	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002a	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  00031	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 390  : 		i->total_size = 0;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00042	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 391  : 		i->record_count = 0;

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0004c	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00053	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 392  : 		i->index_list_size = 0;

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0
  00064	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 393  : 		i->prealloc = INDEX_GROUP_SIZE;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	c7 40 30 00 02
	00 00		 mov	 DWORD PTR [eax+48], 512	; 00000200H

; 394  : 		i->checks = 0;

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00078	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0
$LN1@index_init:

; 395  : 	}
; 396  : 
; 397  : 	return i;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 398  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_index_init_plain ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_stream_init
_TEXT	SEGMENT
_s$ = -4						; size = 4
_compressed_base$ = 8					; size = 8
_uncompressed_base$ = 16				; size = 8
_stream_number$ = 24					; size = 4
_block_number_base$ = 28				; size = 8
_allocator$ = 36					; size = 4
_index_stream_init PROC					; COMDAT

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 348  : 	index_stream *s = lzma_alloc(sizeof(index_stream), allocator);

  00004	8b 45 24	 mov	 eax, DWORD PTR _allocator$[ebp]
  00007	50		 push	 eax
  00008	68 90 00 00 00	 push	 144			; 00000090H
  0000d	e8 00 00 00 00	 call	 _lzma_alloc
  00012	83 c4 08	 add	 esp, 8
  00015	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 349  : 	if (s == NULL)

  00018	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0001c	75 07		 jne	 SHORT $LN1@index_stre

; 350  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	e9 a8 00 00 00	 jmp	 $LN2@index_stre
$LN1@index_stre:

; 351  : 
; 352  : 	s->node.uncompressed_base = uncompressed_base;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00028	8b 55 10	 mov	 edx, DWORD PTR _uncompressed_base$[ebp]
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	8b 45 14	 mov	 eax, DWORD PTR _uncompressed_base$[ebp+4]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 353  : 	s->node.compressed_base = compressed_base;

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR _compressed_base$[ebp]
  00039	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _compressed_base$[ebp+4]
  0003f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 354  : 	s->node.parent = NULL;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 355  : 	s->node.left = NULL;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0004f	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 356  : 	s->node.right = NULL;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00059	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 357  : 
; 358  : 	s->number = stream_number;

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00063	8b 55 18	 mov	 edx, DWORD PTR _stream_number$[ebp]
  00066	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 359  : 	s->block_number_base = block_number_base;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0006c	8b 4d 1c	 mov	 ecx, DWORD PTR _block_number_base$[ebp]
  0006f	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00072	8b 55 20	 mov	 edx, DWORD PTR _block_number_base$[ebp+4]
  00075	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 360  : 
; 361  : 	index_tree_init(&s->groups);

  00078	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0007b	83 c0 30	 add	 eax, 48			; 00000030H
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _index_tree_init
  00084	83 c4 04	 add	 esp, 4

; 362  : 
; 363  : 	s->record_count = 0;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0008a	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00091	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 364  : 	s->index_list_size = 0;

  00098	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0009b	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0
  000a2	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 365  : 	s->stream_flags.version = UINT32_MAX;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000ac	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [eax+80], -1

; 366  : 	s->stream_padding = 0;

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000b6	c7 81 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+136], 0
  000c0	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], 0

; 367  : 
; 368  : 	return s;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
$LN2@index_stre:

; 369  : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_index_stream_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_tree_append
_TEXT	SEGMENT
$T78195 = -24						; size = 4
_i$78194 = -20						; size = 4
$T78190 = -16						; size = 4
_i$78189 = -12						; size = 4
_pivot$32351 = -8					; size = 4
_up$32346 = -4						; size = 4
_tree$ = 8						; size = 4
_node$ = 12						; size = 4
_index_tree_append PROC					; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 232  : 	node->parent = tree->rightmost;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 233  : 	node->left = NULL;

  00012	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00015	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 234  : 	node->right = NULL;

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  0001f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 235  : 
; 236  : 	++tree->count;

  00026	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00029	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002c	83 c0 01	 add	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00032	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 237  : 
; 238  : 	// Handle the special case of adding the first node.
; 239  : 	if (tree->root == NULL) {

  00035	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00038	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0003b	75 1f		 jne	 SHORT $LN8@index_tree@3

; 240  : 		tree->root = node;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  00043	89 08		 mov	 DWORD PTR [eax], ecx

; 241  : 		tree->leftmost = node;

  00045	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00048	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  0004b	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 242  : 		tree->rightmost = node;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00051	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  00054	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 243  : 		return;

  00057	e9 d6 00 00 00	 jmp	 $LN9@index_tree@3
$LN8@index_tree@3:

; 244  : 	}
; 245  : 
; 246  : 	// The tree is always filled sequentially.
; 247  : 	assert(tree->rightmost->uncompressed_base <= node->uncompressed_base);
; 248  : 	assert(tree->rightmost->compressed_base < node->compressed_base);
; 249  : 
; 250  : 	// Add the new node after the rightmost node. It's the correct
; 251  : 	// place due to the reason above.
; 252  : 	tree->rightmost->right = node;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0005f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00062	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  00065	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 253  : 	tree->rightmost = node;

  00068	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  0006e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 254  : 
; 255  : 	// Balance the AVL-tree if needed. We don't need to keep the balance
; 256  : 	// factors in nodes, because we always fill the tree sequentially,
; 257  : 	// and thus know the state of the tree just by looking at the node
; 258  : 	// count. From the node count we can calculate how many steps to go
; 259  : 	// up in the tree to find the rotation root.
; 260  :   {
; 261  : 	uint32_t up = tree->count ^ (UINT32_C(1) << bsr32(tree->count));

  00071	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00074	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00077	89 45 f0	 mov	 DWORD PTR $T78190[ebp], eax
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR $T78190[ebp]
  0007d	0f bd d1	 bsr	 edx, ecx
  00080	89 55 f4	 mov	 DWORD PTR _i$78189[ebp], edx
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	8b 4d f4	 mov	 ecx, DWORD PTR _i$78189[ebp]
  0008b	d3 e0		 shl	 eax, cl
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00090	33 41 0c	 xor	 eax, DWORD PTR [ecx+12]
  00093	89 45 fc	 mov	 DWORD PTR _up$32346[ebp], eax

; 262  : 	if (up != 0) {

  00096	0f 84 96 00 00
	00		 je	 $LN9@index_tree@3

; 263  : 		// Locate the root node for the rotation.
; 264  : 		up = ctz32(tree->count) + 2;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0009f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a2	89 45 e8	 mov	 DWORD PTR $T78195[ebp], eax
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR $T78195[ebp]
  000a8	0f bc d1	 bsf	 edx, ecx
  000ab	89 55 ec	 mov	 DWORD PTR _i$78194[ebp], edx
  000ae	8b 45 ec	 mov	 eax, DWORD PTR _i$78194[ebp]
  000b1	83 c0 02	 add	 eax, 2
  000b4	89 45 fc	 mov	 DWORD PTR _up$32346[ebp], eax
$LN6@index_tree@3:

; 265  : 		do {
; 266  : 			node = node->parent;

  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  000ba	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000bd	89 55 0c	 mov	 DWORD PTR _node$[ebp], edx

; 267  : 		} while (--up > 0);

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _up$32346[ebp]
  000c3	83 e8 01	 sub	 eax, 1
  000c6	89 45 fc	 mov	 DWORD PTR _up$32346[ebp], eax
  000c9	75 ec		 jne	 SHORT $LN6@index_tree@3

; 268  : 
; 269  : 		// Rotate left using node as the rotation root.
; 270  : 	  {
; 271  : 		index_tree_node *pivot = node->right;

  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  000ce	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d1	89 55 f8	 mov	 DWORD PTR _pivot$32351[ebp], edx

; 272  : 
; 273  : 		if (node->parent == NULL) {

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  000d7	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000db	75 0a		 jne	 SHORT $LN3@index_tree@3

; 274  : 			tree->root = pivot;

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000e0	8b 55 f8	 mov	 edx, DWORD PTR _pivot$32351[ebp]
  000e3	89 11		 mov	 DWORD PTR [ecx], edx

; 275  : 		} else {

  000e5	eb 0c		 jmp	 SHORT $LN2@index_tree@3
$LN3@index_tree@3:

; 276  : 			assert(node->parent->right == node);
; 277  : 			node->parent->right = pivot;

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  000ea	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ed	8b 55 f8	 mov	 edx, DWORD PTR _pivot$32351[ebp]
  000f0	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$LN2@index_tree@3:

; 278  : 		}
; 279  : 
; 280  : 		pivot->parent = node->parent;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _pivot$32351[ebp]
  000f6	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  000f9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fc	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 281  : 
; 282  : 		node->right = pivot->left;

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _pivot$32351[ebp]
  00105	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00108	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 283  : 		if (node->right != NULL)

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  0010e	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00112	74 0c		 je	 SHORT $LN1@index_tree@3

; 284  : 			node->right->parent = node;

  00114	8b 4d 0c	 mov	 ecx, DWORD PTR _node$[ebp]
  00117	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0011a	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  0011d	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN1@index_tree@3:

; 285  : 
; 286  : 		pivot->left = node;

  00120	8b 4d f8	 mov	 ecx, DWORD PTR _pivot$32351[ebp]
  00123	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  00126	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 287  : 		node->parent = pivot;

  00129	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _pivot$32351[ebp]
  0012f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN9@index_tree@3:

; 288  : 	  }
; 289  : 	}
; 290  :   }
; 291  : 
; 292  : 	return;
; 293  : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
_index_tree_append ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_tree_end
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_allocator$ = 12					; size = 4
_free_func$ = 16					; size = 4
_index_tree_end PROC					; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  : 	assert(free_func != NULL);
; 219  : 
; 220  : 	if (tree->root != NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 16		 je	 SHORT $LN2@index_tree@4

; 221  : 		index_tree_node_end(tree->root, allocator, free_func);

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _free_func$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00012	52		 push	 edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _index_tree_node_end
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@index_tree@4:

; 222  : 
; 223  : 	return;
; 224  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_index_tree_end ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
_TEXT	ENDS
;	COMDAT _index_size
_TEXT	SEGMENT
$T78201 = -8						; size = 8
_count$ = 8						; size = 8
_index_list_size$ = 16					; size = 8
_index_size PROC					; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 59   : 	return vli_ceil4(index_size_unpadded(count, index_list_size));

  00006	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp+4]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _count$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _lzma_vli_size
  00013	83 c4 08	 add	 esp, 8
  00016	83 c0 01	 add	 eax, 1
  00019	33 d2		 xor	 edx, edx
  0001b	03 45 10	 add	 eax, DWORD PTR _index_list_size$[ebp]
  0001e	13 55 14	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  00021	83 c0 04	 add	 eax, 4
  00024	83 d2 00	 adc	 edx, 0
  00027	89 45 f8	 mov	 DWORD PTR $T78201[ebp], eax
  0002a	89 55 fc	 mov	 DWORD PTR $T78201[ebp+4], edx
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T78201[ebp]
  00030	83 c0 03	 add	 eax, 3
  00033	8b 55 fc	 mov	 edx, DWORD PTR $T78201[ebp+4]
  00036	83 d2 00	 adc	 edx, 0
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH

; 60   : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_index_size ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
;	COMDAT _iter_set_info
_TEXT	SEGMENT
tv203 = -72						; size = 8
tv196 = -64						; size = 8
tv145 = -56						; size = 4
$T78900 = -52						; size = 8
$T78899 = -44						; size = 8
$T78889 = -36						; size = 8
$T78875 = -28						; size = 8
_g$32733 = -20						; size = 4
_record$ = -16						; size = 4
_group$ = -12						; size = 4
_i$ = -8						; size = 4
_stream$ = -4						; size = 4
_iter$ = 8						; size = 4
_iter_set_info PROC					; COMDAT

; 1012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1013 : 	const lzma_index *i = iter->internal[ITER_INDEX].p;

  00008	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0000b	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00011	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 1014 : 	const index_stream *stream = iter->internal[ITER_STREAM].p;

  00014	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00017	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  0001d	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 1015 : 	const index_group *group = iter->internal[ITER_GROUP].p;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00023	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  00029	89 55 f4	 mov	 DWORD PTR _group$[ebp], edx

; 1016 : 	const size_t record = iter->internal[ITER_RECORD].s;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0002f	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  00035	89 4d f0	 mov	 DWORD PTR _record$[ebp], ecx

; 1017 : 
; 1018 : 	// lzma_index_iter.internal must not contain a pointer to the last
; 1019 : 	// group in the index, because that may be reallocated by
; 1020 : 	// lzma_index_cat().
; 1021 : 	if (group == NULL) {

  00038	83 7d f4 00	 cmp	 DWORD PTR _group$[ebp], 0
  0003c	75 0f		 jne	 SHORT $LN10@iter_set_i

; 1022 : 		// There are no groups.
; 1023 : 		assert(stream->groups.root == NULL);
; 1024 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_LEFTMOST;

  0003e	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00041	c7 82 00 01 00
	00 02 00 00 00	 mov	 DWORD PTR [edx+256], 2

; 1025 : 
; 1026 : 	} else if (i->streams.rightmost != &stream->node

  0004b	eb 68		 jmp	 SHORT $LN9@iter_set_i
$LN10@iter_set_i:

; 1027 : 			|| stream->groups.rightmost != &group->node) {

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00053	3b 4d fc	 cmp	 ecx, DWORD PTR _stream$[ebp]
  00056	75 0b		 jne	 SHORT $LN7@iter_set_i
  00058	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0005b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0005e	3b 45 f4	 cmp	 eax, DWORD PTR _group$[ebp]
  00061	74 0f		 je	 SHORT $LN8@iter_set_i
$LN7@iter_set_i:

; 1028 : 		// The group is not not the last group in the index.
; 1029 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_NORMAL;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00066	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0
  00070	eb 43		 jmp	 SHORT $LN9@iter_set_i
$LN8@iter_set_i:

; 1030 : 
; 1031 : 	} else if (stream->groups.leftmost != &group->node) {

  00072	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00075	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00078	3b 45 f4	 cmp	 eax, DWORD PTR _group$[ebp]
  0007b	74 1e		 je	 SHORT $LN5@iter_set_i

; 1032 : 		// The group isn't the only group in the Stream, thus we
; 1033 : 		// know that it must have a parent group i.e. it's not
; 1034 : 		// the root node.
; 1035 : 		assert(stream->groups.root != &group->node);
; 1036 : 		assert(group->node.parent->right == &group->node);
; 1037 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_NEXT;

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00080	c7 81 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+256], 1

; 1038 : 		iter->internal[ITER_GROUP].p = group->node.parent;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _group$[ebp]
  00090	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00093	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 1039 : 
; 1040 : 	} else {

  00099	eb 1a		 jmp	 SHORT $LN9@iter_set_i
$LN5@iter_set_i:

; 1041 : 		// The Stream has only one group.
; 1042 : 		assert(stream->groups.root == &group->node);
; 1043 : 		assert(group->node.parent == NULL);
; 1044 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_LEFTMOST;

  0009b	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  0009e	c7 82 00 01 00
	00 02 00 00 00	 mov	 DWORD PTR [edx+256], 2

; 1045 : 		iter->internal[ITER_GROUP].p = NULL;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  000ab	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0
$LN9@iter_set_i:

; 1046 : 	}
; 1047 : 
; 1048 : 	// NOTE: lzma_index_iter.stream.number is lzma_vli but we use uint32_t
; 1049 : 	// internally.
; 1050 : 	iter->stream.number = stream->number;

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000b8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000bb	33 c0		 xor	 eax, eax
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  000c0	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000c3	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1051 : 	iter->stream.block_count = stream->record_count;

  000c6	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  000c9	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000cc	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000cf	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  000d2	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  000d5	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 1052 : 	iter->stream.compressed_offset = stream->node.compressed_base;

  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  000db	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000de	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e1	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  000e4	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000e7	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 1053 : 	iter->stream.uncompressed_offset = stream->node.uncompressed_base;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	89 50 28	 mov	 DWORD PTR [eax+40], edx
  000f5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f8	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 1054 : 
; 1055 : 	// iter->stream.flags will be NULL if the Stream Flags haven't been
; 1056 : 	// set with lzma_index_stream_flags().
; 1057 : 	iter->stream.flags = stream->stream_flags.version == UINT32_MAX
; 1058 : 			? NULL : &stream->stream_flags;

  000fb	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000fe	83 7a 50 ff	 cmp	 DWORD PTR [edx+80], -1
  00102	75 09		 jne	 SHORT $LN13@iter_set_i
  00104	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  0010b	eb 09		 jmp	 SHORT $LN14@iter_set_i
$LN13@iter_set_i:
  0010d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00110	83 c0 50	 add	 eax, 80			; 00000050H
  00113	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
$LN14@iter_set_i:
  00116	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00119	8b 55 c8	 mov	 edx, DWORD PTR tv145[ebp]
  0011c	89 11		 mov	 DWORD PTR [ecx], edx

; 1059 : 	iter->stream.padding = stream->stream_padding;

  0011e	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00124	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  0012a	89 50 40	 mov	 DWORD PTR [eax+64], edx
  0012d	8b 89 8c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+140]
  00133	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 1060 : 
; 1061 : 	if (stream->groups.rightmost == NULL) {

  00136	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00139	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0013d	75 57		 jne	 SHORT $LN3@iter_set_i

; 1062 : 		// Stream has no Blocks.
; 1063 : 		iter->stream.compressed_size = index_size(0, 0)
; 1064 : 				+ 2 * LZMA_STREAM_HEADER_SIZE;

  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	e8 00 00 00 00	 call	 _lzma_vli_size
  00148	83 c4 08	 add	 esp, 8
  0014b	83 c0 01	 add	 eax, 1
  0014e	33 c9		 xor	 ecx, ecx
  00150	83 c0 00	 add	 eax, 0
  00153	83 d1 00	 adc	 ecx, 0
  00156	83 c0 04	 add	 eax, 4
  00159	83 d1 00	 adc	 ecx, 0
  0015c	89 45 e4	 mov	 DWORD PTR $T78875[ebp], eax
  0015f	89 4d e8	 mov	 DWORD PTR $T78875[ebp+4], ecx
  00162	8b 55 e4	 mov	 edx, DWORD PTR $T78875[ebp]
  00165	83 c2 03	 add	 edx, 3
  00168	8b 45 e8	 mov	 eax, DWORD PTR $T78875[ebp+4]
  0016b	83 d0 00	 adc	 eax, 0
  0016e	83 e2 fc	 and	 edx, -4			; fffffffcH
  00171	83 c2 18	 add	 edx, 24			; 00000018H
  00174	83 d0 00	 adc	 eax, 0
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0017a	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  0017d	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1065 : 		iter->stream.uncompressed_size = 0;

  00180	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00183	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
  0018a	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 1066 : 	} else {

  00191	e9 aa 00 00 00	 jmp	 $LN2@iter_set_i
$LN3@iter_set_i:

; 1067 : 		const index_group *g = (const index_group *)(
; 1068 : 				stream->groups.rightmost);

  00196	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00199	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0019c	89 4d ec	 mov	 DWORD PTR _g$32733[ebp], ecx

; 1069 : 
; 1070 : 		// Stream Header + Stream Footer + Index + Blocks
; 1071 : 		iter->stream.compressed_size = 2 * LZMA_STREAM_HEADER_SIZE
; 1072 : 				+ index_size(stream->record_count,
; 1073 : 					stream->index_list_size)
; 1074 : 				+ vli_ceil4(g->records[g->last].unpadded_sum);

  0019f	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001a2	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  001a5	89 45 cc	 mov	 DWORD PTR $T78900[ebp], eax
  001a8	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  001ab	89 4d d0	 mov	 DWORD PTR $T78900[ebp+4], ecx
  001ae	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001b1	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  001b4	89 45 d4	 mov	 DWORD PTR $T78899[ebp], eax
  001b7	8b 4a 44	 mov	 ecx, DWORD PTR [edx+68]
  001ba	89 4d d8	 mov	 DWORD PTR $T78899[ebp+4], ecx
  001bd	8b 55 d8	 mov	 edx, DWORD PTR $T78899[ebp+4]
  001c0	52		 push	 edx
  001c1	8b 45 d4	 mov	 eax, DWORD PTR $T78899[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _lzma_vli_size
  001ca	83 c4 08	 add	 esp, 8
  001cd	83 c0 01	 add	 eax, 1
  001d0	33 c9		 xor	 ecx, ecx
  001d2	03 45 cc	 add	 eax, DWORD PTR $T78900[ebp]
  001d5	13 4d d0	 adc	 ecx, DWORD PTR $T78900[ebp+4]
  001d8	83 c0 04	 add	 eax, 4
  001db	83 d1 00	 adc	 ecx, 0
  001de	89 45 dc	 mov	 DWORD PTR $T78889[ebp], eax
  001e1	89 4d e0	 mov	 DWORD PTR $T78889[ebp+4], ecx
  001e4	8b 55 dc	 mov	 edx, DWORD PTR $T78889[ebp]
  001e7	83 c2 03	 add	 edx, 3
  001ea	8b 45 e0	 mov	 eax, DWORD PTR $T78889[ebp+4]
  001ed	83 d0 00	 adc	 eax, 0
  001f0	83 e2 fc	 and	 edx, -4			; fffffffcH
  001f3	83 c2 18	 add	 edx, 24			; 00000018H
  001f6	83 d0 00	 adc	 eax, 0
  001f9	8b 4d ec	 mov	 ecx, DWORD PTR _g$32733[ebp]
  001fc	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  001ff	c1 e1 04	 shl	 ecx, 4
  00202	8b 75 ec	 mov	 esi, DWORD PTR _g$32733[ebp]
  00205	8b 7c 0e 38	 mov	 edi, DWORD PTR [esi+ecx+56]
  00209	83 c7 03	 add	 edi, 3
  0020c	8b 4c 0e 3c	 mov	 ecx, DWORD PTR [esi+ecx+60]
  00210	83 d1 00	 adc	 ecx, 0
  00213	83 e7 fc	 and	 edi, -4			; fffffffcH
  00216	03 d7		 add	 edx, edi
  00218	13 c1		 adc	 eax, ecx
  0021a	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0021d	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00220	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1075 : 		iter->stream.uncompressed_size
; 1076 : 				= g->records[g->last].uncompressed_sum;

  00223	8b 55 ec	 mov	 edx, DWORD PTR _g$32733[ebp]
  00226	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00229	c1 e0 04	 shl	 eax, 4
  0022c	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _g$32733[ebp]
  00232	8b 74 02 30	 mov	 esi, DWORD PTR [edx+eax+48]
  00236	89 71 38	 mov	 DWORD PTR [ecx+56], esi
  00239	8b 44 02 34	 mov	 eax, DWORD PTR [edx+eax+52]
  0023d	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
$LN2@iter_set_i:

; 1077 : 	}
; 1078 : 
; 1079 : 	if (group != NULL) {

  00240	83 7d f4 00	 cmp	 DWORD PTR _group$[ebp], 0
  00244	0f 84 bf 01 00
	00		 je	 $LN11@iter_set_i

; 1080 : 		iter->block.number_in_stream = group->number_base + record;

  0024a	8b 4d f0	 mov	 ecx, DWORD PTR _record$[ebp]
  0024d	33 d2		 xor	 edx, edx
  0024f	8b 45 f4	 mov	 eax, DWORD PTR _group$[ebp]
  00252	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  00255	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00258	13 c2		 adc	 eax, edx
  0025a	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  0025d	89 8a 80 00 00
	00		 mov	 DWORD PTR [edx+128], ecx
  00263	89 82 84 00 00
	00		 mov	 DWORD PTR [edx+132], eax

; 1081 : 		iter->block.number_in_file = iter->block.number_in_stream
; 1082 : 				+ stream->block_number_base;

  00269	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0026c	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0026f	8b 90 80 00 00
	00		 mov	 edx, DWORD PTR [eax+128]
  00275	03 51 28	 add	 edx, DWORD PTR [ecx+40]
  00278	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  0027e	13 41 2c	 adc	 eax, DWORD PTR [ecx+44]
  00281	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00284	89 51 68	 mov	 DWORD PTR [ecx+104], edx
  00287	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 1083 : 
; 1084 : 		iter->block.compressed_stream_offset
; 1085 : 				= record == 0 ? group->node.compressed_base
; 1086 : 				: vli_ceil4(group->records[
; 1087 : 					record - 1].unpadded_sum);

  0028a	83 7d f0 00	 cmp	 DWORD PTR _record$[ebp], 0
  0028e	75 11		 jne	 SHORT $LN33@iter_set_i
  00290	8b 55 f4	 mov	 edx, DWORD PTR _group$[ebp]
  00293	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00296	89 45 c0	 mov	 DWORD PTR tv196[ebp], eax
  00299	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0029c	89 4d c4	 mov	 DWORD PTR tv196[ebp+4], ecx
  0029f	eb 23		 jmp	 SHORT $LN16@iter_set_i
$LN33@iter_set_i:
  002a1	8b 55 f0	 mov	 edx, DWORD PTR _record$[ebp]
  002a4	83 ea 01	 sub	 edx, 1
  002a7	c1 e2 04	 shl	 edx, 4
  002aa	8b 45 f4	 mov	 eax, DWORD PTR _group$[ebp]
  002ad	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  002b1	83 c1 03	 add	 ecx, 3
  002b4	8b 54 10 3c	 mov	 edx, DWORD PTR [eax+edx+60]
  002b8	83 d2 00	 adc	 edx, 0
  002bb	83 e1 fc	 and	 ecx, -4			; fffffffcH
  002be	89 4d c0	 mov	 DWORD PTR tv196[ebp], ecx
  002c1	89 55 c4	 mov	 DWORD PTR tv196[ebp+4], edx
$LN16@iter_set_i:
  002c4	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  002c7	8b 4d c0	 mov	 ecx, DWORD PTR tv196[ebp]
  002ca	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx
  002d0	8b 55 c4	 mov	 edx, DWORD PTR tv196[ebp+4]
  002d3	89 90 8c 00 00
	00		 mov	 DWORD PTR [eax+140], edx

; 1088 : 		iter->block.uncompressed_stream_offset
; 1089 : 				= record == 0 ? group->node.uncompressed_base
; 1090 : 				: group->records[record - 1].uncompressed_sum;

  002d9	83 7d f0 00	 cmp	 DWORD PTR _record$[ebp], 0
  002dd	75 10		 jne	 SHORT $LN17@iter_set_i
  002df	8b 45 f4	 mov	 eax, DWORD PTR _group$[ebp]
  002e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e4	89 4d b8	 mov	 DWORD PTR tv203[ebp], ecx
  002e7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002ea	89 55 bc	 mov	 DWORD PTR tv203[ebp+4], edx
  002ed	eb 1a		 jmp	 SHORT $LN18@iter_set_i
$LN17@iter_set_i:
  002ef	8b 45 f0	 mov	 eax, DWORD PTR _record$[ebp]
  002f2	83 e8 01	 sub	 eax, 1
  002f5	c1 e0 04	 shl	 eax, 4
  002f8	8b 4d f4	 mov	 ecx, DWORD PTR _group$[ebp]
  002fb	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  002ff	89 55 b8	 mov	 DWORD PTR tv203[ebp], edx
  00302	8b 44 01 34	 mov	 eax, DWORD PTR [ecx+eax+52]
  00306	89 45 bc	 mov	 DWORD PTR tv203[ebp+4], eax
$LN18@iter_set_i:
  00309	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0030c	8b 55 b8	 mov	 edx, DWORD PTR tv203[ebp]
  0030f	89 91 90 00 00
	00		 mov	 DWORD PTR [ecx+144], edx
  00315	8b 45 bc	 mov	 eax, DWORD PTR tv203[ebp+4]
  00318	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 1091 : 
; 1092 : 		iter->block.uncompressed_size
; 1093 : 				= group->records[record].uncompressed_sum
; 1094 : 				- iter->block.uncompressed_stream_offset;

  0031e	8b 4d f0	 mov	 ecx, DWORD PTR _record$[ebp]
  00321	c1 e1 04	 shl	 ecx, 4
  00324	8b 55 f4	 mov	 edx, DWORD PTR _group$[ebp]
  00327	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0032a	8b 74 0a 30	 mov	 esi, DWORD PTR [edx+ecx+48]
  0032e	2b b0 90 00 00
	00		 sub	 esi, DWORD PTR [eax+144]
  00334	8b 4c 0a 34	 mov	 ecx, DWORD PTR [edx+ecx+52]
  00338	1b 88 94 00 00
	00		 sbb	 ecx, DWORD PTR [eax+148]
  0033e	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00341	89 b2 98 00 00
	00		 mov	 DWORD PTR [edx+152], esi
  00347	89 8a 9c 00 00
	00		 mov	 DWORD PTR [edx+156], ecx

; 1095 : 		iter->block.unpadded_size
; 1096 : 				= group->records[record].unpadded_sum
; 1097 : 				- iter->block.compressed_stream_offset;

  0034d	8b 45 f0	 mov	 eax, DWORD PTR _record$[ebp]
  00350	c1 e0 04	 shl	 eax, 4
  00353	8b 4d f4	 mov	 ecx, DWORD PTR _group$[ebp]
  00356	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00359	8b 74 01 38	 mov	 esi, DWORD PTR [ecx+eax+56]
  0035d	2b b2 88 00 00
	00		 sub	 esi, DWORD PTR [edx+136]
  00363	8b 44 01 3c	 mov	 eax, DWORD PTR [ecx+eax+60]
  00367	1b 82 8c 00 00
	00		 sbb	 eax, DWORD PTR [edx+140]
  0036d	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00370	89 b1 a0 00 00
	00		 mov	 DWORD PTR [ecx+160], esi
  00376	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax

; 1098 : 		iter->block.total_size = vli_ceil4(iter->block.unpadded_size);

  0037c	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  0037f	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00385	83 c0 03	 add	 eax, 3
  00388	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  0038e	83 d1 00	 adc	 ecx, 0
  00391	83 e0 fc	 and	 eax, -4			; fffffffcH
  00394	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00397	89 82 a8 00 00
	00		 mov	 DWORD PTR [edx+168], eax
  0039d	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 1099 : 
; 1100 : 		iter->block.compressed_stream_offset
; 1101 : 				+= LZMA_STREAM_HEADER_SIZE;

  003a3	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  003a6	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  003ac	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003af	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  003b5	83 d2 00	 adc	 edx, 0
  003b8	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  003bb	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx
  003c1	89 90 8c 00 00
	00		 mov	 DWORD PTR [eax+140], edx

; 1102 : 
; 1103 : 		iter->block.compressed_file_offset
; 1104 : 				= iter->block.compressed_stream_offset
; 1105 : 				+ iter->stream.compressed_offset;

  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  003ca	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  003cd	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  003d3	03 42 20	 add	 eax, DWORD PTR [edx+32]
  003d6	8b 89 8c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+140]
  003dc	13 4a 24	 adc	 ecx, DWORD PTR [edx+36]
  003df	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  003e2	89 42 70	 mov	 DWORD PTR [edx+112], eax
  003e5	89 4a 74	 mov	 DWORD PTR [edx+116], ecx

; 1106 : 		iter->block.uncompressed_file_offset
; 1107 : 				= iter->block.uncompressed_stream_offset
; 1108 : 				+ iter->stream.uncompressed_offset;

  003e8	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  003eb	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  003ee	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  003f4	03 51 28	 add	 edx, DWORD PTR [ecx+40]
  003f7	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  003fd	13 41 2c	 adc	 eax, DWORD PTR [ecx+44]
  00400	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00403	89 51 78	 mov	 DWORD PTR [ecx+120], edx
  00406	89 41 7c	 mov	 DWORD PTR [ecx+124], eax
$LN11@iter_set_i:

; 1109 : 	}
; 1110 : 
; 1111 : 	return;
; 1112 : }

  00409	5f		 pop	 edi
  0040a	5e		 pop	 esi
  0040b	8b e5		 mov	 esp, ebp
  0040d	5d		 pop	 ebp
  0040e	c3		 ret	 0
_iter_set_info ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_cat_helper
_TEXT	SEGMENT
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_info$ = 8						; size = 4
_this$ = 12						; size = 4
_index_cat_helper PROC					; COMDAT

; 759  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 760  : 	index_stream *left = (index_stream *)(this->node.left);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  00009	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000c	89 4d fc	 mov	 DWORD PTR _left$[ebp], ecx

; 761  : 	index_stream *right = (index_stream *)(this->node.right);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00015	89 45 f8	 mov	 DWORD PTR _right$[ebp], eax

; 762  : 
; 763  : 	if (left != NULL)

  00018	83 7d fc 00	 cmp	 DWORD PTR _left$[ebp], 0
  0001c	74 10		 je	 SHORT $LN2@index_cat_

; 764  : 		index_cat_helper(info, left);

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _left$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _index_cat_helper
  0002b	83 c4 08	 add	 esp, 8
$LN2@index_cat_:

; 765  : 
; 766  : 	this->node.uncompressed_base += info->uncompressed_size;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	03 11		 add	 edx, DWORD PTR [ecx]
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	13 41 04	 adc	 eax, DWORD PTR [ecx+4]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	89 11		 mov	 DWORD PTR [ecx], edx
  00043	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 767  : 	this->node.compressed_base += info->file_size;

  00046	8b 55 0c	 mov	 edx, DWORD PTR _this$[ebp]
  00049	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0004c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0004f	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  00052	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00055	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  00058	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0005e	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 768  : 	this->number += info->stream_number_add;

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00067	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0006a	03 50 18	 add	 edx, DWORD PTR [eax+24]
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 769  : 	this->block_number_base += info->block_number_add;

  00073	8b 55 0c	 mov	 edx, DWORD PTR _this$[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00079	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0007c	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  0007f	8b 52 2c	 mov	 edx, DWORD PTR [edx+44]
  00082	13 50 14	 adc	 edx, DWORD PTR [eax+20]
  00085	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  00088	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  0008b	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 770  : 	index_tree_append(info->streams, &this->node);

  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00095	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _index_tree_append
  0009e	83 c4 08	 add	 esp, 8

; 771  : 
; 772  : 	if (right != NULL)

  000a1	83 7d f8 00	 cmp	 DWORD PTR _right$[ebp], 0
  000a5	74 10		 je	 SHORT $LN3@index_cat_

; 773  : 		index_cat_helper(info, right);

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _right$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 _index_cat_helper
  000b4	83 c4 08	 add	 esp, 8
$LN3@index_cat_:

; 774  : 
; 775  : 	return;
; 776  : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_index_cat_helper ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_stream_flags
; Function compile flags: /Odtp
;	COMDAT _lzma_index_stream_flags
_TEXT	SEGMENT
_s$32544 = -8						; size = 4
_ret_$32542 = -4					; size = 4
_i$ = 8							; size = 4
_stream_flags$ = 12					; size = 4
_lzma_index_stream_flags PROC				; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 609  : 	if (i == NULL || stream_flags == NULL)

  00008	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  0000c	74 06		 je	 SHORT $LN5@lzma_index@5
  0000e	83 7d 0c 00	 cmp	 DWORD PTR _stream_flags$[ebp], 0
  00012	75 07		 jne	 SHORT $LN4@lzma_index@5
$LN5@lzma_index@5:

; 610  : 		return LZMA_PROG_ERROR;

  00014	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00019	eb 3d		 jmp	 SHORT $LN7@lzma_index@5
$LN4@lzma_index@5:

; 611  : 
; 612  : 	// Validate the Stream Flags.
; 613  : 	return_if_error(lzma_stream_flags_compare(
; 614  : 			stream_flags, stream_flags));

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _stream_flags$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _stream_flags$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 _lzma_stream_flags_compare
  00028	83 c4 08	 add	 esp, 8
  0002b	89 45 fc	 mov	 DWORD PTR _ret_$32542[ebp], eax
  0002e	83 7d fc 00	 cmp	 DWORD PTR _ret_$32542[ebp], 0
  00032	74 05		 je	 SHORT $LN3@lzma_index@5
  00034	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32542[ebp]
  00037	eb 1f		 jmp	 SHORT $LN7@lzma_index@5
$LN3@lzma_index@5:
  00039	33 d2		 xor	 edx, edx
  0003b	75 de		 jne	 SHORT $LN4@lzma_index@5

; 615  : 
; 616  :   {
; 617  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00040	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00043	89 4d f8	 mov	 DWORD PTR _s$32544[ebp], ecx

; 618  : 	s->stream_flags = *stream_flags;

  00046	8b 75 0c	 mov	 esi, DWORD PTR _stream_flags$[ebp]
  00049	8b 7d f8	 mov	 edi, DWORD PTR _s$32544[ebp]
  0004c	83 c7 50	 add	 edi, 80			; 00000050H
  0004f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00054	f3 a5		 rep movsd

; 619  :   }
; 620  : 
; 621  : 	return LZMA_OK;

  00056	33 c0		 xor	 eax, eax
$LN7@lzma_index@5:

; 622  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_lzma_index_stream_flags ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_file_size
_TEXT	SEGMENT
$T78920 = -16						; size = 8
_file_size$ = -8					; size = 8
_compressed_base$ = 8					; size = 8
_unpadded_sum$ = 16					; size = 8
_record_count$ = 24					; size = 8
_index_list_size$ = 32					; size = 8
_stream_padding$ = 40					; size = 8
_index_file_size PROC					; COMDAT

; 545  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 546  : 	// Earlier Streams and Stream Paddings + Stream Header
; 547  : 	// + Blocks + Index + Stream Footer + Stream Padding
; 548  : 	//
; 549  : 	// This might go over LZMA_VLI_MAX due to too big unpadded_sum
; 550  : 	// when this function is used in lzma_index_append().
; 551  : 	lzma_vli file_size = compressed_base + 2 * LZMA_STREAM_HEADER_SIZE
; 552  : 			+ stream_padding + vli_ceil4(unpadded_sum);

  00007	8b 45 08	 mov	 eax, DWORD PTR _compressed_base$[ebp]
  0000a	83 c0 18	 add	 eax, 24			; 00000018H
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _compressed_base$[ebp+4]
  00010	83 d1 00	 adc	 ecx, 0
  00013	03 45 28	 add	 eax, DWORD PTR _stream_padding$[ebp]
  00016	13 4d 2c	 adc	 ecx, DWORD PTR _stream_padding$[ebp+4]
  00019	8b 55 10	 mov	 edx, DWORD PTR _unpadded_sum$[ebp]
  0001c	83 c2 03	 add	 edx, 3
  0001f	8b 75 14	 mov	 esi, DWORD PTR _unpadded_sum$[ebp+4]
  00022	83 d6 00	 adc	 esi, 0
  00025	83 e2 fc	 and	 edx, -4			; fffffffcH
  00028	03 c2		 add	 eax, edx
  0002a	13 ce		 adc	 ecx, esi
  0002c	89 45 f8	 mov	 DWORD PTR _file_size$[ebp], eax
  0002f	89 4d fc	 mov	 DWORD PTR _file_size$[ebp+4], ecx

; 553  : 	if (file_size > LZMA_VLI_MAX)

  00032	81 7d fc ff ff
	ff 7f		 cmp	 DWORD PTR _file_size$[ebp+4], 2147483647 ; 7fffffffH
  00039	72 10		 jb	 SHORT $LN2@index_file
  0003b	77 06		 ja	 SHORT $LN13@index_file
  0003d	83 7d f8 ff	 cmp	 DWORD PTR _file_size$[ebp], -1
  00041	76 08		 jbe	 SHORT $LN2@index_file
$LN13@index_file:

; 554  : 		return LZMA_VLI_UNKNOWN;

  00043	83 c8 ff	 or	 eax, -1
  00046	83 ca ff	 or	 edx, -1
  00049	eb 63		 jmp	 SHORT $LN3@index_file
$LN2@index_file:

; 555  : 
; 556  : 	// The same applies here.
; 557  : 	file_size += index_size(record_count, index_list_size);

  0004b	8b 45 1c	 mov	 eax, DWORD PTR _record_count$[ebp+4]
  0004e	50		 push	 eax
  0004f	8b 4d 18	 mov	 ecx, DWORD PTR _record_count$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _lzma_vli_size
  00058	83 c4 08	 add	 esp, 8
  0005b	83 c0 01	 add	 eax, 1
  0005e	33 d2		 xor	 edx, edx
  00060	03 45 20	 add	 eax, DWORD PTR _index_list_size$[ebp]
  00063	13 55 24	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  00066	83 c0 04	 add	 eax, 4
  00069	83 d2 00	 adc	 edx, 0
  0006c	89 45 f0	 mov	 DWORD PTR $T78920[ebp], eax
  0006f	89 55 f4	 mov	 DWORD PTR $T78920[ebp+4], edx
  00072	8b 45 f0	 mov	 eax, DWORD PTR $T78920[ebp]
  00075	83 c0 03	 add	 eax, 3
  00078	8b 4d f4	 mov	 ecx, DWORD PTR $T78920[ebp+4]
  0007b	83 d1 00	 adc	 ecx, 0
  0007e	83 e0 fc	 and	 eax, -4			; fffffffcH
  00081	03 45 f8	 add	 eax, DWORD PTR _file_size$[ebp]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _file_size$[ebp+4]
  00087	13 d1		 adc	 edx, ecx
  00089	89 45 f8	 mov	 DWORD PTR _file_size$[ebp], eax
  0008c	89 55 fc	 mov	 DWORD PTR _file_size$[ebp+4], edx

; 558  : 	if (file_size > LZMA_VLI_MAX)

  0008f	81 7d fc ff ff
	ff 7f		 cmp	 DWORD PTR _file_size$[ebp+4], 2147483647 ; 7fffffffH
  00096	72 10		 jb	 SHORT $LN1@index_file
  00098	77 06		 ja	 SHORT $LN14@index_file
  0009a	83 7d f8 ff	 cmp	 DWORD PTR _file_size$[ebp], -1
  0009e	76 08		 jbe	 SHORT $LN1@index_file
$LN14@index_file:

; 559  : 		return LZMA_VLI_UNKNOWN;

  000a0	83 c8 ff	 or	 eax, -1
  000a3	83 ca ff	 or	 edx, -1
  000a6	eb 06		 jmp	 SHORT $LN3@index_file
$LN1@index_file:

; 560  : 
; 561  : 	return file_size;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _file_size$[ebp]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _file_size$[ebp+4]
$LN3@index_file:

; 562  : }

  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_index_file_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_size
; Function compile flags: /Odtp
;	COMDAT _lzma_index_size
_TEXT	SEGMENT
$T78948 = -24						; size = 8
$T78947 = -16						; size = 8
$T78937 = -8						; size = 8
_i$ = 8							; size = 4
_lzma_index_size PROC					; COMDAT

; 519  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 520  : 	return index_size(i->record_count, i->index_list_size);

  00006	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00009	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000c	89 4d e8	 mov	 DWORD PTR $T78948[ebp], ecx
  0000f	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00012	89 55 ec	 mov	 DWORD PTR $T78948[ebp+4], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00018	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001b	89 4d f0	 mov	 DWORD PTR $T78947[ebp], ecx
  0001e	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00021	89 55 f4	 mov	 DWORD PTR $T78947[ebp+4], edx
  00024	8b 45 f4	 mov	 eax, DWORD PTR $T78947[ebp+4]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T78947[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _lzma_vli_size
  00031	83 c4 08	 add	 esp, 8
  00034	83 c0 01	 add	 eax, 1
  00037	33 d2		 xor	 edx, edx
  00039	03 45 e8	 add	 eax, DWORD PTR $T78948[ebp]
  0003c	13 55 ec	 adc	 edx, DWORD PTR $T78948[ebp+4]
  0003f	83 c0 04	 add	 eax, 4
  00042	83 d2 00	 adc	 edx, 0
  00045	89 45 f8	 mov	 DWORD PTR $T78937[ebp], eax
  00048	89 55 fc	 mov	 DWORD PTR $T78937[ebp+4], edx
  0004b	8b 45 f8	 mov	 eax, DWORD PTR $T78937[ebp]
  0004e	83 c0 03	 add	 eax, 3
  00051	8b 55 fc	 mov	 edx, DWORD PTR $T78937[ebp+4]
  00054	83 d2 00	 adc	 edx, 0
  00057	83 e0 fc	 and	 eax, -4			; fffffffcH

; 521  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_lzma_index_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_init
; Function compile flags: /Odtp
;	COMDAT _lzma_index_init
_TEXT	SEGMENT
_s$32433 = -8						; size = 4
_i$ = -4						; size = 4
_allocator$ = 8						; size = 4
_lzma_index_init PROC					; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 404  : 	lzma_index *i = index_init_plain(allocator);

  00006	8b 45 08	 mov	 eax, DWORD PTR _allocator$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _index_init_plain
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 405  : 	if (i == NULL)

  00015	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00019	75 04		 jne	 SHORT $LN2@lzma_index@6

; 406  : 		return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 4a		 jmp	 SHORT $LN3@lzma_index@6
$LN2@lzma_index@6:

; 407  : 
; 408  :   {
; 409  : 	index_stream *s = index_stream_init(0, 0, 1, 0, allocator);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 01		 push	 1
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 _index_stream_init
  00036	83 c4 20	 add	 esp, 32			; 00000020H
  00039	89 45 f8	 mov	 DWORD PTR _s$32433[ebp], eax

; 410  : 	if (s == NULL) {

  0003c	83 7d f8 00	 cmp	 DWORD PTR _s$32433[ebp], 0
  00040	75 14		 jne	 SHORT $LN1@lzma_index@6

; 411  : 		lzma_free(i, allocator);

  00042	8b 55 08	 mov	 edx, DWORD PTR _allocator$[ebp]
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _lzma_free
  0004f	83 c4 08	 add	 esp, 8

; 412  : 		return NULL;

  00052	33 c0		 xor	 eax, eax
  00054	eb 13		 jmp	 SHORT $LN3@lzma_index@6
$LN1@lzma_index@6:

; 413  : 	}
; 414  : 
; 415  : 	index_tree_append(&i->streams, &s->node);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _s$32433[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _index_tree_append
  00063	83 c4 08	 add	 esp, 8

; 416  :   }
; 417  : 
; 418  : 	return i;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
$LN3@lzma_index@6:

; 419  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_lzma_index_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_stream_end
_TEXT	SEGMENT
_s$ = -4						; size = 4
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_index_stream_end PROC					; COMDAT

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 376  : 	index_stream *s = node;

  00004	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 377  : 	index_tree_end(&s->groups, allocator, &lzma_free);

  0000a	68 00 00 00 00	 push	 OFFSET _lzma_free
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00016	83 c2 30	 add	 edx, 48			; 00000030H
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 _index_tree_end
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 	lzma_free(s, allocator);

  00022	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 _lzma_free
  0002f	83 c4 08	 add	 esp, 8

; 379  : 	return;
; 380  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_index_stream_end ENDP
PUBLIC	_lzma_index_iter_next
; Function compile flags: /Odtp
;	COMDAT _lzma_index_iter_next
_TEXT	SEGMENT
tv224 = -44						; size = 4
tv223 = -40						; size = 4
tv222 = -36						; size = 4
tv221 = -32						; size = 4
tv209 = -28						; size = 4
tv208 = -24						; size = 4
tv78 = -20						; size = 4
_record$32758 = -16					; size = 4
_group$32756 = -12					; size = 4
_i$32754 = -8						; size = 4
_stream$32755 = -4					; size = 4
_iter$ = 8						; size = 4
_mode$ = 12						; size = 4
_lzma_index_iter_next PROC				; COMDAT

; 1137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 1138 : 	// Catch unsupported mode values.
; 1139 : 	if ((unsigned int)(mode) > LZMA_INDEX_ITER_NONEMPTY_BLOCK)

  00007	83 7d 0c 03	 cmp	 DWORD PTR _mode$[ebp], 3
  0000b	76 07		 jbe	 SHORT $LN27@lzma_index@7

; 1140 : 		return true;

  0000d	b0 01		 mov	 al, 1
  0000f	e9 01 02 00 00	 jmp	 $LN28@lzma_index@7
$LN27@lzma_index@7:

; 1141 : 
; 1142 :   {
; 1143 : 	const lzma_index *i = iter->internal[ITER_INDEX].p;

  00014	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00017	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0001d	89 4d f8	 mov	 DWORD PTR _i$32754[ebp], ecx

; 1144 : 	const index_stream *stream = iter->internal[ITER_STREAM].p;

  00020	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00023	8b 82 e8 00 00
	00		 mov	 eax, DWORD PTR [edx+232]
  00029	89 45 fc	 mov	 DWORD PTR _stream$32755[ebp], eax

; 1145 : 	const index_group *group = NULL;

  0002c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _group$32756[ebp], 0

; 1146 : 	size_t record = iter->internal[ITER_RECORD].s;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00036	8b 91 f8 00 00
	00		 mov	 edx, DWORD PTR [ecx+248]
  0003c	89 55 f0	 mov	 DWORD PTR _record$32758[ebp], edx

; 1147 : 
; 1148 : 	// If we are being asked for the next Stream, leave group to NULL
; 1149 : 	// so that the rest of the this function thinks that this Stream
; 1150 : 	// has no groups and will thus go to the next Stream.
; 1151 : 	if (mode != LZMA_INDEX_ITER_STREAM) {

  0003f	83 7d 0c 01	 cmp	 DWORD PTR _mode$[ebp], 1
  00043	74 4e		 je	 SHORT $again$32768

; 1152 : 		// Get the pointer to the current group. See iter_set_inf()
; 1153 : 		// for explanation.
; 1154 : 		switch (iter->internal[ITER_METHOD].s) {

  00045	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00048	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  0004e	89 4d ec	 mov	 DWORD PTR tv78[ebp], ecx
  00051	83 7d ec 00	 cmp	 DWORD PTR tv78[ebp], 0
  00055	74 0e		 je	 SHORT $LN23@lzma_index@7
  00057	83 7d ec 01	 cmp	 DWORD PTR tv78[ebp], 1
  0005b	74 16		 je	 SHORT $LN22@lzma_index@7
  0005d	83 7d ec 02	 cmp	 DWORD PTR tv78[ebp], 2
  00061	74 27		 je	 SHORT $LN21@lzma_index@7
  00063	eb 2e		 jmp	 SHORT $again$32768
$LN23@lzma_index@7:

; 1155 : 		case ITER_METHOD_NORMAL:
; 1156 : 			group = iter->internal[ITER_GROUP].p;

  00065	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00068	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  0006e	89 45 f4	 mov	 DWORD PTR _group$32756[ebp], eax

; 1157 : 			break;

  00071	eb 20		 jmp	 SHORT $again$32768
$LN22@lzma_index@7:

; 1158 : 
; 1159 : 		case ITER_METHOD_NEXT:
; 1160 : 			group = index_tree_next(iter->internal[ITER_GROUP].p);

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00076	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _index_tree_next
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 f4	 mov	 DWORD PTR _group$32756[ebp], eax

; 1161 : 			break;

  00088	eb 09		 jmp	 SHORT $again$32768
$LN21@lzma_index@7:

; 1162 : 
; 1163 : 		case ITER_METHOD_LEFTMOST:
; 1164 : 			group = (const index_group *)(
; 1165 : 					stream->groups.leftmost);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _stream$32755[ebp]
  0008d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00090	89 4d f4	 mov	 DWORD PTR _group$32756[ebp], ecx
$again$32768:

; 1166 : 			break;
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : again:
; 1171 : 	if (stream == NULL) {

  00093	83 7d fc 00	 cmp	 DWORD PTR _stream$32755[ebp], 0
  00097	75 48		 jne	 SHORT $LN20@lzma_index@7

; 1172 : 		// We at the beginning of the lzma_index.
; 1173 : 		// Locate the first Stream.
; 1174 : 		stream = (const index_stream *)(i->streams.leftmost);

  00099	8b 55 f8	 mov	 edx, DWORD PTR _i$32754[ebp]
  0009c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009f	89 45 fc	 mov	 DWORD PTR _stream$32755[ebp], eax

; 1175 : 		if (mode >= LZMA_INDEX_ITER_BLOCK) {

  000a2	83 7d 0c 02	 cmp	 DWORD PTR _mode$[ebp], 2
  000a6	7c 27		 jl	 SHORT $LN19@lzma_index@7
$LN18@lzma_index@7:

; 1176 : 			// Since we are being asked to return information
; 1177 : 			// about the first a Block, skip Streams that have
; 1178 : 			// no Blocks.
; 1179 : 			while (stream->groups.leftmost == NULL) {

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _stream$32755[ebp]
  000ab	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  000af	75 1e		 jne	 SHORT $LN19@lzma_index@7

; 1180 : 				stream = index_tree_next(&stream->node);

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _stream$32755[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 _index_tree_next
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 fc	 mov	 DWORD PTR _stream$32755[ebp], eax

; 1181 : 				if (stream == NULL)

  000c0	83 7d fc 00	 cmp	 DWORD PTR _stream$32755[ebp], 0
  000c4	75 07		 jne	 SHORT $LN16@lzma_index@7

; 1182 : 					return true;

  000c6	b0 01		 mov	 al, 1
  000c8	e9 48 01 00 00	 jmp	 $LN28@lzma_index@7
$LN16@lzma_index@7:

; 1183 : 			}

  000cd	eb d9		 jmp	 SHORT $LN18@lzma_index@7
$LN19@lzma_index@7:

; 1184 : 		}
; 1185 : 
; 1186 : 		// Start from the first Record in the Stream.
; 1187 : 		group = (const index_group *)(stream->groups.leftmost);

  000cf	8b 45 fc	 mov	 eax, DWORD PTR _stream$32755[ebp]
  000d2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d5	89 4d f4	 mov	 DWORD PTR _group$32756[ebp], ecx

; 1188 : 		record = 0;

  000d8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _record$32758[ebp], 0
  000df	eb 72		 jmp	 SHORT $LN15@lzma_index@7
$LN20@lzma_index@7:

; 1189 : 
; 1190 : 	} else if (group != NULL && record < group->last) {

  000e1	83 7d f4 00	 cmp	 DWORD PTR _group$32756[ebp], 0
  000e5	74 16		 je	 SHORT $LN14@lzma_index@7
  000e7	8b 55 f4	 mov	 edx, DWORD PTR _group$32756[ebp]
  000ea	8b 45 f0	 mov	 eax, DWORD PTR _record$32758[ebp]
  000ed	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  000f0	73 0b		 jae	 SHORT $LN14@lzma_index@7

; 1191 : 		// The next Record is in the same group.
; 1192 : 		++record;

  000f2	8b 4d f0	 mov	 ecx, DWORD PTR _record$32758[ebp]
  000f5	83 c1 01	 add	 ecx, 1
  000f8	89 4d f0	 mov	 DWORD PTR _record$32758[ebp], ecx

; 1193 : 
; 1194 : 	} else {

  000fb	eb 56		 jmp	 SHORT $LN15@lzma_index@7
$LN14@lzma_index@7:

; 1195 : 		// This group has no more Records or this Stream has
; 1196 : 		// no Blocks at all.
; 1197 : 		record = 0;

  000fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _record$32758[ebp], 0

; 1198 : 
; 1199 : 		// If group is not NULL, this Stream has at least one Block
; 1200 : 		// and thus at least one group. Find the next group.
; 1201 : 		if (group != NULL)

  00104	83 7d f4 00	 cmp	 DWORD PTR _group$32756[ebp], 0
  00108	74 0f		 je	 SHORT $LN12@lzma_index@7

; 1202 : 			group = index_tree_next(&group->node);

  0010a	8b 55 f4	 mov	 edx, DWORD PTR _group$32756[ebp]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _index_tree_next
  00113	83 c4 04	 add	 esp, 4
  00116	89 45 f4	 mov	 DWORD PTR _group$32756[ebp], eax
$LN12@lzma_index@7:

; 1203 : 
; 1204 : 		if (group == NULL) {

  00119	83 7d f4 00	 cmp	 DWORD PTR _group$32756[ebp], 0
  0011d	75 34		 jne	 SHORT $LN15@lzma_index@7
$LN10@lzma_index@7:

; 1205 : 			// This Stream has no more Records. Find the next
; 1206 : 			// Stream. If we are being asked to return information
; 1207 : 			// about a Block, we skip empty Streams.
; 1208 : 			do {
; 1209 : 				stream = index_tree_next(&stream->node);

  0011f	8b 45 fc	 mov	 eax, DWORD PTR _stream$32755[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _index_tree_next
  00128	83 c4 04	 add	 esp, 4
  0012b	89 45 fc	 mov	 DWORD PTR _stream$32755[ebp], eax

; 1210 : 				if (stream == NULL)

  0012e	83 7d fc 00	 cmp	 DWORD PTR _stream$32755[ebp], 0
  00132	75 07		 jne	 SHORT $LN9@lzma_index@7

; 1211 : 					return true;

  00134	b0 01		 mov	 al, 1
  00136	e9 da 00 00 00	 jmp	 $LN28@lzma_index@7
$LN9@lzma_index@7:

; 1212 : 			} while (mode >= LZMA_INDEX_ITER_BLOCK
; 1213 : 					&& stream->groups.leftmost == NULL);

  0013b	83 7d 0c 02	 cmp	 DWORD PTR _mode$[ebp], 2
  0013f	7c 09		 jl	 SHORT $LN8@lzma_index@7
  00141	8b 4d fc	 mov	 ecx, DWORD PTR _stream$32755[ebp]
  00144	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00148	74 d5		 je	 SHORT $LN10@lzma_index@7
$LN8@lzma_index@7:

; 1214 : 
; 1215 : 			group = (const index_group *)(
; 1216 : 					stream->groups.leftmost);

  0014a	8b 55 fc	 mov	 edx, DWORD PTR _stream$32755[ebp]
  0014d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00150	89 45 f4	 mov	 DWORD PTR _group$32756[ebp], eax
$LN15@lzma_index@7:

; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	if (mode == LZMA_INDEX_ITER_NONEMPTY_BLOCK) {

  00153	83 7d 0c 03	 cmp	 DWORD PTR _mode$[ebp], 3
  00157	0f 85 86 00 00
	00		 jne	 $LN5@lzma_index@7

; 1221 : 		// We need to look for the next Block again if this Block
; 1222 : 		// is empty.
; 1223 : 		if (record == 0) {

  0015d	83 7d f0 00	 cmp	 DWORD PTR _record$32758[ebp], 0
  00161	75 2e		 jne	 SHORT $LN4@lzma_index@7

; 1224 : 			if (group->node.uncompressed_base
; 1225 : 					== group->records[0].uncompressed_sum)

  00163	8b 4d f4	 mov	 ecx, DWORD PTR _group$32756[ebp]
  00166	8b 55 f4	 mov	 edx, DWORD PTR _group$32756[ebp]
  00169	89 4d e8	 mov	 DWORD PTR tv208[ebp], ecx
  0016c	89 55 e4	 mov	 DWORD PTR tv209[ebp], edx
  0016f	8b 45 e8	 mov	 eax, DWORD PTR tv208[ebp]
  00172	8b 4d e4	 mov	 ecx, DWORD PTR tv209[ebp]
  00175	8b 10		 mov	 edx, DWORD PTR [eax]
  00177	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  0017a	75 13		 jne	 SHORT $LN3@lzma_index@7
  0017c	8b 45 e8	 mov	 eax, DWORD PTR tv208[ebp]
  0017f	8b 4d e4	 mov	 ecx, DWORD PTR tv209[ebp]
  00182	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00185	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  00188	75 05		 jne	 SHORT $LN3@lzma_index@7

; 1226 : 				goto again;

  0018a	e9 04 ff ff ff	 jmp	 $again$32768
$LN3@lzma_index@7:

; 1227 : 		} else if (group->records[record - 1].uncompressed_sum

  0018f	eb 52		 jmp	 SHORT $LN5@lzma_index@7
$LN4@lzma_index@7:

; 1228 : 				== group->records[record].uncompressed_sum) {

  00191	8b 45 f0	 mov	 eax, DWORD PTR _record$32758[ebp]
  00194	83 e8 01	 sub	 eax, 1
  00197	c1 e0 04	 shl	 eax, 4
  0019a	8b 4d f0	 mov	 ecx, DWORD PTR _record$32758[ebp]
  0019d	c1 e1 04	 shl	 ecx, 4
  001a0	8b 55 f4	 mov	 edx, DWORD PTR _group$32756[ebp]
  001a3	8b 75 f4	 mov	 esi, DWORD PTR _group$32756[ebp]
  001a6	89 55 e0	 mov	 DWORD PTR tv221[ebp], edx
  001a9	89 45 dc	 mov	 DWORD PTR tv222[ebp], eax
  001ac	89 75 d8	 mov	 DWORD PTR tv223[ebp], esi
  001af	89 4d d4	 mov	 DWORD PTR tv224[ebp], ecx
  001b2	8b 45 dc	 mov	 eax, DWORD PTR tv222[ebp]
  001b5	8b 4d e0	 mov	 ecx, DWORD PTR tv221[ebp]
  001b8	8b 55 d4	 mov	 edx, DWORD PTR tv224[ebp]
  001bb	8b 75 d8	 mov	 esi, DWORD PTR tv223[ebp]
  001be	8b 44 01 30	 mov	 eax, DWORD PTR [ecx+eax+48]
  001c2	3b 44 16 30	 cmp	 eax, DWORD PTR [esi+edx+48]
  001c6	75 1b		 jne	 SHORT $LN5@lzma_index@7
  001c8	8b 4d dc	 mov	 ecx, DWORD PTR tv222[ebp]
  001cb	8b 55 e0	 mov	 edx, DWORD PTR tv221[ebp]
  001ce	8b 45 d4	 mov	 eax, DWORD PTR tv224[ebp]
  001d1	8b 75 d8	 mov	 esi, DWORD PTR tv223[ebp]
  001d4	8b 4c 0a 34	 mov	 ecx, DWORD PTR [edx+ecx+52]
  001d8	3b 4c 06 34	 cmp	 ecx, DWORD PTR [esi+eax+52]
  001dc	75 05		 jne	 SHORT $LN5@lzma_index@7

; 1229 : 			goto again;

  001de	e9 b0 fe ff ff	 jmp	 $again$32768
$LN5@lzma_index@7:

; 1230 : 		}
; 1231 : 	}
; 1232 : 
; 1233 : 	iter->internal[ITER_STREAM].p = stream;

  001e3	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  001e6	8b 45 fc	 mov	 eax, DWORD PTR _stream$32755[ebp]
  001e9	89 82 e8 00 00
	00		 mov	 DWORD PTR [edx+232], eax

; 1234 : 	iter->internal[ITER_GROUP].p = group;

  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  001f2	8b 55 f4	 mov	 edx, DWORD PTR _group$32756[ebp]
  001f5	89 91 f0 00 00
	00		 mov	 DWORD PTR [ecx+240], edx

; 1235 : 	iter->internal[ITER_RECORD].s = record;

  001fb	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  001fe	8b 4d f0	 mov	 ecx, DWORD PTR _record$32758[ebp]
  00201	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx

; 1236 : 
; 1237 : 	iter_set_info(iter);

  00207	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  0020a	52		 push	 edx
  0020b	e8 00 00 00 00	 call	 _iter_set_info
  00210	83 c4 04	 add	 esp, 4

; 1238 :   }
; 1239 : 
; 1240 : 	return false;

  00213	32 c0		 xor	 al, al
$LN28@lzma_index@7:

; 1241 : }

  00215	5e		 pop	 esi
  00216	8b e5		 mov	 esp, ebp
  00218	5d		 pop	 ebp
  00219	c3		 ret	 0
_lzma_index_iter_next ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_append
; Function compile flags: /Odtp
;	COMDAT _lzma_index_append
_TEXT	SEGMENT
tv349 = -84						; size = 8
tv307 = -76						; size = 8
tv84 = -68						; size = 8
tv78 = -60						; size = 8
$T79426 = -52						; size = 8
$T79425 = -44						; size = 8
$T79415 = -36						; size = 8
_g$32572 = -28						; size = 4
_uncompressed_base$32576 = -24				; size = 8
_s$32570 = -16						; size = 4
_index_list_size_add$32578 = -12			; size = 4
_compressed_base$32574 = -8				; size = 8
_i$ = 8							; size = 4
_allocator$ = 12					; size = 4
_unpadded_size$ = 16					; size = 8
_uncompressed_size$ = 24				; size = 8
_lzma_index_append PROC					; COMDAT

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	56		 push	 esi

; 654  : 	// Validate.
; 655  : 	if (i == NULL || unpadded_size < UNPADDED_SIZE_MIN
; 656  : 			|| unpadded_size > UNPADDED_SIZE_MAX
; 657  : 			|| uncompressed_size > LZMA_VLI_MAX)

  00007	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  0000b	74 2e		 je	 SHORT $LN6@lzma_index@8
  0000d	83 7d 14 00	 cmp	 DWORD PTR _unpadded_size$[ebp+4], 0
  00011	77 06		 ja	 SHORT $LN24@lzma_index@8
  00013	83 7d 10 05	 cmp	 DWORD PTR _unpadded_size$[ebp], 5
  00017	72 22		 jb	 SHORT $LN6@lzma_index@8
$LN24@lzma_index@8:
  00019	81 7d 14 ff ff
	ff 7f		 cmp	 DWORD PTR _unpadded_size$[ebp+4], 2147483647 ; 7fffffffH
  00020	77 19		 ja	 SHORT $LN6@lzma_index@8
  00022	72 06		 jb	 SHORT $LN25@lzma_index@8
  00024	83 7d 10 fc	 cmp	 DWORD PTR _unpadded_size$[ebp], -4 ; fffffffcH
  00028	77 11		 ja	 SHORT $LN6@lzma_index@8
$LN25@lzma_index@8:
  0002a	81 7d 1c ff ff
	ff 7f		 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 2147483647 ; 7fffffffH
  00031	72 12		 jb	 SHORT $LN7@lzma_index@8
  00033	77 06		 ja	 SHORT $LN6@lzma_index@8
  00035	83 7d 18 ff	 cmp	 DWORD PTR _uncompressed_size$[ebp], -1
  00039	76 0a		 jbe	 SHORT $LN7@lzma_index@8
$LN6@lzma_index@8:

; 658  : 		return LZMA_PROG_ERROR;

  0003b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00040	e9 47 03 00 00	 jmp	 $LN8@lzma_index@8
$LN7@lzma_index@8:

; 659  : 
; 660  :   {
; 661  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  00045	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR _s$32570[ebp], ecx

; 662  : 	index_group *g = (index_group *)(s->groups.rightmost);

  0004e	8b 55 f0	 mov	 edx, DWORD PTR _s$32570[ebp]
  00051	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00054	89 45 e4	 mov	 DWORD PTR _g$32572[ebp], eax

; 663  : 
; 664  : 	const lzma_vli compressed_base = g == NULL ? 0
; 665  : 			: vli_ceil4(g->records[g->last].unpadded_sum);

  00057	83 7d e4 00	 cmp	 DWORD PTR _g$32572[ebp], 0
  0005b	75 10		 jne	 SHORT $LN14@lzma_index@8
  0005d	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00064	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp+4], 0
  0006b	eb 23		 jmp	 SHORT $LN11@lzma_index@8
$LN14@lzma_index@8:
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  00070	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00073	c1 e2 04	 shl	 edx, 4
  00076	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00079	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  0007d	83 c1 03	 add	 ecx, 3
  00080	8b 54 10 3c	 mov	 edx, DWORD PTR [eax+edx+60]
  00084	83 d2 00	 adc	 edx, 0
  00087	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0008a	89 4d c4	 mov	 DWORD PTR tv78[ebp], ecx
  0008d	89 55 c8	 mov	 DWORD PTR tv78[ebp+4], edx
$LN11@lzma_index@8:
  00090	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00093	89 45 f8	 mov	 DWORD PTR _compressed_base$32574[ebp], eax
  00096	8b 4d c8	 mov	 ecx, DWORD PTR tv78[ebp+4]
  00099	89 4d fc	 mov	 DWORD PTR _compressed_base$32574[ebp+4], ecx

; 666  : 	const lzma_vli uncompressed_base = g == NULL ? 0
; 667  : 			: g->records[g->last].uncompressed_sum;

  0009c	83 7d e4 00	 cmp	 DWORD PTR _g$32572[ebp], 0
  000a0	75 10		 jne	 SHORT $LN12@lzma_index@8
  000a2	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  000a9	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv84[ebp+4], 0
  000b0	eb 1a		 jmp	 SHORT $LN13@lzma_index@8
$LN12@lzma_index@8:
  000b2	8b 55 e4	 mov	 edx, DWORD PTR _g$32572[ebp]
  000b5	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b8	c1 e0 04	 shl	 eax, 4
  000bb	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  000be	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  000c2	89 55 bc	 mov	 DWORD PTR tv84[ebp], edx
  000c5	8b 44 01 34	 mov	 eax, DWORD PTR [ecx+eax+52]
  000c9	89 45 c0	 mov	 DWORD PTR tv84[ebp+4], eax
$LN13@lzma_index@8:
  000cc	8b 4d bc	 mov	 ecx, DWORD PTR tv84[ebp]
  000cf	89 4d e8	 mov	 DWORD PTR _uncompressed_base$32576[ebp], ecx
  000d2	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp+4]
  000d5	89 55 ec	 mov	 DWORD PTR _uncompressed_base$32576[ebp+4], edx

; 668  : 	const uint32_t index_list_size_add = lzma_vli_size(unpadded_size)
; 669  : 			+ lzma_vli_size(uncompressed_size);

  000d8	8b 45 14	 mov	 eax, DWORD PTR _unpadded_size$[ebp+4]
  000db	50		 push	 eax
  000dc	8b 4d 10	 mov	 ecx, DWORD PTR _unpadded_size$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _lzma_vli_size
  000e5	83 c4 08	 add	 esp, 8
  000e8	8b f0		 mov	 esi, eax
  000ea	8b 55 1c	 mov	 edx, DWORD PTR _uncompressed_size$[ebp+4]
  000ed	52		 push	 edx
  000ee	8b 45 18	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _lzma_vli_size
  000f7	83 c4 08	 add	 esp, 8
  000fa	03 f0		 add	 esi, eax
  000fc	89 75 f4	 mov	 DWORD PTR _index_list_size_add$32578[ebp], esi

; 670  : 
; 671  : 	// Check that the file size will stay within limits.
; 672  : 	if (index_file_size(s->node.compressed_base,
; 673  : 			compressed_base + unpadded_size, s->record_count + 1,
; 674  : 			s->index_list_size + index_list_size_add,
; 675  : 			s->stream_padding) == LZMA_VLI_UNKNOWN)

  000ff	8b 4d f0	 mov	 ecx, DWORD PTR _s$32570[ebp]
  00102	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00108	52		 push	 edx
  00109	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0010f	50		 push	 eax
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _index_list_size_add$32578[ebp]
  00113	33 d2		 xor	 edx, edx
  00115	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  00118	03 48 48	 add	 ecx, DWORD PTR [eax+72]
  0011b	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0011e	13 c2		 adc	 eax, edx
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _s$32570[ebp]
  00125	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00128	83 c2 01	 add	 edx, 1
  0012b	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0012e	83 d0 00	 adc	 eax, 0
  00131	50		 push	 eax
  00132	52		 push	 edx
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _compressed_base$32574[ebp]
  00136	03 4d 10	 add	 ecx, DWORD PTR _unpadded_size$[ebp]
  00139	8b 55 fc	 mov	 edx, DWORD PTR _compressed_base$32574[ebp+4]
  0013c	13 55 14	 adc	 edx, DWORD PTR _unpadded_size$[ebp+4]
  0013f	52		 push	 edx
  00140	51		 push	 ecx
  00141	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  00144	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00147	51		 push	 ecx
  00148	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0014b	52		 push	 edx
  0014c	e8 00 00 00 00	 call	 _index_file_size
  00151	83 c4 28	 add	 esp, 40			; 00000028H
  00154	89 45 b4	 mov	 DWORD PTR tv307[ebp], eax
  00157	89 55 b8	 mov	 DWORD PTR tv307[ebp+4], edx
  0015a	8b 45 b4	 mov	 eax, DWORD PTR tv307[ebp]
  0015d	23 45 b8	 and	 eax, DWORD PTR tv307[ebp+4]
  00160	83 f8 ff	 cmp	 eax, -1
  00163	75 0a		 jne	 SHORT $LN5@lzma_index@8

; 676  : 		return LZMA_DATA_ERROR;

  00165	b8 09 00 00 00	 mov	 eax, 9
  0016a	e9 1d 02 00 00	 jmp	 $LN8@lzma_index@8
$LN5@lzma_index@8:

; 677  : 
; 678  : 	// The size of the Index field must not exceed the maximum value
; 679  : 	// that can be stored in the Backward Size field.
; 680  : 	if (index_size(i->record_count + 1,
; 681  : 			i->index_list_size + index_list_size_add)
; 682  : 			> LZMA_BACKWARD_SIZE_MAX)

  0016f	8b 4d f4	 mov	 ecx, DWORD PTR _index_list_size_add$32578[ebp]
  00172	33 d2		 xor	 edx, edx
  00174	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00177	03 48 28	 add	 ecx, DWORD PTR [eax+40]
  0017a	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0017d	13 c2		 adc	 eax, edx
  0017f	89 4d cc	 mov	 DWORD PTR $T79426[ebp], ecx
  00182	89 45 d0	 mov	 DWORD PTR $T79426[ebp+4], eax
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00188	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0018b	83 c2 01	 add	 edx, 1
  0018e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00191	83 d0 00	 adc	 eax, 0
  00194	89 55 d4	 mov	 DWORD PTR $T79425[ebp], edx
  00197	89 45 d8	 mov	 DWORD PTR $T79425[ebp+4], eax
  0019a	8b 4d d8	 mov	 ecx, DWORD PTR $T79425[ebp+4]
  0019d	51		 push	 ecx
  0019e	8b 55 d4	 mov	 edx, DWORD PTR $T79425[ebp]
  001a1	52		 push	 edx
  001a2	e8 00 00 00 00	 call	 _lzma_vli_size
  001a7	83 c4 08	 add	 esp, 8
  001aa	83 c0 01	 add	 eax, 1
  001ad	33 c9		 xor	 ecx, ecx
  001af	03 45 cc	 add	 eax, DWORD PTR $T79426[ebp]
  001b2	13 4d d0	 adc	 ecx, DWORD PTR $T79426[ebp+4]
  001b5	83 c0 04	 add	 eax, 4
  001b8	83 d1 00	 adc	 ecx, 0
  001bb	89 45 dc	 mov	 DWORD PTR $T79415[ebp], eax
  001be	89 4d e0	 mov	 DWORD PTR $T79415[ebp+4], ecx
  001c1	8b 55 dc	 mov	 edx, DWORD PTR $T79415[ebp]
  001c4	83 c2 03	 add	 edx, 3
  001c7	8b 45 e0	 mov	 eax, DWORD PTR $T79415[ebp+4]
  001ca	83 d0 00	 adc	 eax, 0
  001cd	83 e2 fc	 and	 edx, -4			; fffffffcH
  001d0	89 55 ac	 mov	 DWORD PTR tv349[ebp], edx
  001d3	89 45 b0	 mov	 DWORD PTR tv349[ebp+4], eax
  001d6	83 7d b0 04	 cmp	 DWORD PTR tv349[ebp+4], 4
  001da	72 12		 jb	 SHORT $LN4@lzma_index@8
  001dc	77 06		 ja	 SHORT $LN27@lzma_index@8
  001de	83 7d ac 00	 cmp	 DWORD PTR tv349[ebp], 0
  001e2	76 0a		 jbe	 SHORT $LN4@lzma_index@8
$LN27@lzma_index@8:

; 683  : 		return LZMA_DATA_ERROR;

  001e4	b8 09 00 00 00	 mov	 eax, 9
  001e9	e9 9e 01 00 00	 jmp	 $LN8@lzma_index@8
$LN4@lzma_index@8:

; 684  : 
; 685  : 	if (g != NULL && g->last + 1 < g->allocated) {

  001ee	83 7d e4 00	 cmp	 DWORD PTR _g$32572[ebp], 0
  001f2	74 25		 je	 SHORT $LN3@lzma_index@8
  001f4	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  001f7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001fa	83 c2 01	 add	 edx, 1
  001fd	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00200	3b 50 28	 cmp	 edx, DWORD PTR [eax+40]
  00203	73 14		 jae	 SHORT $LN3@lzma_index@8

; 686  : 		// There is space in the last group at least for one Record.
; 687  : 		++g->last;

  00205	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  00208	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0020b	83 c2 01	 add	 edx, 1
  0020e	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00211	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 688  : 	} else {

  00214	e9 94 00 00 00	 jmp	 $LN2@lzma_index@8
$LN3@lzma_index@8:

; 689  : 		// We need to allocate a new group.
; 690  : 		g = lzma_alloc(sizeof(index_group)
; 691  : 				+ i->prealloc * sizeof(index_record),
; 692  : 				allocator);

  00219	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0021c	51		 push	 ecx
  0021d	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00220	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00223	c1 e0 04	 shl	 eax, 4
  00226	83 c0 30	 add	 eax, 48			; 00000030H
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _lzma_alloc
  0022f	83 c4 08	 add	 esp, 8
  00232	89 45 e4	 mov	 DWORD PTR _g$32572[ebp], eax

; 693  : 		if (g == NULL)

  00235	83 7d e4 00	 cmp	 DWORD PTR _g$32572[ebp], 0
  00239	75 0a		 jne	 SHORT $LN1@lzma_index@8

; 694  : 			return LZMA_MEM_ERROR;

  0023b	b8 05 00 00 00	 mov	 eax, 5
  00240	e9 47 01 00 00	 jmp	 $LN8@lzma_index@8
$LN1@lzma_index@8:

; 695  : 
; 696  : 		g->last = 0;

  00245	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  00248	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 697  : 		g->allocated = i->prealloc;

  0024f	8b 55 e4	 mov	 edx, DWORD PTR _g$32572[ebp]
  00252	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00255	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00258	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 698  : 
; 699  : 		// Reset prealloc so that if the application happens to
; 700  : 		// add new Records, the allocation size will be sane.
; 701  : 		i->prealloc = INDEX_GROUP_SIZE;

  0025b	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  0025e	c7 42 30 00 02
	00 00		 mov	 DWORD PTR [edx+48], 512	; 00000200H

; 702  : 
; 703  : 		// Set the start offsets of this group.
; 704  : 		g->node.uncompressed_base = uncompressed_base;

  00265	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00268	8b 4d e8	 mov	 ecx, DWORD PTR _uncompressed_base$32576[ebp]
  0026b	89 08		 mov	 DWORD PTR [eax], ecx
  0026d	8b 55 ec	 mov	 edx, DWORD PTR _uncompressed_base$32576[ebp+4]
  00270	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 705  : 		g->node.compressed_base = compressed_base;

  00273	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _compressed_base$32574[ebp]
  00279	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0027c	8b 55 fc	 mov	 edx, DWORD PTR _compressed_base$32574[ebp+4]
  0027f	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 706  : 		g->number_base = s->record_count + 1;

  00282	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  00285	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00288	83 c1 01	 add	 ecx, 1
  0028b	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  0028e	83 d2 00	 adc	 edx, 0
  00291	8b 45 e4	 mov	 eax, DWORD PTR _g$32572[ebp]
  00294	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00297	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 707  : 
; 708  : 		// Add the new group to the Stream.
; 709  : 		index_tree_append(&s->groups, &g->node);

  0029a	8b 4d e4	 mov	 ecx, DWORD PTR _g$32572[ebp]
  0029d	51		 push	 ecx
  0029e	8b 55 f0	 mov	 edx, DWORD PTR _s$32570[ebp]
  002a1	83 c2 30	 add	 edx, 48			; 00000030H
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 _index_tree_append
  002aa	83 c4 08	 add	 esp, 8
$LN2@lzma_index@8:

; 710  : 	}
; 711  : 
; 712  : 	// Add the new Record to the group.
; 713  : 	g->records[g->last].uncompressed_sum
; 714  : 			= uncompressed_base + uncompressed_size;

  002ad	8b 45 e8	 mov	 eax, DWORD PTR _uncompressed_base$32576[ebp]
  002b0	03 45 18	 add	 eax, DWORD PTR _uncompressed_size$[ebp]
  002b3	8b 4d ec	 mov	 ecx, DWORD PTR _uncompressed_base$32576[ebp+4]
  002b6	13 4d 1c	 adc	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  002b9	8b 55 e4	 mov	 edx, DWORD PTR _g$32572[ebp]
  002bc	8b 52 2c	 mov	 edx, DWORD PTR [edx+44]
  002bf	c1 e2 04	 shl	 edx, 4
  002c2	8b 75 e4	 mov	 esi, DWORD PTR _g$32572[ebp]
  002c5	89 44 16 30	 mov	 DWORD PTR [esi+edx+48], eax
  002c9	89 4c 16 34	 mov	 DWORD PTR [esi+edx+52], ecx

; 715  : 	g->records[g->last].unpadded_sum
; 716  : 			= compressed_base + unpadded_size;

  002cd	8b 45 f8	 mov	 eax, DWORD PTR _compressed_base$32574[ebp]
  002d0	03 45 10	 add	 eax, DWORD PTR _unpadded_size$[ebp]
  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _compressed_base$32574[ebp+4]
  002d6	13 4d 14	 adc	 ecx, DWORD PTR _unpadded_size$[ebp+4]
  002d9	8b 55 e4	 mov	 edx, DWORD PTR _g$32572[ebp]
  002dc	8b 52 2c	 mov	 edx, DWORD PTR [edx+44]
  002df	c1 e2 04	 shl	 edx, 4
  002e2	8b 75 e4	 mov	 esi, DWORD PTR _g$32572[ebp]
  002e5	89 44 16 38	 mov	 DWORD PTR [esi+edx+56], eax
  002e9	89 4c 16 3c	 mov	 DWORD PTR [esi+edx+60], ecx

; 717  : 
; 718  : 	// Update the totals.
; 719  : 	++s->record_count;

  002ed	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  002f0	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  002f3	83 c1 01	 add	 ecx, 1
  002f6	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  002f9	83 d2 00	 adc	 edx, 0
  002fc	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  002ff	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00302	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 720  : 	s->index_list_size += index_list_size_add;

  00305	8b 4d f4	 mov	 ecx, DWORD PTR _index_list_size_add$32578[ebp]
  00308	33 d2		 xor	 edx, edx
  0030a	8b 45 f0	 mov	 eax, DWORD PTR _s$32570[ebp]
  0030d	03 48 48	 add	 ecx, DWORD PTR [eax+72]
  00310	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00313	13 c2		 adc	 eax, edx
  00315	8b 55 f0	 mov	 edx, DWORD PTR _s$32570[ebp]
  00318	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  0031b	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 721  : 
; 722  : 	i->total_size += vli_ceil4(unpadded_size);

  0031e	8b 45 10	 mov	 eax, DWORD PTR _unpadded_size$[ebp]
  00321	83 c0 03	 add	 eax, 3
  00324	8b 4d 14	 mov	 ecx, DWORD PTR _unpadded_size$[ebp+4]
  00327	83 d1 00	 adc	 ecx, 0
  0032a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0032d	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00330	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00333	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  00336	13 d1		 adc	 edx, ecx
  00338	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0033b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0033e	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 723  : 	i->uncompressed_size += uncompressed_size;

  00341	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00344	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00347	03 45 18	 add	 eax, DWORD PTR _uncompressed_size$[ebp]
  0034a	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0034d	13 4d 1c	 adc	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  00350	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00353	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00356	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 724  : 	++i->record_count;

  00359	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0035c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0035f	83 c1 01	 add	 ecx, 1
  00362	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00365	83 d2 00	 adc	 edx, 0
  00368	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0036b	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0036e	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 725  : 	i->index_list_size += index_list_size_add;

  00371	8b 4d f4	 mov	 ecx, DWORD PTR _index_list_size_add$32578[ebp]
  00374	33 d2		 xor	 edx, edx
  00376	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00379	03 48 28	 add	 ecx, DWORD PTR [eax+40]
  0037c	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0037f	13 c2		 adc	 eax, edx
  00381	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00384	89 4a 28	 mov	 DWORD PTR [edx+40], ecx
  00387	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 726  :   }
; 727  : 
; 728  : 	return LZMA_OK;

  0038a	33 c0		 xor	 eax, eax
$LN8@lzma_index@8:

; 729  : }

  0038c	5e		 pop	 esi
  0038d	8b e5		 mov	 esp, ebp
  0038f	5d		 pop	 ebp
  00390	c3		 ret	 0
_lzma_index_append ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_file_size
; Function compile flags: /Odtp
;	COMDAT _lzma_index_file_size
_TEXT	SEGMENT
tv79 = -16						; size = 8
_g$ = -8						; size = 4
_s$ = -4						; size = 4
_i$ = 8							; size = 4
_lzma_index_file_size PROC				; COMDAT

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 568  : 	const index_stream *s = (const index_stream *)(i->streams.rightmost);

  00006	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 569  : 	const index_group *g = (const index_group *)(s->groups.rightmost);

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00012	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00015	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 570  : 	return index_file_size(s->node.compressed_base,
; 571  : 			g == NULL ? 0 : g->records[g->last].unpadded_sum,
; 572  : 			s->record_count, s->index_list_size,
; 573  : 			s->stream_padding);

  00018	83 7d f8 00	 cmp	 DWORD PTR _g$[ebp], 0
  0001c	75 10		 jne	 SHORT $LN3@lzma_index@9
  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv79[ebp+4], 0
  0002c	eb 1a		 jmp	 SHORT $LN4@lzma_index@9
$LN3@lzma_index@9:
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00031	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00034	c1 e2 04	 shl	 edx, 4
  00037	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0003a	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  0003e	89 4d f0	 mov	 DWORD PTR tv79[ebp], ecx
  00041	8b 54 10 3c	 mov	 edx, DWORD PTR [eax+edx+60]
  00045	89 55 f4	 mov	 DWORD PTR tv79[ebp+4], edx
$LN4@lzma_index@9:
  00048	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004b	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00051	51		 push	 ecx
  00052	8b 90 88 00 00
	00		 mov	 edx, DWORD PTR [eax+136]
  00058	52		 push	 edx
  00059	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0005c	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0005f	51		 push	 ecx
  00060	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  00063	52		 push	 edx
  00064	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00067	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0006a	51		 push	 ecx
  0006b	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  0006e	52		 push	 edx
  0006f	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp+4]
  00072	50		 push	 eax
  00073	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  00076	51		 push	 ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0007a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007d	50		 push	 eax
  0007e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _index_file_size
  00087	83 c4 28	 add	 esp, 40			; 00000028H

; 574  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_lzma_index_file_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_end
; Function compile flags: /Odtp
;	COMDAT _lzma_index_end
_TEXT	SEGMENT
_i$ = 8							; size = 4
_allocator$ = 12					; size = 4
_lzma_index_end PROC					; COMDAT

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 425  : 	// NOTE: If you modify this function, check also the bottom
; 426  : 	// of lzma_index_cat().
; 427  : 	if (i != NULL) {

  00003	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  00007	74 25		 je	 SHORT $LN2@lzma_index@10

; 428  : 		index_tree_end(&i->streams, allocator, &index_stream_end);

  00009	68 00 00 00 00	 push	 OFFSET _index_stream_end
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 _index_tree_end
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 		lzma_free(i, allocator);

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _lzma_free
  0002b	83 c4 08	 add	 esp, 8
$LN2@lzma_index@10:

; 430  : 	}
; 431  : 
; 432  : 	return;
; 433  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_lzma_index_end ENDP
PUBLIC	_lzma_index_cat
; Function compile flags: /Odtp
;	COMDAT _lzma_index_cat
_TEXT	SEGMENT
tv327 = -128						; size = 8
tv237 = -120						; size = 8
tv223 = -112						; size = 8
$T79693 = -104						; size = 8
$T79692 = -96						; size = 8
$T79688 = -88						; size = 8
$T79687 = -80						; size = 8
_info$32642 = -72					; size = 32
_newg$32630 = -36					; size = 4
_g$32624 = -32						; size = 4
_s$32622 = -28						; size = 4
_dest_size$32619 = -24					; size = 8
_src_size$32620 = -16					; size = 8
_dest_file_size$ = -8					; size = 8
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_allocator$ = 16					; size = 4
_lzma_index_cat PROC					; COMDAT

; 782  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 783  : 	const lzma_vli dest_file_size = lzma_index_file_size(dest);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _lzma_index_file_size
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 f8	 mov	 DWORD PTR _dest_file_size$[ebp], eax
  0001a	89 55 fc	 mov	 DWORD PTR _dest_file_size$[ebp+4], edx

; 784  : 
; 785  : 	// Check that we don't exceed the file size limits.
; 786  : 	if (dest_file_size + lzma_index_file_size(src) > LZMA_VLI_MAX
; 787  : 			|| dest->uncompressed_size + src->uncompressed_size
; 788  : 				> LZMA_VLI_MAX)

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _lzma_index_file_size
  00026	83 c4 04	 add	 esp, 4
  00029	03 45 f8	 add	 eax, DWORD PTR _dest_file_size$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _dest_file_size$[ebp+4]
  0002f	13 ca		 adc	 ecx, edx
  00031	89 45 90	 mov	 DWORD PTR tv223[ebp], eax
  00034	89 4d 94	 mov	 DWORD PTR tv223[ebp+4], ecx
  00037	81 7d 94 ff ff
	ff 7f		 cmp	 DWORD PTR tv223[ebp+4], 2147483647 ; 7fffffffH
  0003e	77 31		 ja	 SHORT $LN7@lzma_index@11
  00040	72 06		 jb	 SHORT $LN17@lzma_index@11
  00042	83 7d 90 ff	 cmp	 DWORD PTR tv223[ebp], -1
  00046	77 29		 ja	 SHORT $LN7@lzma_index@11
$LN17@lzma_index@11:
  00048	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0004e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00051	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  00054	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  00057	13 50 14	 adc	 edx, DWORD PTR [eax+20]
  0005a	89 4d 88	 mov	 DWORD PTR tv237[ebp], ecx
  0005d	89 55 8c	 mov	 DWORD PTR tv237[ebp+4], edx
  00060	81 7d 8c ff ff
	ff 7f		 cmp	 DWORD PTR tv237[ebp+4], 2147483647 ; 7fffffffH
  00067	72 12		 jb	 SHORT $LN8@lzma_index@11
  00069	77 06		 ja	 SHORT $LN7@lzma_index@11
  0006b	83 7d 88 ff	 cmp	 DWORD PTR tv237[ebp], -1
  0006f	76 0a		 jbe	 SHORT $LN8@lzma_index@11
$LN7@lzma_index@11:

; 789  : 		return LZMA_DATA_ERROR;

  00071	b8 09 00 00 00	 mov	 eax, 9
  00076	e9 be 02 00 00	 jmp	 $LN9@lzma_index@11
$LN8@lzma_index@11:

; 790  : 
; 791  : 	// Check that the encoded size of the combined lzma_indexes stays
; 792  : 	// within limits. In theory, this should be done only if we know
; 793  : 	// that the user plans to actually combine the Streams and thus
; 794  : 	// construct a single Index (probably rare). However, exceeding
; 795  : 	// this limit is quite theoretical, so we do this check always
; 796  : 	// to simplify things elsewhere.
; 797  : 	{
; 798  : 		const lzma_vli dest_size = index_size_unpadded(
; 799  : 				dest->record_count, dest->index_list_size);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0007e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00081	89 4d a8	 mov	 DWORD PTR $T79688[ebp], ecx
  00084	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00087	89 55 ac	 mov	 DWORD PTR $T79688[ebp+4], edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0008d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00090	89 4d b0	 mov	 DWORD PTR $T79687[ebp], ecx
  00093	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00096	89 55 b4	 mov	 DWORD PTR $T79687[ebp+4], edx
  00099	8b 45 b4	 mov	 eax, DWORD PTR $T79687[ebp+4]
  0009c	50		 push	 eax
  0009d	8b 4d b0	 mov	 ecx, DWORD PTR $T79687[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _lzma_vli_size
  000a6	83 c4 08	 add	 esp, 8
  000a9	83 c0 01	 add	 eax, 1
  000ac	33 d2		 xor	 edx, edx
  000ae	03 45 a8	 add	 eax, DWORD PTR $T79688[ebp]
  000b1	13 55 ac	 adc	 edx, DWORD PTR $T79688[ebp+4]
  000b4	83 c0 04	 add	 eax, 4
  000b7	83 d2 00	 adc	 edx, 0
  000ba	89 45 e8	 mov	 DWORD PTR _dest_size$32619[ebp], eax
  000bd	89 55 ec	 mov	 DWORD PTR _dest_size$32619[ebp+4], edx

; 800  : 		const lzma_vli src_size = index_size_unpadded(
; 801  : 				src->record_count, src->index_list_size);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  000c3	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000c6	89 4d 98	 mov	 DWORD PTR $T79693[ebp], ecx
  000c9	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  000cc	89 55 9c	 mov	 DWORD PTR $T79693[ebp+4], edx
  000cf	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  000d2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000d5	89 4d a0	 mov	 DWORD PTR $T79692[ebp], ecx
  000d8	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  000db	89 55 a4	 mov	 DWORD PTR $T79692[ebp+4], edx
  000de	8b 45 a4	 mov	 eax, DWORD PTR $T79692[ebp+4]
  000e1	50		 push	 eax
  000e2	8b 4d a0	 mov	 ecx, DWORD PTR $T79692[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _lzma_vli_size
  000eb	83 c4 08	 add	 esp, 8
  000ee	83 c0 01	 add	 eax, 1
  000f1	33 d2		 xor	 edx, edx
  000f3	03 45 98	 add	 eax, DWORD PTR $T79693[ebp]
  000f6	13 55 9c	 adc	 edx, DWORD PTR $T79693[ebp+4]
  000f9	83 c0 04	 add	 eax, 4
  000fc	83 d2 00	 adc	 edx, 0
  000ff	89 45 f0	 mov	 DWORD PTR _src_size$32620[ebp], eax
  00102	89 55 f4	 mov	 DWORD PTR _src_size$32620[ebp+4], edx

; 802  : 		if (vli_ceil4(dest_size + src_size) > LZMA_BACKWARD_SIZE_MAX)

  00105	8b 45 e8	 mov	 eax, DWORD PTR _dest_size$32619[ebp]
  00108	03 45 f0	 add	 eax, DWORD PTR _src_size$32620[ebp]
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _dest_size$32619[ebp+4]
  0010e	13 4d f4	 adc	 ecx, DWORD PTR _src_size$32620[ebp+4]
  00111	83 c0 03	 add	 eax, 3
  00114	83 d1 00	 adc	 ecx, 0
  00117	83 e0 fc	 and	 eax, -4			; fffffffcH
  0011a	89 45 80	 mov	 DWORD PTR tv327[ebp], eax
  0011d	89 4d 84	 mov	 DWORD PTR tv327[ebp+4], ecx
  00120	83 7d 84 04	 cmp	 DWORD PTR tv327[ebp+4], 4
  00124	72 12		 jb	 SHORT $LN6@lzma_index@11
  00126	77 06		 ja	 SHORT $LN19@lzma_index@11
  00128	83 7d 80 00	 cmp	 DWORD PTR tv327[ebp], 0
  0012c	76 0a		 jbe	 SHORT $LN6@lzma_index@11
$LN19@lzma_index@11:

; 803  : 			return LZMA_DATA_ERROR;

  0012e	b8 09 00 00 00	 mov	 eax, 9
  00133	e9 01 02 00 00	 jmp	 $LN9@lzma_index@11
$LN6@lzma_index@11:

; 804  : 	}
; 805  : 
; 806  : 	// Optimize the last group to minimize memory usage. Allocation has
; 807  : 	// to be done before modifying dest or src.
; 808  : 	{
; 809  : 		index_stream *s = (index_stream *)(dest->streams.rightmost);

  00138	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0013b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0013e	89 45 e4	 mov	 DWORD PTR _s$32622[ebp], eax

; 810  : 		index_group *g = (index_group *)(s->groups.rightmost);

  00141	8b 4d e4	 mov	 ecx, DWORD PTR _s$32622[ebp]
  00144	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00147	89 55 e0	 mov	 DWORD PTR _g$32624[ebp], edx

; 811  : 		if (g != NULL && g->last + 1 < g->allocated) {

  0014a	83 7d e0 00	 cmp	 DWORD PTR _g$32624[ebp], 0
  0014e	0f 84 f4 00 00
	00		 je	 $LN5@lzma_index@11
  00154	8b 45 e0	 mov	 eax, DWORD PTR _g$32624[ebp]
  00157	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0015a	83 c1 01	 add	 ecx, 1
  0015d	8b 55 e0	 mov	 edx, DWORD PTR _g$32624[ebp]
  00160	3b 4a 28	 cmp	 ecx, DWORD PTR [edx+40]
  00163	0f 83 df 00 00
	00		 jae	 $LN5@lzma_index@11

; 812  : 			assert(g->node.left == NULL);
; 813  : 			assert(g->node.right == NULL);
; 814  : 
; 815  : 		  {
; 816  : 			index_group *newg = lzma_alloc(sizeof(index_group)
; 817  : 					+ (g->last + 1)
; 818  : 					* sizeof(index_record),
; 819  : 					allocator);

  00169	8b 45 10	 mov	 eax, DWORD PTR _allocator$[ebp]
  0016c	50		 push	 eax
  0016d	8b 4d e0	 mov	 ecx, DWORD PTR _g$32624[ebp]
  00170	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00173	83 c2 01	 add	 edx, 1
  00176	c1 e2 04	 shl	 edx, 4
  00179	83 c2 30	 add	 edx, 48			; 00000030H
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _lzma_alloc
  00182	83 c4 08	 add	 esp, 8
  00185	89 45 dc	 mov	 DWORD PTR _newg$32630[ebp], eax

; 820  : 			if (newg == NULL)

  00188	83 7d dc 00	 cmp	 DWORD PTR _newg$32630[ebp], 0
  0018c	75 0a		 jne	 SHORT $LN4@lzma_index@11

; 821  : 				return LZMA_MEM_ERROR;

  0018e	b8 05 00 00 00	 mov	 eax, 5
  00193	e9 a1 01 00 00	 jmp	 $LN9@lzma_index@11
$LN4@lzma_index@11:

; 822  : 
; 823  : 			newg->node = g->node;

  00198	8b 75 e0	 mov	 esi, DWORD PTR _g$32624[ebp]
  0019b	b9 08 00 00 00	 mov	 ecx, 8
  001a0	8b 7d dc	 mov	 edi, DWORD PTR _newg$32630[ebp]
  001a3	f3 a5		 rep movsd

; 824  : 			newg->allocated = g->last + 1;

  001a5	8b 45 e0	 mov	 eax, DWORD PTR _g$32624[ebp]
  001a8	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001ab	83 c1 01	 add	 ecx, 1
  001ae	8b 55 dc	 mov	 edx, DWORD PTR _newg$32630[ebp]
  001b1	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 825  : 			newg->last = g->last;

  001b4	8b 45 dc	 mov	 eax, DWORD PTR _newg$32630[ebp]
  001b7	8b 4d e0	 mov	 ecx, DWORD PTR _g$32624[ebp]
  001ba	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001bd	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 826  : 			newg->number_base = g->number_base;

  001c0	8b 45 dc	 mov	 eax, DWORD PTR _newg$32630[ebp]
  001c3	8b 4d e0	 mov	 ecx, DWORD PTR _g$32624[ebp]
  001c6	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001c9	89 50 20	 mov	 DWORD PTR [eax+32], edx
  001cc	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  001cf	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 827  : 
; 828  : 			memcpy(newg->records, g->records, newg->allocated
; 829  : 					* sizeof(index_record));

  001d2	8b 55 dc	 mov	 edx, DWORD PTR _newg$32630[ebp]
  001d5	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001d8	c1 e0 04	 shl	 eax, 4
  001db	50		 push	 eax
  001dc	8b 4d e0	 mov	 ecx, DWORD PTR _g$32624[ebp]
  001df	83 c1 30	 add	 ecx, 48			; 00000030H
  001e2	51		 push	 ecx
  001e3	8b 55 dc	 mov	 edx, DWORD PTR _newg$32630[ebp]
  001e6	83 c2 30	 add	 edx, 48			; 00000030H
  001e9	52		 push	 edx
  001ea	e8 00 00 00 00	 call	 _memcpy
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 830  : 
; 831  : 			if (g->node.parent != NULL) {

  001f2	8b 45 e0	 mov	 eax, DWORD PTR _g$32624[ebp]
  001f5	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  001f9	74 0c		 je	 SHORT $LN3@lzma_index@11

; 832  : 				assert(g->node.parent->right == &g->node);
; 833  : 				g->node.parent->right = &newg->node;

  001fb	8b 4d e0	 mov	 ecx, DWORD PTR _g$32624[ebp]
  001fe	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00201	8b 45 dc	 mov	 eax, DWORD PTR _newg$32630[ebp]
  00204	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN3@lzma_index@11:

; 834  : 			}
; 835  : 
; 836  : 			if (s->groups.leftmost == &g->node) {

  00207	8b 4d e4	 mov	 ecx, DWORD PTR _s$32622[ebp]
  0020a	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0020d	3b 55 e0	 cmp	 edx, DWORD PTR _g$32624[ebp]
  00210	75 12		 jne	 SHORT $LN2@lzma_index@11

; 837  : 				assert(s->groups.root == &g->node);
; 838  : 				s->groups.leftmost = &newg->node;

  00212	8b 45 e4	 mov	 eax, DWORD PTR _s$32622[ebp]
  00215	8b 4d dc	 mov	 ecx, DWORD PTR _newg$32630[ebp]
  00218	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 839  : 				s->groups.root = &newg->node;

  0021b	8b 55 e4	 mov	 edx, DWORD PTR _s$32622[ebp]
  0021e	8b 45 dc	 mov	 eax, DWORD PTR _newg$32630[ebp]
  00221	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN2@lzma_index@11:

; 840  : 			}
; 841  : 
; 842  : 			if (s->groups.rightmost == &g->node)

  00224	8b 4d e4	 mov	 ecx, DWORD PTR _s$32622[ebp]
  00227	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0022a	3b 55 e0	 cmp	 edx, DWORD PTR _g$32624[ebp]
  0022d	75 09		 jne	 SHORT $LN1@lzma_index@11

; 843  : 				s->groups.rightmost = &newg->node;

  0022f	8b 45 e4	 mov	 eax, DWORD PTR _s$32622[ebp]
  00232	8b 4d dc	 mov	 ecx, DWORD PTR _newg$32630[ebp]
  00235	89 48 38	 mov	 DWORD PTR [eax+56], ecx
$LN1@lzma_index@11:

; 844  : 
; 845  : 			lzma_free(g, allocator);

  00238	8b 55 10	 mov	 edx, DWORD PTR _allocator$[ebp]
  0023b	52		 push	 edx
  0023c	8b 45 e0	 mov	 eax, DWORD PTR _g$32624[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _lzma_free
  00245	83 c4 08	 add	 esp, 8
$LN5@lzma_index@11:

; 846  : 
; 847  : 			// NOTE: newg isn't leaked here because
; 848  : 			// newg == (void *)&newg->node.
; 849  : 		  }
; 850  : 		}
; 851  : 	}
; 852  : 
; 853  : 	// Add all the Streams from src to dest. Update the base offsets
; 854  : 	// of each Stream from src.
; 855  : 	{ //MiSt
; 856  : 	/*
; 857  : 	const index_cat_info info = {
; 858  : 		.uncompressed_size = dest->uncompressed_size,
; 859  : 		.file_size = dest_file_size,
; 860  : 		.stream_number_add = dest->streams.count,
; 861  : 		.block_number_add = dest->record_count,
; 862  : 		.streams = &dest->streams,
; 863  : 	};
; 864  : 	*/
; 865  : 	index_cat_info info;
; 866  : 	memset (&info, 0, sizeof(info));

  00248	6a 20		 push	 32			; 00000020H
  0024a	6a 00		 push	 0
  0024c	8d 4d b8	 lea	 ecx, DWORD PTR _info$32642[ebp]
  0024f	51		 push	 ecx
  00250	e8 00 00 00 00	 call	 _memset
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH

; 867  : 	info.uncompressed_size = dest->uncompressed_size;

  00258	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0025b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0025e	89 45 b8	 mov	 DWORD PTR _info$32642[ebp], eax
  00261	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00264	89 4d bc	 mov	 DWORD PTR _info$32642[ebp+4], ecx

; 868  : 	info.file_size = dest_file_size;

  00267	8b 55 f8	 mov	 edx, DWORD PTR _dest_file_size$[ebp]
  0026a	89 55 c0	 mov	 DWORD PTR _info$32642[ebp+8], edx
  0026d	8b 45 fc	 mov	 eax, DWORD PTR _dest_file_size$[ebp+4]
  00270	89 45 c4	 mov	 DWORD PTR _info$32642[ebp+12], eax

; 869  : 	info.stream_number_add = dest->streams.count;

  00273	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00276	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00279	89 55 d0	 mov	 DWORD PTR _info$32642[ebp+24], edx

; 870  : 	info.block_number_add = dest->record_count;

  0027c	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0027f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00282	89 4d c8	 mov	 DWORD PTR _info$32642[ebp+16], ecx
  00285	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00288	89 55 cc	 mov	 DWORD PTR _info$32642[ebp+20], edx

; 871  : 	info.streams = &dest->streams;

  0028b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0028e	89 45 d4	 mov	 DWORD PTR _info$32642[ebp+28], eax

; 872  : 
; 873  : 	index_cat_helper(&info, (index_stream *)(src->streams.root));

  00291	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00294	8b 11		 mov	 edx, DWORD PTR [ecx]
  00296	52		 push	 edx
  00297	8d 45 b8	 lea	 eax, DWORD PTR _info$32642[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 _index_cat_helper
  002a0	83 c4 08	 add	 esp, 8

; 874  : 
; 875  : 	// Update info about all the combined Streams.
; 876  : 	dest->uncompressed_size += src->uncompressed_size;

  002a3	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  002a6	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  002a9	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  002ac	03 42 10	 add	 eax, DWORD PTR [edx+16]
  002af	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  002b2	13 4a 14	 adc	 ecx, DWORD PTR [edx+20]
  002b5	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  002b8	89 42 10	 mov	 DWORD PTR [edx+16], eax
  002bb	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 877  : 	dest->total_size += src->total_size;

  002be	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  002c1	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  002c4	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  002c7	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  002ca	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  002cd	13 41 1c	 adc	 eax, DWORD PTR [ecx+28]
  002d0	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  002d3	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  002d6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 878  : 	dest->record_count += src->record_count;

  002d9	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  002dc	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  002df	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  002e2	03 48 20	 add	 ecx, DWORD PTR [eax+32]
  002e5	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  002e8	13 50 24	 adc	 edx, DWORD PTR [eax+36]
  002eb	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  002ee	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  002f1	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 879  : 	dest->index_list_size += src->index_list_size;

  002f4	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  002f7	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  002fa	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  002fd	03 42 28	 add	 eax, DWORD PTR [edx+40]
  00300	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00303	13 4a 2c	 adc	 ecx, DWORD PTR [edx+44]
  00306	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00309	89 42 28	 mov	 DWORD PTR [edx+40], eax
  0030c	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 880  : 	dest->checks = lzma_index_checks(dest) | src->checks;

  0030f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 _lzma_index_checks
  00318	83 c4 04	 add	 esp, 4
  0031b	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0031e	0b 41 34	 or	 eax, DWORD PTR [ecx+52]
  00321	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00324	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 881  : 
; 882  : 	// There's nothing else left in src than the base structure.
; 883  : 	lzma_free(src, allocator);

  00327	8b 45 10	 mov	 eax, DWORD PTR _allocator$[ebp]
  0032a	50		 push	 eax
  0032b	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0032e	51		 push	 ecx
  0032f	e8 00 00 00 00	 call	 _lzma_free
  00334	83 c4 08	 add	 esp, 8

; 884  : 	}
; 885  : 
; 886  : 	return LZMA_OK;

  00337	33 c0		 xor	 eax, eax
$LN9@lzma_index@11:

; 887  : }

  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	8b e5		 mov	 esp, ebp
  0033d	5d		 pop	 ebp
  0033e	c3		 ret	 0
_lzma_index_cat ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_stream_padding
; Function compile flags: /Odtp
;	COMDAT _lzma_index_stream_padding
_TEXT	SEGMENT
tv139 = -32						; size = 8
tv83 = -24						; size = 8
_old_stream_padding$32556 = -16				; size = 8
_s$32554 = -4						; size = 4
_i$ = 8							; size = 4
_stream_padding$ = 12					; size = 8
_lzma_index_stream_padding PROC				; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 628  : 	if (i == NULL || stream_padding > LZMA_VLI_MAX
; 629  : 			|| (stream_padding & 3) != 0)

  00006	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  0000a	74 2b		 je	 SHORT $LN2@lzma_index@12
  0000c	81 7d 10 ff ff
	ff 7f		 cmp	 DWORD PTR _stream_padding$[ebp+4], 2147483647 ; 7fffffffH
  00013	77 22		 ja	 SHORT $LN2@lzma_index@12
  00015	72 06		 jb	 SHORT $LN6@lzma_index@12
  00017	83 7d 0c ff	 cmp	 DWORD PTR _stream_padding$[ebp], -1
  0001b	77 1a		 ja	 SHORT $LN2@lzma_index@12
$LN6@lzma_index@12:
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _stream_padding$[ebp]
  00020	83 e0 03	 and	 eax, 3
  00023	8b 4d 10	 mov	 ecx, DWORD PTR _stream_padding$[ebp+4]
  00026	83 e1 00	 and	 ecx, 0
  00029	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  0002c	89 4d ec	 mov	 DWORD PTR tv83[ebp+4], ecx
  0002f	8b 55 e8	 mov	 edx, DWORD PTR tv83[ebp]
  00032	0b 55 ec	 or	 edx, DWORD PTR tv83[ebp+4]
  00035	74 0a		 je	 SHORT $LN3@lzma_index@12
$LN2@lzma_index@12:

; 630  : 		return LZMA_PROG_ERROR;

  00037	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0003c	e9 91 00 00 00	 jmp	 $LN4@lzma_index@12
$LN3@lzma_index@12:

; 631  : 
; 632  :   {
; 633  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  00041	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00044	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00047	89 4d fc	 mov	 DWORD PTR _s$32554[ebp], ecx

; 634  : 
; 635  : 	// Check that the new value won't make the file grow too big.
; 636  : 	const lzma_vli old_stream_padding = s->stream_padding;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _s$32554[ebp]
  0004d	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00053	89 45 f0	 mov	 DWORD PTR _old_stream_padding$32556[ebp], eax
  00056	8b 8a 8c 00 00
	00		 mov	 ecx, DWORD PTR [edx+140]
  0005c	89 4d f4	 mov	 DWORD PTR _old_stream_padding$32556[ebp+4], ecx

; 637  : 	s->stream_padding = 0;

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _s$32554[ebp]
  00062	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], 0
  0006c	c7 82 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+140], 0

; 638  : 	if (lzma_index_file_size(i) + stream_padding > LZMA_VLI_MAX) {

  00076	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _lzma_index_file_size
  0007f	83 c4 04	 add	 esp, 4
  00082	03 45 0c	 add	 eax, DWORD PTR _stream_padding$[ebp]
  00085	13 55 10	 adc	 edx, DWORD PTR _stream_padding$[ebp+4]
  00088	89 45 e0	 mov	 DWORD PTR tv139[ebp], eax
  0008b	89 55 e4	 mov	 DWORD PTR tv139[ebp+4], edx
  0008e	81 7d e4 ff ff
	ff 7f		 cmp	 DWORD PTR tv139[ebp+4], 2147483647 ; 7fffffffH
  00095	72 24		 jb	 SHORT $LN1@lzma_index@12
  00097	77 06		 ja	 SHORT $LN7@lzma_index@12
  00099	83 7d e0 ff	 cmp	 DWORD PTR tv139[ebp], -1
  0009d	76 1c		 jbe	 SHORT $LN1@lzma_index@12
$LN7@lzma_index@12:

; 639  : 		s->stream_padding = old_stream_padding;

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _s$32554[ebp]
  000a2	8b 55 f0	 mov	 edx, DWORD PTR _old_stream_padding$32556[ebp]
  000a5	89 91 88 00 00
	00		 mov	 DWORD PTR [ecx+136], edx
  000ab	8b 45 f4	 mov	 eax, DWORD PTR _old_stream_padding$32556[ebp+4]
  000ae	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 640  : 		return LZMA_DATA_ERROR;

  000b4	b8 09 00 00 00	 mov	 eax, 9
  000b9	eb 17		 jmp	 SHORT $LN4@lzma_index@12
$LN1@lzma_index@12:

; 641  : 	}
; 642  : 
; 643  : 	s->stream_padding = stream_padding;

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _s$32554[ebp]
  000be	8b 55 0c	 mov	 edx, DWORD PTR _stream_padding$[ebp]
  000c1	89 91 88 00 00
	00		 mov	 DWORD PTR [ecx+136], edx
  000c7	8b 45 10	 mov	 eax, DWORD PTR _stream_padding$[ebp+4]
  000ca	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 644  :   }
; 645  : 
; 646  : 	return LZMA_OK;

  000d0	33 c0		 xor	 eax, eax
$LN4@lzma_index@12:

; 647  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_lzma_index_stream_padding ENDP
END
