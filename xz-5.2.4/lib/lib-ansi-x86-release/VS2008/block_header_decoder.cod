; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_header_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT _read32le
_TEXT	SEGMENT
_num$ = -4						; size = 4
_buf$ = 8						; size = 4
_read32le PROC						; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 221  : 	uint32_t num = *(const uint32_t *)buf;

  00004	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _num$[ebp], ecx

; 222  : 	return conv32le(num);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _num$[ebp]

; 223  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_read32le ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_header_decoder.c
;	COMDAT _free_properties
_TEXT	SEGMENT
_i$ = -4						; size = 4
_block$ = 8						; size = 4
_allocator$ = 12					; size = 4
_free_properties PROC					; COMDAT

; 19   : {	size_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 20   : 
; 21   : 	// Free allocated filter options. The last array member is not
; 22   : 	// touched after the initialization in the beginning of
; 23   : 	// lzma_block_header_decode(), so we don't need to touch that here.
; 24   : 	for (i = 0; i < LZMA_FILTERS_MAX; ++i) {

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN3@free_prope
$LN2@free_prope:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@free_prope:
  00016	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0001a	73 4e		 jae	 SHORT $LN4@free_prope

; 25   : 		lzma_free(block->filters[i].options, allocator);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	c1 e2 04	 shl	 edx, 4
  00026	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00029	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002c	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _lzma_free
  00036	83 c4 08	 add	 esp, 8

; 26   : 		block->filters[i].id = LZMA_VLI_UNKNOWN;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	c1 e0 04	 shl	 eax, 4
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00042	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00045	c7 04 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+edx], -1
  0004c	c7 44 10 04 ff
	ff ff ff	 mov	 DWORD PTR [eax+edx+4], -1

; 27   : 		block->filters[i].options = NULL;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	c1 e0 04	 shl	 eax, 4
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0005d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00060	c7 44 02 08 00
	00 00 00	 mov	 DWORD PTR [edx+eax+8], 0

; 28   : 	}

  00068	eb a3		 jmp	 SHORT $LN2@free_prope
$LN4@free_prope:

; 29   : 
; 30   : 	return;
; 31   : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_free_properties ENDP
PUBLIC	_lzma_block_header_decode
; Function compile flags: /Odtp
;	COMDAT _lzma_block_header_decode
_TEXT	SEGMENT
tv224 = -44						; size = 8
_num$36041 = -36					; size = 4
_ret$32319 = -32					; size = 4
_i$32315 = -28						; size = 4
_filter_count$32314 = -24				; size = 4
_ret_$32310 = -20					; size = 4
_ret_$32301 = -16					; size = 4
_in_pos$32296 = -12					; size = 4
_in_size$32293 = -8					; size = 4
_i$ = -4						; size = 4
_block$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_lzma_block_header_decode PROC				; COMDAT

; 37   : {	size_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 38   : 
; 39   : 	// NOTE: We consider the header to be corrupt not only when the
; 40   : 	// CRC32 doesn't match, but also when variable-length integers
; 41   : 	// are invalid or over 63 bits, or if the header is too small
; 42   : 	// to contain the claimed information.
; 43   : 
; 44   : 	// Initialize the filter options array. This way the caller can
; 45   : 	// safely free() the options even if an error occurs in this function.
; 46   : 	for (i = 0; i <= LZMA_FILTERS_MAX; ++i) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN28@lzma_block@2
$LN27@lzma_block@2:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN28@lzma_block@2:
  00018	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0001c	77 31		 ja	 SHORT $LN26@lzma_block@2

; 47   : 		block->filters[i].id = LZMA_VLI_UNKNOWN;

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	c1 e1 04	 shl	 ecx, 4
  00024	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	c7 04 01 ff ff
	ff ff		 mov	 DWORD PTR [ecx+eax], -1
  00031	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1

; 48   : 		block->filters[i].options = NULL;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0003c	c1 e1 04	 shl	 ecx, 4
  0003f	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00042	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00045	c7 44 08 08 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+8], 0

; 49   : 	}

  0004d	eb c0		 jmp	 SHORT $LN27@lzma_block@2
$LN26@lzma_block@2:

; 50   : 
; 51   : 	// Versions 0 and 1 are supported. If a newer version was specified,
; 52   : 	// we need to downgrade it.
; 53   : 	if (block->version > 1)

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00052	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00055	76 09		 jbe	 SHORT $LN25@lzma_block@2

; 54   : 		block->version = 1;

  00057	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0005a	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN25@lzma_block@2:

; 55   : 
; 56   : 	// This isn't a Block Header option, but since the decompressor will
; 57   : 	// read it if version >= 1, it's better to initialize it here than
; 58   : 	// to expect the caller to do it since in almost all cases this
; 59   : 	// should be false.
; 60   : 	block->ignore_check = false;

  00060	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00063	c6 80 b8 00 00
	00 00		 mov	 BYTE PTR [eax+184], 0

; 61   : 
; 62   : 	// Validate Block Header Size and Check type. The caller must have
; 63   : 	// already set these, so it is a programming error if this test fails.
; 64   : 	if (lzma_block_header_size_decode(in[0]) != block->header_size
; 65   : 			|| (unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  0006a	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0006d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00070	8d 04 95 04 00
	00 00		 lea	 eax, DWORD PTR [edx*4+4]
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0007a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0007d	75 09		 jne	 SHORT $LN23@lzma_block@2
  0007f	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00082	83 7a 08 0f	 cmp	 DWORD PTR [edx+8], 15	; 0000000fH
  00086	76 0a		 jbe	 SHORT $LN24@lzma_block@2
$LN23@lzma_block@2:

; 66   : 		return LZMA_PROG_ERROR;

  00088	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0008d	e9 c6 01 00 00	 jmp	 $LN29@lzma_block@2
$LN24@lzma_block@2:

; 67   : 
; 68   : 	// Exclude the CRC32 field.
; 69   :   {
; 70   : 	const size_t in_size = block->header_size - 4;

  00092	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00095	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00098	83 e9 04	 sub	 ecx, 4
  0009b	89 4d f8	 mov	 DWORD PTR _in_size$32293[ebp], ecx

; 71   : 
; 72   : 	// Verify CRC32
; 73   : 	if (lzma_crc32(in, in_size, 0) != unaligned_read32le(in + in_size))

  0009e	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  000a1	03 55 f8	 add	 edx, DWORD PTR _in_size$32293[ebp]
  000a4	8b 02		 mov	 eax, DWORD PTR [edx]
  000a6	89 45 dc	 mov	 DWORD PTR _num$36041[ebp], eax
  000a9	6a 00		 push	 0
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _in_size$32293[ebp]
  000ae	51		 push	 ecx
  000af	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 _lzma_crc32
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	3b 45 dc	 cmp	 eax, DWORD PTR _num$36041[ebp]
  000be	74 0a		 je	 SHORT $LN22@lzma_block@2

; 74   : 		return LZMA_DATA_ERROR;

  000c0	b8 09 00 00 00	 mov	 eax, 9
  000c5	e9 8e 01 00 00	 jmp	 $LN29@lzma_block@2
$LN22@lzma_block@2:

; 75   : 
; 76   : 	// Check for unsupported flags.
; 77   : 	if (in[1] & 0x3C)

  000ca	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  000cd	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000d1	83 e1 3c	 and	 ecx, 60			; 0000003cH
  000d4	74 0a		 je	 SHORT $LN21@lzma_block@2

; 78   : 		return LZMA_OPTIONS_ERROR;

  000d6	b8 08 00 00 00	 mov	 eax, 8
  000db	e9 78 01 00 00	 jmp	 $LN29@lzma_block@2
$LN21@lzma_block@2:

; 79   : 
; 80   : 	// Start after the Block Header Size and Block Flags fields.
; 81   :   {
; 82   : 	size_t in_pos = 2;

  000e0	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _in_pos$32296[ebp], 2

; 83   : 
; 84   : 	// Compressed Size
; 85   : 	if (in[1] & 0x40) {

  000e7	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  000ea	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000ee	83 e0 40	 and	 eax, 64			; 00000040H
  000f1	74 58		 je	 SHORT $LN20@lzma_block@2
$LN19@lzma_block@2:

; 86   : 		return_if_error(lzma_vli_decode(&block->compressed_size,
; 87   : 				NULL, in, &in_pos, in_size));

  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _in_size$32293[ebp]
  000f6	51		 push	 ecx
  000f7	8d 55 f4	 lea	 edx, DWORD PTR _in_pos$32296[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  000fe	50		 push	 eax
  000ff	6a 00		 push	 0
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00104	83 c1 10	 add	 ecx, 16			; 00000010H
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 _lzma_vli_decode
  0010d	83 c4 14	 add	 esp, 20			; 00000014H
  00110	89 45 f0	 mov	 DWORD PTR _ret_$32301[ebp], eax
  00113	83 7d f0 00	 cmp	 DWORD PTR _ret_$32301[ebp], 0
  00117	74 08		 je	 SHORT $LN18@lzma_block@2
  00119	8b 45 f0	 mov	 eax, DWORD PTR _ret_$32301[ebp]
  0011c	e9 37 01 00 00	 jmp	 $LN29@lzma_block@2
$LN18@lzma_block@2:
  00121	33 d2		 xor	 edx, edx
  00123	75 ce		 jne	 SHORT $LN19@lzma_block@2

; 88   : 
; 89   : 		// Validate Compressed Size. This checks that it isn't zero
; 90   : 		// and that the total size of the Block is a valid VLI.
; 91   : 		if (lzma_block_unpadded_size(block) == 0)

  00125	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  0012e	83 c4 04	 add	 esp, 4
  00131	89 45 d4	 mov	 DWORD PTR tv224[ebp], eax
  00134	89 55 d8	 mov	 DWORD PTR tv224[ebp+4], edx
  00137	8b 4d d4	 mov	 ecx, DWORD PTR tv224[ebp]
  0013a	0b 4d d8	 or	 ecx, DWORD PTR tv224[ebp+4]
  0013d	75 0a		 jne	 SHORT $LN15@lzma_block@2

; 92   : 			return LZMA_DATA_ERROR;

  0013f	b8 09 00 00 00	 mov	 eax, 9
  00144	e9 0f 01 00 00	 jmp	 $LN29@lzma_block@2
$LN15@lzma_block@2:

; 93   : 	} else {

  00149	eb 11		 jmp	 SHORT $LN14@lzma_block@2
$LN20@lzma_block@2:

; 94   : 		block->compressed_size = LZMA_VLI_UNKNOWN;

  0014b	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0014e	c7 42 10 ff ff
	ff ff		 mov	 DWORD PTR [edx+16], -1
  00155	c7 42 14 ff ff
	ff ff		 mov	 DWORD PTR [edx+20], -1
$LN14@lzma_block@2:

; 95   : 	}
; 96   : 
; 97   : 	// Uncompressed Size
; 98   : 	if (in[1] & 0x80)

  0015c	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0015f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00163	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00169	74 34		 je	 SHORT $LN13@lzma_block@2
$LN12@lzma_block@2:

; 99   : 		return_if_error(lzma_vli_decode(&block->uncompressed_size,
; 100  : 				NULL, in, &in_pos, in_size));

  0016b	8b 55 f8	 mov	 edx, DWORD PTR _in_size$32293[ebp]
  0016e	52		 push	 edx
  0016f	8d 45 f4	 lea	 eax, DWORD PTR _in_pos$32296[ebp]
  00172	50		 push	 eax
  00173	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00176	51		 push	 ecx
  00177	6a 00		 push	 0
  00179	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0017c	83 c2 18	 add	 edx, 24			; 00000018H
  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 _lzma_vli_decode
  00185	83 c4 14	 add	 esp, 20			; 00000014H
  00188	89 45 ec	 mov	 DWORD PTR _ret_$32310[ebp], eax
  0018b	83 7d ec 00	 cmp	 DWORD PTR _ret_$32310[ebp], 0
  0018f	74 08		 je	 SHORT $LN11@lzma_block@2
  00191	8b 45 ec	 mov	 eax, DWORD PTR _ret_$32310[ebp]
  00194	e9 bf 00 00 00	 jmp	 $LN29@lzma_block@2
$LN11@lzma_block@2:
  00199	33 c0		 xor	 eax, eax
  0019b	75 ce		 jne	 SHORT $LN12@lzma_block@2

; 101  : 	else

  0019d	eb 11		 jmp	 SHORT $LN8@lzma_block@2
$LN13@lzma_block@2:

; 102  : 		block->uncompressed_size = LZMA_VLI_UNKNOWN;

  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  001a2	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1
  001a9	c7 41 1c ff ff
	ff ff		 mov	 DWORD PTR [ecx+28], -1
$LN8@lzma_block@2:

; 103  : 
; 104  : 	// Filter Flags
; 105  :   {
; 106  : 	const size_t filter_count = (in[1] & 3) + 1;

  001b0	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  001b3	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  001b7	83 e0 03	 and	 eax, 3
  001ba	83 c0 01	 add	 eax, 1
  001bd	89 45 e8	 mov	 DWORD PTR _filter_count$32314[ebp], eax

; 107  : 	size_t i;
; 108  : 
; 109  : 	for (i = 0; i < filter_count; ++i) {

  001c0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$32315[ebp], 0
  001c7	eb 09		 jmp	 SHORT $LN7@lzma_block@2
$LN6@lzma_block@2:
  001c9	8b 4d e4	 mov	 ecx, DWORD PTR _i$32315[ebp]
  001cc	83 c1 01	 add	 ecx, 1
  001cf	89 4d e4	 mov	 DWORD PTR _i$32315[ebp], ecx
$LN7@lzma_block@2:
  001d2	8b 55 e4	 mov	 edx, DWORD PTR _i$32315[ebp]
  001d5	3b 55 e8	 cmp	 edx, DWORD PTR _filter_count$32314[ebp]
  001d8	73 45		 jae	 SHORT $LN3@lzma_block@2

; 110  : 		const lzma_ret ret = lzma_filter_flags_decode(
; 111  : 				&block->filters[i], allocator,
; 112  : 				in, &in_pos, in_size);

  001da	8b 45 f8	 mov	 eax, DWORD PTR _in_size$32293[ebp]
  001dd	50		 push	 eax
  001de	8d 4d f4	 lea	 ecx, DWORD PTR _in_pos$32296[ebp]
  001e1	51		 push	 ecx
  001e2	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  001e5	52		 push	 edx
  001e6	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  001e9	50		 push	 eax
  001ea	8b 4d e4	 mov	 ecx, DWORD PTR _i$32315[ebp]
  001ed	c1 e1 04	 shl	 ecx, 4
  001f0	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  001f3	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 _lzma_filter_flags_decode
  001fc	83 c4 14	 add	 esp, 20			; 00000014H
  001ff	89 45 e0	 mov	 DWORD PTR _ret$32319[ebp], eax

; 113  : 		if (ret != LZMA_OK) {

  00202	83 7d e0 00	 cmp	 DWORD PTR _ret$32319[ebp], 0
  00206	74 15		 je	 SHORT $LN4@lzma_block@2

; 114  : 			free_properties(block, allocator);

  00208	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _free_properties
  00215	83 c4 08	 add	 esp, 8

; 115  : 			return ret;

  00218	8b 45 e0	 mov	 eax, DWORD PTR _ret$32319[ebp]
  0021b	eb 3b		 jmp	 SHORT $LN29@lzma_block@2
$LN4@lzma_block@2:

; 116  : 		}
; 117  : 	}

  0021d	eb aa		 jmp	 SHORT $LN6@lzma_block@2
$LN3@lzma_block@2:

; 118  : 
; 119  : 	// Padding
; 120  : 	while (in_pos < in_size) {

  0021f	8b 55 f4	 mov	 edx, DWORD PTR _in_pos$32296[ebp]
  00222	3b 55 f8	 cmp	 edx, DWORD PTR _in_size$32293[ebp]
  00225	73 2f		 jae	 SHORT $LN2@lzma_block@2

; 121  : 		if (in[in_pos++] != 0x00) {

  00227	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0022a	03 45 f4	 add	 eax, DWORD PTR _in_pos$32296[ebp]
  0022d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00230	8b 55 f4	 mov	 edx, DWORD PTR _in_pos$32296[ebp]
  00233	83 c2 01	 add	 edx, 1
  00236	89 55 f4	 mov	 DWORD PTR _in_pos$32296[ebp], edx
  00239	85 c9		 test	 ecx, ecx
  0023b	74 17		 je	 SHORT $LN1@lzma_block@2

; 122  : 			free_properties(block, allocator);

  0023d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00240	50		 push	 eax
  00241	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00244	51		 push	 ecx
  00245	e8 00 00 00 00	 call	 _free_properties
  0024a	83 c4 08	 add	 esp, 8

; 123  : 
; 124  : 			// Possibly some new field present so use
; 125  : 			// LZMA_OPTIONS_ERROR instead of LZMA_DATA_ERROR.
; 126  : 			return LZMA_OPTIONS_ERROR;

  0024d	b8 08 00 00 00	 mov	 eax, 8
  00252	eb 04		 jmp	 SHORT $LN29@lzma_block@2
$LN1@lzma_block@2:

; 127  : 		}
; 128  : 	}

  00254	eb c9		 jmp	 SHORT $LN3@lzma_block@2
$LN2@lzma_block@2:

; 129  :   }}}
; 130  : 
; 131  : 	return LZMA_OK;

  00256	33 c0		 xor	 eax, eax
$LN29@lzma_block@2:

; 132  : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c3		 ret	 0
_lzma_block_header_decode ENDP
END
