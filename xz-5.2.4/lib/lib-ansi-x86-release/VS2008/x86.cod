; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\x86.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_x86_decoder_init
?MASK_TO_ALLOWED_STATUS@?1??x86_code@@9@9 DB 01H	; `x86_code'::`2'::MASK_TO_ALLOWED_STATUS
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
?MASK_TO_BIT_NUMBER@?1??x86_code@@9@9 DD 00H		; `x86_code'::`2'::MASK_TO_BIT_NUMBER
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\x86.c
;	COMDAT _x86_code
_TEXT	SEGMENT
_i$32406 = -44						; size = 4
_src$32393 = -40					; size = 4
_dest$32397 = -36					; size = 4
_i$32387 = -32						; size = 4
_offset$32382 = -28					; size = 4
_b$32380 = -21						; size = 1
_limit$32375 = -20					; size = 4
_buffer_pos$32376 = -16					; size = 4
_prev_pos$ = -12					; size = 4
_prev_mask$ = -8					; size = 4
_simple$ = -4						; size = 4
_simple_ptr$ = 8					; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_x86_code PROC						; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 30   : 	static const bool MASK_TO_ALLOWED_STATUS[8]
; 31   : 		= { true, true, true, false, true, false, false, false };
; 32   : 
; 33   : 	static const uint32_t MASK_TO_BIT_NUMBER[8]
; 34   : 			= { 0, 1, 2, 2, 3, 3, 3, 3 };
; 35   : 
; 36   : 	lzma_simple_x86 *simple = simple_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _simple_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _simple$[ebp], eax

; 37   : 	uint32_t prev_mask = simple->prev_mask;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _simple$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f8	 mov	 DWORD PTR _prev_mask$[ebp], edx

; 38   : 	uint32_t prev_pos = simple->prev_pos;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _simple$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	89 4d f4	 mov	 DWORD PTR _prev_pos$[ebp], ecx

; 39   : 
; 40   : 	if (size < 5)

  0001d	83 7d 18 05	 cmp	 DWORD PTR _size$[ebp], 5
  00021	73 07		 jae	 SHORT $LN21@x86_code

; 41   : 		return 0;

  00023	33 c0		 xor	 eax, eax
  00025	e9 62 02 00 00	 jmp	 $LN22@x86_code
$LN21@x86_code:

; 42   : 
; 43   : 	if (now_pos - prev_pos > 5)

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  0002d	2b 55 f4	 sub	 edx, DWORD PTR _prev_pos$[ebp]
  00030	83 fa 05	 cmp	 edx, 5
  00033	76 09		 jbe	 SHORT $LN20@x86_code

; 44   : 		prev_pos = now_pos - 5;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _now_pos$[ebp]
  00038	83 e8 05	 sub	 eax, 5
  0003b	89 45 f4	 mov	 DWORD PTR _prev_pos$[ebp], eax
$LN20@x86_code:

; 45   : 
; 46   :   {
; 47   : 	const size_t limit = size - 5;

  0003e	8b 4d 18	 mov	 ecx, DWORD PTR _size$[ebp]
  00041	83 e9 05	 sub	 ecx, 5
  00044	89 4d ec	 mov	 DWORD PTR _limit$32375[ebp], ecx

; 48   : 	size_t buffer_pos = 0;

  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _buffer_pos$32376[ebp], 0
$LN19@x86_code:

; 49   : 
; 50   : 	while (buffer_pos <= limit) {

  0004e	8b 55 f0	 mov	 edx, DWORD PTR _buffer_pos$32376[ebp]
  00051	3b 55 ec	 cmp	 edx, DWORD PTR _limit$32375[ebp]
  00054	0f 87 1e 02 00
	00		 ja	 $LN18@x86_code

; 51   : 		uint8_t b = buffer[buffer_pos];

  0005a	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005d	03 45 f0	 add	 eax, DWORD PTR _buffer_pos$32376[ebp]
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	88 4d eb	 mov	 BYTE PTR _b$32380[ebp], cl

; 52   : 		if (b != 0xE8 && b != 0xE9) {

  00065	0f b6 55 eb	 movzx	 edx, BYTE PTR _b$32380[ebp]
  00069	81 fa e8 00 00
	00		 cmp	 edx, 232		; 000000e8H
  0006f	74 16		 je	 SHORT $LN17@x86_code
  00071	0f b6 45 eb	 movzx	 eax, BYTE PTR _b$32380[ebp]
  00075	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  0007a	74 0b		 je	 SHORT $LN17@x86_code

; 53   : 			++buffer_pos;

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _buffer_pos$32376[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d f0	 mov	 DWORD PTR _buffer_pos$32376[ebp], ecx

; 54   : 			continue;

  00085	eb c7		 jmp	 SHORT $LN19@x86_code
$LN17@x86_code:

; 55   : 		}
; 56   : 
; 57   :       {
; 58   : 		const uint32_t offset = now_pos + (uint32_t)(buffer_pos)
; 59   : 				- prev_pos;

  00087	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  0008a	03 55 f0	 add	 edx, DWORD PTR _buffer_pos$32376[ebp]
  0008d	2b 55 f4	 sub	 edx, DWORD PTR _prev_pos$[ebp]
  00090	89 55 e4	 mov	 DWORD PTR _offset$32382[ebp], edx

; 60   : 		prev_pos = now_pos + (uint32_t)(buffer_pos);

  00093	8b 45 0c	 mov	 eax, DWORD PTR _now_pos$[ebp]
  00096	03 45 f0	 add	 eax, DWORD PTR _buffer_pos$32376[ebp]
  00099	89 45 f4	 mov	 DWORD PTR _prev_pos$[ebp], eax

; 61   : 
; 62   : 		if (offset > 5) {

  0009c	83 7d e4 05	 cmp	 DWORD PTR _offset$32382[ebp], 5
  000a0	76 09		 jbe	 SHORT $LN16@x86_code

; 63   : 			prev_mask = 0;

  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _prev_mask$[ebp], 0

; 64   : 		} else {

  000a9	eb 2d		 jmp	 SHORT $LN15@x86_code
$LN16@x86_code:

; 65   : 			uint32_t i;
; 66   : 			for (i = 0; i < offset; ++i) {

  000ab	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$32387[ebp], 0
  000b2	eb 09		 jmp	 SHORT $LN14@x86_code
$LN13@x86_code:
  000b4	8b 4d e0	 mov	 ecx, DWORD PTR _i$32387[ebp]
  000b7	83 c1 01	 add	 ecx, 1
  000ba	89 4d e0	 mov	 DWORD PTR _i$32387[ebp], ecx
$LN14@x86_code:
  000bd	8b 55 e0	 mov	 edx, DWORD PTR _i$32387[ebp]
  000c0	3b 55 e4	 cmp	 edx, DWORD PTR _offset$32382[ebp]
  000c3	73 13		 jae	 SHORT $LN15@x86_code

; 67   : 				prev_mask &= 0x77;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _prev_mask$[ebp]
  000c8	83 e0 77	 and	 eax, 119		; 00000077H
  000cb	89 45 f8	 mov	 DWORD PTR _prev_mask$[ebp], eax

; 68   : 				prev_mask <<= 1;

  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _prev_mask$[ebp]
  000d1	d1 e1		 shl	 ecx, 1
  000d3	89 4d f8	 mov	 DWORD PTR _prev_mask$[ebp], ecx

; 69   : 			}

  000d6	eb dc		 jmp	 SHORT $LN13@x86_code
$LN15@x86_code:

; 70   : 		}
; 71   : 
; 72   : 		b = buffer[buffer_pos + 4];

  000d8	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  000db	03 55 f0	 add	 edx, DWORD PTR _buffer_pos$32376[ebp]
  000de	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  000e1	88 45 eb	 mov	 BYTE PTR _b$32380[ebp], al

; 73   : 
; 74   : 		if (Test86MSByte(b)
; 75   : 			&& MASK_TO_ALLOWED_STATUS[(prev_mask >> 1) & 0x7]
; 76   : 				&& (prev_mask >> 1) < 0x10) {

  000e4	0f b6 4d eb	 movzx	 ecx, BYTE PTR _b$32380[ebp]
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 10		 je	 SHORT $LN10@x86_code
  000ec	0f b6 55 eb	 movzx	 edx, BYTE PTR _b$32380[ebp]
  000f0	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000f6	0f 85 49 01 00
	00		 jne	 $LN11@x86_code
$LN10@x86_code:
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _prev_mask$[ebp]
  000ff	d1 e8		 shr	 eax, 1
  00101	83 e0 07	 and	 eax, 7
  00104	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?MASK_TO_ALLOWED_STATUS@?1??x86_code@@9@9[eax]
  0010b	85 c9		 test	 ecx, ecx
  0010d	0f 84 32 01 00
	00		 je	 $LN11@x86_code
  00113	8b 55 f8	 mov	 edx, DWORD PTR _prev_mask$[ebp]
  00116	d1 ea		 shr	 edx, 1
  00118	83 fa 10	 cmp	 edx, 16			; 00000010H
  0011b	0f 83 24 01 00
	00		 jae	 $LN11@x86_code

; 77   : 
; 78   : 			uint32_t src = ((uint32_t)(b) << 24)
; 79   : 				| ((uint32_t)(buffer[buffer_pos + 3]) << 16)
; 80   : 				| ((uint32_t)(buffer[buffer_pos + 2]) << 8)
; 81   : 				| (buffer[buffer_pos + 1]);

  00121	0f b6 45 eb	 movzx	 eax, BYTE PTR _b$32380[ebp]
  00125	c1 e0 18	 shl	 eax, 24			; 00000018H
  00128	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0012b	03 4d f0	 add	 ecx, DWORD PTR _buffer_pos$32376[ebp]
  0012e	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00132	c1 e2 10	 shl	 edx, 16			; 00000010H
  00135	0b c2		 or	 eax, edx
  00137	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0013a	03 4d f0	 add	 ecx, DWORD PTR _buffer_pos$32376[ebp]
  0013d	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00141	c1 e2 08	 shl	 edx, 8
  00144	0b c2		 or	 eax, edx
  00146	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00149	03 4d f0	 add	 ecx, DWORD PTR _buffer_pos$32376[ebp]
  0014c	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00150	0b c2		 or	 eax, edx
  00152	89 45 d8	 mov	 DWORD PTR _src$32393[ebp], eax
$LN9@x86_code:

; 82   : 
; 83   : 			uint32_t dest;
; 84   : 			while (true) {

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	0f 84 90 00 00
	00		 je	 $LN8@x86_code

; 85   : 				if (is_encoder)

  00162	0f b6 4d 10	 movzx	 ecx, BYTE PTR _is_encoder$[ebp]
  00166	85 c9		 test	 ecx, ecx
  00168	74 12		 je	 SHORT $LN7@x86_code

; 86   : 					dest = src + (now_pos + (uint32_t)(
; 87   : 							buffer_pos) + 5);

  0016a	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  0016d	03 55 f0	 add	 edx, DWORD PTR _buffer_pos$32376[ebp]
  00170	8b 45 d8	 mov	 eax, DWORD PTR _src$32393[ebp]
  00173	8d 4c 10 05	 lea	 ecx, DWORD PTR [eax+edx+5]
  00177	89 4d dc	 mov	 DWORD PTR _dest$32397[ebp], ecx

; 88   : 				else

  0017a	eb 12		 jmp	 SHORT $LN6@x86_code
$LN7@x86_code:

; 89   : 					dest = src - (now_pos + (uint32_t)(
; 90   : 							buffer_pos) + 5);

  0017c	8b 55 f0	 mov	 edx, DWORD PTR _buffer_pos$32376[ebp]
  0017f	8b 45 0c	 mov	 eax, DWORD PTR _now_pos$[ebp]
  00182	8d 4c 10 05	 lea	 ecx, DWORD PTR [eax+edx+5]
  00186	8b 55 d8	 mov	 edx, DWORD PTR _src$32393[ebp]
  00189	2b d1		 sub	 edx, ecx
  0018b	89 55 dc	 mov	 DWORD PTR _dest$32397[ebp], edx
$LN6@x86_code:

; 91   : 
; 92   : 				if (prev_mask == 0)

  0018e	83 7d f8 00	 cmp	 DWORD PTR _prev_mask$[ebp], 0
  00192	75 02		 jne	 SHORT $LN5@x86_code

; 93   : 					break;

  00194	eb 5c		 jmp	 SHORT $LN8@x86_code
$LN5@x86_code:

; 94   : 
; 95   :               {
; 96   : 				const uint32_t i = MASK_TO_BIT_NUMBER[
; 97   : 						prev_mask >> 1];

  00196	8b 45 f8	 mov	 eax, DWORD PTR _prev_mask$[ebp]
  00199	d1 e8		 shr	 eax, 1
  0019b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?MASK_TO_BIT_NUMBER@?1??x86_code@@9@9[eax*4]
  001a2	89 4d d4	 mov	 DWORD PTR _i$32406[ebp], ecx

; 98   : 
; 99   : 				b = (uint8_t)(dest >> (24 - i * 8));

  001a5	8b 55 d4	 mov	 edx, DWORD PTR _i$32406[ebp]
  001a8	c1 e2 03	 shl	 edx, 3
  001ab	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  001b0	2b ca		 sub	 ecx, edx
  001b2	8b 45 dc	 mov	 eax, DWORD PTR _dest$32397[ebp]
  001b5	d3 e8		 shr	 eax, cl
  001b7	88 45 eb	 mov	 BYTE PTR _b$32380[ebp], al

; 100  : 
; 101  : 				if (!Test86MSByte(b))

  001ba	0f b6 4d eb	 movzx	 ecx, BYTE PTR _b$32380[ebp]
  001be	85 c9		 test	 ecx, ecx
  001c0	74 0e		 je	 SHORT $LN4@x86_code
  001c2	0f b6 55 eb	 movzx	 edx, BYTE PTR _b$32380[ebp]
  001c6	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  001cc	74 02		 je	 SHORT $LN4@x86_code

; 102  : 					break;

  001ce	eb 22		 jmp	 SHORT $LN8@x86_code
$LN4@x86_code:

; 103  : 
; 104  : 				src = dest ^ ((1 << (32 - i * 8)) - 1);

  001d0	8b 45 d4	 mov	 eax, DWORD PTR _i$32406[ebp]
  001d3	c1 e0 03	 shl	 eax, 3
  001d6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001db	2b c8		 sub	 ecx, eax
  001dd	ba 01 00 00 00	 mov	 edx, 1
  001e2	d3 e2		 shl	 edx, cl
  001e4	83 ea 01	 sub	 edx, 1
  001e7	33 55 dc	 xor	 edx, DWORD PTR _dest$32397[ebp]
  001ea	89 55 d8	 mov	 DWORD PTR _src$32393[ebp], edx

; 105  : 			  }
; 106  : 			}

  001ed	e9 63 ff ff ff	 jmp	 $LN9@x86_code
$LN8@x86_code:

; 107  : 
; 108  : 			buffer[buffer_pos + 4]
; 109  : 					= (uint8_t)(~(((dest >> 24) & 1) - 1));

  001f2	8b 45 dc	 mov	 eax, DWORD PTR _dest$32397[ebp]
  001f5	c1 e8 18	 shr	 eax, 24			; 00000018H
  001f8	83 e0 01	 and	 eax, 1
  001fb	83 e8 01	 sub	 eax, 1
  001fe	f7 d0		 not	 eax
  00200	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00203	03 4d f0	 add	 ecx, DWORD PTR _buffer_pos$32376[ebp]
  00206	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 110  : 			buffer[buffer_pos + 3] = (uint8_t)(dest >> 16);

  00209	8b 55 dc	 mov	 edx, DWORD PTR _dest$32397[ebp]
  0020c	c1 ea 10	 shr	 edx, 16			; 00000010H
  0020f	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00212	03 45 f0	 add	 eax, DWORD PTR _buffer_pos$32376[ebp]
  00215	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 111  : 			buffer[buffer_pos + 2] = (uint8_t)(dest >> 8);

  00218	8b 4d dc	 mov	 ecx, DWORD PTR _dest$32397[ebp]
  0021b	c1 e9 08	 shr	 ecx, 8
  0021e	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00221	03 55 f0	 add	 edx, DWORD PTR _buffer_pos$32376[ebp]
  00224	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 112  : 			buffer[buffer_pos + 1] = (uint8_t)(dest);

  00227	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  0022a	03 45 f0	 add	 eax, DWORD PTR _buffer_pos$32376[ebp]
  0022d	8a 4d dc	 mov	 cl, BYTE PTR _dest$32397[ebp]
  00230	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 113  : 			buffer_pos += 5;

  00233	8b 55 f0	 mov	 edx, DWORD PTR _buffer_pos$32376[ebp]
  00236	83 c2 05	 add	 edx, 5
  00239	89 55 f0	 mov	 DWORD PTR _buffer_pos$32376[ebp], edx

; 114  : 			prev_mask = 0;

  0023c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _prev_mask$[ebp], 0

; 115  : 
; 116  : 		} else {

  00243	eb 2e		 jmp	 SHORT $LN3@x86_code
$LN11@x86_code:

; 117  : 			++buffer_pos;

  00245	8b 45 f0	 mov	 eax, DWORD PTR _buffer_pos$32376[ebp]
  00248	83 c0 01	 add	 eax, 1
  0024b	89 45 f0	 mov	 DWORD PTR _buffer_pos$32376[ebp], eax

; 118  : 			prev_mask |= 1;

  0024e	8b 4d f8	 mov	 ecx, DWORD PTR _prev_mask$[ebp]
  00251	83 c9 01	 or	 ecx, 1
  00254	89 4d f8	 mov	 DWORD PTR _prev_mask$[ebp], ecx

; 119  : 			if (Test86MSByte(b))

  00257	0f b6 55 eb	 movzx	 edx, BYTE PTR _b$32380[ebp]
  0025b	85 d2		 test	 edx, edx
  0025d	74 0b		 je	 SHORT $LN1@x86_code
  0025f	0f b6 45 eb	 movzx	 eax, BYTE PTR _b$32380[ebp]
  00263	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00268	75 09		 jne	 SHORT $LN3@x86_code
$LN1@x86_code:

; 120  : 				prev_mask |= 0x10;

  0026a	8b 4d f8	 mov	 ecx, DWORD PTR _prev_mask$[ebp]
  0026d	83 c9 10	 or	 ecx, 16			; 00000010H
  00270	89 4d f8	 mov	 DWORD PTR _prev_mask$[ebp], ecx
$LN3@x86_code:

; 121  : 		}
; 122  : 	}
; 123  :   }

  00273	e9 d6 fd ff ff	 jmp	 $LN19@x86_code
$LN18@x86_code:

; 124  : 
; 125  : 	simple->prev_mask = prev_mask;

  00278	8b 55 fc	 mov	 edx, DWORD PTR _simple$[ebp]
  0027b	8b 45 f8	 mov	 eax, DWORD PTR _prev_mask$[ebp]
  0027e	89 02		 mov	 DWORD PTR [edx], eax

; 126  : 	simple->prev_pos = prev_pos;

  00280	8b 4d fc	 mov	 ecx, DWORD PTR _simple$[ebp]
  00283	8b 55 f4	 mov	 edx, DWORD PTR _prev_pos$[ebp]
  00286	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 127  : 
; 128  : 	return buffer_pos;

  00289	8b 45 f0	 mov	 eax, DWORD PTR _buffer_pos$32376[ebp]
$LN22@x86_code:

; 129  :   }
; 130  : }

  0028c	8b e5		 mov	 esp, ebp
  0028e	5d		 pop	 ebp
  0028f	c3		 ret	 0
_x86_code ENDP
; Function compile flags: /Odtp
;	COMDAT _x86_coder_init
_TEXT	SEGMENT
_coder$32429 = -12					; size = 4
_simple$32430 = -8					; size = 4
_ret$ = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_x86_coder_init PROC					; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 137  : 	const lzma_ret ret = lzma_simple_coder_init(next, allocator, filters,
; 138  : 			&x86_code, sizeof(lzma_simple_x86), 5, 1, is_encoder);

  00006	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	6a 05		 push	 5
  0000f	6a 08		 push	 8
  00011	68 00 00 00 00	 push	 OFFSET _x86_code
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00027	83 c4 20	 add	 esp, 32			; 00000020H
  0002a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 139  : 
; 140  : 	if (ret == LZMA_OK) {

  0002d	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00031	75 24		 jne	 SHORT $LN1@x86_coder_

; 141  : 		lzma_simple_coder *coder = next->coder;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	89 55 f4	 mov	 DWORD PTR _coder$32429[ebp], edx

; 142  : 		lzma_simple_x86 *simple = coder->simple;

  0003b	8b 45 f4	 mov	 eax, DWORD PTR _coder$32429[ebp]
  0003e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00041	89 4d f8	 mov	 DWORD PTR _simple$32430[ebp], ecx

; 143  : 		simple->prev_mask = 0;

  00044	8b 55 f8	 mov	 edx, DWORD PTR _simple$32430[ebp]
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 144  : 		simple->prev_pos = (uint32_t)(-5);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _simple$32430[ebp]
  00050	c7 40 04 fb ff
	ff ff		 mov	 DWORD PTR [eax+4], -5	; fffffffbH
$LN1@x86_coder_:

; 145  : 	}
; 146  : 
; 147  : 	return ret;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 148  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_x86_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_x86_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_x86_decoder_init PROC			; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  : 	return x86_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _x86_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 166  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_x86_decoder_init ENDP
END
