; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lz\lz_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.c
;	COMDAT _move_window
_TEXT	SEGMENT
_move_size$32489 = -8					; size = 4
_move_offset$32487 = -4					; size = 4
_mf$ = 8						; size = 4
_move_window PROC					; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 48   : 	// Align the move to a multiple of 16 bytes. Some LZ-based encoders
; 49   : 	// like LZMA use the lowest bits of mf->read_pos to know the
; 50   : 	// alignment of the uncompressed data. We also get better speed
; 51   : 	// for memmove() with aligned buffers.
; 52   : 	assert(mf->read_pos > mf->keep_size_before);
; 53   :   {
; 54   : 	const uint32_t move_offset
; 55   : 		= (mf->read_pos - mf->keep_size_before) & ~UINT32_C(15);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000f	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00012	83 e2 f0	 and	 edx, -16		; fffffff0H
  00015	89 55 fc	 mov	 DWORD PTR _move_offset$32487[ebp], edx

; 56   : 
; 57   : 	assert(mf->write_pos > move_offset);
; 58   :   {
; 59   : 	const size_t move_size = mf->write_pos - move_offset;

  00018	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001e	2b 4d fc	 sub	 ecx, DWORD PTR _move_offset$32487[ebp]
  00021	89 4d f8	 mov	 DWORD PTR _move_size$32489[ebp], ecx

; 60   : 
; 61   : 	assert(move_offset + move_size <= mf->size);
; 62   : 
; 63   : 	memmove(mf->buffer, mf->buffer + move_offset, move_size);

  00024	8b 55 f8	 mov	 edx, DWORD PTR _move_size$32489[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	03 4d fc	 add	 ecx, DWORD PTR _move_offset$32487[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _memmove
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 64   : 
; 65   : 	mf->offset += move_offset;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00042	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00045	03 55 fc	 add	 edx, DWORD PTR _move_offset$32487[ebp]
  00048	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0004b	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 66   : 	mf->read_pos -= move_offset;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00051	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00054	2b 55 fc	 sub	 edx, DWORD PTR _move_offset$32487[ebp]
  00057	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005a	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 67   : 	mf->read_limit -= move_offset;

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00060	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00063	2b 55 fc	 sub	 edx, DWORD PTR _move_offset$32487[ebp]
  00066	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00069	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 68   : 	mf->write_pos -= move_offset;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0006f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00072	2b 55 fc	 sub	 edx, DWORD PTR _move_offset$32487[ebp]
  00075	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00078	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 69   :   }}
; 70   : 
; 71   : 	return;
; 72   : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_move_window ENDP
; Function compile flags: /Odtp
;	COMDAT _lz_encoder_update
_TEXT	SEGMENT
_ret_$32673 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters_null$ = 16					; size = 4
_reversed_filters$ = 20					; size = 4
_lz_encoder_update PROC					; COMDAT

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 555  : 	lzma_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 556  : 
; 557  : 	if (coder->lz.options_update == NULL)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00013	75 07		 jne	 SHORT $LN4@lz_encoder

; 558  : 		return LZMA_PROG_ERROR;

  00015	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0001a	eb 41		 jmp	 SHORT $LN6@lz_encoder
$LN4@lz_encoder:

; 559  : 
; 560  : 	return_if_error(coder->lz.options_update(
; 561  : 			coder->lz.coder, reversed_filters));

  0001c	8b 55 14	 mov	 edx, DWORD PTR _reversed_filters$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00029	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002c	ff d0		 call	 eax
  0002e	83 c4 08	 add	 esp, 8
  00031	89 45 f8	 mov	 DWORD PTR _ret_$32673[ebp], eax
  00034	83 7d f8 00	 cmp	 DWORD PTR _ret_$32673[ebp], 0
  00038	74 05		 je	 SHORT $LN3@lz_encoder
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32673[ebp]
  0003d	eb 1e		 jmp	 SHORT $LN6@lz_encoder
$LN3@lz_encoder:
  0003f	33 c9		 xor	 ecx, ecx
  00041	75 d9		 jne	 SHORT $LN4@lz_encoder

; 562  : 
; 563  : 	return lzma_next_filter_update(
; 564  : 			&coder->next, allocator, reversed_filters + 1);

  00043	8b 55 14	 mov	 edx, DWORD PTR _reversed_filters$[ebp]
  00046	83 c2 10	 add	 edx, 16			; 00000010H
  00049	52		 push	 edx
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00051	83 c1 70	 add	 ecx, 112		; 00000070H
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _lzma_next_filter_update
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@lz_encoder:

; 565  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_lz_encoder_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lz_encoder_init
_TEXT	SEGMENT
tv162 = -4						; size = 4
_mf$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lz_options$ = 16					; size = 4
_lz_encoder_init PROC					; COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 388  : 	// Allocate the history buffer.
; 389  : 	if (mf->buffer == NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00007	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000a	75 42		 jne	 SHORT $LN9@lz_encoder@2

; 390  : 		// lzma_memcmplen() is used for the dictionary buffer
; 391  : 		// so we need to allocate a few extra bytes to prevent
; 392  : 		// it from reading past the end of the buffer.
; 393  : 		mf->buffer = lzma_alloc(mf->size + LZMA_MEMCMPLEN_EXTRA,
; 394  : 				allocator);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00013	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00016	83 c0 04	 add	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _lzma_alloc
  0001f	83 c4 08	 add	 esp, 8
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00025	89 01		 mov	 DWORD PTR [ecx], eax

; 395  : 		if (mf->buffer == NULL)

  00027	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0002a	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002d	75 07		 jne	 SHORT $LN8@lz_encoder@2

; 396  : 			return true;

  0002f	b0 01		 mov	 al, 1
  00031	e9 c5 01 00 00	 jmp	 $LN10@lz_encoder@2
$LN8@lz_encoder@2:

; 397  : 
; 398  : 		// Keep Valgrind happy with lzma_memcmplen() and initialize
; 399  : 		// the extra bytes whose value may get read but which will
; 400  : 		// effectively get ignored.
; 401  : 		memzero(mf->buffer + mf->size, LZMA_MEMCMPLEN_EXTRA);

  00036	6a 04		 push	 4
  00038	6a 00		 push	 0
  0003a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00042	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _memset
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@lz_encoder@2:

; 402  : 	}
; 403  : 
; 404  : 	// Use cyclic_size as initial mf->offset. This allows
; 405  : 	// avoiding a few branches in the match finders. The downside is
; 406  : 	// that match finder needs to be normalized more often, which may
; 407  : 	// hurt performance with huge dictionaries.
; 408  : 	mf->offset = mf->cyclic_size;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00054	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00057	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 409  : 	mf->read_pos = 0;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 410  : 	mf->read_ahead = 0;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00067	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 411  : 	mf->read_limit = 0;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00071	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 412  : 	mf->write_pos = 0;

  00078	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0007b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 413  : 	mf->pending = 0;

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00085	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 414  : 
; 415  : #if UINT32_MAX >= SIZE_MAX / 4
; 416  : 	// Check for integer overflow. (Huge dictionaries are not
; 417  : 	// possible on 32-bit CPU.)
; 418  : 	if (mf->hash_count > SIZE_MAX / sizeof(uint32_t)
; 419  : 			|| mf->sons_count > SIZE_MAX / sizeof(uint32_t))

  0008c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0008f	81 7a 54 ff ff
	ff 3f		 cmp	 DWORD PTR [edx+84], 1073741823 ; 3fffffffH
  00096	77 0c		 ja	 SHORT $LN6@lz_encoder@2
  00098	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0009b	81 78 58 ff ff
	ff 3f		 cmp	 DWORD PTR [eax+88], 1073741823 ; 3fffffffH
  000a2	76 07		 jbe	 SHORT $LN7@lz_encoder@2
$LN6@lz_encoder@2:

; 420  : 		return true;

  000a4	b0 01		 mov	 al, 1
  000a6	e9 50 01 00 00	 jmp	 $LN10@lz_encoder@2
$LN7@lz_encoder@2:

; 421  : #endif
; 422  : 
; 423  : 	// Allocate and initialize the hash table. Since EMPTY_HASH_VALUE
; 424  : 	// is zero, we can use lzma_alloc_zero() or memzero() for mf->hash.
; 425  : 	//
; 426  : 	// We don't need to initialize mf->son, but not doing that may
; 427  : 	// make Valgrind complain in normalization (see normalize() in
; 428  : 	// lz_encoder_mf.c). Skipping the initialization is *very* good
; 429  : 	// when big dictionary is used but only small amount of data gets
; 430  : 	// actually compressed: most of the mf->son won't get actually
; 431  : 	// allocated by the kernel, so we avoid wasting RAM and improve
; 432  : 	// initialization speed a lot.
; 433  : 	if (mf->hash == NULL) {

  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000ae	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000b2	0f 85 8d 00 00
	00		 jne	 $LN5@lz_encoder@2

; 434  : 		mf->hash = lzma_alloc_zero(mf->hash_count * sizeof(uint32_t),
; 435  : 				allocator);

  000b8	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000bf	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000c2	c1 e1 02	 shl	 ecx, 2
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _lzma_alloc_zero
  000cb	83 c4 08	 add	 esp, 8
  000ce	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000d1	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 436  : 		mf->son = lzma_alloc(mf->sons_count * sizeof(uint32_t),
; 437  : 				allocator);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000db	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  000de	c1 e2 02	 shl	 edx, 2
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 _lzma_alloc
  000e7	83 c4 08	 add	 esp, 8
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000ed	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 438  : 
; 439  : 		if (mf->hash == NULL || mf->son == NULL) {

  000f0	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000f3	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  000f7	74 09		 je	 SHORT $LN3@lz_encoder@2
  000f9	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000fc	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00100	75 41		 jne	 SHORT $LN4@lz_encoder@2
$LN3@lz_encoder@2:

; 440  : 			lzma_free(mf->hash, allocator);

  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00105	51		 push	 ecx
  00106	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00109	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _lzma_free
  00112	83 c4 08	 add	 esp, 8

; 441  : 			mf->hash = NULL;

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00118	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 442  : 
; 443  : 			lzma_free(mf->son, allocator);

  0011f	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00122	52		 push	 edx
  00123	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00126	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 _lzma_free
  0012f	83 c4 08	 add	 esp, 8

; 444  : 			mf->son = NULL;

  00132	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00135	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 445  : 
; 446  : 			return true;

  0013c	b0 01		 mov	 al, 1
  0013e	e9 b8 00 00 00	 jmp	 $LN10@lz_encoder@2
$LN4@lz_encoder@2:

; 447  : 		}
; 448  : 	} else {

  00143	eb 1b		 jmp	 SHORT $LN2@lz_encoder@2
$LN5@lz_encoder@2:

; 449  : /*
; 450  : 		for (uint32_t i = 0; i < mf->hash_count; ++i)
; 451  : 			mf->hash[i] = EMPTY_HASH_VALUE;
; 452  : */
; 453  : 		memzero(mf->hash, mf->hash_count * sizeof(uint32_t));

  00145	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00148	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0014b	c1 e1 02	 shl	 ecx, 2
  0014e	51		 push	 ecx
  0014f	6a 00		 push	 0
  00151	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00154	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _memset
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@lz_encoder@2:

; 454  : 	}
; 455  : 
; 456  : 	mf->cyclic_pos = 0;

  00160	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00163	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 457  : 
; 458  : 	// Handle preset dictionary.
; 459  : 	if (lz_options->preset_dict != NULL
; 460  : 			&& lz_options->preset_dict_size > 0) {

  0016a	8b 55 10	 mov	 edx, DWORD PTR _lz_options$[ebp]
  0016d	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00171	74 7c		 je	 SHORT $LN1@lz_encoder@2
  00173	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00176	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0017a	76 73		 jbe	 SHORT $LN1@lz_encoder@2

; 461  : 		// If the preset dictionary is bigger than the actual
; 462  : 		// dictionary, use only the tail.
; 463  : 		mf->write_pos = my_min(lz_options->preset_dict_size, mf->size);

  0017c	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  0017f	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00182	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00185	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00188	73 0b		 jae	 SHORT $LN12@lz_encoder@2
  0018a	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  0018d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00190	89 55 fc	 mov	 DWORD PTR tv162[ebp], edx
  00193	eb 09		 jmp	 SHORT $LN13@lz_encoder@2
$LN12@lz_encoder@2:
  00195	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00198	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019b	89 4d fc	 mov	 DWORD PTR tv162[ebp], ecx
$LN13@lz_encoder@2:
  0019e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  001a1	8b 45 fc	 mov	 eax, DWORD PTR tv162[ebp]
  001a4	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 464  : 		memcpy(mf->buffer, lz_options->preset_dict
; 465  : 				+ lz_options->preset_dict_size - mf->write_pos,
; 466  : 				mf->write_pos);

  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001aa	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001ad	52		 push	 edx
  001ae	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  001b1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001b4	8b 55 10	 mov	 edx, DWORD PTR _lz_options$[ebp]
  001b7	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  001ba	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001bd	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  001c0	51		 push	 ecx
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 _memcpy
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 467  : 		mf->action = LZMA_SYNC_FLUSH;

  001cf	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001d2	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [eax+80], 1

; 468  : 		mf->skip(mf, mf->write_pos);

  001d9	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001dc	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001df	52		 push	 edx
  001e0	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001e3	50		 push	 eax
  001e4	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001e7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001ea	ff d2		 call	 edx
  001ec	83 c4 08	 add	 esp, 8
$LN1@lz_encoder@2:

; 469  : 	}
; 470  : 
; 471  : 	mf->action = LZMA_RUN;

  001ef	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001f2	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 472  : 
; 473  : 	return false;

  001f9	32 c0		 xor	 al, al
$LN10@lz_encoder@2:

; 474  : }

  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
_lz_encoder_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fill_window
_TEXT	SEGMENT
tv84 = -16						; size = 4
_pending$32518 = -12					; size = 4
_ret$32508 = -8						; size = 4
_write_pos$32507 = -4					; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_action$ = 28						; size = 4
_fill_window PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 88   : 	assert(coder->mf.read_pos <= coder->mf.write_pos);
; 89   : 
; 90   : 	// Move the sliding window if needed.
; 91   : 	if (coder->mf.read_pos >= coder->mf.size - coder->mf.keep_size_after)

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000f	2b 51 1c	 sub	 edx, DWORD PTR [ecx+28]
  00012	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00015	39 50 24	 cmp	 DWORD PTR [eax+36], edx
  00018	72 0f		 jb	 SHORT $LN7@fill_windo

; 92   : 		move_window(&coder->mf);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0001d	83 c1 10	 add	 ecx, 16			; 00000010H
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _move_window
  00026	83 c4 04	 add	 esp, 4
$LN7@fill_windo:

; 93   : 
; 94   : 	// Maybe this is ugly, but lzma_mf uses uint32_t for most things
; 95   : 	// (which I find cleanest), but we need size_t here when filling
; 96   : 	// the history window.
; 97   :   {
; 98   : 	size_t write_pos = coder->mf.write_pos;

  00029	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0002f	89 45 fc	 mov	 DWORD PTR _write_pos$32507[ebp], eax

; 99   : 	lzma_ret ret;
; 100  : 	if (coder->next.code == NULL) {

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00035	83 b9 84 00 00
	00 00		 cmp	 DWORD PTR [ecx+132], 0
  0003c	75 4e		 jne	 SHORT $LN6@fill_windo

; 101  : 		// Not using a filter, simply memcpy() as much as possible.
; 102  : 		lzma_bufcpy(in, in_pos, in_size, coder->mf.buffer,
; 103  : 				&write_pos, coder->mf.size);

  0003e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00041	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00044	50		 push	 eax
  00045	8d 4d fc	 lea	 ecx, DWORD PTR _write_pos$32507[ebp]
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004f	50		 push	 eax
  00050	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00057	52		 push	 edx
  00058	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _lzma_bufcpy
  00061	83 c4 18	 add	 esp, 24			; 00000018H

; 104  : 
; 105  : 		ret = action != LZMA_RUN && *in_pos == in_size
; 106  : 				? LZMA_STREAM_END : LZMA_OK;

  00064	83 7d 1c 00	 cmp	 DWORD PTR _action$[ebp], 0
  00068	74 13		 je	 SHORT $LN10@fill_windo
  0006a	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0006d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006f	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00072	75 09		 jne	 SHORT $LN10@fill_windo
  00074	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  0007b	eb 07		 jmp	 SHORT $LN11@fill_windo
$LN10@fill_windo:
  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN11@fill_windo:
  00084	8b 45 f0	 mov	 eax, DWORD PTR tv84[ebp]
  00087	89 45 f8	 mov	 DWORD PTR _ret$32508[ebp], eax

; 107  : 
; 108  : 	} else {

  0008a	eb 3e		 jmp	 SHORT $LN5@fill_windo
$LN6@fill_windo:

; 109  : 		ret = coder->next.code(coder->next.coder, allocator,
; 110  : 				in, in_pos, in_size,
; 111  : 				coder->mf.buffer, &write_pos,
; 112  : 				coder->mf.size, action);

  0008c	8b 4d 1c	 mov	 ecx, DWORD PTR _action$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00093	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00096	50		 push	 eax
  00097	8d 4d fc	 lea	 ecx, DWORD PTR _write_pos$32507[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0009e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a1	50		 push	 eax
  000a2	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  000a5	51		 push	 ecx
  000a6	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  000a9	52		 push	 edx
  000aa	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000b5	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  000b8	50		 push	 eax
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000bc	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  000c2	ff d2		 call	 edx
  000c4	83 c4 24	 add	 esp, 36			; 00000024H
  000c7	89 45 f8	 mov	 DWORD PTR _ret$32508[ebp], eax
$LN5@fill_windo:

; 113  : 	}
; 114  : 
; 115  : 	coder->mf.write_pos = (uint32_t)write_pos;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _write_pos$32507[ebp]
  000d0	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 116  : 
; 117  : 	// Silence Valgrind. lzma_memcmplen() can read extra bytes
; 118  : 	// and Valgrind will give warnings if those bytes are uninitialized
; 119  : 	// because Valgrind cannot see that the values of the uninitialized
; 120  : 	// bytes are eventually ignored.
; 121  : 	memzero(coder->mf.buffer + write_pos, LZMA_MEMCMPLEN_EXTRA);

  000d3	6a 04		 push	 4
  000d5	6a 00		 push	 0
  000d7	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000da	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000dd	03 45 fc	 add	 eax, DWORD PTR _write_pos$32507[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _memset
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 
; 123  : 	// If end of stream has been reached or flushing completed, we allow
; 124  : 	// the encoder to process all the input (that is, read_pos is allowed
; 125  : 	// to reach write_pos). Otherwise we keep keep_size_after bytes
; 126  : 	// available as prebuffer.
; 127  : 	if (ret == LZMA_STREAM_END) {

  000e9	83 7d f8 01	 cmp	 DWORD PTR _ret$32508[ebp], 1
  000ed	75 1e		 jne	 SHORT $LN4@fill_windo

; 128  : 		assert(*in_pos == in_size);
; 129  : 		ret = LZMA_OK;

  000ef	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$32508[ebp], 0

; 130  : 		coder->mf.action = action;

  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000f9	8b 55 1c	 mov	 edx, DWORD PTR _action$[ebp]
  000fc	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 131  : 		coder->mf.read_limit = coder->mf.write_pos;

  000ff	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00105	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00108	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  0010b	eb 20		 jmp	 SHORT $LN3@fill_windo
$LN4@fill_windo:

; 132  : 
; 133  : 	} else if (coder->mf.write_pos > coder->mf.keep_size_after) {

  0010d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00113	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00116	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00119	76 12		 jbe	 SHORT $LN3@fill_windo

; 134  : 		// This needs to be done conditionally, because if we got
; 135  : 		// only little new input, there may be too little input
; 136  : 		// to do any encoding yet.
; 137  : 		coder->mf.read_limit = coder->mf.write_pos
; 138  : 				- coder->mf.keep_size_after;

  0011b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00121	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00124	2b 51 1c	 sub	 edx, DWORD PTR [ecx+28]
  00127	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0012a	89 50 2c	 mov	 DWORD PTR [eax+44], edx
$LN3@fill_windo:

; 139  : 	}
; 140  : 
; 141  : 	// Restart the match finder after finished LZMA_SYNC_FLUSH.
; 142  : 	if (coder->mf.pending > 0
; 143  : 			&& coder->mf.read_pos < coder->mf.read_limit) {

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00130	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00134	76 46		 jbe	 SHORT $LN1@fill_windo
  00136	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00139	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0013c	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0013f	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  00142	73 38		 jae	 SHORT $LN1@fill_windo

; 144  : 		// Match finder may update coder->pending and expects it to
; 145  : 		// start from zero, so use a temporary variable.
; 146  : 		const uint32_t pending = coder->mf.pending;

  00144	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00147	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0014a	89 45 f4	 mov	 DWORD PTR _pending$32518[ebp], eax

; 147  : 		coder->mf.pending = 0;

  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00150	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 148  : 
; 149  : 		// Rewind read_pos so that the match finder can hash
; 150  : 		// the pending bytes.
; 151  : 		assert(coder->mf.read_pos >= pending);
; 152  : 		coder->mf.read_pos -= pending;

  00157	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0015a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0015d	2b 45 f4	 sub	 eax, DWORD PTR _pending$32518[ebp]
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00163	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 153  : 
; 154  : 		// Call the skip function directly instead of using
; 155  : 		// mf_skip(), since we don't want to touch mf->read_ahead.
; 156  : 		coder->mf.skip(&coder->mf, pending);

  00166	8b 55 f4	 mov	 edx, DWORD PTR _pending$32518[ebp]
  00169	52		 push	 edx
  0016a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0016d	83 c0 10	 add	 eax, 16			; 00000010H
  00170	50		 push	 eax
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00174	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00177	ff d2		 call	 edx
  00179	83 c4 08	 add	 esp, 8
$LN1@fill_windo:

; 157  : 	}
; 158  : 
; 159  : 	return ret;

  0017c	8b 45 f8	 mov	 eax, DWORD PTR _ret$32508[ebp]

; 160  :   }
; 161  : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
_fill_window ENDP
; Function compile flags: /Odtp
;	COMDAT _lz_encoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lz_encoder_end PROC					; COMDAT

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 532  : 	lzma_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 533  : 
; 534  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	83 c2 70	 add	 edx, 112		; 00000070H
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _lzma_next_end
  0001a	83 c4 08	 add	 esp, 8

; 535  : 
; 536  : 	lzma_free(coder->mf.son, allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _lzma_free
  0002d	83 c4 08	 add	 esp, 8

; 537  : 	lzma_free(coder->mf.hash, allocator);

  00030	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00033	50		 push	 eax
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00037	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _lzma_free
  00040	83 c4 08	 add	 esp, 8

; 538  : 	lzma_free(coder->mf.buffer, allocator);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _lzma_free
  00053	83 c4 08	 add	 esp, 8

; 539  : 
; 540  : 	if (coder->lz.end != NULL)

  00056	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00059	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0005d	74 17		 je	 SHORT $LN2@lz_encoder@3

; 541  : 		coder->lz.end(coder->lz.coder, allocator);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00066	8b 02		 mov	 eax, DWORD PTR [edx]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006f	ff d2		 call	 edx
  00071	83 c4 08	 add	 esp, 8

; 542  : 	else

  00074	eb 12		 jmp	 SHORT $LN1@lz_encoder@3
$LN2@lz_encoder@3:

; 543  : 		lzma_free(coder->lz.coder, allocator);

  00076	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _lzma_free
  00085	83 c4 08	 add	 esp, 8
$LN1@lz_encoder@3:

; 544  : 
; 545  : 	lzma_free(coder, allocator);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _lzma_free
  00095	83 c4 08	 add	 esp, 8

; 546  : 	return;
; 547  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_lz_encoder_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lz_encoder_prepare
_TEXT	SEGMENT
tv140 = -32						; size = 4
_old_sons_count$32599 = -28				; size = 4
_old_hash_count$32598 = -24				; size = 4
_is_bt$32588 = -17					; size = 1
_hs$32589 = -16						; size = 4
_hash_bytes$32586 = -12					; size = 4
_old_size$32569 = -8					; size = 4
_reserve$32565 = -4					; size = 4
_mf$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lz_options$ = 16					; size = 4
_lz_encoder_prepare PROC				; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 203  : 	// For now, the dictionary size is limited to 1.5 GiB. This may grow
; 204  : 	// in the future if needed, but it needs a little more work than just
; 205  : 	// changing this check.
; 206  : 	if (lz_options->dict_size < LZMA_DICT_SIZE_MIN
; 207  : 			|| lz_options->dict_size
; 208  : 				> (UINT32_C(1) << 30) + (UINT32_C(1) << 29)
; 209  : 			|| lz_options->nice_len > lz_options->match_len_max)

  00006	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00009	81 78 04 00 10
	00 00		 cmp	 DWORD PTR [eax+4], 4096	; 00001000H
  00010	72 1a		 jb	 SHORT $LN25@lz_encoder@4
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00015	81 79 04 00 00
	00 60		 cmp	 DWORD PTR [ecx+4], 1610612736 ; 60000000H
  0001c	77 0e		 ja	 SHORT $LN25@lz_encoder@4
  0001e	8b 55 10	 mov	 edx, DWORD PTR _lz_options$[ebp]
  00021	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00024	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00027	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0002a	76 07		 jbe	 SHORT $LN26@lz_encoder@4
$LN25@lz_encoder@4:

; 210  : 		return true;

  0002c	b0 01		 mov	 al, 1
  0002e	e9 24 03 00 00	 jmp	 $LN27@lz_encoder@4
$LN26@lz_encoder@4:

; 211  : 
; 212  : 	mf->keep_size_before = (uint32_t)(lz_options->before_size + lz_options->dict_size);

  00033	8b 55 10	 mov	 edx, DWORD PTR _lz_options$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  0003b	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00041	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 213  : 
; 214  : 	mf->keep_size_after = (uint32_t)(lz_options->after_size
; 215  : 			+ lz_options->match_len_max);

  00044	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00047	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004a	8b 55 10	 mov	 edx, DWORD PTR _lz_options$[ebp]
  0004d	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  00050	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00053	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 216  : 
; 217  : 	// To avoid constant memmove()s, allocate some extra space. Since
; 218  : 	// memmove()s become more expensive when the size of the buffer
; 219  : 	// increases, we reserve more space when a large dictionary is
; 220  : 	// used to make the memmove() calls rarer.
; 221  : 	//
; 222  : 	// This works with dictionaries up to about 3 GiB. If bigger
; 223  : 	// dictionary is wanted, some extra work is needed:
; 224  : 	//   - Several variables in lzma_mf have to be changed from uint32_t
; 225  : 	//     to size_t.
; 226  : 	//   - Memory usage calculation needs something too, e.g. use uint64_t
; 227  : 	//     for mf->size.
; 228  :   {
; 229  : 	uint32_t reserve = (uint32_t)(lz_options->dict_size / 2);

  00056	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00059	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005c	d1 ea		 shr	 edx, 1
  0005e	89 55 fc	 mov	 DWORD PTR _reserve$32565[ebp], edx

; 230  : 	if (reserve > (UINT32_C(1) << 30))

  00061	81 7d fc 00 00
	00 40		 cmp	 DWORD PTR _reserve$32565[ebp], 1073741824 ; 40000000H
  00068	76 08		 jbe	 SHORT $LN24@lz_encoder@4

; 231  : 		reserve /= 2;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _reserve$32565[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	89 45 fc	 mov	 DWORD PTR _reserve$32565[ebp], eax
$LN24@lz_encoder@4:

; 232  : 
; 233  : //	reserve += (lz_options->before_size + lz_options->match_len_max
; 234  : //			+ lz_options->after_size) / 2 + (UINT32_C(1) << 19);
; 235  :     reserve = (uint32_t)(reserve + (lz_options->before_size + lz_options->match_len_max + lz_options->after_size) / 2 + (UINT32_C(1) << 19));

  00072	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  0007a	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  0007d	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00080	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00083	d1 ea		 shr	 edx, 1
  00085	8b 45 fc	 mov	 eax, DWORD PTR _reserve$32565[ebp]
  00088	8d 8c 10 00 00
	08 00		 lea	 ecx, DWORD PTR [eax+edx+524288]
  0008f	89 4d fc	 mov	 DWORD PTR _reserve$32565[ebp], ecx

; 236  : 
; 237  :   {
; 238  : 	const uint32_t old_size = mf->size;

  00092	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00095	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00098	89 45 f8	 mov	 DWORD PTR _old_size$32569[ebp], eax

; 239  : 	mf->size = mf->keep_size_before + reserve + mf->keep_size_after;

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0009e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a1	03 55 fc	 add	 edx, DWORD PTR _reserve$32565[ebp]
  000a4	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000a7	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000ad	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 240  : 
; 241  : 	// Deallocate the old history buffer if it exists but has different
; 242  : 	// size than what is needed now.
; 243  : 	if (mf->buffer != NULL && old_size != mf->size) {

  000b0	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000b3	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000b6	74 26		 je	 SHORT $LN23@lz_encoder@4
  000b8	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _old_size$32569[ebp]
  000be	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000c1	74 1b		 je	 SHORT $LN23@lz_encoder@4

; 244  : 		lzma_free(mf->buffer, allocator);

  000c3	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000c6	52		 push	 edx
  000c7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _lzma_free
  000d2	83 c4 08	 add	 esp, 8

; 245  : 		mf->buffer = NULL;

  000d5	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000d8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN23@lz_encoder@4:

; 246  : 	}
; 247  : 
; 248  : 	// Match finder options
; 249  : 	mf->match_len_max = (uint32_t)lz_options->match_len_max;

  000de	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000e1	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  000e4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000e7	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 250  : 	mf->nice_len = (uint32_t)lz_options->nice_len;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000ed	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  000f0	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000f3	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 251  : 
; 252  : 	// cyclic_size has to stay smaller than 2 Gi. Note that this doesn't
; 253  : 	// mean limiting dictionary size to less than 2 GiB. With a match
; 254  : 	// finder that uses multibyte resolution (hashes start at e.g. every
; 255  : 	// fourth byte), cyclic_size would stay below 2 Gi even when
; 256  : 	// dictionary size is greater than 2 GiB.
; 257  : 	//
; 258  : 	// It would be possible to allow cyclic_size >= 2 Gi, but then we
; 259  : 	// would need to be careful to use 64-bit types in various places
; 260  : 	// (size_t could do since we would need bigger than 32-bit address
; 261  : 	// space anyway). It would also require either zeroing a multigigabyte
; 262  : 	// buffer at initialization (waste of time and RAM) or allow
; 263  : 	// normalization in lz_encoder_mf.c to access uninitialized
; 264  : 	// memory to keep the code simpler. The current way is simple and
; 265  : 	// still allows pretty big dictionaries, so I don't expect these
; 266  : 	// limits to change.
; 267  : 	mf->cyclic_size = (uint32_t)(lz_options->dict_size + 1);

  000f6	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  000f9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fc	83 c1 01	 add	 ecx, 1
  000ff	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00102	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 268  : 
; 269  : 	// Validate the match finder ID and setup the function pointers.
; 270  : 	switch (lz_options->match_finder) {

  00105	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00108	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0010b	89 4d e0	 mov	 DWORD PTR tv140[ebp], ecx
  0010e	8b 55 e0	 mov	 edx, DWORD PTR tv140[ebp]
  00111	83 ea 03	 sub	 edx, 3
  00114	89 55 e0	 mov	 DWORD PTR tv140[ebp], edx
  00117	83 7d e0 11	 cmp	 DWORD PTR tv140[ebp], 17 ; 00000011H
  0011b	77 7f		 ja	 SHORT $LN15@lz_encoder@4
  0011d	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  00120	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN29@lz_encoder@4[eax]
  00127	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN30@lz_encoder@4[ecx*4]
$LN20@lz_encoder@4:

; 271  : #ifdef HAVE_MF_HC3
; 272  : 	case LZMA_MF_HC3:
; 273  : 		mf->find = &lzma_mf_hc3_find;

  0012e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00131	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _lzma_mf_hc3_find

; 274  : 		mf->skip = &lzma_mf_hc3_skip;

  00138	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0013b	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _lzma_mf_hc3_skip

; 275  : 		break;

  00142	eb 5f		 jmp	 SHORT $LN21@lz_encoder@4
$LN19@lz_encoder@4:

; 276  : #endif
; 277  : #ifdef HAVE_MF_HC4
; 278  : 	case LZMA_MF_HC4:
; 279  : 		mf->find = &lzma_mf_hc4_find;

  00144	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00147	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _lzma_mf_hc4_find

; 280  : 		mf->skip = &lzma_mf_hc4_skip;

  0014e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00151	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], OFFSET _lzma_mf_hc4_skip

; 281  : 		break;

  00158	eb 49		 jmp	 SHORT $LN21@lz_encoder@4
$LN18@lz_encoder@4:

; 282  : #endif
; 283  : #ifdef HAVE_MF_BT2
; 284  : 	case LZMA_MF_BT2:
; 285  : 		mf->find = &lzma_mf_bt2_find;

  0015a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0015d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _lzma_mf_bt2_find

; 286  : 		mf->skip = &lzma_mf_bt2_skip;

  00164	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00167	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _lzma_mf_bt2_skip

; 287  : 		break;

  0016e	eb 33		 jmp	 SHORT $LN21@lz_encoder@4
$LN17@lz_encoder@4:

; 288  : #endif
; 289  : #ifdef HAVE_MF_BT3
; 290  : 	case LZMA_MF_BT3:
; 291  : 		mf->find = &lzma_mf_bt3_find;

  00170	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00173	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _lzma_mf_bt3_find

; 292  : 		mf->skip = &lzma_mf_bt3_skip;

  0017a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0017d	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _lzma_mf_bt3_skip

; 293  : 		break;

  00184	eb 1d		 jmp	 SHORT $LN21@lz_encoder@4
$LN16@lz_encoder@4:

; 294  : #endif
; 295  : #ifdef HAVE_MF_BT4
; 296  : 	case LZMA_MF_BT4:
; 297  : 		mf->find = &lzma_mf_bt4_find;

  00186	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00189	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _lzma_mf_bt4_find

; 298  : 		mf->skip = &lzma_mf_bt4_skip;

  00190	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00193	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], OFFSET _lzma_mf_bt4_skip

; 299  : 		break;

  0019a	eb 07		 jmp	 SHORT $LN21@lz_encoder@4
$LN15@lz_encoder@4:

; 300  : #endif
; 301  : 
; 302  : 	default:
; 303  : 		return true;

  0019c	b0 01		 mov	 al, 1
  0019e	e9 b4 01 00 00	 jmp	 $LN27@lz_encoder@4
$LN21@lz_encoder@4:

; 304  : 	}
; 305  : 
; 306  : 	// Calculate the sizes of mf->hash and mf->son and check that
; 307  : 	// nice_len is big enough for the selected match finder.
; 308  :   {
; 309  : 	const uint32_t hash_bytes = lz_options->match_finder & 0x0F;

  001a3	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  001a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a9	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001ac	89 4d f4	 mov	 DWORD PTR _hash_bytes$32586[ebp], ecx

; 310  : 	if (hash_bytes > mf->nice_len)

  001af	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  001b2	8b 45 f4	 mov	 eax, DWORD PTR _hash_bytes$32586[ebp]
  001b5	3b 42 48	 cmp	 eax, DWORD PTR [edx+72]
  001b8	76 07		 jbe	 SHORT $LN14@lz_encoder@4

; 311  : 		return true;

  001ba	b0 01		 mov	 al, 1
  001bc	e9 96 01 00 00	 jmp	 $LN27@lz_encoder@4
$LN14@lz_encoder@4:

; 312  : 
; 313  :   {
; 314  : 	const bool is_bt = (lz_options->match_finder & 0x10) != 0;

  001c1	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  001c4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001c7	83 e2 10	 and	 edx, 16			; 00000010H
  001ca	f7 da		 neg	 edx
  001cc	1b d2		 sbb	 edx, edx
  001ce	f7 da		 neg	 edx
  001d0	88 55 ef	 mov	 BYTE PTR _is_bt$32588[ebp], dl

; 315  : 	uint32_t hs;
; 316  : 
; 317  : 	if (hash_bytes == 2) {

  001d3	83 7d f4 02	 cmp	 DWORD PTR _hash_bytes$32586[ebp], 2
  001d7	75 09		 jne	 SHORT $LN13@lz_encoder@4

; 318  : 		hs = 0xFFFF;

  001d9	c7 45 f0 ff ff
	00 00		 mov	 DWORD PTR _hs$32589[ebp], 65535 ; 0000ffffH

; 319  : 	} else {

  001e0	eb 6f		 jmp	 SHORT $LN12@lz_encoder@4
$LN13@lz_encoder@4:

; 320  : 		// Round dictionary size up to the next 2^n - 1 so it can
; 321  : 		// be used as a hash mask.
; 322  : 		hs = (uint32_t)(lz_options->dict_size - 1);

  001e2	8b 45 10	 mov	 eax, DWORD PTR _lz_options$[ebp]
  001e5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e8	83 e9 01	 sub	 ecx, 1
  001eb	89 4d f0	 mov	 DWORD PTR _hs$32589[ebp], ecx

; 323  : 		hs |= hs >> 1;

  001ee	8b 55 f0	 mov	 edx, DWORD PTR _hs$32589[ebp]
  001f1	d1 ea		 shr	 edx, 1
  001f3	0b 55 f0	 or	 edx, DWORD PTR _hs$32589[ebp]
  001f6	89 55 f0	 mov	 DWORD PTR _hs$32589[ebp], edx

; 324  : 		hs |= hs >> 2;

  001f9	8b 45 f0	 mov	 eax, DWORD PTR _hs$32589[ebp]
  001fc	c1 e8 02	 shr	 eax, 2
  001ff	0b 45 f0	 or	 eax, DWORD PTR _hs$32589[ebp]
  00202	89 45 f0	 mov	 DWORD PTR _hs$32589[ebp], eax

; 325  : 		hs |= hs >> 4;

  00205	8b 4d f0	 mov	 ecx, DWORD PTR _hs$32589[ebp]
  00208	c1 e9 04	 shr	 ecx, 4
  0020b	0b 4d f0	 or	 ecx, DWORD PTR _hs$32589[ebp]
  0020e	89 4d f0	 mov	 DWORD PTR _hs$32589[ebp], ecx

; 326  : 		hs |= hs >> 8;

  00211	8b 55 f0	 mov	 edx, DWORD PTR _hs$32589[ebp]
  00214	c1 ea 08	 shr	 edx, 8
  00217	0b 55 f0	 or	 edx, DWORD PTR _hs$32589[ebp]
  0021a	89 55 f0	 mov	 DWORD PTR _hs$32589[ebp], edx

; 327  : 		hs >>= 1;

  0021d	8b 45 f0	 mov	 eax, DWORD PTR _hs$32589[ebp]
  00220	d1 e8		 shr	 eax, 1
  00222	89 45 f0	 mov	 DWORD PTR _hs$32589[ebp], eax

; 328  : 		hs |= 0xFFFF;

  00225	8b 4d f0	 mov	 ecx, DWORD PTR _hs$32589[ebp]
  00228	81 c9 ff ff 00
	00		 or	 ecx, 65535		; 0000ffffH
  0022e	89 4d f0	 mov	 DWORD PTR _hs$32589[ebp], ecx

; 329  : 
; 330  : 		if (hs > (UINT32_C(1) << 24)) {

  00231	81 7d f0 00 00
	00 01		 cmp	 DWORD PTR _hs$32589[ebp], 16777216 ; 01000000H
  00238	76 17		 jbe	 SHORT $LN12@lz_encoder@4

; 331  : 			if (hash_bytes == 3)

  0023a	83 7d f4 03	 cmp	 DWORD PTR _hash_bytes$32586[ebp], 3
  0023e	75 09		 jne	 SHORT $LN10@lz_encoder@4

; 332  : 				hs = (UINT32_C(1) << 24) - 1;

  00240	c7 45 f0 ff ff
	ff 00		 mov	 DWORD PTR _hs$32589[ebp], 16777215 ; 00ffffffH

; 333  : 			else

  00247	eb 08		 jmp	 SHORT $LN12@lz_encoder@4
$LN10@lz_encoder@4:

; 334  : 				hs >>= 1;

  00249	8b 55 f0	 mov	 edx, DWORD PTR _hs$32589[ebp]
  0024c	d1 ea		 shr	 edx, 1
  0024e	89 55 f0	 mov	 DWORD PTR _hs$32589[ebp], edx
$LN12@lz_encoder@4:

; 335  : 		}
; 336  : 	}
; 337  : 
; 338  : 	mf->hash_mask = hs;

  00251	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00254	8b 4d f0	 mov	 ecx, DWORD PTR _hs$32589[ebp]
  00257	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 339  : 
; 340  : 	++hs;

  0025a	8b 55 f0	 mov	 edx, DWORD PTR _hs$32589[ebp]
  0025d	83 c2 01	 add	 edx, 1
  00260	89 55 f0	 mov	 DWORD PTR _hs$32589[ebp], edx

; 341  : 	if (hash_bytes > 2)

  00263	83 7d f4 02	 cmp	 DWORD PTR _hash_bytes$32586[ebp], 2
  00267	76 0b		 jbe	 SHORT $LN8@lz_encoder@4

; 342  : 		hs += HASH_2_SIZE;

  00269	8b 45 f0	 mov	 eax, DWORD PTR _hs$32589[ebp]
  0026c	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00271	89 45 f0	 mov	 DWORD PTR _hs$32589[ebp], eax
$LN8@lz_encoder@4:

; 343  : 	if (hash_bytes > 3)

  00274	83 7d f4 03	 cmp	 DWORD PTR _hash_bytes$32586[ebp], 3
  00278	76 0c		 jbe	 SHORT $LN7@lz_encoder@4

; 344  : 		hs += HASH_3_SIZE;

  0027a	8b 4d f0	 mov	 ecx, DWORD PTR _hs$32589[ebp]
  0027d	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H
  00283	89 4d f0	 mov	 DWORD PTR _hs$32589[ebp], ecx
$LN7@lz_encoder@4:

; 345  : /*
; 346  : 	No match finder uses this at the moment.
; 347  : 	if (mf->hash_bytes > 4)
; 348  : 		hs += HASH_4_SIZE;
; 349  : */
; 350  :   {
; 351  : 
; 352  : 	const uint32_t old_hash_count = mf->hash_count;

  00286	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00289	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0028c	89 45 e8	 mov	 DWORD PTR _old_hash_count$32598[ebp], eax

; 353  : 	const uint32_t old_sons_count = mf->sons_count;

  0028f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00292	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00295	89 55 e4	 mov	 DWORD PTR _old_sons_count$32599[ebp], edx

; 354  : 	mf->hash_count = hs;

  00298	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0029b	8b 4d f0	 mov	 ecx, DWORD PTR _hs$32589[ebp]
  0029e	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 355  : 	mf->sons_count = mf->cyclic_size;

  002a1	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002a4	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002a7	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  002aa	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 356  : 	if (is_bt)

  002ad	0f b6 55 ef	 movzx	 edx, BYTE PTR _is_bt$32588[ebp]
  002b1	85 d2		 test	 edx, edx
  002b3	74 0e		 je	 SHORT $LN6@lz_encoder@4

; 357  : 		mf->sons_count *= 2;

  002b5	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002b8	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  002bb	d1 e1		 shl	 ecx, 1
  002bd	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002c0	89 4a 58	 mov	 DWORD PTR [edx+88], ecx
$LN6@lz_encoder@4:

; 358  : 
; 359  : 	// Deallocate the old hash array if it exists and has different size
; 360  : 	// than what is needed now.
; 361  : 	if (old_hash_count != mf->hash_count
; 362  : 			|| old_sons_count != mf->sons_count) {

  002c3	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002c6	8b 4d e8	 mov	 ecx, DWORD PTR _old_hash_count$32598[ebp]
  002c9	3b 48 54	 cmp	 ecx, DWORD PTR [eax+84]
  002cc	75 0b		 jne	 SHORT $LN4@lz_encoder@4
  002ce	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002d1	8b 45 e4	 mov	 eax, DWORD PTR _old_sons_count$32599[ebp]
  002d4	3b 42 58	 cmp	 eax, DWORD PTR [edx+88]
  002d7	74 3a		 je	 SHORT $LN5@lz_encoder@4
$LN4@lz_encoder@4:

; 363  : 		lzma_free(mf->hash, allocator);

  002d9	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  002dc	51		 push	 ecx
  002dd	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002e0	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _lzma_free
  002e9	83 c4 08	 add	 esp, 8

; 364  : 		mf->hash = NULL;

  002ec	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  002ef	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 365  : 
; 366  : 		lzma_free(mf->son, allocator);

  002f6	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  002f9	52		 push	 edx
  002fa	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002fd	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00300	51		 push	 ecx
  00301	e8 00 00 00 00	 call	 _lzma_free
  00306	83 c4 08	 add	 esp, 8

; 367  : 		mf->son = NULL;

  00309	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0030c	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$LN5@lz_encoder@4:

; 368  : 	}
; 369  : 
; 370  : 	// Maximum number of match finder cycles
; 371  : 	mf->depth = lz_options->depth;

  00313	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00316	8b 4d 10	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00319	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0031c	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 372  : 	if (mf->depth == 0) {

  0031f	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00322	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00326	75 2d		 jne	 SHORT $LN3@lz_encoder@4

; 373  : 		if (is_bt)

  00328	0f b6 4d ef	 movzx	 ecx, BYTE PTR _is_bt$32588[ebp]
  0032c	85 c9		 test	 ecx, ecx
  0032e	74 13		 je	 SHORT $LN2@lz_encoder@4

; 374  : 			mf->depth = 16 + mf->nice_len / 2;

  00330	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00333	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00336	d1 e8		 shr	 eax, 1
  00338	83 c0 10	 add	 eax, 16			; 00000010H
  0033b	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0033e	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 375  : 		else

  00341	eb 12		 jmp	 SHORT $LN3@lz_encoder@4
$LN2@lz_encoder@4:

; 376  : 			mf->depth = 4 + mf->nice_len / 4;

  00343	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00346	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00349	c1 e8 02	 shr	 eax, 2
  0034c	83 c0 04	 add	 eax, 4
  0034f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00352	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN3@lz_encoder@4:

; 377  : 	}
; 378  :   }}}}}
; 379  : 
; 380  : 	return false;

  00355	32 c0		 xor	 al, al
$LN27@lz_encoder@4:

; 381  : }

  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
  0035b	90		 npad	 1
$LN30@lz_encoder@4:
  0035c	00 00 00 00	 DD	 $LN20@lz_encoder@4
  00360	00 00 00 00	 DD	 $LN19@lz_encoder@4
  00364	00 00 00 00	 DD	 $LN18@lz_encoder@4
  00368	00 00 00 00	 DD	 $LN17@lz_encoder@4
  0036c	00 00 00 00	 DD	 $LN16@lz_encoder@4
  00370	00 00 00 00	 DD	 $LN15@lz_encoder@4
$LN29@lz_encoder@4:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	05		 DB	 5
  00377	05		 DB	 5
  00378	05		 DB	 5
  00379	05		 DB	 5
  0037a	05		 DB	 5
  0037b	05		 DB	 5
  0037c	05		 DB	 5
  0037d	05		 DB	 5
  0037e	05		 DB	 5
  0037f	05		 DB	 5
  00380	05		 DB	 5
  00381	05		 DB	 5
  00382	05		 DB	 5
  00383	02		 DB	 2
  00384	03		 DB	 3
  00385	04		 DB	 4
_lz_encoder_prepare ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lz_encode
_TEXT	SEGMENT
_ret$32551 = -12					; size = 4
_ret_$32549 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_lz_encode PROC						; COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 171  : 	lzma_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN9@lz_encode:

; 172  : 
; 173  : 	while (*out_pos < out_size
; 174  : 			&& (*in_pos < in_size || action != LZMA_RUN)) {

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 24	 cmp	 edx, DWORD PTR _out_size$[ebp]
  00014	0f 83 9e 00 00
	00		 jae	 $LN8@lz_encode
  0001a	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  00022	72 0a		 jb	 SHORT $LN7@lz_encode
  00024	83 7d 28 00	 cmp	 DWORD PTR _action$[ebp], 0
  00028	0f 84 8a 00 00
	00		 je	 $LN8@lz_encode
$LN7@lz_encode:

; 175  : 		// Read more data to coder->mf.buffer if needed.
; 176  : 		if (coder->mf.action == LZMA_RUN && coder->mf.read_pos
; 177  : 				>= coder->mf.read_limit)

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00031	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  00035	75 40		 jne	 SHORT $LN6@lz_encode
  00037	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003d	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00040	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  00043	72 32		 jb	 SHORT $LN6@lz_encode
$LN5@lz_encode:

; 178  : 			return_if_error(fill_window(coder, allocator,
; 179  : 					in, in_pos, in_size, action));

  00045	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00050	52		 push	 edx
  00051	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _fill_window
  00062	83 c4 18	 add	 esp, 24			; 00000018H
  00065	89 45 f8	 mov	 DWORD PTR _ret_$32549[ebp], eax
  00068	83 7d f8 00	 cmp	 DWORD PTR _ret_$32549[ebp], 0
  0006c	74 05		 je	 SHORT $LN4@lz_encode
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32549[ebp]
  00071	eb 47		 jmp	 SHORT $LN10@lz_encode
$LN4@lz_encode:
  00073	33 c0		 xor	 eax, eax
  00075	75 ce		 jne	 SHORT $LN5@lz_encode
$LN6@lz_encode:

; 180  : 
; 181  : 		// Encode
; 182  : 	  {
; 183  : 		const lzma_ret ret = coder->lz.code(coder->lz.coder,
; 184  : 				&coder->mf, out, out_pos, out_size);

  00077	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00082	50		 push	 eax
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00086	83 c1 10	 add	 ecx, 16			; 00000010H
  00089	51		 push	 ecx
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00093	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00096	ff d2		 call	 edx
  00098	83 c4 14	 add	 esp, 20			; 00000014H
  0009b	89 45 f4	 mov	 DWORD PTR _ret$32551[ebp], eax

; 185  : 		if (ret != LZMA_OK) {

  0009e	83 7d f4 00	 cmp	 DWORD PTR _ret$32551[ebp], 0
  000a2	74 0f		 je	 SHORT $LN1@lz_encode

; 186  : 			// Setting this to LZMA_RUN for cases when we are
; 187  : 			// flushing. It doesn't matter when finishing or if
; 188  : 			// an error occurred.
; 189  : 			coder->mf.action = LZMA_RUN;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000a7	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0

; 190  : 			return ret;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _ret$32551[ebp]
  000b1	eb 07		 jmp	 SHORT $LN10@lz_encode
$LN1@lz_encode:

; 191  : 		}
; 192  : 	  }
; 193  : 	}

  000b3	e9 54 ff ff ff	 jmp	 $LN9@lz_encode
$LN8@lz_encode:

; 194  : 
; 195  : 	return LZMA_OK;

  000b8	33 c0		 xor	 eax, eax
$LN10@lz_encode:

; 196  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_lz_encode ENDP
PUBLIC	_lzma_lz_encoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_lz_encoder_init
_TEXT	SEGMENT
_ret_$32708 = -44					; size = 4
_lz_options$32704 = -40					; size = 36
_coder$ = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lz_init$ = 20						; size = 4
_lzma_lz_encoder_init PROC				; COMDAT

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 575  : #ifdef HAVE_SMALL
; 576  : 	// We need that the CRC32 table has been initialized.
; 577  : 	lzma_crc32_init();
; 578  : #endif
; 579  : 
; 580  : 	// Allocate and initialize the base data structure.
; 581  : 	lzma_coder *coder = next->coder;

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _coder$[ebp], ecx

; 582  : 	if (coder == NULL) {

  00010	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00014	0f 85 b5 00 00
	00		 jne	 $LN6@lzma_lz_en

; 583  : 		coder = lzma_alloc(sizeof(lzma_coder), allocator);

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001d	52		 push	 edx
  0001e	68 a0 00 00 00	 push	 160			; 000000a0H
  00023	e8 00 00 00 00	 call	 _lzma_alloc
  00028	83 c4 08	 add	 esp, 8
  0002b	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 584  : 		if (coder == NULL)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00032	75 0a		 jne	 SHORT $LN7@lzma_lz_en

; 585  : 			return LZMA_MEM_ERROR;

  00034	b8 05 00 00 00	 mov	 eax, 5
  00039	e9 20 01 00 00	 jmp	 $LN9@lzma_lz_en
$LN7@lzma_lz_en:

; 586  : 
; 587  : 		next->coder = coder;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00044	89 08		 mov	 DWORD PTR [eax], ecx

; 588  : 		next->code = &lz_encode;

  00046	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00049	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _lz_encode

; 589  : 		next->end = &lz_encoder_end;

  00050	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00053	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _lz_encoder_end

; 590  : 		next->update = &lz_encoder_update;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0005d	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _lz_encoder_update

; 591  : 
; 592  : 		coder->lz.coder = NULL;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00067	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 593  : 		coder->lz.code = NULL;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00070	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 594  : 		coder->lz.end = NULL;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 595  : 
; 596  : 		// mf.size is initialized to silence Valgrind
; 597  : 		// when used on optimized binaries (GCC may reorder
; 598  : 		// code in a way that Valgrind gets unhappy).
; 599  : 		coder->mf.buffer = NULL;

  00081	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00084	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 600  : 		coder->mf.size = 0;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0008e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 601  : 		coder->mf.hash = NULL;

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00098	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 602  : 		coder->mf.son = NULL;

  0009f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000a2	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 603  : 		coder->mf.hash_count = 0;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000ac	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 604  : 		coder->mf.sons_count = 0;

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000b6	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 605  : 
; 606  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000bd	8b 7d fc	 mov	 edi, DWORD PTR _coder$[ebp]
  000c0	83 c7 70	 add	 edi, 112		; 00000070H
  000c3	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000c8	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000cd	f3 a5		 rep movsd
$LN6@lzma_lz_en:

; 607  : 	}
; 608  : 
; 609  : 	// Initialize the LZ-based encoder.
; 610  :   {
; 611  : 	lzma_lz_options lz_options;
; 612  : 	return_if_error(lz_init(&coder->lz, allocator,
; 613  : 			filters[0].options, &lz_options));

  000cf	8d 55 d8	 lea	 edx, DWORD PTR _lz_options$32704[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  000d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d9	51		 push	 ecx
  000da	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000e1	50		 push	 eax
  000e2	ff 55 14	 call	 DWORD PTR _lz_init$[ebp]
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	89 45 d4	 mov	 DWORD PTR _ret_$32708[ebp], eax
  000eb	83 7d d4 00	 cmp	 DWORD PTR _ret_$32708[ebp], 0
  000ef	74 05		 je	 SHORT $LN5@lzma_lz_en
  000f1	8b 45 d4	 mov	 eax, DWORD PTR _ret_$32708[ebp]
  000f4	eb 68		 jmp	 SHORT $LN9@lzma_lz_en
$LN5@lzma_lz_en:
  000f6	33 c9		 xor	 ecx, ecx
  000f8	75 d5		 jne	 SHORT $LN6@lzma_lz_en

; 614  : 
; 615  : 	// Setup the size information into coder->mf and deallocate
; 616  : 	// old buffers if they have wrong size.
; 617  : 	if (lz_encoder_prepare(&coder->mf, allocator, &lz_options))

  000fa	8d 55 d8	 lea	 edx, DWORD PTR _lz_options$32704[ebp]
  000fd	52		 push	 edx
  000fe	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00101	50		 push	 eax
  00102	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00105	83 c1 10	 add	 ecx, 16			; 00000010H
  00108	51		 push	 ecx
  00109	e8 00 00 00 00	 call	 _lz_encoder_prepare
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	0f b6 d0	 movzx	 edx, al
  00114	85 d2		 test	 edx, edx
  00116	74 07		 je	 SHORT $LN2@lzma_lz_en

; 618  : 		return LZMA_OPTIONS_ERROR;

  00118	b8 08 00 00 00	 mov	 eax, 8
  0011d	eb 3f		 jmp	 SHORT $LN9@lzma_lz_en
$LN2@lzma_lz_en:

; 619  : 
; 620  : 	// Allocate new buffers if needed, and do the rest of
; 621  : 	// the initialization.
; 622  : 	if (lz_encoder_init(&coder->mf, allocator, &lz_options))

  0011f	8d 45 d8	 lea	 eax, DWORD PTR _lz_options$32704[ebp]
  00122	50		 push	 eax
  00123	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00126	51		 push	 ecx
  00127	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0012a	83 c2 10	 add	 edx, 16			; 00000010H
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _lz_encoder_init
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
  00136	0f b6 c0	 movzx	 eax, al
  00139	85 c0		 test	 eax, eax
  0013b	74 07		 je	 SHORT $LN1@lzma_lz_en

; 623  : 		return LZMA_MEM_ERROR;

  0013d	b8 05 00 00 00	 mov	 eax, 5
  00142	eb 1a		 jmp	 SHORT $LN9@lzma_lz_en
$LN1@lzma_lz_en:

; 624  :   }
; 625  : 
; 626  : 	// Initialize the next filter in the chain, if any.
; 627  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  00144	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00147	83 c1 10	 add	 ecx, 16			; 00000010H
  0014a	51		 push	 ecx
  0014b	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0014e	52		 push	 edx
  0014f	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00152	83 c0 70	 add	 eax, 112		; 00000070H
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _lzma_next_filter_init
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@lzma_lz_en:

; 628  : }

  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_lzma_lz_encoder_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_lz_encoder_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_lz_encoder_memusage
_TEXT	SEGMENT
_mf$ = -96						; size = 92
_lz_options$ = 8					; size = 4
_lzma_lz_encoder_memusage PROC				; COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	56		 push	 esi

; 480  : 	// Old buffers must not exist when calling lz_encoder_prepare().
; 481  : 	/*
; 482  : 	lzma_mf mf = {
; 483  : 		.buffer = NULL,
; 484  : 		.hash = NULL,
; 485  : 		.son = NULL,
; 486  : 		.hash_count = 0,
; 487  : 		.sons_count = 0,
; 488  : 	};
; 489  : 	*/
; 490  : 	/*
; 491  : 	lzma_mf mf = {
; 492  : 		NULL,   //uint8_t *buffer;
; 493  : 		0,      //uint32_t size;
; 494  : 		0,      //uint32_t keep_size_before;
; 495  : 		0,      //uint32_t keep_size_after;
; 496  : 		0,      //uint32_t offset;
; 497  : 		0,      //uint32_t read_pos;
; 498  : 		0,      //uint32_t read_ahead;
; 499  : 		0,      //uint32_t read_limit;
; 500  : 		0,      //uint32_t write_pos;
; 501  : 		0,      //uint32_t pending;
; 502  : 		NULL,   //uint32_t (*find)(lzma_mf *mf, lzma_match *matches);
; 503  : 		NULL,   //void (*skip)(lzma_mf *mf, uint32_t num);
; 504  : 		NULL,   //uint32_t *hash;
; 505  : 		NULL,   //uint32_t *son;
; 506  : 		NULL,   //uint32_t cyclic_pos;
; 507  : 		0,      //uint32_t cyclic_size; // Must be dictionary size + 1.
; 508  : 		0,      //uint32_t hash_mask;
; 509  : 		0,      //uint32_t depth;
; 510  : 		0,      //uint32_t nice_len;
; 511  : 		0,      //uint32_t match_len_max;
; 512  : 		{0},    //lzma_action action;
; 513  : 		0,      //uint32_t hash_size_sum;
; 514  : 		0,      //uint32_t sons_count;
; 515  : 	};
; 516  : 	*/
; 517  : 	lzma_mf mf = {0};

  00007	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _mf$[ebp], 0
  0000e	6a 58		 push	 88			; 00000058H
  00010	6a 00		 push	 0
  00012	8d 45 a4	 lea	 eax, DWORD PTR _mf$[ebp+4]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 518  : 
; 519  : 	// Setup the size information into mf.
; 520  : 	if (lz_encoder_prepare(&mf, NULL, lz_options))

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00021	51		 push	 ecx
  00022	6a 00		 push	 0
  00024	8d 55 a0	 lea	 edx, DWORD PTR _mf$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _lz_encoder_prepare
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN1@lzma_lz_en@2

; 521  : 		return UINT64_MAX;

  00037	83 c8 ff	 or	 eax, -1
  0003a	83 ca ff	 or	 edx, -1
  0003d	eb 2a		 jmp	 SHORT $LN2@lzma_lz_en@2
$LN1@lzma_lz_en@2:

; 522  : 
; 523  : 	// Calculate the memory usage.
; 524  : 	return ((uint64_t)(mf.hash_count) + mf.sons_count) * sizeof(uint32_t)
; 525  : 			+ mf.size + sizeof(lzma_coder);

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _mf$[ebp+84]
  00042	33 d2		 xor	 edx, edx
  00044	8b 45 f8	 mov	 eax, DWORD PTR _mf$[ebp+88]
  00047	33 f6		 xor	 esi, esi
  00049	03 c8		 add	 ecx, eax
  0004b	13 d6		 adc	 edx, esi
  0004d	6a 00		 push	 0
  0004f	6a 04		 push	 4
  00051	52		 push	 edx
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 __allmul
  00058	8b 4d a4	 mov	 ecx, DWORD PTR _mf$[ebp+4]
  0005b	33 f6		 xor	 esi, esi
  0005d	03 c1		 add	 eax, ecx
  0005f	13 d6		 adc	 edx, esi
  00061	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00066	83 d2 00	 adc	 edx, 0
$LN2@lzma_lz_en@2:

; 526  : }

  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_lzma_lz_encoder_memusage ENDP
END
