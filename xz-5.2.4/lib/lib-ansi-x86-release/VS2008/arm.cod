; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\arm.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_arm_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\arm.c
;	COMDAT _arm_code
_TEXT	SEGMENT
_dest$32368 = -12					; size = 4
_src$32367 = -8						; size = 4
_i$ = -4						; size = 4
_simple$ = 8						; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_arm_code PROC						; COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 4) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN6@arm_code
$LN5@arm_code:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@arm_code:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp]
  00021	0f 87 ab 00 00
	00		 ja	 $LN4@arm_code

; 24   : 		if (buffer[i + 3] == 0xEB) {

  00027	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002a	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002d	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00031	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00036	0f 85 91 00 00
	00		 jne	 $LN3@arm_code

; 25   : 			uint32_t src = (buffer[i + 2] << 16)
; 26   : 					| (buffer[i + 1] << 8)
; 27   : 					| (buffer[i + 0]);

  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003f	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00042	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00046	c1 e2 10	 shl	 edx, 16			; 00000010H
  00049	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004c	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0004f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00053	c1 e1 08	 shl	 ecx, 8
  00056	0b d1		 or	 edx, ecx
  00058	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0005e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00061	0b d1		 or	 edx, ecx
  00063	89 55 f8	 mov	 DWORD PTR _src$32367[ebp], edx

; 28   : 			src <<= 2;

  00066	8b 55 f8	 mov	 edx, DWORD PTR _src$32367[ebp]
  00069	c1 e2 02	 shl	 edx, 2
  0006c	89 55 f8	 mov	 DWORD PTR _src$32367[ebp], edx

; 29   : 
; 30   :           { uint32_t dest;
; 31   : 			if (is_encoder)

  0006f	0f b6 45 10	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00073	85 c0		 test	 eax, eax
  00075	74 12		 je	 SHORT $LN2@arm_code

; 32   : 				dest = now_pos + (uint32_t)(i) + 8 + src;

  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _now_pos$[ebp]
  0007a	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _src$32367[ebp]
  00080	8d 44 11 08	 lea	 eax, DWORD PTR [ecx+edx+8]
  00084	89 45 f4	 mov	 DWORD PTR _dest$32368[ebp], eax

; 33   : 			else

  00087	eb 12		 jmp	 SHORT $LN1@arm_code
$LN2@arm_code:

; 34   : 				dest = src - (now_pos + (uint32_t)(i) + 8);

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008c	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  0008f	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _src$32367[ebp]
  00096	2b c8		 sub	 ecx, eax
  00098	89 4d f4	 mov	 DWORD PTR _dest$32368[ebp], ecx
$LN1@arm_code:

; 35   : 
; 36   : 			dest >>= 2;

  0009b	8b 55 f4	 mov	 edx, DWORD PTR _dest$32368[ebp]
  0009e	c1 ea 02	 shr	 edx, 2
  000a1	89 55 f4	 mov	 DWORD PTR _dest$32368[ebp], edx

; 37   : 			buffer[i + 2] = (dest >> 16);

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _dest$32368[ebp]
  000a7	c1 e8 10	 shr	 eax, 16			; 00000010H
  000aa	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ad	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000b0	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 38   : 			buffer[i + 1] = (dest >> 8);

  000b3	8b 55 f4	 mov	 edx, DWORD PTR _dest$32368[ebp]
  000b6	c1 ea 08	 shr	 edx, 8
  000b9	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  000bc	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000bf	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 39   : 			buffer[i + 0] = dest;

  000c2	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000c5	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000c8	8a 55 f4	 mov	 dl, BYTE PTR _dest$32368[ebp]
  000cb	88 11		 mov	 BYTE PTR [ecx], dl
$LN3@arm_code:

; 40   : 		  }
; 41   : 		}
; 42   : 	}

  000cd	e9 3d ff ff ff	 jmp	 $LN5@arm_code
$LN4@arm_code:

; 43   : 
; 44   : 	return i;

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 45   : }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_arm_code ENDP
; Function compile flags: /Odtp
;	COMDAT _arm_coder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_arm_coder_init PROC					; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	return lzma_simple_coder_init(next, allocator, filters,
; 53   : 			&arm_code, 0, 4, 4, is_encoder);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00007	50		 push	 eax
  00008	6a 04		 push	 4
  0000a	6a 04		 push	 4
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _arm_code
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 54   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_arm_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_arm_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_arm_decoder_init PROC			; COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	return arm_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _arm_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 72   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_arm_decoder_init ENDP
END
