; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\common\tuklib_physmem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@	; `string'
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
;	COMDAT ??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@
CONST	SEGMENT
??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@ DB 'GlobalMemoryStatusEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@ DB 'kernel32.dll', 00H ; `string'
PUBLIC	_lzmatuklib_physmem
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_physmem.c
;	COMDAT _lzmatuklib_physmem
_TEXT	SEGMENT
_meminfo$72868 = -112					; size = 32
_meminfo$72865 = -80					; size = 64
_gmse$72860 = -16					; size = 4
_kernel32$72854 = -12					; size = 4
_ret$ = -8						; size = 8
_lzmatuklib_physmem PROC				; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H

; 79   : 	uint64_t ret = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp+4], 0

; 80   : 
; 81   : #if defined(_WIN32) || defined(__CYGWIN__)
; 82   :   #if 0  /*Mist: from Windows 8.1 onwards GetVersion() and GetVersionEx() have been deprecated!*/
; 83   :   if ((GetVersion () & 0xFF) >= 5) {
; 84   :   #else
; 85   :   extern LONG GetWindowsVer (void);
; 86   : 
; 87   :   #if !defined(MAJOR_VERSION)
; 88   :   #define MAJOR_VERSION(packvers)     HIWORD(packvers)
; 89   :   #endif
; 90   :   #if !defined(MINOR_VERSION)
; 91   :   #define MINOR_VERSION(packvers)     LOWORD(packvers)
; 92   :   #endif
; 93   : 
; 94   :   if (MAJOR_VERSION (GetWindowsVer ()) >= 5) {

  00014	e8 00 00 00 00	 call	 _GetWindowsVer
  00019	c1 e8 10	 shr	 eax, 16			; 00000010H
  0001c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00021	0f b7 c0	 movzx	 eax, ax
  00024	83 f8 05	 cmp	 eax, 5
  00027	7c 4a		 jl	 SHORT $LN5@lzmatuklib

; 95   :   #endif
; 96   : 		// Windows 2000 and later have GlobalMemoryStatusEx() which
; 97   : 		// supports reporting values greater than 4 GiB. To keep the
; 98   : 		// code working also on older Windows versions, use
; 99   : 		// GlobalMemoryStatusEx() conditionally.
; 100  : 		HMODULE kernel32 = GetModuleHandle("kernel32.dll");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00034	89 45 f4	 mov	 DWORD PTR _kernel32$72854[ebp], eax

; 101  : 		if (kernel32 != NULL) {

  00037	83 7d f4 00	 cmp	 DWORD PTR _kernel32$72854[ebp], 0
  0003b	74 36		 je	 SHORT $LN5@lzmatuklib

; 102  : 			typedef BOOL (WINAPI *gmse_type)(LPMEMORYSTATUSEX);
; 103  : 			gmse_type gmse = (gmse_type)GetProcAddress(
; 104  : 					kernel32, "GlobalMemoryStatusEx");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _kernel32$72854[ebp]
  00045	51		 push	 ecx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004c	89 45 f0	 mov	 DWORD PTR _gmse$72860[ebp], eax

; 105  : 			if (gmse != NULL) {

  0004f	83 7d f0 00	 cmp	 DWORD PTR _gmse$72860[ebp], 0
  00053	74 1e		 je	 SHORT $LN5@lzmatuklib

; 106  : 				MEMORYSTATUSEX meminfo;
; 107  : 				meminfo.dwLength = sizeof(meminfo);

  00055	c7 45 b0 40 00
	00 00		 mov	 DWORD PTR _meminfo$72865[ebp], 64 ; 00000040H

; 108  : 				if (gmse(&meminfo))

  0005c	8d 55 b0	 lea	 edx, DWORD PTR _meminfo$72865[ebp]
  0005f	52		 push	 edx
  00060	ff 55 f0	 call	 DWORD PTR _gmse$72860[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 0c		 je	 SHORT $LN5@lzmatuklib

; 109  : 					ret = meminfo.ullTotalPhys;

  00067	8b 45 b8	 mov	 eax, DWORD PTR _meminfo$72865[ebp+8]
  0006a	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0006d	8b 4d bc	 mov	 ecx, DWORD PTR _meminfo$72865[ebp+12]
  00070	89 4d fc	 mov	 DWORD PTR _ret$[ebp+4], ecx
$LN5@lzmatuklib:

; 110  : 			}
; 111  : 		}
; 112  : 	}
; 113  : 
; 114  : 	if (ret == 0) {

  00073	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  00076	0b 55 fc	 or	 edx, DWORD PTR _ret$[ebp+4]
  00079	75 1c		 jne	 SHORT $LN1@lzmatuklib

; 115  : 		// GlobalMemoryStatus() is supported by Windows 95 and later,
; 116  : 		// so it is fine to link against it unconditionally. Note that
; 117  : 		// GlobalMemoryStatus() has no return value.
; 118  : 		MEMORYSTATUS meminfo;
; 119  : 		meminfo.dwLength = sizeof(meminfo);

  0007b	c7 45 90 20 00
	00 00		 mov	 DWORD PTR _meminfo$72868[ebp], 32 ; 00000020H

; 120  : 		GlobalMemoryStatus(&meminfo);

  00082	8d 45 90	 lea	 eax, DWORD PTR _meminfo$72868[ebp]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 121  : 		ret = meminfo.dwTotalPhys;

  0008c	8b 4d 98	 mov	 ecx, DWORD PTR _meminfo$72868[ebp+8]
  0008f	33 d2		 xor	 edx, edx
  00091	89 4d f8	 mov	 DWORD PTR _ret$[ebp], ecx
  00094	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx
$LN1@lzmatuklib:

; 122  : 	}
; 123  : 
; 124  : #elif defined(__OS2__)
; 125  : 	unsigned long mem;
; 126  : 	if (DosQuerySysInfo(QSV_TOTPHYSMEM, QSV_TOTPHYSMEM,
; 127  : 			&mem, sizeof(mem)) == 0)
; 128  : 		ret = mem;
; 129  : 
; 130  : #elif defined(__DJGPP__)
; 131  : 	__dpmi_free_mem_info meminfo;
; 132  : 	if (__dpmi_get_free_memory_information(&meminfo) == 0
; 133  : 			&& meminfo.total_number_of_physical_pages
; 134  : 				!= (unsigned long)-1)
; 135  : 		ret = (uint64_t)meminfo.total_number_of_physical_pages * 4096;
; 136  : 
; 137  : #elif defined(__VMS)
; 138  : 	int vms_mem;
; 139  : 	int val = SYI$_MEMSIZE;
; 140  : 	if (LIB$GETSYI(&val, &vms_mem, 0, 0, 0, 0) == SS$_NORMAL)
; 141  : 		ret = (uint64_t)vms_mem * 8192;
; 142  : 
; 143  : #elif defined(AMIGA) || defined(__AROS__)
; 144  : 	ret = AvailMem(MEMF_TOTAL);
; 145  : 
; 146  : #elif defined(__QNX__)
; 147  : 	const struct asinfo_entry *entries = SYSPAGE_ENTRY(asinfo);
; 148  : 	size_t count = SYSPAGE_ENTRY_SIZE(asinfo) / sizeof(struct asinfo_entry);
; 149  : 	const char *strings = SYSPAGE_ENTRY(strings)->data;
; 150  : 
; 151  : 	for (size_t i = 0; i < count; ++i)
; 152  : 		if (strcmp(strings + entries[i].name, "ram") == 0)
; 153  : 			ret += entries[i].end - entries[i].start + 1;
; 154  : 
; 155  : #elif defined(TUKLIB_PHYSMEM_AIX)
; 156  : 	ret = _system_configuration.physmem;
; 157  : 
; 158  : #elif defined(TUKLIB_PHYSMEM_SYSCONF)
; 159  : 	const long pagesize = sysconf(_SC_PAGESIZE);
; 160  : 	const long pages = sysconf(_SC_PHYS_PAGES);
; 161  : 	if (pagesize != -1 && pages != -1)
; 162  : 		// According to docs, pagesize * pages can overflow.
; 163  : 		// Simple case is 32-bit box with 4 GiB or more RAM,
; 164  : 		// which may report exactly 4 GiB of RAM, and "long"
; 165  : 		// being 32-bit will overflow. Casting to uint64_t
; 166  : 		// hopefully avoids overflows in the near future.
; 167  : 		ret = (uint64_t)pagesize * (uint64_t)pages;
; 168  : 
; 169  : #elif defined(TUKLIB_PHYSMEM_SYSCTL)
; 170  : 	int name[2] = {
; 171  : 		CTL_HW,
; 172  : #ifdef HW_PHYSMEM64
; 173  : 		HW_PHYSMEM64
; 174  : #else
; 175  : 		HW_PHYSMEM
; 176  : #endif
; 177  : 	};
; 178  : 	union {
; 179  : 		uint32_t u32;
; 180  : 		uint64_t u64;
; 181  : 	} mem;
; 182  : 	size_t mem_ptr_size = sizeof(mem.u64);
; 183  : 	if (sysctl(name, 2, &mem.u64, &mem_ptr_size, NULL, 0) != -1) {
; 184  : 		// IIRC, 64-bit "return value" is possible on some 64-bit
; 185  : 		// BSD systems even with HW_PHYSMEM (instead of HW_PHYSMEM64),
; 186  : 		// so support both.
; 187  : 		if (mem_ptr_size == sizeof(mem.u64))
; 188  : 			ret = mem.u64;
; 189  : 		else if (mem_ptr_size == sizeof(mem.u32))
; 190  : 			ret = mem.u32;
; 191  : 	}
; 192  : 
; 193  : #elif defined(TUKLIB_PHYSMEM_GETSYSINFO)
; 194  : 	// Docs are unclear if "start" is needed, but it doesn't hurt
; 195  : 	// much to have it.
; 196  : 	int memkb;
; 197  : 	int start = 0;
; 198  : 	if (getsysinfo(GSI_PHYSMEM, (caddr_t)&memkb, sizeof(memkb), &start)
; 199  : 			!= -1)
; 200  : 		ret = (uint64_t)memkb * 1024;
; 201  : 
; 202  : #elif defined(TUKLIB_PHYSMEM_PSTAT_GETSTATIC)
; 203  : 	struct pst_static pst;
; 204  : 	if (pstat_getstatic(&pst, sizeof(pst), 1, 0) != -1)
; 205  : 		ret = (uint64_t)pst.physical_memory * (uint64_t)pst.page_size;
; 206  : 
; 207  : #elif defined(TUKLIB_PHYSMEM_GETINVENT_R)
; 208  : 	inv_state_t *st = NULL;
; 209  : 	if (setinvent_r(&st) != -1) {
; 210  : 		inventory_t *i;
; 211  : 		while ((i = getinvent_r(st)) != NULL) {
; 212  : 			if (i->inv_class == INV_MEMORY
; 213  : 					&& i->inv_type == INV_MAIN_MB) {
; 214  : 				ret = (uint64_t)i->inv_state << 20;
; 215  : 				break;
; 216  : 			}
; 217  : 		}
; 218  : 
; 219  : 		endinvent_r(st);
; 220  : 	}
; 221  : 
; 222  : #elif defined(TUKLIB_PHYSMEM_SYSINFO)
; 223  : 	struct sysinfo si;
; 224  : 	if (sysinfo(&si) == 0)
; 225  : 		ret = (uint64_t)si.totalram * si.mem_unit;
; 226  : #endif
; 227  : 
; 228  : 	return ret;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]

; 229  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_lzmatuklib_physmem ENDP
END
