; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\armthumb.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_armthumb_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\armthumb.c
;	COMDAT _armthumb_code
_TEXT	SEGMENT
_dest$32368 = -12					; size = 4
_src$32367 = -8						; size = 4
_i$ = -4						; size = 4
_simple$ = 8						; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_armthumb_code PROC					; COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 2) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN6@armthumb_c
$LN5@armthumb_c:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 02	 add	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@armthumb_c:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp]
  00021	0f 87 08 01 00
	00		 ja	 $LN4@armthumb_c

; 24   : 		if ((buffer[i + 1] & 0xF8) == 0xF0
; 25   : 				&& (buffer[i + 3] & 0xF8) == 0xF8) {

  00027	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002a	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002d	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00031	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00036	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0003b	0f 85 e9 00 00
	00		 jne	 $LN3@armthumb_c
  00041	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00044	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00047	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0004b	81 e2 f8 00 00
	00		 and	 edx, 248		; 000000f8H
  00051	81 fa f8 00 00
	00		 cmp	 edx, 248		; 000000f8H
  00057	0f 85 cd 00 00
	00		 jne	 $LN3@armthumb_c

; 26   : 			uint32_t src = ((buffer[i + 1] & 0x7) << 19)
; 27   : 					| (buffer[i + 0] << 11)
; 28   : 					| ((buffer[i + 3] & 0x7) << 8)
; 29   : 					| (buffer[i + 2]);

  0005d	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00060	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00063	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00067	83 e1 07	 and	 ecx, 7
  0006a	c1 e1 13	 shl	 ecx, 19			; 00000013H
  0006d	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00070	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00073	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00076	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00079	0b c8		 or	 ecx, eax
  0007b	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0007e	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00081	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00085	83 e0 07	 and	 eax, 7
  00088	c1 e0 08	 shl	 eax, 8
  0008b	0b c8		 or	 ecx, eax
  0008d	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00090	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00093	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00097	0b c8		 or	 ecx, eax
  00099	89 4d f8	 mov	 DWORD PTR _src$32367[ebp], ecx

; 30   : 
; 31   : 			src <<= 1;

  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _src$32367[ebp]
  0009f	d1 e1		 shl	 ecx, 1
  000a1	89 4d f8	 mov	 DWORD PTR _src$32367[ebp], ecx

; 32   : 
; 33   :           { uint32_t dest;
; 34   : 			if (is_encoder)

  000a4	0f b6 55 10	 movzx	 edx, BYTE PTR _is_encoder$[ebp]
  000a8	85 d2		 test	 edx, edx
  000aa	74 12		 je	 SHORT $LN2@armthumb_c

; 35   : 				dest = now_pos + (uint32_t)(i) + 4 + src;

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _now_pos$[ebp]
  000af	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _src$32367[ebp]
  000b5	8d 54 08 04	 lea	 edx, DWORD PTR [eax+ecx+4]
  000b9	89 55 f4	 mov	 DWORD PTR _dest$32368[ebp], edx

; 36   : 			else

  000bc	eb 12		 jmp	 SHORT $LN1@armthumb_c
$LN2@armthumb_c:

; 37   : 				dest = src - (now_pos + (uint32_t)(i) + 4);

  000be	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _now_pos$[ebp]
  000c4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _src$32367[ebp]
  000cb	2b c2		 sub	 eax, edx
  000cd	89 45 f4	 mov	 DWORD PTR _dest$32368[ebp], eax
$LN1@armthumb_c:

; 38   : 
; 39   : 			dest >>= 1;

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR _dest$32368[ebp]
  000d3	d1 e9		 shr	 ecx, 1
  000d5	89 4d f4	 mov	 DWORD PTR _dest$32368[ebp], ecx

; 40   : 			buffer[i + 1] = 0xF0 | ((dest >> 19) & 0x7);

  000d8	8b 55 f4	 mov	 edx, DWORD PTR _dest$32368[ebp]
  000db	c1 ea 13	 shr	 edx, 19			; 00000013H
  000de	83 e2 07	 and	 edx, 7
  000e1	81 ca f0 00 00
	00		 or	 edx, 240		; 000000f0H
  000e7	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  000ea	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000ed	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 41   : 			buffer[i + 0] = (dest >> 11);

  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _dest$32368[ebp]
  000f3	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  000f6	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  000f9	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000fc	88 0a		 mov	 BYTE PTR [edx], cl

; 42   : 			buffer[i + 3] = 0xF8 | ((dest >> 8) & 0x7);

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _dest$32368[ebp]
  00101	c1 e8 08	 shr	 eax, 8
  00104	83 e0 07	 and	 eax, 7
  00107	0d f8 00 00 00	 or	 eax, 248		; 000000f8H
  0010c	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0010f	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00112	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 43   : 			buffer[i + 2] = (dest);

  00115	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00118	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0011b	8a 45 f4	 mov	 al, BYTE PTR _dest$32368[ebp]
  0011e	88 42 02	 mov	 BYTE PTR [edx+2], al

; 44   : 			i += 2;

  00121	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00124	83 c1 02	 add	 ecx, 2
  00127	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@armthumb_c:

; 45   : 		  }
; 46   : 		}
; 47   : 	}

  0012a	e9 e0 fe ff ff	 jmp	 $LN5@armthumb_c
$LN4@armthumb_c:

; 48   : 
; 49   : 	return i;

  0012f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 50   : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
_armthumb_code ENDP
; Function compile flags: /Odtp
;	COMDAT _armthumb_coder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_armthumb_coder_init PROC				; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return lzma_simple_coder_init(next, allocator, filters,
; 58   : 			&armthumb_code, 0, 4, 2, is_encoder);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00007	50		 push	 eax
  00008	6a 02		 push	 2
  0000a	6a 04		 push	 4
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _armthumb_code
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 59   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_armthumb_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_armthumb_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_armthumb_decoder_init PROC			; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 	return armthumb_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _armthumb_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 77   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_armthumb_decoder_init ENDP
END
