; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\delta\delta_common.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_delta_coder_memusage
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\delta\delta_common.c
;	COMDAT _lzma_delta_coder_memusage
_TEXT	SEGMENT
_opt$ = -4						; size = 4
_options$ = 8						; size = 4
_lzma_delta_coder_memusage PROC				; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 67   : 	const lzma_options_delta *opt = options;

  00004	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _opt$[ebp], eax

; 68   : 
; 69   : 	if (opt == NULL || opt->type != LZMA_DELTA_TYPE_BYTE
; 70   : 			|| opt->dist < LZMA_DELTA_DIST_MIN
; 71   : 			|| opt->dist > LZMA_DELTA_DIST_MAX)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _opt$[ebp], 0
  0000e	74 1d		 je	 SHORT $LN1@lzma_delta
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _opt$[ebp]
  00013	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00016	75 15		 jne	 SHORT $LN1@lzma_delta
  00018	8b 55 fc	 mov	 edx, DWORD PTR _opt$[ebp]
  0001b	83 7a 04 01	 cmp	 DWORD PTR [edx+4], 1
  0001f	72 0c		 jb	 SHORT $LN1@lzma_delta
  00021	8b 45 fc	 mov	 eax, DWORD PTR _opt$[ebp]
  00024	81 78 04 00 01
	00 00		 cmp	 DWORD PTR [eax+4], 256	; 00000100H
  0002b	76 08		 jbe	 SHORT $LN2@lzma_delta
$LN1@lzma_delta:

; 72   : 		return UINT64_MAX;

  0002d	83 c8 ff	 or	 eax, -1
  00030	83 ca ff	 or	 edx, -1
  00033	eb 07		 jmp	 SHORT $LN3@lzma_delta
$LN2@lzma_delta:

; 73   : 
; 74   : 	return sizeof(lzma_delta_coder);

  00035	b8 38 01 00 00	 mov	 eax, 312		; 00000138H
  0003a	33 d2		 xor	 edx, edx
$LN3@lzma_delta:

; 75   : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_lzma_delta_coder_memusage ENDP
; Function compile flags: /Odtp
;	COMDAT _delta_coder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_delta_coder_end PROC					; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 20   : 	lzma_delta_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 21   : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 22   : 	lzma_free(coder, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _lzma_free
  00027	83 c4 08	 add	 esp, 8

; 23   : 	return;
; 24   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_delta_coder_end ENDP
PUBLIC	_lzma_delta_coder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_delta_coder_init
_TEXT	SEGMENT
tv137 = -16						; size = 8
_opt$32253 = -8						; size = 4
_coder$ = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_delta_coder_init PROC				; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 31   : 	// Allocate memory for the decoder if needed.
; 32   : 	lzma_delta_coder *coder = next->coder;

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _coder$[ebp], ecx

; 33   : 	if (coder == NULL) {

  00010	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00014	75 45		 jne	 SHORT $LN3@lzma_delta@3

; 34   : 		coder = lzma_alloc(sizeof(lzma_delta_coder), allocator);

  00016	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00019	52		 push	 edx
  0001a	68 38 01 00 00	 push	 312			; 00000138H
  0001f	e8 00 00 00 00	 call	 _lzma_alloc
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 35   : 		if (coder == NULL)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  0002e	75 0a		 jne	 SHORT $LN2@lzma_delta@3

; 36   : 			return LZMA_MEM_ERROR;

  00030	b8 05 00 00 00	 mov	 eax, 5
  00035	e9 91 00 00 00	 jmp	 $LN4@lzma_delta@3
$LN2@lzma_delta@3:

; 37   : 
; 38   : 		next->coder = coder;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00040	89 08		 mov	 DWORD PTR [eax], ecx

; 39   : 
; 40   : 		// End function is the same for encoder and decoder.
; 41   : 		next->end = &delta_coder_end;

  00042	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00045	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _delta_coder_end

; 42   : 		coder->next = LZMA_NEXT_CODER_INIT;

  0004c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00051	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00056	8b 7d fc	 mov	 edi, DWORD PTR _coder$[ebp]
  00059	f3 a5		 rep movsd
$LN3@lzma_delta@3:

; 43   : 	}
; 44   : 
; 45   : 	// Validate the options.
; 46   : 	if (lzma_delta_coder_memusage(filters[0].options) == UINT64_MAX)

  0005b	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  0005e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _lzma_delta_coder_memusage
  00067	83 c4 04	 add	 esp, 4
  0006a	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  0006d	89 55 f4	 mov	 DWORD PTR tv137[ebp+4], edx
  00070	8b 55 f0	 mov	 edx, DWORD PTR tv137[ebp]
  00073	23 55 f4	 and	 edx, DWORD PTR tv137[ebp+4]
  00076	83 fa ff	 cmp	 edx, -1
  00079	75 07		 jne	 SHORT $LN1@lzma_delta@3

; 47   : 		return LZMA_OPTIONS_ERROR;

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	eb 49		 jmp	 SHORT $LN4@lzma_delta@3
$LN1@lzma_delta@3:

; 48   : 
; 49   : 	// Set the delta distance.
; 50   :   {
; 51   :   const lzma_options_delta *opt = filters[0].options;

  00082	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00085	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00088	89 4d f8	 mov	 DWORD PTR _opt$32253[ebp], ecx

; 52   : 	coder->distance = opt->dist;

  0008b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0008e	8b 45 f8	 mov	 eax, DWORD PTR _opt$32253[ebp]
  00091	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00094	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 53   :   }
; 54   : 
; 55   : 	// Initialize the rest of the variables.
; 56   : 	coder->pos = 0;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0009a	c6 42 34 00	 mov	 BYTE PTR [edx+52], 0

; 57   : 	memzero(coder->history, LZMA_DELTA_DIST_MAX);

  0009e	68 00 01 00 00	 push	 256			; 00000100H
  000a3	6a 00		 push	 0
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000a8	83 c0 35	 add	 eax, 53			; 00000035H
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 58   : 
; 59   : 	// Initialize the next decoder in the chain, if any.
; 60   : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  000b4	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  000b7	83 c1 10	 add	 ecx, 16			; 00000010H
  000ba	51		 push	 ecx
  000bb	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _lzma_next_filter_init
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@lzma_delta@3:

; 61   : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_lzma_delta_coder_init ENDP
END
