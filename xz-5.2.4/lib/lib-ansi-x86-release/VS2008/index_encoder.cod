; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\index_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_encoder.c
;	COMDAT _index_encoder_reset
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_i$ = 12						; size = 4
_index_encoder_reset PROC				; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  : 	lzma_index_iter_init(&coder->iter, i);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _lzma_index_iter_init
  00013	83 c4 08	 add	 esp, 8

; 175  : 
; 176  : 	coder->sequence = SEQ_INDICATOR;

  00016	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00019	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 177  : 	coder->index = i;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 178  : 	coder->pos = 0;

  00028	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002b	c7 82 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+280], 0

; 179  : 	coder->crc32 = 0;

  00035	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00038	c7 80 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+284], 0

; 180  : 
; 181  : 	return;
; 182  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_index_encoder_reset ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_encoder_end
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_index_encoder_end PROC					; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	lzma_free(coder, allocator);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _lzma_free
  00010	83 c4 08	 add	 esp, 8

; 167  : 	return;
; 168  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_index_encoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _index_encode
_TEXT	SEGMENT
tv93 = -44						; size = 8
tv65 = -36						; size = 4
_size$32361 = -32					; size = 8
_count$32354 = -24					; size = 8
_coder$ = -12						; size = 4
_ret$ = -8						; size = 4
_out_start$ = -4					; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_index_encode PROC					; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 53   : 	lzma_index_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _coder$[ebp], eax

; 54   : 
; 55   : 	// Position where to start calculating CRC32. The idea is that we
; 56   : 	// need to call lzma_crc32() only once per call to index_encode().
; 57   : 	const size_t out_start = *out_pos;

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 fc	 mov	 DWORD PTR _out_start$[ebp], edx

; 58   : 
; 59   : 	// Return value to use if we return at the end of this function.
; 60   : 	// We use "goto out" to jump out of the while-switch construct
; 61   : 	// instead of returning directly, because that way we don't need
; 62   : 	// to copypaste the lzma_crc32() call to many places.
; 63   : 	lzma_ret ret = LZMA_OK;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN19@index_enco:

; 64   : 
; 65   : 	while (*out_pos < out_size)

  0001b	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	3b 4d 24	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  00023	0f 83 7c 02 00
	00		 jae	 $out$32356

; 66   : 	switch (coder->sequence) {

  00029	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	89 45 dc	 mov	 DWORD PTR tv65[ebp], eax
  00031	83 7d dc 06	 cmp	 DWORD PTR tv65[ebp], 6
  00035	0f 87 5e 02 00
	00		 ja	 $LN1@index_enco
  0003b	8b 4d dc	 mov	 ecx, DWORD PTR tv65[ebp]
  0003e	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN24@index_enco[ecx*4]
$LN15@index_enco:

; 67   : 	case SEQ_INDICATOR:
; 68   : 		out[*out_pos] = 0x00;

  00045	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0004d	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 69   : 		++*out_pos;

  00051	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	83 c0 01	 add	 eax, 1
  00059	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax

; 70   : 		coder->sequence = SEQ_COUNT;

  0005e	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00061	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 71   : 		break;

  00067	e9 34 02 00 00	 jmp	 $LN16@index_enco
$LN14@index_enco:

; 72   : 
; 73   : 	case SEQ_COUNT: {
; 74   : 		const lzma_vli count = lzma_index_block_count(coder->index);

  0006c	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _lzma_index_block_count
  00078	83 c4 04	 add	 esp, 4
  0007b	89 45 e8	 mov	 DWORD PTR _count$32354[ebp], eax
  0007e	89 55 ec	 mov	 DWORD PTR _count$32354[ebp+4], edx

; 75   : 		ret = lzma_vli_encode(count, &coder->pos,
; 76   : 				out, out_pos, out_size);

  00081	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00084	52		 push	 edx
  00085	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00090	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  00096	52		 push	 edx
  00097	8b 45 ec	 mov	 eax, DWORD PTR _count$32354[ebp+4]
  0009a	50		 push	 eax
  0009b	8b 4d e8	 mov	 ecx, DWORD PTR _count$32354[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _lzma_vli_encode
  000a4	83 c4 18	 add	 esp, 24			; 00000018H
  000a7	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 77   : 		if (ret != LZMA_STREAM_END)

  000aa	83 7d f8 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000ae	74 05		 je	 SHORT $LN13@index_enco

; 78   : 			goto out;

  000b0	e9 f0 01 00 00	 jmp	 $out$32356
$LN13@index_enco:

; 79   : 
; 80   : 		ret = LZMA_OK;

  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 81   : 		coder->pos = 0;

  000bc	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  000bf	c7 82 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+280], 0

; 82   : 		coder->sequence = SEQ_NEXT;

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  000cc	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4

; 83   : 		break;

  000d2	e9 c9 01 00 00	 jmp	 $LN16@index_enco
$LN12@index_enco:

; 84   : 	}
; 85   : 
; 86   : 	case SEQ_NEXT:
; 87   : 		if (lzma_index_iter_next(
; 88   : 				&coder->iter, LZMA_INDEX_ITER_BLOCK)) {

  000d7	6a 02		 push	 2
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  000dc	83 c1 08	 add	 ecx, 8
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _lzma_index_iter_next
  000e5	83 c4 08	 add	 esp, 8
  000e8	0f b6 d0	 movzx	 edx, al
  000eb	85 d2		 test	 edx, edx
  000ed	74 26		 je	 SHORT $LN11@index_enco

; 89   : 			// Get the size of the Index Padding field.
; 90   : 			coder->pos = lzma_index_padding_size(coder->index);

  000ef	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	51		 push	 ecx
  000f6	e8 00 00 00 00	 call	 _lzma_index_padding_size
  000fb	83 c4 04	 add	 esp, 4
  000fe	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00101	89 82 18 01 00
	00		 mov	 DWORD PTR [edx+280], eax

; 91   : 			assert(coder->pos <= 3);
; 92   : 			coder->sequence = SEQ_PADDING;

  00107	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0010a	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5

; 93   : 			break;

  00110	e9 8b 01 00 00	 jmp	 $LN16@index_enco
$LN11@index_enco:

; 94   : 		}
; 95   : 
; 96   : 		coder->sequence = SEQ_UNPADDED;

  00115	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00118	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN10@index_enco:

; 97   : 
; 98   : 	// Fall through
; 99   : 
; 100  : 	case SEQ_UNPADDED:
; 101  : 	case SEQ_UNCOMPRESSED: {
; 102  : 		const lzma_vli size = coder->sequence == SEQ_UNPADDED
; 103  : 				? coder->iter.block.unpadded_size
; 104  : 				: coder->iter.block.uncompressed_size;

  0011e	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00121	83 3a 02	 cmp	 DWORD PTR [edx], 2
  00124	75 17		 jne	 SHORT $LN22@index_enco
  00126	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00129	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0012f	89 4d d4	 mov	 DWORD PTR tv93[ebp], ecx
  00132	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00138	89 55 d8	 mov	 DWORD PTR tv93[ebp+4], edx
  0013b	eb 15		 jmp	 SHORT $LN23@index_enco
$LN22@index_enco:
  0013d	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00140	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00146	89 4d d4	 mov	 DWORD PTR tv93[ebp], ecx
  00149	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  0014f	89 55 d8	 mov	 DWORD PTR tv93[ebp+4], edx
$LN23@index_enco:
  00152	8b 45 d4	 mov	 eax, DWORD PTR tv93[ebp]
  00155	89 45 e0	 mov	 DWORD PTR _size$32361[ebp], eax
  00158	8b 4d d8	 mov	 ecx, DWORD PTR tv93[ebp+4]
  0015b	89 4d e4	 mov	 DWORD PTR _size$32361[ebp+4], ecx

; 105  : 
; 106  : 		ret = lzma_vli_encode(size, &coder->pos,
; 107  : 				out, out_pos, out_size);

  0015e	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00161	52		 push	 edx
  00162	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00165	50		 push	 eax
  00166	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00169	51		 push	 ecx
  0016a	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0016d	81 c2 18 01 00
	00		 add	 edx, 280		; 00000118H
  00173	52		 push	 edx
  00174	8b 45 e4	 mov	 eax, DWORD PTR _size$32361[ebp+4]
  00177	50		 push	 eax
  00178	8b 4d e0	 mov	 ecx, DWORD PTR _size$32361[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 _lzma_vli_encode
  00181	83 c4 18	 add	 esp, 24			; 00000018H
  00184	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 108  : 		if (ret != LZMA_STREAM_END)

  00187	83 7d f8 01	 cmp	 DWORD PTR _ret$[ebp], 1
  0018b	74 05		 je	 SHORT $LN9@index_enco

; 109  : 			goto out;

  0018d	e9 13 01 00 00	 jmp	 $out$32356
$LN9@index_enco:

; 110  : 
; 111  : 		ret = LZMA_OK;

  00192	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 112  : 		coder->pos = 0;

  00199	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0019c	c7 82 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+280], 0

; 113  : 
; 114  : 		// Advance to SEQ_UNCOMPRESSED or SEQ_NEXT.
; 115  : 		++coder->sequence;

  001a6	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  001a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ab	83 c1 01	 add	 ecx, 1
  001ae	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  001b1	89 0a		 mov	 DWORD PTR [edx], ecx

; 116  : 		break;

  001b3	e9 e8 00 00 00	 jmp	 $LN16@index_enco
$LN8@index_enco:

; 117  : 	}
; 118  : 
; 119  : 	case SEQ_PADDING:
; 120  : 		if (coder->pos > 0) {

  001b8	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  001bb	83 b8 18 01 00
	00 00		 cmp	 DWORD PTR [eax+280], 0
  001c2	76 33		 jbe	 SHORT $LN7@index_enco

; 121  : 			--coder->pos;

  001c4	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c7	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR [ecx+280]
  001cd	83 ea 01	 sub	 edx, 1
  001d0	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  001d3	89 90 18 01 00
	00		 mov	 DWORD PTR [eax+280], edx

; 122  : 			out[(*out_pos)++] = 0x00;

  001d9	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001de	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  001e1	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
  001e5	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ea	83 c2 01	 add	 edx, 1
  001ed	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001f0	89 10		 mov	 DWORD PTR [eax], edx

; 123  : 			break;

  001f2	e9 a9 00 00 00	 jmp	 $LN16@index_enco
$LN7@index_enco:

; 124  : 		}
; 125  : 
; 126  : 		// Finish the CRC32 calculation.
; 127  : 		coder->crc32 = lzma_crc32(out + out_start,
; 128  : 				*out_pos - out_start, coder->crc32);

  001f7	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  001fa	8b 91 1c 01 00
	00		 mov	 edx, DWORD PTR [ecx+284]
  00200	52		 push	 edx
  00201	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	2b 4d fc	 sub	 ecx, DWORD PTR _out_start$[ebp]
  00209	51		 push	 ecx
  0020a	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  0020d	03 55 fc	 add	 edx, DWORD PTR _out_start$[ebp]
  00210	52		 push	 edx
  00211	e8 00 00 00 00	 call	 _lzma_crc32
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH
  00219	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  0021c	89 81 1c 01 00
	00		 mov	 DWORD PTR [ecx+284], eax

; 129  : 
; 130  : 		coder->sequence = SEQ_CRC32;

  00222	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00225	c7 02 06 00 00
	00		 mov	 DWORD PTR [edx], 6
$LN5@index_enco:

; 131  : 
; 132  : 	// Fall through
; 133  : 
; 134  : 	case SEQ_CRC32:
; 135  : 		// We don't use the main loop, because we don't want
; 136  : 		// coder->crc32 to be touched anymore.
; 137  : 		do {
; 138  : 			if (*out_pos == out_size)

  0022b	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0022e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00230	3b 4d 24	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  00233	75 07		 jne	 SHORT $LN2@index_enco

; 139  : 				return LZMA_OK;

  00235	33 c0		 xor	 eax, eax
  00237	e9 97 00 00 00	 jmp	 $LN20@index_enco
$LN2@index_enco:

; 140  : 
; 141  : 			out[*out_pos] = (coder->crc32 >> (coder->pos * 8))
; 142  : 					& 0xFF;

  0023c	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0023f	8b 8a 18 01 00
	00		 mov	 ecx, DWORD PTR [edx+280]
  00245	c1 e1 03	 shl	 ecx, 3
  00248	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0024b	8b 90 1c 01 00
	00		 mov	 edx, DWORD PTR [eax+284]
  00251	d3 ea		 shr	 edx, cl
  00253	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00259	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0025c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025e	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00261	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 143  : 			++*out_pos;

  00264	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00267	8b 11		 mov	 edx, DWORD PTR [ecx]
  00269	83 c2 01	 add	 edx, 1
  0026c	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0026f	89 10		 mov	 DWORD PTR [eax], edx

; 144  : 
; 145  : 		} while (++coder->pos < 4);

  00271	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00274	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR [ecx+280]
  0027a	83 c2 01	 add	 edx, 1
  0027d	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00280	89 90 18 01 00
	00		 mov	 DWORD PTR [eax+280], edx
  00286	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00289	83 b9 18 01 00
	00 04		 cmp	 DWORD PTR [ecx+280], 4
  00290	72 99		 jb	 SHORT $LN5@index_enco

; 146  : 
; 147  : 		return LZMA_STREAM_END;

  00292	b8 01 00 00 00	 mov	 eax, 1
  00297	eb 3a		 jmp	 SHORT $LN20@index_enco
$LN1@index_enco:

; 148  : 
; 149  : 	default:
; 150  : 		assert(0);
; 151  : 		return LZMA_PROG_ERROR;

  00299	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0029e	eb 33		 jmp	 SHORT $LN20@index_enco
$LN16@index_enco:

; 152  : 	}

  002a0	e9 76 fd ff ff	 jmp	 $LN19@index_enco
$out$32356:

; 153  : 
; 154  : out:
; 155  : 	// Update the CRC32.
; 156  : 	coder->crc32 = lzma_crc32(out + out_start,
; 157  : 			*out_pos - out_start, coder->crc32);

  002a5	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  002a8	8b 82 1c 01 00
	00		 mov	 eax, DWORD PTR [edx+284]
  002ae	50		 push	 eax
  002af	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  002b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b4	2b 55 fc	 sub	 edx, DWORD PTR _out_start$[ebp]
  002b7	52		 push	 edx
  002b8	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  002bb	03 45 fc	 add	 eax, DWORD PTR _out_start$[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 _lzma_crc32
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c7	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  002ca	89 81 1c 01 00
	00		 mov	 DWORD PTR [ecx+284], eax

; 158  : 
; 159  : 	return ret;

  002d0	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
$LN20@index_enco:

; 160  : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
  002d7	90		 npad	 1
$LN24@index_enco:
  002d8	00 00 00 00	 DD	 $LN15@index_enco
  002dc	00 00 00 00	 DD	 $LN14@index_enco
  002e0	00 00 00 00	 DD	 $LN10@index_enco
  002e4	00 00 00 00	 DD	 $LN10@index_enco
  002e8	00 00 00 00	 DD	 $LN12@index_enco
  002ec	00 00 00 00	 DD	 $LN8@index_enco
  002f0	00 00 00 00	 DD	 $LN5@index_enco
_index_encode ENDP
PUBLIC	_lzma_index_encoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_index_encoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_i$ = 16						; size = 4
_lzma_index_encoder_init PROC				; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN7@lzma_index@15:

; 189  : 	lzma_next_coder_init(&lzma_index_encoder_init, next, allocator);

  00003	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00006	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _lzma_index_encoder_init
  0000d	74 10		 je	 SHORT $LN4@lzma_index@15
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _lzma_next_end
  0001c	83 c4 08	 add	 esp, 8
$LN4@lzma_index@15:
  0001f	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00022	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma_index_encoder_init
  00029	33 c9		 xor	 ecx, ecx
  0002b	75 d6		 jne	 SHORT $LN7@lzma_index@15

; 190  : 
; 191  : 	if (i == NULL)

  0002d	83 7d 10 00	 cmp	 DWORD PTR _i$[ebp], 0
  00031	75 07		 jne	 SHORT $LN3@lzma_index@15

; 192  : 		return LZMA_PROG_ERROR;

  00033	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00038	eb 55		 jmp	 SHORT $LN8@lzma_index@15
$LN3@lzma_index@15:

; 193  : 
; 194  : 	if (next->coder == NULL) {

  0003a	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0003d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00040	75 39		 jne	 SHORT $LN2@lzma_index@15

; 195  : 		next->coder = lzma_alloc(sizeof(lzma_index_coder), allocator);

  00042	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00045	50		 push	 eax
  00046	68 20 01 00 00	 push	 288			; 00000120H
  0004b	e8 00 00 00 00	 call	 _lzma_alloc
  00050	83 c4 08	 add	 esp, 8
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00056	89 01		 mov	 DWORD PTR [ecx], eax

; 196  : 		if (next->coder == NULL)

  00058	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0005b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005e	75 07		 jne	 SHORT $LN1@lzma_index@15

; 197  : 			return LZMA_MEM_ERROR;

  00060	b8 05 00 00 00	 mov	 eax, 5
  00065	eb 28		 jmp	 SHORT $LN8@lzma_index@15
$LN1@lzma_index@15:

; 198  : 
; 199  : 		next->code = &index_encode;

  00067	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0006a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _index_encode

; 200  : 		next->end = &index_encoder_end;

  00071	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00074	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _index_encoder_end
$LN2@lzma_index@15:

; 201  : 	}
; 202  : 
; 203  : 	index_encoder_reset(next->coder, i);

  0007b	8b 55 10	 mov	 edx, DWORD PTR _i$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _index_encoder_reset
  0008a	83 c4 08	 add	 esp, 8

; 204  : 
; 205  : 	return LZMA_OK;

  0008d	33 c0		 xor	 eax, eax
$LN8@lzma_index@15:

; 206  : }

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_lzma_index_encoder_init ENDP
END
