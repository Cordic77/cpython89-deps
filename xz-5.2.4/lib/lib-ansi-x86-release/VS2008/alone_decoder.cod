; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\alone_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\alone_decoder.c
;	COMDAT _alone_decoder_memconfig
_TEXT	SEGMENT
tv87 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_memusage$ = 12						; size = 4
_old_memlimit$ = 16					; size = 4
_new_memlimit$ = 20					; size = 8
_alone_decoder_memconfig PROC				; COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 199  : 	lzma_alone_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 200  : 
; 201  : 	*memusage = coder->memusage;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _memusage$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00012	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00015	89 01		 mov	 DWORD PTR [ecx], eax
  00017	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  0001a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 202  : 	*old_memlimit = coder->memlimit;

  0001d	8b 45 10	 mov	 eax, DWORD PTR _old_memlimit$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00023	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00026	89 10		 mov	 DWORD PTR [eax], edx
  00028	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  0002b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 203  : 
; 204  : 	if (new_memlimit != 0) {

  0002e	8b 55 14	 mov	 edx, DWORD PTR _new_memlimit$[ebp]
  00031	0b 55 18	 or	 edx, DWORD PTR _new_memlimit$[ebp+4]
  00034	74 34		 je	 SHORT $LN2@alone_deco

; 205  : 		if (new_memlimit < coder->memusage)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00039	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR tv87[ebp]
  0003f	8b 55 18	 mov	 edx, DWORD PTR _new_memlimit$[ebp+4]
  00042	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  00045	77 14		 ja	 SHORT $LN1@alone_deco
  00047	72 0b		 jb	 SHORT $LN5@alone_deco
  00049	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  0004c	8b 4d 14	 mov	 ecx, DWORD PTR _new_memlimit$[ebp]
  0004f	3b 48 50	 cmp	 ecx, DWORD PTR [eax+80]
  00052	73 07		 jae	 SHORT $LN1@alone_deco
$LN5@alone_deco:

; 206  : 			return LZMA_MEMLIMIT_ERROR;

  00054	b8 06 00 00 00	 mov	 eax, 6
  00059	eb 11		 jmp	 SHORT $LN3@alone_deco
$LN1@alone_deco:

; 207  : 
; 208  : 		coder->memlimit = new_memlimit;

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0005e	8b 45 14	 mov	 eax, DWORD PTR _new_memlimit$[ebp]
  00061	89 42 48	 mov	 DWORD PTR [edx+72], eax
  00064	8b 4d 18	 mov	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  00067	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
$LN2@alone_deco:

; 209  : 	}
; 210  : 
; 211  : 	return LZMA_OK;

  0006a	33 c0		 xor	 eax, eax
$LN3@alone_deco:

; 212  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_alone_decoder_memconfig ENDP
; Function compile flags: /Odtp
;	COMDAT _alone_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_alone_decoder_end PROC					; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 188  : 	lzma_alone_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 189  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 190  : 	lzma_free(coder, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _lzma_free
  00027	83 c4 08	 add	 esp, 8

; 191  : 	return;
; 192  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_alone_decoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _alone_decode
_TEXT	SEGMENT
tv317 = -64						; size = 4
tv316 = -60						; size = 4
tv295 = -56						; size = 4
tv288 = -52						; size = 4
tv69 = -48						; size = 4
_ret$32448 = -44					; size = 4
_filters$32445 = -40					; size = 32
_d$32437 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_alone_decode PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 60   : 	lzma_alone_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN19@alone_deco@2:

; 61   : 
; 62   : 	while (*out_pos < out_size
; 63   : 			&& (coder->sequence == SEQ_CODE || *in_pos < in_size))

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 24	 cmp	 edx, DWORD PTR _out_size$[ebp]
  00014	0f 83 21 03 00
	00		 jae	 $LN18@alone_deco@2
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0001d	83 78 30 04	 cmp	 DWORD PTR [eax+48], 4
  00021	74 0e		 je	 SHORT $LN17@alone_deco@2
  00023	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  0002b	0f 83 0a 03 00
	00		 jae	 $LN18@alone_deco@2
$LN17@alone_deco@2:

; 64   : 	switch (coder->sequence) {

  00031	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00034	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00037	89 4d d0	 mov	 DWORD PTR tv69[ebp], ecx
  0003a	83 7d d0 04	 cmp	 DWORD PTR tv69[ebp], 4
  0003e	0f 87 eb 02 00
	00		 ja	 $LN1@alone_deco@2
  00044	8b 55 d0	 mov	 edx, DWORD PTR tv69[ebp]
  00047	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN24@alone_deco@2[edx*4]
$LN14@alone_deco@2:

; 65   : 	case SEQ_PROPERTIES:
; 66   : 		if (lzma_lzma_lclppb_decode(&coder->options, in[*in_pos]))

  0004e	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00056	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005e	83 c1 58	 add	 ecx, 88			; 00000058H
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _lzma_lzma_lclppb_decode
  00067	83 c4 08	 add	 esp, 8
  0006a	0f b6 d0	 movzx	 edx, al
  0006d	85 d2		 test	 edx, edx
  0006f	74 0a		 je	 SHORT $LN13@alone_deco@2

; 67   : 			return LZMA_FORMAT_ERROR;

  00071	b8 07 00 00 00	 mov	 eax, 7
  00076	e9 c2 02 00 00	 jmp	 $LN20@alone_deco@2
$LN13@alone_deco@2:

; 68   : 
; 69   : 		coder->sequence = SEQ_DICTIONARY_SIZE;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0007e	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 70   : 		++*in_pos;

  00085	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00088	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008a	83 c2 01	 add	 edx, 1
  0008d	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00090	89 10		 mov	 DWORD PTR [eax], edx

; 71   : 		break;

  00092	e9 9f 02 00 00	 jmp	 $LN15@alone_deco@2
$LN12@alone_deco@2:

; 72   : 
; 73   : 	case SEQ_DICTIONARY_SIZE:
; 74   : 		coder->options.dict_size
; 75   : 				|= (size_t)(in[*in_pos]) << (coder->pos * 8);

  00097	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0009f	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000a6	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a9	c1 e1 03	 shl	 ecx, 3
  000ac	d3 e2		 shl	 edx, cl
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000b1	0b 51 58	 or	 edx, DWORD PTR [ecx+88]
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000b7	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 76   : 
; 77   : 		if (++coder->pos == 4) {

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000bd	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000c0	83 c2 01	 add	 edx, 1
  000c3	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000c6	89 50 38	 mov	 DWORD PTR [eax+56], edx
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000cc	83 79 38 04	 cmp	 DWORD PTR [ecx+56], 4
  000d0	0f 85 8e 00 00
	00		 jne	 $LN11@alone_deco@2

; 78   : 			if (coder->picky && coder->options.dict_size
; 79   : 					!= UINT32_MAX) {

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000d9	0f b6 42 34	 movzx	 eax, BYTE PTR [edx+52]
  000dd	85 c0		 test	 eax, eax
  000df	74 6f		 je	 SHORT $LN10@alone_deco@2
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e4	83 79 58 ff	 cmp	 DWORD PTR [ecx+88], -1
  000e8	74 66		 je	 SHORT $LN10@alone_deco@2

; 80   : 				// A hack to ditch tons of false positives:
; 81   : 				// We allow only dictionary sizes that are
; 82   : 				// 2^n or 2^n + 2^(n-1). LZMA_Alone created
; 83   : 				// only files with 2^n, but accepts any
; 84   : 				// dictionary size.
; 85   : 				uint32_t d = coder->options.dict_size - 1;

  000ea	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000ed	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  000f0	83 e8 01	 sub	 eax, 1
  000f3	89 45 f8	 mov	 DWORD PTR _d$32437[ebp], eax

; 86   : 				d |= d >> 2;

  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _d$32437[ebp]
  000f9	c1 e9 02	 shr	 ecx, 2
  000fc	0b 4d f8	 or	 ecx, DWORD PTR _d$32437[ebp]
  000ff	89 4d f8	 mov	 DWORD PTR _d$32437[ebp], ecx

; 87   : 				d |= d >> 3;

  00102	8b 55 f8	 mov	 edx, DWORD PTR _d$32437[ebp]
  00105	c1 ea 03	 shr	 edx, 3
  00108	0b 55 f8	 or	 edx, DWORD PTR _d$32437[ebp]
  0010b	89 55 f8	 mov	 DWORD PTR _d$32437[ebp], edx

; 88   : 				d |= d >> 4;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _d$32437[ebp]
  00111	c1 e8 04	 shr	 eax, 4
  00114	0b 45 f8	 or	 eax, DWORD PTR _d$32437[ebp]
  00117	89 45 f8	 mov	 DWORD PTR _d$32437[ebp], eax

; 89   : 				d |= d >> 8;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _d$32437[ebp]
  0011d	c1 e9 08	 shr	 ecx, 8
  00120	0b 4d f8	 or	 ecx, DWORD PTR _d$32437[ebp]
  00123	89 4d f8	 mov	 DWORD PTR _d$32437[ebp], ecx

; 90   : 				d |= d >> 16;

  00126	8b 55 f8	 mov	 edx, DWORD PTR _d$32437[ebp]
  00129	c1 ea 10	 shr	 edx, 16			; 00000010H
  0012c	0b 55 f8	 or	 edx, DWORD PTR _d$32437[ebp]
  0012f	89 55 f8	 mov	 DWORD PTR _d$32437[ebp], edx

; 91   : 				++d;

  00132	8b 45 f8	 mov	 eax, DWORD PTR _d$32437[ebp]
  00135	83 c0 01	 add	 eax, 1
  00138	89 45 f8	 mov	 DWORD PTR _d$32437[ebp], eax

; 92   : 
; 93   : 				if (d != coder->options.dict_size)

  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013e	8b 55 f8	 mov	 edx, DWORD PTR _d$32437[ebp]
  00141	3b 51 58	 cmp	 edx, DWORD PTR [ecx+88]
  00144	74 0a		 je	 SHORT $LN10@alone_deco@2

; 94   : 					return LZMA_FORMAT_ERROR;

  00146	b8 07 00 00 00	 mov	 eax, 7
  0014b	e9 ed 01 00 00	 jmp	 $LN20@alone_deco@2
$LN10@alone_deco@2:

; 95   : 			}
; 96   : 
; 97   : 			coder->pos = 0;

  00150	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00153	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 98   : 			coder->sequence = SEQ_UNCOMPRESSED_SIZE;

  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0015d	c7 41 30 02 00
	00 00		 mov	 DWORD PTR [ecx+48], 2
$LN11@alone_deco@2:

; 99   : 		}
; 100  : 
; 101  : 		++*in_pos;

  00164	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00167	8b 02		 mov	 eax, DWORD PTR [edx]
  00169	83 c0 01	 add	 eax, 1
  0016c	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0016f	89 01		 mov	 DWORD PTR [ecx], eax

; 102  : 		break;

  00171	e9 c0 01 00 00	 jmp	 $LN15@alone_deco@2
$LN8@alone_deco@2:

; 103  : 
; 104  : 	case SEQ_UNCOMPRESSED_SIZE:
; 105  : 		coder->uncompressed_size
; 106  : 				|= (lzma_vli)(in[*in_pos]) << (coder->pos * 8);

  00176	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00179	8b 02		 mov	 eax, DWORD PTR [edx]
  0017b	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0017e	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00182	99		 cdq
  00183	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00186	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  00189	c1 e1 03	 shl	 ecx, 3
  0018c	e8 00 00 00 00	 call	 __allshl
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00194	0b 41 40	 or	 eax, DWORD PTR [ecx+64]
  00197	0b 51 44	 or	 edx, DWORD PTR [ecx+68]
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0019d	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  001a0	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 107  : 		++*in_pos;

  001a3	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  001a6	8b 02		 mov	 eax, DWORD PTR [edx]
  001a8	83 c0 01	 add	 eax, 1
  001ab	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  001ae	89 01		 mov	 DWORD PTR [ecx], eax

; 108  : 		if (++coder->pos < 8)

  001b0	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001b3	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001b6	83 c0 01	 add	 eax, 1
  001b9	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001bc	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  001bf	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001c2	83 7a 38 08	 cmp	 DWORD PTR [edx+56], 8
  001c6	73 05		 jae	 SHORT $LN7@alone_deco@2

; 109  : 			break;

  001c8	e9 69 01 00 00	 jmp	 $LN15@alone_deco@2
$LN7@alone_deco@2:

; 110  : 
; 111  : 		// Another hack to ditch false positives: Assume that
; 112  : 		// if the uncompressed size is known, it must be less
; 113  : 		// than 256 GiB.
; 114  : 		if (coder->picky
; 115  : 				&& coder->uncompressed_size != LZMA_VLI_UNKNOWN
; 116  : 				&& coder->uncompressed_size
; 117  : 					>= (LZMA_VLI_C(1) << 38))

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001d0	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  001d4	85 c9		 test	 ecx, ecx
  001d6	74 3b		 je	 SHORT $LN6@alone_deco@2
  001d8	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001db	89 55 cc	 mov	 DWORD PTR tv288[ebp], edx
  001de	8b 45 cc	 mov	 eax, DWORD PTR tv288[ebp]
  001e1	8b 4d cc	 mov	 ecx, DWORD PTR tv288[ebp]
  001e4	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  001e7	23 51 44	 and	 edx, DWORD PTR [ecx+68]
  001ea	83 fa ff	 cmp	 edx, -1
  001ed	74 24		 je	 SHORT $LN6@alone_deco@2
  001ef	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001f2	89 45 c8	 mov	 DWORD PTR tv295[ebp], eax
  001f5	8b 4d c8	 mov	 ecx, DWORD PTR tv295[ebp]
  001f8	83 79 44 40	 cmp	 DWORD PTR [ecx+68], 64	; 00000040H
  001fc	72 15		 jb	 SHORT $LN6@alone_deco@2
  001fe	77 09		 ja	 SHORT $LN22@alone_deco@2
  00200	8b 55 c8	 mov	 edx, DWORD PTR tv295[ebp]
  00203	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  00207	72 0a		 jb	 SHORT $LN6@alone_deco@2
$LN22@alone_deco@2:

; 118  : 			return LZMA_FORMAT_ERROR;

  00209	b8 07 00 00 00	 mov	 eax, 7
  0020e	e9 2a 01 00 00	 jmp	 $LN20@alone_deco@2
$LN6@alone_deco@2:

; 119  : 
; 120  : 		// Calculate the memory usage so that it is ready
; 121  : 		// for SEQ_CODER_INIT.
; 122  : 		coder->memusage = lzma_lzma_decoder_memusage(&coder->options)
; 123  : 				+ LZMA_MEMUSAGE_BASE;

  00213	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00216	83 c0 58	 add	 eax, 88			; 00000058H
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 _lzma_lzma_decoder_memusage
  0021f	83 c4 04	 add	 esp, 4
  00222	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  00227	83 d2 00	 adc	 edx, 0
  0022a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0022d	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00230	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 124  : 
; 125  : 		coder->pos = 0;

  00233	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00236	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 126  : 		coder->sequence = SEQ_CODER_INIT;

  0023d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00240	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [eax+48], 3
$LN5@alone_deco@2:

; 127  : 
; 128  : 	// Fall through
; 129  : 
; 130  : 	case SEQ_CODER_INIT: {
; 131  : 		if (coder->memusage > coder->memlimit)

  00247	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0024a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0024d	89 4d c4	 mov	 DWORD PTR tv316[ebp], ecx
  00250	89 55 c0	 mov	 DWORD PTR tv317[ebp], edx
  00253	8b 45 c4	 mov	 eax, DWORD PTR tv316[ebp]
  00256	8b 4d c0	 mov	 ecx, DWORD PTR tv317[ebp]
  00259	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  0025c	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0025f	72 1a		 jb	 SHORT $LN4@alone_deco@2
  00261	77 0e		 ja	 SHORT $LN23@alone_deco@2
  00263	8b 45 c4	 mov	 eax, DWORD PTR tv316[ebp]
  00266	8b 4d c0	 mov	 ecx, DWORD PTR tv317[ebp]
  00269	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0026c	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  0026f	76 0a		 jbe	 SHORT $LN4@alone_deco@2
$LN23@alone_deco@2:

; 132  : 			return LZMA_MEMLIMIT_ERROR;

  00271	b8 06 00 00 00	 mov	 eax, 6
  00276	e9 c2 00 00 00	 jmp	 $LN20@alone_deco@2
$LN4@alone_deco@2:

; 133  : 
; 134  :       {
; 135  : 	    /* //MiSt
; 136  : 		lzma_filter_info filters[2] = {
; 137  : 			{
; 138  : 				.init = &lzma_lzma_decoder_init,
; 139  : 				.options = &coder->options,
; 140  : 			}, {
; 141  : 				.init = NULL,
; 142  : 			}
; 143  : 		};
; 144  : 		*/
; 145  : 		lzma_filter_info filters[2] = {
; 146  : 			{
; 147  : 				0,                          // lzma_vli id;

  0027b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp], 0
  00282	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+4], 0

; 148  : 				&lzma_lzma_decoder_init,    // lzma_init_function init;

  00289	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+8], OFFSET _lzma_lzma_decoder_init

; 149  : 				&coder->options,            // void *options;

  00290	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00293	83 c0 58	 add	 eax, 88			; 00000058H
  00296	89 45 e4	 mov	 DWORD PTR _filters$32445[ebp+12], eax

; 150  : 			}, {
; 151  : 				0,

  00299	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+16], 0
  002a0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+20], 0

; 152  : 				NULL,

  002a7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+24], 0

; 153  : 				NULL,

  002ae	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _filters$32445[ebp+28], 0

; 154  : 			}
; 155  : 		};
; 156  : 
; 157  : 		const lzma_ret ret = lzma_next_filter_init(&coder->next,
; 158  : 				allocator, filters);

  002b5	8d 4d d8	 lea	 ecx, DWORD PTR _filters$32445[ebp]
  002b8	51		 push	 ecx
  002b9	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  002bc	52		 push	 edx
  002bd	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _lzma_next_filter_init
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c9	89 45 d4	 mov	 DWORD PTR _ret$32448[ebp], eax

; 159  : 		if (ret != LZMA_OK)

  002cc	83 7d d4 00	 cmp	 DWORD PTR _ret$32448[ebp], 0
  002d0	74 05		 je	 SHORT $LN3@alone_deco@2

; 160  : 			return ret;

  002d2	8b 45 d4	 mov	 eax, DWORD PTR _ret$32448[ebp]
  002d5	eb 66		 jmp	 SHORT $LN20@alone_deco@2
$LN3@alone_deco@2:

; 161  : 
; 162  : 		// Use a hack to set the uncompressed size.
; 163  : 		lzma_lz_decoder_uncompressed(coder->next.coder,
; 164  : 				coder->uncompressed_size);

  002d7	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002da	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  002dd	52		 push	 edx
  002de	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  002e1	50		 push	 eax
  002e2	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  002e7	52		 push	 edx
  002e8	e8 00 00 00 00	 call	 _lzma_lz_decoder_uncompressed
  002ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 
; 166  : 		coder->sequence = SEQ_CODE;

  002f0	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002f3	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [eax+48], 4

; 167  : 	  }
; 168  : 		break;

  002fa	eb 3a		 jmp	 SHORT $LN15@alone_deco@2
$LN2@alone_deco@2:

; 169  : 	}
; 170  : 
; 171  : 	case SEQ_CODE: {
; 172  : 		return coder->next.code(coder->next.coder,
; 173  : 				allocator, in, in_pos, in_size,
; 174  : 				out, out_pos, out_size, action);

  002fc	8b 4d 28	 mov	 ecx, DWORD PTR _action$[ebp]
  002ff	51		 push	 ecx
  00300	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00303	52		 push	 edx
  00304	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00307	50		 push	 eax
  00308	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0030b	51		 push	 ecx
  0030c	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  0030f	52		 push	 edx
  00310	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00313	50		 push	 eax
  00314	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00317	51		 push	 ecx
  00318	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0031b	52		 push	 edx
  0031c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0031f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00321	51		 push	 ecx
  00322	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00325	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00328	ff d0		 call	 eax
  0032a	83 c4 24	 add	 esp, 36			; 00000024H
  0032d	eb 0e		 jmp	 SHORT $LN20@alone_deco@2
$LN1@alone_deco@2:

; 175  : 	}
; 176  : 
; 177  : 	default:
; 178  : 		return LZMA_PROG_ERROR;

  0032f	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00334	eb 07		 jmp	 SHORT $LN20@alone_deco@2
$LN15@alone_deco@2:

; 179  : 	}

  00336	e9 d1 fc ff ff	 jmp	 $LN19@alone_deco@2
$LN18@alone_deco@2:

; 180  : 
; 181  : 	return LZMA_OK;

  0033b	33 c0		 xor	 eax, eax
$LN20@alone_deco@2:

; 182  : }

  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c3		 ret	 0
  00341	8d 49 00	 npad	 3
$LN24@alone_deco@2:
  00344	00 00 00 00	 DD	 $LN14@alone_deco@2
  00348	00 00 00 00	 DD	 $LN12@alone_deco@2
  0034c	00 00 00 00	 DD	 $LN8@alone_deco@2
  00350	00 00 00 00	 DD	 $LN5@alone_deco@2
  00354	00 00 00 00	 DD	 $LN2@alone_deco@2
_alone_decode ENDP
PUBLIC	_lzma_alone_decoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_alone_decoder_init
_TEXT	SEGMENT
tv87 = -12						; size = 8
_coder$32487 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_memlimit$ = 16						; size = 8
_picky$ = 24						; size = 1
_lzma_alone_decoder_init PROC				; COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN6@lzma_alone:

; 219  : 	lzma_next_coder_init(&lzma_alone_decoder_init, next, allocator);

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _lzma_alone_decoder_init
  00012	74 10		 je	 SHORT $LN3@lzma_alone
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _lzma_next_end
  00021	83 c4 08	 add	 esp, 8
$LN3@lzma_alone:
  00024	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma_alone_decoder_init
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 d6		 jne	 SHORT $LN6@lzma_alone

; 220  : 
; 221  :   {
; 222  : 	lzma_alone_coder *coder = next->coder;

  00032	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 fc	 mov	 DWORD PTR _coder$32487[ebp], eax

; 223  : 
; 224  : 	if (coder == NULL) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _coder$32487[ebp], 0
  0003e	75 59		 jne	 SHORT $LN2@lzma_alone

; 225  : 		coder = lzma_alloc(sizeof(lzma_alone_coder), allocator);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00043	51		 push	 ecx
  00044	68 b8 00 00 00	 push	 184			; 000000b8H
  00049	e8 00 00 00 00	 call	 _lzma_alloc
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 fc	 mov	 DWORD PTR _coder$32487[ebp], eax

; 226  : 		if (coder == NULL)

  00054	83 7d fc 00	 cmp	 DWORD PTR _coder$32487[ebp], 0
  00058	75 0a		 jne	 SHORT $LN1@lzma_alone

; 227  : 			return LZMA_MEM_ERROR;

  0005a	b8 05 00 00 00	 mov	 eax, 5
  0005f	e9 cd 00 00 00	 jmp	 $LN7@lzma_alone
$LN1@lzma_alone:

; 228  : 
; 229  : 		next->coder = coder;

  00064	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00067	8b 45 fc	 mov	 eax, DWORD PTR _coder$32487[ebp]
  0006a	89 02		 mov	 DWORD PTR [edx], eax

; 230  : 		next->code = &alone_decode;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0006f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _alone_decode

; 231  : 		next->end = &alone_decoder_end;

  00076	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00079	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _alone_decoder_end

; 232  : 		next->memconfig = &alone_decoder_memconfig;

  00080	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00083	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _alone_decoder_memconfig

; 233  : 		coder->next = LZMA_NEXT_CODER_INIT;

  0008a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0008f	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00094	8b 7d fc	 mov	 edi, DWORD PTR _coder$32487[ebp]
  00097	f3 a5		 rep movsd
$LN2@lzma_alone:

; 234  : 	}
; 235  : 
; 236  : 	coder->sequence = SEQ_PROPERTIES;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32487[ebp]
  0009c	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 237  : 	coder->picky = picky;

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _coder$32487[ebp]
  000a6	8a 45 18	 mov	 al, BYTE PTR _picky$[ebp]
  000a9	88 42 34	 mov	 BYTE PTR [edx+52], al

; 238  : 	coder->pos = 0;

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32487[ebp]
  000af	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 239  : 	coder->options.dict_size = 0;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _coder$32487[ebp]
  000b9	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 240  : 	coder->options.preset_dict = NULL;

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _coder$32487[ebp]
  000c3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 241  : 	coder->options.preset_dict_size = 0;

  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32487[ebp]
  000cd	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0

; 242  : 	coder->uncompressed_size = 0;

  000d4	8b 55 fc	 mov	 edx, DWORD PTR _coder$32487[ebp]
  000d7	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0
  000de	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 243  : 	coder->memlimit = my_max(1, memlimit);

  000e5	83 7d 14 00	 cmp	 DWORD PTR _memlimit$[ebp+4], 0
  000e9	77 18		 ja	 SHORT $LN9@lzma_alone
  000eb	72 06		 jb	 SHORT $LN11@lzma_alone
  000ed	83 7d 10 01	 cmp	 DWORD PTR _memlimit$[ebp], 1
  000f1	73 10		 jae	 SHORT $LN9@lzma_alone
$LN11@lzma_alone:
  000f3	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  000fa	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp+4], 0
  00101	eb 0c		 jmp	 SHORT $LN10@lzma_alone
$LN9@lzma_alone:
  00103	8b 45 10	 mov	 eax, DWORD PTR _memlimit$[ebp]
  00106	89 45 f4	 mov	 DWORD PTR tv87[ebp], eax
  00109	8b 4d 14	 mov	 ecx, DWORD PTR _memlimit$[ebp+4]
  0010c	89 4d f8	 mov	 DWORD PTR tv87[ebp+4], ecx
$LN10@lzma_alone:
  0010f	8b 55 fc	 mov	 edx, DWORD PTR _coder$32487[ebp]
  00112	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00115	89 42 48	 mov	 DWORD PTR [edx+72], eax
  00118	8b 4d f8	 mov	 ecx, DWORD PTR tv87[ebp+4]
  0011b	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 244  : 	coder->memusage = LZMA_MEMUSAGE_BASE;

  0011e	8b 55 fc	 mov	 edx, DWORD PTR _coder$32487[ebp]
  00121	c7 42 50 00 80
	00 00		 mov	 DWORD PTR [edx+80], 32768 ; 00008000H
  00128	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0

; 245  :   }
; 246  : 
; 247  : 	return LZMA_OK;

  0012f	33 c0		 xor	 eax, eax
$LN7@lzma_alone:

; 248  : }

  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
_lzma_alone_decoder_init ENDP
PUBLIC	_lzma_alone_decoder
; Function compile flags: /Odtp
;	COMDAT _lzma_alone_decoder
_TEXT	SEGMENT
_ret_$32507 = -8					; size = 4
_ret_$32505 = -4					; size = 4
_strm$ = 8						; size = 4
_memlimit$ = 12						; size = 8
_lzma_alone_decoder PROC				; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_alone@2:

; 254  : 	lzma_next_strm_init(lzma_alone_decoder_init, strm, memlimit, false);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32505[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32505[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_alone@2
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32505[ebp]
  0001e	eb 58		 jmp	 SHORT $LN9@lzma_alone@2
$LN4@lzma_alone@2:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_alone@2
  00024	6a 00		 push	 0
  00026	8b 55 10	 mov	 edx, DWORD PTR _memlimit$[ebp+4]
  00029	52		 push	 edx
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _memlimit$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00031	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00038	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _lzma_alone_decoder_init
  00041	83 c4 14	 add	 esp, 20			; 00000014H
  00044	89 45 f8	 mov	 DWORD PTR _ret_$32507[ebp], eax
  00047	83 7d f8 00	 cmp	 DWORD PTR _ret_$32507[ebp], 0
  0004b	74 11		 je	 SHORT $LN7@lzma_alone@2
  0004d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _lzma_end
  00056	83 c4 04	 add	 esp, 4
  00059	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32507[ebp]
  0005c	eb 1a		 jmp	 SHORT $LN9@lzma_alone@2
$LN7@lzma_alone@2:
  0005e	33 c0		 xor	 eax, eax
  00060	75 a4		 jne	 SHORT $LN5@lzma_alone@2

; 255  : 
; 256  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00065	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00068	c6 42 38 01	 mov	 BYTE PTR [edx+56], 1

; 257  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00072	c6 41 3b 01	 mov	 BYTE PTR [ecx+59], 1

; 258  : 
; 259  : 	return LZMA_OK;

  00076	33 c0		 xor	 eax, eax
$LN9@lzma_alone@2:

; 260  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_lzma_alone_decoder ENDP
END
