; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma_encoder_presets.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?dict_pow2@?2??lzma_lzma_preset@@9@9 DB 012H		; `lzma_lzma_preset'::`3'::dict_pow2
	DB	014H
	DB	015H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	ORG $+2
?depths@?4??lzma_lzma_preset@@9@9 DB 04H		; `lzma_lzma_preset'::`5'::depths
	DB	08H
	DB	018H
	DB	030H
PUBLIC	_lzma_lzma_preset
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_presets.c
;	COMDAT _lzma_lzma_preset
_TEXT	SEGMENT
tv95 = -16						; size = 4
_supported_flags$ = -12					; size = 4
_flags$ = -8						; size = 4
_level$ = -4						; size = 4
_options$ = 8						; size = 4
_preset$ = 12						; size = 4
_lzma_lzma_preset PROC					; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 20   : 	const uint32_t level = preset & LZMA_PRESET_LEVEL_MASK;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _preset$[ebp]
  00009	83 e0 1f	 and	 eax, 31			; 0000001fH
  0000c	89 45 fc	 mov	 DWORD PTR _level$[ebp], eax

; 21   : 	const uint32_t flags = preset & ~LZMA_PRESET_LEVEL_MASK;

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _preset$[ebp]
  00012	83 e1 e0	 and	 ecx, -32		; ffffffe0H
  00015	89 4d f8	 mov	 DWORD PTR _flags$[ebp], ecx

; 22   : 	const uint32_t supported_flags = LZMA_PRESET_EXTREME;

  00018	c7 45 f4 00 00
	00 80		 mov	 DWORD PTR _supported_flags$[ebp], -2147483648 ; 80000000H

; 23   : 
; 24   : 	if (level > 9 || (flags & ~supported_flags))

  0001f	83 7d fc 09	 cmp	 DWORD PTR _level$[ebp], 9
  00023	77 0a		 ja	 SHORT $LN7@lzma_lzma_@2
  00025	8b 55 f4	 mov	 edx, DWORD PTR _supported_flags$[ebp]
  00028	f7 d2		 not	 edx
  0002a	23 55 f8	 and	 edx, DWORD PTR _flags$[ebp]
  0002d	74 07		 je	 SHORT $LN8@lzma_lzma_@2
$LN7@lzma_lzma_@2:

; 25   : 		return true;

  0002f	b0 01		 mov	 al, 1
  00031	e9 36 01 00 00	 jmp	 $LN9@lzma_lzma_@2
$LN8@lzma_lzma_@2:

; 26   : 
; 27   : 	options->preset_dict = NULL;

  00036	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 28   : 	options->preset_dict_size = 0;

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00043	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 29   : 
; 30   : 	options->lc = LZMA_LC_DEFAULT;

  0004a	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0004d	c7 42 0c 03 00
	00 00		 mov	 DWORD PTR [edx+12], 3

; 31   : 	options->lp = LZMA_LP_DEFAULT;

  00054	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00057	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 32   : 	options->pb = LZMA_PB_DEFAULT;

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00061	c7 41 14 02 00
	00 00		 mov	 DWORD PTR [ecx+20], 2

; 33   : 
; 34   :   { static const uint8_t dict_pow2[]
; 35   : 			= { 18, 20, 21, 22, 22, 23, 23, 24, 25, 26 };
; 36   : 	options->dict_size = UINT32_C(1) << dict_pow2[level];

  00068	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  0006b	0f b6 8a 00 00
	00 00		 movzx	 ecx, BYTE PTR ?dict_pow2@?2??lzma_lzma_preset@@9@9[edx]
  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	d3 e0		 shl	 eax, cl
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0007c	89 01		 mov	 DWORD PTR [ecx], eax

; 37   :   }
; 38   : 
; 39   : 	if (level <= 3) {

  0007e	83 7d fc 03	 cmp	 DWORD PTR _level$[ebp], 3
  00082	77 48		 ja	 SHORT $LN6@lzma_lzma_@2

; 40   : 		options->mode = LZMA_MODE_FAST;

  00084	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00087	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1

; 41   : 		options->mf = level == 0 ? LZMA_MF_HC3 : LZMA_MF_HC4;

  0008e	33 c0		 xor	 eax, eax
  00090	83 7d fc 00	 cmp	 DWORD PTR _level$[ebp], 0
  00094	0f 95 c0	 setne	 al
  00097	83 c0 03	 add	 eax, 3
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0009d	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 42   : 		options->nice_len = level <= 1 ? 128 : 273;

  000a0	ba 01 00 00 00	 mov	 edx, 1
  000a5	3b 55 fc	 cmp	 edx, DWORD PTR _level$[ebp]
  000a8	1b c0		 sbb	 eax, eax
  000aa	25 91 00 00 00	 and	 eax, 145		; 00000091H
  000af	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  000b7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 43   : 	  {
; 44   : 		static const uint8_t depths[] = { 4, 8, 24, 48 };
; 45   : 		options->depth = depths[level];

  000ba	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  000bd	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR ?depths@?4??lzma_lzma_preset@@9@9[edx]
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  000c7	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 46   : 	  }
; 47   : 	} else {

  000ca	eb 49		 jmp	 SHORT $LN5@lzma_lzma_@2
$LN6@lzma_lzma_@2:

; 48   : 		options->mode = LZMA_MODE_NORMAL;

  000cc	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  000cf	c7 42 18 02 00
	00 00		 mov	 DWORD PTR [edx+24], 2

; 49   : 		options->mf = LZMA_MF_BT4;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  000d9	c7 40 20 14 00
	00 00		 mov	 DWORD PTR [eax+32], 20	; 00000014H

; 50   : 		options->nice_len = level == 4 ? 16 : level == 5 ? 32 : 64;

  000e0	83 7d fc 04	 cmp	 DWORD PTR _level$[ebp], 4
  000e4	75 09		 jne	 SHORT $LN11@lzma_lzma_@2
  000e6	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR tv95[ebp], 16	; 00000010H
  000ed	eb 13		 jmp	 SHORT $LN12@lzma_lzma_@2
$LN11@lzma_lzma_@2:
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  000f2	83 e9 05	 sub	 ecx, 5
  000f5	f7 d9		 neg	 ecx
  000f7	1b c9		 sbb	 ecx, ecx
  000f9	83 e1 20	 and	 ecx, 32			; 00000020H
  000fc	83 c1 20	 add	 ecx, 32			; 00000020H
  000ff	89 4d f0	 mov	 DWORD PTR tv95[ebp], ecx
$LN12@lzma_lzma_@2:
  00102	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00105	8b 45 f0	 mov	 eax, DWORD PTR tv95[ebp]
  00108	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 51   : 		options->depth = 0;

  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0010e	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$LN5@lzma_lzma_@2:

; 52   : 	}
; 53   : 
; 54   : 	if (flags & LZMA_PRESET_EXTREME) {

  00115	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  00118	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0011e	74 4a		 je	 SHORT $LN4@lzma_lzma_@2

; 55   : 		options->mode = LZMA_MODE_NORMAL;

  00120	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00123	c7 40 18 02 00
	00 00		 mov	 DWORD PTR [eax+24], 2

; 56   : 		options->mf = LZMA_MF_BT4;

  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0012d	c7 41 20 14 00
	00 00		 mov	 DWORD PTR [ecx+32], 20	; 00000014H

; 57   : 		if (level == 3 || level == 5) {

  00134	83 7d fc 03	 cmp	 DWORD PTR _level$[ebp], 3
  00138	74 06		 je	 SHORT $LN2@lzma_lzma_@2
  0013a	83 7d fc 05	 cmp	 DWORD PTR _level$[ebp], 5
  0013e	75 16		 jne	 SHORT $LN3@lzma_lzma_@2
$LN2@lzma_lzma_@2:

; 58   : 			options->nice_len = 192;

  00140	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00143	c7 42 1c c0 00
	00 00		 mov	 DWORD PTR [edx+28], 192	; 000000c0H

; 59   : 			options->depth = 0;

  0014a	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  0014d	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 60   : 		} else {

  00154	eb 14		 jmp	 SHORT $LN4@lzma_lzma_@2
$LN3@lzma_lzma_@2:

; 61   : 			options->nice_len = 273;

  00156	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00159	c7 41 1c 11 01
	00 00		 mov	 DWORD PTR [ecx+28], 273	; 00000111H

; 62   : 			options->depth = 512;

  00160	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00163	c7 42 24 00 02
	00 00		 mov	 DWORD PTR [edx+36], 512	; 00000200H
$LN4@lzma_lzma_@2:

; 63   : 		}
; 64   : 	}
; 65   : 
; 66   : 	return false;

  0016a	32 c0		 xor	 al, al
$LN9@lzma_lzma_@2:

; 67   : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_lzma_lzma_preset ENDP
END
