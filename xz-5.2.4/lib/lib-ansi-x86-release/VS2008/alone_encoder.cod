; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\alone_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT _write32ne
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_num$ = 12						; size = 4
_write32ne PROC						; COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	*(uint32_t *)buf = num;

  00003	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 	return;
; 269  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_write32ne ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\alone_encoder.c
;	COMDAT _alone_encode
_TEXT	SEGMENT
tv66 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_alone_encode PROC					; COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 41   : 	lzma_alone_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN8@alone_enco:

; 42   : 
; 43   : 	while (*out_pos < out_size)

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 24	 cmp	 edx, DWORD PTR _out_size$[ebp]
  00014	0f 83 93 00 00
	00		 jae	 $LN7@alone_enco

; 44   : 	switch (coder->sequence) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0001d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00020	89 4d f8	 mov	 DWORD PTR tv66[ebp], ecx
  00023	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00027	74 08		 je	 SHORT $LN4@alone_enco
  00029	83 7d f8 01	 cmp	 DWORD PTR tv66[ebp], 1
  0002d	74 3f		 je	 SHORT $LN2@alone_enco
  0002f	eb 70		 jmp	 SHORT $LN1@alone_enco
$LN4@alone_enco:

; 45   : 	case SEQ_HEADER:
; 46   : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 47   : 				ALONE_HEADER_SIZE,
; 48   : 				out, out_pos, out_size);

  00031	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00034	52		 push	 edx
  00035	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0003c	51		 push	 ecx
  0003d	6a 0d		 push	 13			; 0000000dH
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00042	83 c2 34	 add	 edx, 52			; 00000034H
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00049	83 c0 38	 add	 eax, 56			; 00000038H
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _lzma_bufcpy
  00052	83 c4 18	 add	 esp, 24			; 00000018H

; 49   : 		if (coder->header_pos < ALONE_HEADER_SIZE)

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00058	83 79 34 0d	 cmp	 DWORD PTR [ecx+52], 13	; 0000000dH
  0005c	73 04		 jae	 SHORT $LN3@alone_enco

; 50   : 			return LZMA_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 4d		 jmp	 SHORT $LN9@alone_enco
$LN3@alone_enco:

; 51   : 
; 52   : 		coder->sequence = SEQ_CODE;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00065	c7 42 30 01 00
	00 00		 mov	 DWORD PTR [edx+48], 1

; 53   : 		break;

  0006c	eb 3a		 jmp	 SHORT $LN5@alone_enco
$LN2@alone_enco:

; 54   : 
; 55   : 	case SEQ_CODE:
; 56   : 		return coder->next.code(coder->next.coder,
; 57   : 				allocator, in, in_pos, in_size,
; 58   : 				out, out_pos, out_size, action);

  0006e	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00081	51		 push	 ecx
  00082	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00085	52		 push	 edx
  00086	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	50		 push	 eax
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00097	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0009a	ff d2		 call	 edx
  0009c	83 c4 24	 add	 esp, 36			; 00000024H
  0009f	eb 0e		 jmp	 SHORT $LN9@alone_enco
$LN1@alone_enco:

; 59   : 
; 60   : 	default:
; 61   : 		assert(0);
; 62   : 		return LZMA_PROG_ERROR;

  000a1	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000a6	eb 07		 jmp	 SHORT $LN9@alone_enco
$LN5@alone_enco:

; 63   : 	}

  000a8	e9 5f ff ff ff	 jmp	 $LN8@alone_enco
$LN7@alone_enco:

; 64   : 
; 65   : 	return LZMA_OK;

  000ad	33 c0		 xor	 eax, eax
$LN9@alone_enco:

; 66   : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_alone_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _alone_encoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_alone_encoder_end PROC					; COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   : 	lzma_alone_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 73   : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 74   : 	lzma_free(coder, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _lzma_free
  00027	83 c4 08	 add	 esp, 8

; 75   : 	return;
; 76   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_alone_encoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _alone_encoder_init
_TEXT	SEGMENT
_filters$32311 = -40					; size = 32
_d$32308 = -8						; size = 4
_coder$32300 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_alone_encoder_init PROC				; COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN9@alone_enco@2:

; 84   : 	lzma_next_coder_init(&alone_encoder_init, next, allocator);

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _alone_encoder_init
  00012	74 10		 je	 SHORT $LN6@alone_enco@2
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _lzma_next_end
  00021	83 c4 08	 add	 esp, 8
$LN6@alone_enco@2:
  00024	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _alone_encoder_init
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 d6		 jne	 SHORT $LN9@alone_enco@2

; 85   : 
; 86   :   {
; 87   : 	lzma_alone_coder *coder = next->coder;

  00032	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 fc	 mov	 DWORD PTR _coder$32300[ebp], eax

; 88   : 
; 89   : 	if (coder == NULL) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _coder$32300[ebp], 0
  0003e	75 4c		 jne	 SHORT $LN5@alone_enco@2

; 90   : 		coder = lzma_alloc(sizeof(lzma_alone_coder), allocator);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00043	51		 push	 ecx
  00044	6a 48		 push	 72			; 00000048H
  00046	e8 00 00 00 00	 call	 _lzma_alloc
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 fc	 mov	 DWORD PTR _coder$32300[ebp], eax

; 91   : 		if (coder == NULL)

  00051	83 7d fc 00	 cmp	 DWORD PTR _coder$32300[ebp], 0
  00055	75 0a		 jne	 SHORT $LN4@alone_enco@2

; 92   : 			return LZMA_MEM_ERROR;

  00057	b8 05 00 00 00	 mov	 eax, 5
  0005c	e9 25 01 00 00	 jmp	 $LN10@alone_enco@2
$LN4@alone_enco@2:

; 93   : 
; 94   : 		next->coder = coder;

  00061	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00064	8b 45 fc	 mov	 eax, DWORD PTR _coder$32300[ebp]
  00067	89 02		 mov	 DWORD PTR [edx], eax

; 95   : 		next->code = &alone_encode;

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0006c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _alone_encode

; 96   : 		next->end = &alone_encoder_end;

  00073	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00076	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _alone_encoder_end

; 97   : 		coder->next = LZMA_NEXT_CODER_INIT;

  0007d	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00082	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00087	8b 7d fc	 mov	 edi, DWORD PTR _coder$32300[ebp]
  0008a	f3 a5		 rep movsd
$LN5@alone_enco@2:

; 98   : 	}
; 99   : 
; 100  : 	// Basic initializations
; 101  : 	coder->sequence = SEQ_HEADER;

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _coder$32300[ebp]
  0008f	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 102  : 	coder->header_pos = 0;

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32300[ebp]
  00099	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 103  : 
; 104  : 	// Encode the header:
; 105  : 	// - Properties (1 byte)
; 106  : 	if (lzma_lzma_lclppb_encode(options, coder->header))

  000a0	8b 55 fc	 mov	 edx, DWORD PTR _coder$32300[ebp]
  000a3	83 c2 38	 add	 edx, 56			; 00000038H
  000a6	52		 push	 edx
  000a7	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _lzma_lzma_lclppb_encode
  000b0	83 c4 08	 add	 esp, 8
  000b3	0f b6 c8	 movzx	 ecx, al
  000b6	85 c9		 test	 ecx, ecx
  000b8	74 0a		 je	 SHORT $LN3@alone_enco@2

; 107  : 		return LZMA_OPTIONS_ERROR;

  000ba	b8 08 00 00 00	 mov	 eax, 8
  000bf	e9 c2 00 00 00	 jmp	 $LN10@alone_enco@2
$LN3@alone_enco@2:

; 108  : 
; 109  : 	// - Dictionary size (4 bytes)
; 110  : 	if (options->dict_size < LZMA_DICT_SIZE_MIN)

  000c4	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  000c7	81 3a 00 10 00
	00		 cmp	 DWORD PTR [edx], 4096	; 00001000H
  000cd	73 0a		 jae	 SHORT $LN2@alone_enco@2

; 111  : 		return LZMA_OPTIONS_ERROR;

  000cf	b8 08 00 00 00	 mov	 eax, 8
  000d4	e9 ad 00 00 00	 jmp	 $LN10@alone_enco@2
$LN2@alone_enco@2:

; 112  : 
; 113  : 	// Round up to the next 2^n or 2^n + 2^(n - 1) depending on which
; 114  : 	// one is the next unless it is UINT32_MAX. While the header would
; 115  : 	// allow any 32-bit integer, we do this to keep the decoder of liblzma
; 116  : 	// accepting the resulting files.
; 117  :   {
; 118  : 	uint32_t d = options->dict_size - 1;

  000d9	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 e9 01	 sub	 ecx, 1
  000e1	89 4d f8	 mov	 DWORD PTR _d$32308[ebp], ecx

; 119  : 	d |= d >> 2;

  000e4	8b 55 f8	 mov	 edx, DWORD PTR _d$32308[ebp]
  000e7	c1 ea 02	 shr	 edx, 2
  000ea	0b 55 f8	 or	 edx, DWORD PTR _d$32308[ebp]
  000ed	89 55 f8	 mov	 DWORD PTR _d$32308[ebp], edx

; 120  : 	d |= d >> 3;

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _d$32308[ebp]
  000f3	c1 e8 03	 shr	 eax, 3
  000f6	0b 45 f8	 or	 eax, DWORD PTR _d$32308[ebp]
  000f9	89 45 f8	 mov	 DWORD PTR _d$32308[ebp], eax

; 121  : 	d |= d >> 4;

  000fc	8b 4d f8	 mov	 ecx, DWORD PTR _d$32308[ebp]
  000ff	c1 e9 04	 shr	 ecx, 4
  00102	0b 4d f8	 or	 ecx, DWORD PTR _d$32308[ebp]
  00105	89 4d f8	 mov	 DWORD PTR _d$32308[ebp], ecx

; 122  : 	d |= d >> 8;

  00108	8b 55 f8	 mov	 edx, DWORD PTR _d$32308[ebp]
  0010b	c1 ea 08	 shr	 edx, 8
  0010e	0b 55 f8	 or	 edx, DWORD PTR _d$32308[ebp]
  00111	89 55 f8	 mov	 DWORD PTR _d$32308[ebp], edx

; 123  : 	d |= d >> 16;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _d$32308[ebp]
  00117	c1 e8 10	 shr	 eax, 16			; 00000010H
  0011a	0b 45 f8	 or	 eax, DWORD PTR _d$32308[ebp]
  0011d	89 45 f8	 mov	 DWORD PTR _d$32308[ebp], eax

; 124  : 	if (d != UINT32_MAX)

  00120	83 7d f8 ff	 cmp	 DWORD PTR _d$32308[ebp], -1
  00124	74 09		 je	 SHORT $LN1@alone_enco@2

; 125  : 		++d;

  00126	8b 4d f8	 mov	 ecx, DWORD PTR _d$32308[ebp]
  00129	83 c1 01	 add	 ecx, 1
  0012c	89 4d f8	 mov	 DWORD PTR _d$32308[ebp], ecx
$LN1@alone_enco@2:

; 126  : 
; 127  : 	unaligned_write32le(coder->header + 1, d);

  0012f	8b 55 fc	 mov	 edx, DWORD PTR _coder$32300[ebp]
  00132	8b 45 f8	 mov	 eax, DWORD PTR _d$32308[ebp]
  00135	89 42 39	 mov	 DWORD PTR [edx+57], eax

; 128  :   }
; 129  : 
; 130  : 	// - Uncompressed size (always unknown and using EOPM)
; 131  : 	memset(coder->header + 1 + 4, 0xFF, 8);

  00138	6a 08		 push	 8
  0013a	68 ff 00 00 00	 push	 255			; 000000ffH
  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32300[ebp]
  00142	83 c1 3d	 add	 ecx, 61			; 0000003dH
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _memset
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 
; 133  : 	// Initialize the LZMA encoder.
; 134  : 	{
; 135  : 	/*
; 136  : 	const lzma_filter_info filters[2] = {
; 137  : 		{
; 138  : 			.init = &lzma_lzma_encoder_init,
; 139  : 			.options = (void *)(options),
; 140  : 		}, {
; 141  : 			.init = NULL,
; 142  : 		}
; 143  : 	};
; 144  : 	*/
; 145  : 	/*
; 146  : 	struct lzma_filter_info_s {
; 147  : 		lzma_vli id;
; 148  : 		lzma_init_function init;
; 149  : 		void *options;
; 150  : 	};
; 151  : 	*/
; 152  : 	lzma_filter_info filters[2];
; 153  : 	memset (filters, 0, sizeof(filters));

  0014e	6a 20		 push	 32			; 00000020H
  00150	6a 00		 push	 0
  00152	8d 55 d8	 lea	 edx, DWORD PTR _filters$32311[ebp]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _memset
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 154  : 
; 155  : 	filters[0].init    = &lzma_lzma_encoder_init;

  0015e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _filters$32311[ebp+8], OFFSET _lzma_lzma_encoder_init

; 156  : 	filters[0].options = (void *)(options);

  00165	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00168	89 45 e4	 mov	 DWORD PTR _filters$32311[ebp+12], eax

; 157  : 
; 158  : 	filters[1].init    = NULL;

  0016b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filters$32311[ebp+24], 0

; 159  : 
; 160  : 	return lzma_next_filter_init(&coder->next, allocator, filters);

  00172	8d 4d d8	 lea	 ecx, DWORD PTR _filters$32311[ebp]
  00175	51		 push	 ecx
  00176	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00179	52		 push	 edx
  0017a	8b 45 fc	 mov	 eax, DWORD PTR _coder$32300[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _lzma_next_filter_init
  00183	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@alone_enco@2:

; 161  :   }}
; 162  : }

  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
_alone_encoder_init ENDP
PUBLIC	_lzma_alone_encoder
; Function compile flags: /Odtp
;	COMDAT _lzma_alone_encoder
_TEXT	SEGMENT
_ret_$32327 = -8					; size = 4
_ret_$32325 = -4					; size = 4
_strm$ = 8						; size = 4
_options$ = 12						; size = 4
_lzma_alone_encoder PROC				; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_alone@3:

; 178  : 	lzma_next_strm_init(alone_encoder_init, strm, options);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32325[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32325[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_alone@3
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32325[ebp]
  0001e	eb 52		 jmp	 SHORT $LN9@lzma_alone@3
$LN4@lzma_alone@3:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_alone@3
  00024	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _alone_encoder_init
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	89 45 f8	 mov	 DWORD PTR _ret_$32327[ebp], eax
  00041	83 7d f8 00	 cmp	 DWORD PTR _ret_$32327[ebp], 0
  00045	74 11		 je	 SHORT $LN7@lzma_alone@3
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _lzma_end
  00050	83 c4 04	 add	 esp, 4
  00053	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32327[ebp]
  00056	eb 1a		 jmp	 SHORT $LN9@lzma_alone@3
$LN7@lzma_alone@3:
  00058	33 d2		 xor	 edx, edx
  0005a	75 aa		 jne	 SHORT $LN5@lzma_alone@3

; 179  : 
; 180  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00062	c6 41 38 01	 mov	 BYTE PTR [ecx+56], 1

; 181  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00066	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00069	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006c	c6 40 3b 01	 mov	 BYTE PTR [eax+59], 1

; 182  : 
; 183  : 	return LZMA_OK;

  00070	33 c0		 xor	 eax, eax
$LN9@lzma_alone@3:

; 184  : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_lzma_alone_encoder ENDP
END
