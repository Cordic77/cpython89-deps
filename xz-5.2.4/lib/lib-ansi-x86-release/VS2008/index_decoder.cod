; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\index_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_decoder.c
;	COMDAT _index_decoder_memconfig
_TEXT	SEGMENT
tv130 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_memusage$ = 12						; size = 4
_old_memlimit$ = 16					; size = 4
_new_memlimit$ = 20					; size = 8
_index_decoder_memconfig PROC				; COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 225  : 	lzma_index_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 226  : 
; 227  : 	*memusage = lzma_index_memusage(1, coder->count);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00012	52		 push	 edx
  00013	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 _lzma_index_memusage
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _memusage$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax
  00028	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 228  : 	*old_memlimit = coder->memlimit;

  0002b	8b 55 10	 mov	 edx, DWORD PTR _old_memlimit$[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00031	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00034	89 0a		 mov	 DWORD PTR [edx], ecx
  00036	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00039	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 229  : 
; 230  : 	if (new_memlimit != 0) {

  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _new_memlimit$[ebp]
  0003f	0b 4d 18	 or	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  00042	74 33		 je	 SHORT $LN2@index_deco

; 231  : 		if (new_memlimit < *memusage)

  00044	8b 55 0c	 mov	 edx, DWORD PTR _memusage$[ebp]
  00047	89 55 f8	 mov	 DWORD PTR tv130[ebp], edx
  0004a	8b 45 f8	 mov	 eax, DWORD PTR tv130[ebp]
  0004d	8b 4d 18	 mov	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  00050	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00053	77 13		 ja	 SHORT $LN1@index_deco
  00055	72 0a		 jb	 SHORT $LN5@index_deco
  00057	8b 55 f8	 mov	 edx, DWORD PTR tv130[ebp]
  0005a	8b 45 14	 mov	 eax, DWORD PTR _new_memlimit$[ebp]
  0005d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0005f	73 07		 jae	 SHORT $LN1@index_deco
$LN5@index_deco:

; 232  : 			return LZMA_MEMLIMIT_ERROR;

  00061	b8 06 00 00 00	 mov	 eax, 6
  00066	eb 11		 jmp	 SHORT $LN3@index_deco
$LN1@index_deco:

; 233  : 
; 234  : 		coder->memlimit = new_memlimit;

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006b	8b 55 14	 mov	 edx, DWORD PTR _new_memlimit$[ebp]
  0006e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00071	8b 45 18	 mov	 eax, DWORD PTR _new_memlimit$[ebp+4]
  00074	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN2@index_deco:

; 235  : 	}
; 236  : 
; 237  : 	return LZMA_OK;

  00077	33 c0		 xor	 eax, eax
$LN3@index_deco:

; 238  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_index_decoder_memconfig ENDP
; Function compile flags: /Odtp
;	COMDAT _index_decoder_reset
_TEXT	SEGMENT
tv72 = -8						; size = 8
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_i$ = 16						; size = 4
_memlimit$ = 20						; size = 8
_index_decoder_reset PROC				; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 245  : 	// Remember the pointer given by the application. We will set it
; 246  : 	// to point to the decoded Index only if decoding is successful.
; 247  : 	// Before that, keep it NULL so that applications can always safely
; 248  : 	// pass it to lzma_index_end() no matter did decoding succeed or not.
; 249  : 	coder->index_ptr = i;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _i$[ebp]
  0000c	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 250  : 	*i = NULL;

  0000f	8b 55 10	 mov	 edx, DWORD PTR _i$[ebp]
  00012	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 251  : 
; 252  : 	// We always allocate a new lzma_index.
; 253  : 	coder->index = lzma_index_init(allocator);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _lzma_index_init
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00027	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 254  : 	if (coder->index == NULL)

  0002a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002d	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00031	75 07		 jne	 SHORT $LN1@index_deco@2

; 255  : 		return LZMA_MEM_ERROR;

  00033	b8 05 00 00 00	 mov	 eax, 5
  00038	eb 69		 jmp	 SHORT $LN2@index_deco@2
$LN1@index_deco@2:

; 256  : 
; 257  : 	// Initialize the rest.
; 258  : 	coder->sequence = SEQ_INDICATOR;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 259  : 	coder->memlimit = my_max(1, memlimit);

  00043	83 7d 18 00	 cmp	 DWORD PTR _memlimit$[ebp+4], 0
  00047	77 18		 ja	 SHORT $LN4@index_deco@2
  00049	72 06		 jb	 SHORT $LN6@index_deco@2
  0004b	83 7d 14 01	 cmp	 DWORD PTR _memlimit$[ebp], 1
  0004f	73 10		 jae	 SHORT $LN4@index_deco@2
$LN6@index_deco@2:
  00051	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00058	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv72[ebp+4], 0
  0005f	eb 0c		 jmp	 SHORT $LN5@index_deco@2
$LN4@index_deco@2:
  00061	8b 4d 14	 mov	 ecx, DWORD PTR _memlimit$[ebp]
  00064	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00067	8b 55 18	 mov	 edx, DWORD PTR _memlimit$[ebp+4]
  0006a	89 55 fc	 mov	 DWORD PTR tv72[ebp+4], edx
$LN5@index_deco@2:
  0006d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  00073	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR tv72[ebp+4]
  00079	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 260  : 	coder->count = 0; // Needs to be initialized due to _memconfig().

  0007c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0007f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00086	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 261  : 	coder->pos = 0;

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00090	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 262  : 	coder->crc32 = 0;

  00097	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0009a	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 263  : 
; 264  : 	return LZMA_OK;

  000a1	33 c0		 xor	 eax, eax
$LN2@index_deco@2:

; 265  : }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_index_decoder_reset ENDP
; Function compile flags: /Odtp
;	COMDAT _index_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_index_decoder_end PROC					; COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 214  : 	lzma_index_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 215  : 	lzma_index_end(coder->index, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _lzma_index_end
  0001a	83 c4 08	 add	 esp, 8

; 216  : 	lzma_free(coder, allocator);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 _lzma_free
  0002a	83 c4 08	 add	 esp, 8

; 217  : 	return;
; 218  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_index_decoder_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _index_decode
_TEXT	SEGMENT
tv158 = -64						; size = 4
tv333 = -60						; size = 4
tv298 = -56						; size = 4
tv293 = -52						; size = 4
tv128 = -48						; size = 4
tv92 = -44						; size = 4
tv272 = -40						; size = 4
tv256 = -36						; size = 4
tv253 = -32						; size = 8
tv65 = -24						; size = 4
_ret_$32366 = -20					; size = 4
_size$32357 = -16					; size = 4
_coder$ = -12						; size = 4
_in_start$ = -8						; size = 4
_ret$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_index_decode PROC					; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi

; 65   : 	lzma_index_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 f4	 mov	 DWORD PTR _coder$[ebp], eax

; 66   : 
; 67   : 	// Similar optimization as in index_encoder.c
; 68   : 	const size_t in_start = *in_pos;

  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 55 f8	 mov	 DWORD PTR _in_start$[ebp], edx

; 69   : 	lzma_ret ret = LZMA_OK;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN31@index_deco@3:

; 70   : 
; 71   : 	while (*in_pos < in_size)

  0001c	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  00024	0f 83 88 03 00
	00		 jae	 $out$32353

; 72   : 	switch (coder->sequence) {

  0002a	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	89 45 e8	 mov	 DWORD PTR tv65[ebp], eax
  00032	83 7d e8 07	 cmp	 DWORD PTR tv65[ebp], 7
  00036	0f 87 6a 03 00
	00		 ja	 $LN1@index_deco@3
  0003c	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  0003f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN43@index_deco@3[ecx*4]
$LN27@index_deco@3:

; 73   : 	case SEQ_INDICATOR:
; 74   : 		// Return LZMA_DATA_ERROR instead of e.g. LZMA_PROG_ERROR or
; 75   : 		// LZMA_FORMAT_ERROR, because a typical usage case for Index
; 76   : 		// decoder is when parsing the Stream backwards. If seeking
; 77   : 		// backward from the Stream Footer gives us something that
; 78   : 		// doesn't begin with Index Indicator, the file is considered
; 79   : 		// corrupt, not "programming error" or "unrecognized file
; 80   : 		// format". One could argue that the application should
; 81   : 		// verify the Index Indicator before trying to decode the
; 82   : 		// Index, but well, I suppose it is simpler this way.
; 83   : 		if (in[(*in_pos)++] != 0x00)

  00046	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00049	8b 02		 mov	 eax, DWORD PTR [edx]
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0004e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00052	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	83 c1 01	 add	 ecx, 1
  0005a	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
  0005f	85 d2		 test	 edx, edx
  00061	74 0a		 je	 SHORT $LN26@index_deco@3

; 84   : 			return LZMA_DATA_ERROR;

  00063	b8 09 00 00 00	 mov	 eax, 9
  00068	e9 6d 03 00 00	 jmp	 $LN32@index_deco@3
$LN26@index_deco@3:

; 85   : 
; 86   : 		coder->sequence = SEQ_COUNT;

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00070	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 87   : 		break;

  00076	e9 32 03 00 00	 jmp	 $LN28@index_deco@3
$LN25@index_deco@3:

; 88   : 
; 89   : 	case SEQ_COUNT:
; 90   : 		ret = lzma_vli_decode(&coder->count, &coder->pos,
; 91   : 				in, in_pos, in_size);

  0007b	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00086	51		 push	 ecx
  00087	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0008a	83 c2 30	 add	 edx, 48			; 00000030H
  0008d	52		 push	 edx
  0008e	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00091	83 c0 18	 add	 eax, 24			; 00000018H
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _lzma_vli_decode
  0009a	83 c4 14	 add	 esp, 20			; 00000014H
  0009d	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 92   : 		if (ret != LZMA_STREAM_END)

  000a0	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000a4	74 05		 je	 SHORT $LN24@index_deco@3

; 93   : 			goto out;

  000a6	e9 07 03 00 00	 jmp	 $out$32353
$LN24@index_deco@3:

; 94   : 
; 95   : 		coder->pos = 0;

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ae	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 96   : 		coder->sequence = SEQ_MEMUSAGE;

  000b5	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  000b8	c7 02 02 00 00
	00		 mov	 DWORD PTR [edx], 2
$LN23@index_deco@3:

; 97   : 
; 98   : 	// Fall through
; 99   : 
; 100  : 	case SEQ_MEMUSAGE:
; 101  : 		if (lzma_index_memusage(1, coder->count) > coder->memlimit) {

  000be	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  000c1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000c4	51		 push	 ecx
  000c5	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000c8	52		 push	 edx
  000c9	6a 00		 push	 0
  000cb	6a 01		 push	 1
  000cd	e8 00 00 00 00	 call	 _lzma_index_memusage
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d8	89 45 e0	 mov	 DWORD PTR tv253[ebp], eax
  000db	89 55 e4	 mov	 DWORD PTR tv253[ebp+4], edx
  000de	89 4d dc	 mov	 DWORD PTR tv256[ebp], ecx
  000e1	8b 55 dc	 mov	 edx, DWORD PTR tv256[ebp]
  000e4	8b 45 e4	 mov	 eax, DWORD PTR tv253[ebp+4]
  000e7	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  000ea	72 19		 jb	 SHORT $LN22@index_deco@3
  000ec	77 0b		 ja	 SHORT $LN40@index_deco@3
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR tv256[ebp]
  000f1	8b 55 e0	 mov	 edx, DWORD PTR tv253[ebp]
  000f4	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000f7	76 0c		 jbe	 SHORT $LN22@index_deco@3
$LN40@index_deco@3:

; 102  : 			ret = LZMA_MEMLIMIT_ERROR;

  000f9	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 6

; 103  : 			goto out;

  00100	e9 ad 02 00 00	 jmp	 $out$32353
$LN22@index_deco@3:

; 104  : 		}
; 105  : 
; 106  : 		// Tell the Index handling code how many Records this
; 107  : 		// Index has to allow it to allocate memory more efficiently.
; 108  : 		lzma_index_prealloc(coder->index, coder->count);

  00105	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00108	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0010b	51		 push	 ecx
  0010c	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0010f	52		 push	 edx
  00110	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00113	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 _lzma_index_prealloc
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 109  : 
; 110  : 		ret = LZMA_OK;

  0011f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 111  : 		coder->sequence = coder->count == 0
; 112  : 				? SEQ_PADDING_INIT : SEQ_UNPADDED;

  00126	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00129	89 55 d8	 mov	 DWORD PTR tv272[ebp], edx
  0012c	8b 45 d8	 mov	 eax, DWORD PTR tv272[ebp]
  0012f	8b 4d d8	 mov	 ecx, DWORD PTR tv272[ebp]
  00132	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00135	0b 51 1c	 or	 edx, DWORD PTR [ecx+28]
  00138	75 09		 jne	 SHORT $LN34@index_deco@3
  0013a	c7 45 d4 05 00
	00 00		 mov	 DWORD PTR tv92[ebp], 5
  00141	eb 07		 jmp	 SHORT $LN35@index_deco@3
$LN34@index_deco@3:
  00143	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR tv92[ebp], 3
$LN35@index_deco@3:
  0014a	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0014d	8b 4d d4	 mov	 ecx, DWORD PTR tv92[ebp]
  00150	89 08		 mov	 DWORD PTR [eax], ecx

; 113  : 		break;

  00152	e9 56 02 00 00	 jmp	 $LN28@index_deco@3
$LN21@index_deco@3:

; 114  : 
; 115  : 	case SEQ_UNPADDED:
; 116  : 	case SEQ_UNCOMPRESSED: {
; 117  : 		lzma_vli *size = coder->sequence == SEQ_UNPADDED
; 118  : 				? &coder->unpadded_size
; 119  : 				: &coder->uncompressed_size;

  00157	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0015a	83 3a 03	 cmp	 DWORD PTR [edx], 3
  0015d	75 0b		 jne	 SHORT $LN36@index_deco@3
  0015f	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00162	83 c0 20	 add	 eax, 32			; 00000020H
  00165	89 45 d0	 mov	 DWORD PTR tv128[ebp], eax
  00168	eb 09		 jmp	 SHORT $LN37@index_deco@3
$LN36@index_deco@3:
  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  0016d	83 c1 28	 add	 ecx, 40			; 00000028H
  00170	89 4d d0	 mov	 DWORD PTR tv128[ebp], ecx
$LN37@index_deco@3:
  00173	8b 55 d0	 mov	 edx, DWORD PTR tv128[ebp]
  00176	89 55 f0	 mov	 DWORD PTR _size$32357[ebp], edx

; 120  : 
; 121  : 		ret = lzma_vli_decode(size, &coder->pos,
; 122  : 				in, in_pos, in_size);

  00179	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  0017c	50		 push	 eax
  0017d	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00180	51		 push	 ecx
  00181	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00184	52		 push	 edx
  00185	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00188	83 c0 30	 add	 eax, 48			; 00000030H
  0018b	50		 push	 eax
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _size$32357[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 _lzma_vli_decode
  00195	83 c4 14	 add	 esp, 20			; 00000014H
  00198	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 123  : 		if (ret != LZMA_STREAM_END)

  0019b	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  0019f	74 05		 je	 SHORT $LN20@index_deco@3

; 124  : 			goto out;

  001a1	e9 0c 02 00 00	 jmp	 $out$32353
$LN20@index_deco@3:

; 125  : 
; 126  : 		ret = LZMA_OK;

  001a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 127  : 		coder->pos = 0;

  001ad	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  001b0	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 128  : 
; 129  : 		if (coder->sequence == SEQ_UNPADDED) {

  001b7	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  001ba	83 38 03	 cmp	 DWORD PTR [eax], 3
  001bd	75 4d		 jne	 SHORT $LN15@index_deco@3

; 130  : 			// Validate that encoded Unpadded Size isn't too small
; 131  : 			// or too big.
; 132  : 			if (coder->unpadded_size < UNPADDED_SIZE_MIN
; 133  : 					|| coder->unpadded_size
; 134  : 						> UNPADDED_SIZE_MAX)

  001bf	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c2	89 4d cc	 mov	 DWORD PTR tv293[ebp], ecx
  001c5	8b 55 cc	 mov	 edx, DWORD PTR tv293[ebp]
  001c8	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  001cc	77 09		 ja	 SHORT $LN41@index_deco@3
  001ce	8b 45 cc	 mov	 eax, DWORD PTR tv293[ebp]
  001d1	83 78 20 05	 cmp	 DWORD PTR [eax+32], 5
  001d5	72 1d		 jb	 SHORT $LN17@index_deco@3
$LN41@index_deco@3:
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  001da	89 4d c8	 mov	 DWORD PTR tv298[ebp], ecx
  001dd	8b 55 c8	 mov	 edx, DWORD PTR tv298[ebp]
  001e0	81 7a 24 ff ff
	ff 7f		 cmp	 DWORD PTR [edx+36], 2147483647 ; 7fffffffH
  001e7	72 15		 jb	 SHORT $LN18@index_deco@3
  001e9	77 09		 ja	 SHORT $LN17@index_deco@3
  001eb	8b 45 c8	 mov	 eax, DWORD PTR tv298[ebp]
  001ee	83 78 20 fc	 cmp	 DWORD PTR [eax+32], -4	; fffffffcH
  001f2	76 0a		 jbe	 SHORT $LN18@index_deco@3
$LN17@index_deco@3:

; 135  : 				return LZMA_DATA_ERROR;

  001f4	b8 09 00 00 00	 mov	 eax, 9
  001f9	e9 dc 01 00 00	 jmp	 $LN32@index_deco@3
$LN18@index_deco@3:

; 136  : 
; 137  : 			coder->sequence = SEQ_UNCOMPRESSED;

  001fe	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00201	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 138  : 		} else {

  00207	e9 82 00 00 00	 jmp	 $LN16@index_deco@3
$LN15@index_deco@3:

; 139  : 			// Add the decoded Record to the Index.
; 140  : 			return_if_error(lzma_index_append(
; 141  : 					coder->index, allocator,
; 142  : 					coder->unpadded_size,
; 143  : 					coder->uncompressed_size));

  0020c	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0020f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00212	50		 push	 eax
  00213	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00216	51		 push	 ecx
  00217	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0021a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0021d	50		 push	 eax
  0021e	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00221	51		 push	 ecx
  00222	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00225	52		 push	 edx
  00226	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  00229	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0022c	51		 push	 ecx
  0022d	e8 00 00 00 00	 call	 _lzma_index_append
  00232	83 c4 18	 add	 esp, 24			; 00000018H
  00235	89 45 ec	 mov	 DWORD PTR _ret_$32366[ebp], eax
  00238	83 7d ec 00	 cmp	 DWORD PTR _ret_$32366[ebp], 0
  0023c	74 08		 je	 SHORT $LN14@index_deco@3
  0023e	8b 45 ec	 mov	 eax, DWORD PTR _ret_$32366[ebp]
  00241	e9 94 01 00 00	 jmp	 $LN32@index_deco@3
$LN14@index_deco@3:
  00246	33 d2		 xor	 edx, edx
  00248	75 c2		 jne	 SHORT $LN15@index_deco@3

; 144  : 
; 145  : 			// Check if this was the last Record.
; 146  : 			coder->sequence = --coder->count == 0
; 147  : 					? SEQ_PADDING_INIT
; 148  : 					: SEQ_UNPADDED;

  0024a	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0024d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00250	83 e9 01	 sub	 ecx, 1
  00253	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00256	83 da 00	 sbb	 edx, 0
  00259	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0025c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0025f	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  00262	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00265	89 4d c4	 mov	 DWORD PTR tv333[ebp], ecx
  00268	8b 55 c4	 mov	 edx, DWORD PTR tv333[ebp]
  0026b	8b 45 c4	 mov	 eax, DWORD PTR tv333[ebp]
  0026e	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00271	0b 48 1c	 or	 ecx, DWORD PTR [eax+28]
  00274	75 09		 jne	 SHORT $LN38@index_deco@3
  00276	c7 45 c0 05 00
	00 00		 mov	 DWORD PTR tv158[ebp], 5
  0027d	eb 07		 jmp	 SHORT $LN39@index_deco@3
$LN38@index_deco@3:
  0027f	c7 45 c0 03 00
	00 00		 mov	 DWORD PTR tv158[ebp], 3
$LN39@index_deco@3:
  00286	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00289	8b 45 c0	 mov	 eax, DWORD PTR tv158[ebp]
  0028c	89 02		 mov	 DWORD PTR [edx], eax
$LN16@index_deco@3:

; 149  : 		}
; 150  : 
; 151  : 		break;

  0028e	e9 1a 01 00 00	 jmp	 $LN28@index_deco@3
$LN11@index_deco@3:

; 152  : 	}
; 153  : 
; 154  : 	case SEQ_PADDING_INIT:
; 155  : 		coder->pos = lzma_index_padding_size(coder->index);

  00293	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00296	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00299	52		 push	 edx
  0029a	e8 00 00 00 00	 call	 _lzma_index_padding_size
  0029f	83 c4 04	 add	 esp, 4
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  002a5	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 156  : 		coder->sequence = SEQ_PADDING;

  002a8	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  002ab	c7 02 06 00 00
	00		 mov	 DWORD PTR [edx], 6
$LN10@index_deco@3:

; 157  : 
; 158  : 	// Fall through
; 159  : 
; 160  : 	case SEQ_PADDING:
; 161  : 		if (coder->pos > 0) {

  002b1	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  002b4	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  002b8	76 3b		 jbe	 SHORT $LN9@index_deco@3

; 162  : 			--coder->pos;

  002ba	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  002bd	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002c0	83 ea 01	 sub	 edx, 1
  002c3	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  002c6	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 163  : 			if (in[(*in_pos)++] != 0x00)

  002c9	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  002cc	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ce	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  002d1	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  002d5	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  002d8	8b 02		 mov	 eax, DWORD PTR [edx]
  002da	83 c0 01	 add	 eax, 1
  002dd	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  002e0	89 02		 mov	 DWORD PTR [edx], eax
  002e2	85 c9		 test	 ecx, ecx
  002e4	74 0a		 je	 SHORT $LN8@index_deco@3

; 164  : 				return LZMA_DATA_ERROR;

  002e6	b8 09 00 00 00	 mov	 eax, 9
  002eb	e9 ea 00 00 00	 jmp	 $LN32@index_deco@3
$LN8@index_deco@3:

; 165  : 
; 166  : 			break;

  002f0	e9 b8 00 00 00	 jmp	 $LN28@index_deco@3
$LN9@index_deco@3:

; 167  : 		}
; 168  : 
; 169  : 		// Finish the CRC32 calculation.
; 170  : 		coder->crc32 = lzma_crc32(in + in_start,
; 171  : 				*in_pos - in_start, coder->crc32);

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  002f8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002fb	51		 push	 ecx
  002fc	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  002ff	8b 02		 mov	 eax, DWORD PTR [edx]
  00301	2b 45 f8	 sub	 eax, DWORD PTR _in_start$[ebp]
  00304	50		 push	 eax
  00305	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00308	03 4d f8	 add	 ecx, DWORD PTR _in_start$[ebp]
  0030b	51		 push	 ecx
  0030c	e8 00 00 00 00	 call	 _lzma_crc32
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH
  00314	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00317	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 172  : 
; 173  : 		coder->sequence = SEQ_CRC32;

  0031a	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0031d	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
$LN6@index_deco@3:

; 174  : 
; 175  : 	// Fall through
; 176  : 
; 177  : 	case SEQ_CRC32:
; 178  : 		do {
; 179  : 			if (*in_pos == in_size)

  00323	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00326	8b 11		 mov	 edx, DWORD PTR [ecx]
  00328	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  0032b	75 07		 jne	 SHORT $LN3@index_deco@3

; 180  : 				return LZMA_OK;

  0032d	33 c0		 xor	 eax, eax
  0032f	e9 a6 00 00 00	 jmp	 $LN32@index_deco@3
$LN3@index_deco@3:

; 181  : 
; 182  : 			if (((coder->crc32 >> (coder->pos * 8)) & 0xFF)
; 183  : 					!= in[(*in_pos)++])

  00334	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00337	8b 08		 mov	 ecx, DWORD PTR [eax]
  00339	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  0033c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00340	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00343	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00346	c1 e1 03	 shl	 ecx, 3
  00349	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  0034c	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  0034f	d3 ea		 shr	 edx, cl
  00351	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00357	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0035a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0035c	83 c1 01	 add	 ecx, 1
  0035f	8b 75 14	 mov	 esi, DWORD PTR _in_pos$[ebp]
  00362	89 0e		 mov	 DWORD PTR [esi], ecx
  00364	3b d0		 cmp	 edx, eax
  00366	74 07		 je	 SHORT $LN5@index_deco@3

; 184  : 				return LZMA_DATA_ERROR;

  00368	b8 09 00 00 00	 mov	 eax, 9
  0036d	eb 6b		 jmp	 SHORT $LN32@index_deco@3
$LN5@index_deco@3:

; 185  : 
; 186  : 		} while (++coder->pos < 4);

  0036f	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00372	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00375	83 c0 01	 add	 eax, 1
  00378	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  0037b	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  0037e	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00381	83 7a 30 04	 cmp	 DWORD PTR [edx+48], 4
  00385	72 9c		 jb	 SHORT $LN6@index_deco@3

; 187  : 
; 188  : 		// Decoding was successful, now we can let the application
; 189  : 		// see the decoded Index.
; 190  : 		*coder->index_ptr = coder->index;

  00387	8b 45 f4	 mov	 eax, DWORD PTR _coder$[ebp]
  0038a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0038d	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  00390	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00393	89 01		 mov	 DWORD PTR [ecx], eax

; 191  : 
; 192  : 		// Make index NULL so we don't free it unintentionally.
; 193  : 		coder->index = NULL;

  00395	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  00398	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 194  : 
; 195  : 		return LZMA_STREAM_END;

  0039f	b8 01 00 00 00	 mov	 eax, 1
  003a4	eb 34		 jmp	 SHORT $LN32@index_deco@3
$LN1@index_deco@3:

; 196  : 
; 197  : 	default:
; 198  : 		assert(0);
; 199  : 		return LZMA_PROG_ERROR;

  003a6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  003ab	eb 2d		 jmp	 SHORT $LN32@index_deco@3
$LN28@index_deco@3:

; 200  : 	}

  003ad	e9 6a fc ff ff	 jmp	 $LN31@index_deco@3
$out$32353:

; 201  : 
; 202  : out:
; 203  : 	// Update the CRC32,
; 204  : 	coder->crc32 = lzma_crc32(in + in_start,
; 205  : 			*in_pos - in_start, coder->crc32);

  003b2	8b 55 f4	 mov	 edx, DWORD PTR _coder$[ebp]
  003b5	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  003b8	50		 push	 eax
  003b9	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  003bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  003be	2b 55 f8	 sub	 edx, DWORD PTR _in_start$[ebp]
  003c1	52		 push	 edx
  003c2	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  003c5	03 45 f8	 add	 eax, DWORD PTR _in_start$[ebp]
  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 _lzma_crc32
  003ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d1	8b 4d f4	 mov	 ecx, DWORD PTR _coder$[ebp]
  003d4	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 206  : 
; 207  : 	return ret;

  003d7	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN32@index_deco@3:

; 208  : }

  003da	5e		 pop	 esi
  003db	8b e5		 mov	 esp, ebp
  003dd	5d		 pop	 ebp
  003de	c3		 ret	 0
  003df	90		 npad	 1
$LN43@index_deco@3:
  003e0	00 00 00 00	 DD	 $LN27@index_deco@3
  003e4	00 00 00 00	 DD	 $LN25@index_deco@3
  003e8	00 00 00 00	 DD	 $LN23@index_deco@3
  003ec	00 00 00 00	 DD	 $LN21@index_deco@3
  003f0	00 00 00 00	 DD	 $LN21@index_deco@3
  003f4	00 00 00 00	 DD	 $LN11@index_deco@3
  003f8	00 00 00 00	 DD	 $LN10@index_deco@3
  003fc	00 00 00 00	 DD	 $LN6@index_deco@3
_index_decode ENDP
; Function compile flags: /Odtp
;	COMDAT _index_decoder_init
_TEXT	SEGMENT
_coder$32432 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_i$ = 16						; size = 4
_memlimit$ = 20						; size = 8
_index_decoder_init PROC				; COMDAT

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN8@index_deco@4:

; 272  : 	lzma_next_coder_init(&index_decoder_init, next, allocator);

  00004	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00007	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _index_decoder_init
  0000e	74 10		 je	 SHORT $LN5@index_deco@4
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _lzma_next_end
  0001d	83 c4 08	 add	 esp, 8
$LN5@index_deco@4:
  00020	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00023	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _index_decoder_init
  0002a	33 c9		 xor	 ecx, ecx
  0002c	75 d6		 jne	 SHORT $LN8@index_deco@4

; 273  : 
; 274  : 	if (i == NULL)

  0002e	83 7d 10 00	 cmp	 DWORD PTR _i$[ebp], 0
  00032	75 0a		 jne	 SHORT $LN4@index_deco@4

; 275  : 		return LZMA_PROG_ERROR;

  00034	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00039	e9 8d 00 00 00	 jmp	 $LN9@index_deco@4
$LN4@index_deco@4:

; 276  : 
; 277  :   {
; 278  : 	lzma_index_coder *coder = next->coder;

  0003e	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	89 45 fc	 mov	 DWORD PTR _coder$32432[ebp], eax

; 279  : 	if (coder == NULL) {

  00046	83 7d fc 00	 cmp	 DWORD PTR _coder$32432[ebp], 0
  0004a	75 50		 jne	 SHORT $LN3@index_deco@4

; 280  : 		coder = lzma_alloc(sizeof(lzma_index_coder), allocator);

  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0004f	51		 push	 ecx
  00050	6a 38		 push	 56			; 00000038H
  00052	e8 00 00 00 00	 call	 _lzma_alloc
  00057	83 c4 08	 add	 esp, 8
  0005a	89 45 fc	 mov	 DWORD PTR _coder$32432[ebp], eax

; 281  : 		if (coder == NULL)

  0005d	83 7d fc 00	 cmp	 DWORD PTR _coder$32432[ebp], 0
  00061	75 07		 jne	 SHORT $LN2@index_deco@4

; 282  : 			return LZMA_MEM_ERROR;

  00063	b8 05 00 00 00	 mov	 eax, 5
  00068	eb 61		 jmp	 SHORT $LN9@index_deco@4
$LN2@index_deco@4:

; 283  : 
; 284  : 		next->coder = coder;

  0006a	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _coder$32432[ebp]
  00070	89 02		 mov	 DWORD PTR [edx], eax

; 285  : 		next->code = &index_decode;

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00075	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _index_decode

; 286  : 		next->end = &index_decoder_end;

  0007c	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0007f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _index_decoder_end

; 287  : 		next->memconfig = &index_decoder_memconfig;

  00086	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00089	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _index_decoder_memconfig

; 288  : 		coder->index = NULL;

  00090	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32432[ebp]
  00093	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 289  : 	} else {

  0009a	eb 13		 jmp	 SHORT $LN1@index_deco@4
$LN3@index_deco@4:

; 290  : 		lzma_index_end(coder->index, allocator);

  0009c	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0009f	52		 push	 edx
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _coder$32432[ebp]
  000a3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _lzma_index_end
  000ac	83 c4 08	 add	 esp, 8
$LN1@index_deco@4:

; 291  : 	}
; 292  : 
; 293  : 	return index_decoder_reset(coder, allocator, i, memlimit);

  000af	8b 55 18	 mov	 edx, DWORD PTR _memlimit$[ebp+4]
  000b2	52		 push	 edx
  000b3	8b 45 14	 mov	 eax, DWORD PTR _memlimit$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d 10	 mov	 ecx, DWORD PTR _i$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _coder$32432[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _index_decoder_reset
  000c8	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@index_deco@4:

; 294  :   }
; 295  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_index_decoder_init ENDP
PUBLIC	_lzma_index_decoder
; Function compile flags: /Odtp
;	COMDAT _lzma_index_decoder
_TEXT	SEGMENT
_ret_$32455 = -8					; size = 4
_ret_$32453 = -4					; size = 4
_strm$ = 8						; size = 4
_i$ = 12						; size = 4
_memlimit$ = 16						; size = 8
_lzma_index_decoder PROC				; COMDAT

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_index@16:

; 301  : 	lzma_next_strm_init(index_decoder_init, strm, i, memlimit);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32453[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32453[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_index@16
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32453[ebp]
  0001e	eb 5a		 jmp	 SHORT $LN9@lzma_index@16
$LN4@lzma_index@16:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_index@16
  00024	8b 55 14	 mov	 edx, DWORD PTR _memlimit$[ebp+4]
  00027	52		 push	 edx
  00028	8b 45 10	 mov	 eax, DWORD PTR _memlimit$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00033	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _index_decoder_init
  00043	83 c4 14	 add	 esp, 20			; 00000014H
  00046	89 45 f8	 mov	 DWORD PTR _ret_$32455[ebp], eax
  00049	83 7d f8 00	 cmp	 DWORD PTR _ret_$32455[ebp], 0
  0004d	74 11		 je	 SHORT $LN7@lzma_index@16
  0004f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _lzma_end
  00058	83 c4 04	 add	 esp, 4
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32455[ebp]
  0005e	eb 1a		 jmp	 SHORT $LN9@lzma_index@16
$LN7@lzma_index@16:
  00060	33 c9		 xor	 ecx, ecx
  00062	75 a2		 jne	 SHORT $LN5@lzma_index@16

; 302  : 
; 303  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00064	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00067	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006a	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1

; 304  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00071	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00074	c6 42 3b 01	 mov	 BYTE PTR [edx+59], 1

; 305  : 
; 306  : 	return LZMA_OK;

  00078	33 c0		 xor	 eax, eax
$LN9@lzma_index@16:

; 307  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_lzma_index_decoder ENDP
END
