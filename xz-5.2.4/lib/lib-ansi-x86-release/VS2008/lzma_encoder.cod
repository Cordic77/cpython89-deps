; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_lzma_props_encode
PUBLIC	_lzma_lzma_encoder_memusage
PUBLIC	_lzma_lzma_encoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
;	COMDAT _set_lz_options
_TEXT	SEGMENT
_lz_options$ = 8					; size = 4
_options$ = 12						; size = 4
_set_lz_options PROC					; COMDAT

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 445  : 	// LZ encoder initialization does the validation for these so we
; 446  : 	// don't need to validate here.
; 447  : 	lz_options->before_size = OPTS;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00006	c7 00 00 10 00
	00		 mov	 DWORD PTR [eax], 4096	; 00001000H

; 448  : 	lz_options->dict_size = options->dict_size;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 449  : 	lz_options->after_size = LOOP_INPUT_MAX;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  0001a	c7 41 08 01 10
	00 00		 mov	 DWORD PTR [ecx+8], 4097	; 00001001H

; 450  : 	lz_options->match_len_max = MATCH_LEN_MAX;

  00021	8b 55 08	 mov	 edx, DWORD PTR _lz_options$[ebp]
  00024	c7 42 0c 11 01
	00 00		 mov	 DWORD PTR [edx+12], 273	; 00000111H

; 451  : 	lz_options->nice_len = options->nice_len;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00031	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00034	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 452  : 	lz_options->match_finder = options->mf;

  00037	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  0003d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00040	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 453  : 	lz_options->depth = options->depth;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00049	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0004c	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 454  : 	lz_options->preset_dict = options->preset_dict;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00055	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00058	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 455  : 	lz_options->preset_dict_size = options->preset_dict_size;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _lz_options$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00061	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00064	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 456  : 	return;
; 457  : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_set_lz_options ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT _get_dist_slot
_TEXT	SEGMENT
_dist$ = 8						; size = 4
_get_dist_slot PROC					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00003	81 7d 08 00 20
	00 00		 cmp	 DWORD PTR _dist$[ebp], 8192 ; 00002000H
  0000a	73 0c		 jae	 SHORT $LN2@get_dist_s@4

; 114  : 		return lzma_fastpos[dist];

  0000c	8b 45 08	 mov	 eax, DWORD PTR _dist$[ebp]
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[eax]
  00016	eb 2b		 jmp	 SHORT $LN3@get_dist_s@4
$LN2@get_dist_s@4:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  00018	81 7d 08 00 00
	00 02		 cmp	 DWORD PTR _dist$[ebp], 33554432 ; 02000000H
  0001f	73 12		 jae	 SHORT $LN1@get_dist_s@4

; 117  : 		return fastpos_result(dist, 0, 1);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _dist$[ebp]
  00024	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00027	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[ecx]
  0002e	83 c0 18	 add	 eax, 24			; 00000018H
  00031	eb 10		 jmp	 SHORT $LN3@get_dist_s@4
$LN1@get_dist_s@4:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00033	8b 55 08	 mov	 edx, DWORD PTR _dist$[ebp]
  00036	c1 ea 18	 shr	 edx, 24			; 00000018H
  00039	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  00040	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@4:

; 120  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_get_dist_slot ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_common.h
_TEXT	ENDS
;	COMDAT _literal_init
_TEXT	SEGMENT
_j$32638 = -12						; size = 4
_coders$32636 = -8					; size = 4
_i$32637 = -4						; size = 4
_probs$ = 8						; size = 4
_lc$ = 12						; size = 4
_lp$ = 16						; size = 4
_literal_init PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 132  : 	assert(lc + lp <= LZMA_LCLP_MAX);
; 133  : 
; 134  :   {
; 135  : 	const uint32_t coders = 1U << (lc + lp);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  00009	03 4d 10	 add	 ecx, DWORD PTR _lp$[ebp]
  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	d3 e0		 shl	 eax, cl
  00013	89 45 f8	 mov	 DWORD PTR _coders$32636[ebp], eax

; 136  : 	uint32_t i, j;
; 137  : 
; 138  : 	for (i = 0; i < coders; ++i)

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$32637[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN6@literal_in
$LN5@literal_in:
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _i$32637[ebp]
  00022	83 c1 01	 add	 ecx, 1
  00025	89 4d fc	 mov	 DWORD PTR _i$32637[ebp], ecx
$LN6@literal_in:
  00028	8b 55 fc	 mov	 edx, DWORD PTR _i$32637[ebp]
  0002b	3b 55 f8	 cmp	 edx, DWORD PTR _coders$32636[ebp]
  0002e	73 37		 jae	 SHORT $LN7@literal_in

; 139  : 		for (j = 0; j < LITERAL_CODER_SIZE; ++j)

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$32638[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN3@literal_in
$LN2@literal_in:
  00039	8b 45 f4	 mov	 eax, DWORD PTR _j$32638[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f4	 mov	 DWORD PTR _j$32638[ebp], eax
$LN3@literal_in:
  00042	81 7d f4 00 03
	00 00		 cmp	 DWORD PTR _j$32638[ebp], 768 ; 00000300H
  00049	73 1a		 jae	 SHORT $LN1@literal_in

; 140  : 			bit_reset(probs[i][j]);

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _i$32637[ebp]
  0004e	69 c9 00 06 00
	00		 imul	 ecx, 1536		; 00000600H
  00054	03 4d 08	 add	 ecx, DWORD PTR _probs$[ebp]
  00057	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0005c	8b 45 f4	 mov	 eax, DWORD PTR _j$32638[ebp]
  0005f	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00063	eb d4		 jmp	 SHORT $LN2@literal_in
$LN1@literal_in:
  00065	eb b8		 jmp	 SHORT $LN5@literal_in
$LN7@literal_in:

; 141  :   }
; 142  : 
; 143  : 	return;
; 144  : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_literal_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _is_lclppb_valid
_TEXT	SEGMENT
tv74 = -4						; size = 4
_options$ = 8						; size = 4
_is_lclppb_valid PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 35   : 	return options->lc <= LZMA_LCLP_MAX && options->lp <= LZMA_LCLP_MAX
; 36   : 			&& options->lc + options->lp <= LZMA_LCLP_MAX
; 37   : 			&& options->pb <= LZMA_PB_MAX;

  00004	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00007	83 78 0c 04	 cmp	 DWORD PTR [eax+12], 4
  0000b	77 2c		 ja	 SHORT $LN3@is_lclppb_
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00010	83 79 10 04	 cmp	 DWORD PTR [ecx+16], 4
  00014	77 23		 ja	 SHORT $LN3@is_lclppb_
  00016	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0001f	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00022	83 f8 04	 cmp	 eax, 4
  00025	77 12		 ja	 SHORT $LN3@is_lclppb_
  00027	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0002a	83 7a 14 04	 cmp	 DWORD PTR [edx+20], 4
  0002e	77 09		 ja	 SHORT $LN3@is_lclppb_
  00030	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00037	eb 07		 jmp	 SHORT $LN4@is_lclppb_
$LN3@is_lclppb_:
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@is_lclppb_:
  00040	8a 45 fc	 mov	 al, BYTE PTR tv74[ebp]

; 38   : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_is_lclppb_valid ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
_TEXT	ENDS
;	COMDAT _rc_pending
_TEXT	SEGMENT
_rc$ = 8						; size = 4
_rc_pending PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  : 	return rc->cache_size + 5 - 1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	83 c1 05	 add	 ecx, 5
  0000c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000f	83 d2 00	 adc	 edx, 0
  00012	83 e9 01	 sub	 ecx, 1
  00015	83 da 00	 sbb	 edx, 0
  00018	8b c1		 mov	 eax, ecx

; 229  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_rc_pending ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_shift_low
_TEXT	SEGMENT
tv171 = -4						; size = 4
_rc$ = 8						; size = 4
_out$ = 12						; size = 4
_out_pos$ = 16						; size = 4
_out_size$ = 20						; size = 4
_rc_shift_low PROC					; COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 127  : 	if ((uint32_t)(rc->low) < (uint32_t)(0xFF000000)
; 128  : 			|| (uint32_t)(rc->low >> 32) != 0) {

  00005	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00008	81 38 00 00 00
	ff		 cmp	 DWORD PTR [eax], -16777216 ; ff000000H
  0000e	72 17		 jb	 SHORT $LN4@rc_shift_l
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	b1 20		 mov	 cl, 32			; 00000020H
  0001a	e8 00 00 00 00	 call	 __aullshr
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 94 00 00
	00		 je	 $LN6@rc_shift_l
$LN4@rc_shift_l:

; 129  : 		do {
; 130  : 			if (*out_pos == out_size)

  00027	8b 55 10	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0002a	8b 02		 mov	 eax, DWORD PTR [edx]
  0002c	3b 45 14	 cmp	 eax, DWORD PTR _out_size$[ebp]
  0002f	75 07		 jne	 SHORT $LN1@rc_shift_l

; 131  : 				return true;

  00031	b0 01		 mov	 al, 1
  00033	e9 bc 00 00 00	 jmp	 $LN7@rc_shift_l
$LN1@rc_shift_l:

; 132  : 
; 133  : 			out[*out_pos] = rc->cache + (uint8_t)(rc->low >> 32);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0003b	0f b6 59 14	 movzx	 ebx, BYTE PTR [ecx+20]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00047	b1 20		 mov	 cl, 32			; 00000020H
  00049	e8 00 00 00 00	 call	 __aullshr
  0004e	0f b6 c0	 movzx	 eax, al
  00051	03 d8		 add	 ebx, eax
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00056	8b 11		 mov	 edx, DWORD PTR [ecx]
  00058	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0005b	88 1c 10	 mov	 BYTE PTR [eax+edx], bl

; 134  : 			++*out_pos;

  0005e	8b 4d 10	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	83 c2 01	 add	 edx, 1
  00066	8b 45 10	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00069	89 10		 mov	 DWORD PTR [eax], edx

; 135  : 			rc->cache = 0xFF;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0006e	c6 41 14 ff	 mov	 BYTE PTR [ecx+20], 255	; 000000ffH

; 136  : 
; 137  : 		} while (--rc->cache_size != 0);

  00072	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00075	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00078	83 e8 01	 sub	 eax, 1
  0007b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0007e	83 d9 00	 sbb	 ecx, 0
  00081	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00084	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00087	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0008d	89 45 fc	 mov	 DWORD PTR tv171[ebp], eax
  00090	8b 4d fc	 mov	 ecx, DWORD PTR tv171[ebp]
  00093	8b 55 fc	 mov	 edx, DWORD PTR tv171[ebp]
  00096	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00099	0b 42 0c	 or	 eax, DWORD PTR [edx+12]
  0009c	75 89		 jne	 SHORT $LN4@rc_shift_l

; 138  : 
; 139  : 		rc->cache = (rc->low >> 24) & 0xFF;

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a6	b1 18		 mov	 cl, 24			; 00000018H
  000a8	e8 00 00 00 00	 call	 __aullshr
  000ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b2	83 e2 00	 and	 edx, 0
  000b5	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  000b8	88 42 14	 mov	 BYTE PTR [edx+20], al
$LN6@rc_shift_l:

; 140  : 	}
; 141  : 
; 142  : 	++rc->cache_size;

  000bb	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000be	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c1	83 c1 01	 add	 ecx, 1
  000c4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000c7	83 d2 00	 adc	 edx, 0
  000ca	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000cd	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000d0	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 143  : 	rc->low = (rc->low & 0x00FFFFFF) << RC_SHIFT_BITS;

  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000d6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000dd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e0	83 e2 00	 and	 edx, 0
  000e3	b1 08		 mov	 cl, 8
  000e5	e8 00 00 00 00	 call	 __allshl
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000ed	89 01		 mov	 DWORD PTR [ecx], eax
  000ef	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 144  : 
; 145  : 	return false;

  000f2	32 c0		 xor	 al, al
$LN7@rc_shift_l:

; 146  : }

  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
_rc_shift_low ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_flush
_TEXT	SEGMENT
_i$ = -4						; size = 4
_rc$ = 8						; size = 4
_rc_flush PROC						; COMDAT

; 117  : {   size_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 118  : 	for (i = 0; i < 5; ++i)

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN3@rc_flush
$LN2@rc_flush:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@rc_flush:
  00016	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  0001a	73 22		 jae	 SHORT $LN4@rc_flush

; 119  : 		rc->symbols[rc->count++] = RC_FLUSH;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0001f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00022	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00025	c7 44 90 20 04
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 4
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00030	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00033	83 c2 01	 add	 edx, 1
  00036	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00039	89 50 18	 mov	 DWORD PTR [eax+24], edx
  0003c	eb cf		 jmp	 SHORT $LN2@rc_flush
$LN4@rc_flush:

; 120  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_rc_flush ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_direct
_TEXT	SEGMENT
_rc$ = 8						; size = 4
_value$ = 12						; size = 4
_bit_count$ = 16					; size = 4
_rc_direct PROC						; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN3@rc_direct:

; 108  : 	do {
; 109  : 		rc->symbols[rc->count++]
; 110  : 				= RC_DIRECT_0 + ((value >> --bit_count) & 1);

  00003	8b 45 10	 mov	 eax, DWORD PTR _bit_count$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	89 45 10	 mov	 DWORD PTR _bit_count$[ebp], eax
  0000c	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _bit_count$[ebp]
  00012	d3 ea		 shr	 edx, cl
  00014	83 e2 01	 and	 edx, 1
  00017	83 c2 02	 add	 edx, 2
  0001a	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00020	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00023	89 54 88 20	 mov	 DWORD PTR [eax+ecx*4+32], edx
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0002a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002d	83 c2 01	 add	 edx, 1
  00030	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00033	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 111  : 	} while (bit_count != 0);

  00036	83 7d 10 00	 cmp	 DWORD PTR _bit_count$[ebp], 0
  0003a	75 c7		 jne	 SHORT $LN3@rc_direct

; 112  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_rc_direct ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit
_TEXT	SEGMENT
_rc$ = 8						; size = 4
_prob$ = 12						; size = 4
_bit$ = 16						; size = 4
_rc_bit	PROC						; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	rc->symbols[rc->count] = bit;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00009	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0000c	8b 45 10	 mov	 eax, DWORD PTR _bit$[ebp]
  0000f	89 44 8a 20	 mov	 DWORD PTR [edx+ecx*4+32], eax

; 70   : 	rc->probs[rc->count] = prob;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00016	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00019	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _prob$[ebp]
  0001f	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx

; 71   : 	++rc->count;

  00026	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00029	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0002c	83 c0 01	 add	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00032	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 72   : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_rc_bit	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_reset
_TEXT	SEGMENT
_rc$ = 8						; size = 4
_rc_reset PROC						; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	rc->low = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 58   : 	rc->cache_size = 1;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00016	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
  0001d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 59   : 	rc->range = UINT32_MAX;

  00024	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00027	c7 42 10 ff ff
	ff ff		 mov	 DWORD PTR [edx+16], -1

; 60   : 	rc->cache = 0;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00031	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 61   : 	rc->count = 0;

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00038	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 62   : 	rc->pos = 0;

  0003f	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00042	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 63   : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_rc_reset ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT _rc_bit_1_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_rc_bit_1_price PROC					; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 	return lzma_rc_prices[(prob ^ (RC_BIT_MODEL_TOTAL - 1))
; 47   : 			>> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0000c	c1 e8 04	 shr	 eax, 4
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 48   : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_rc_bit_1_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit_0_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_rc_bit_0_price PROC					; COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	return lzma_rc_prices[prob >> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	c1 f8 04	 sar	 eax, 4
  0000a	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 40   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_rc_bit_0_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_bit$ = 12						; size = 4
_rc_bit_price PROC					; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	return lzma_rc_prices[(prob ^ ((UINT32_C(0) - bit)
; 32   : 			& (RC_BIT_MODEL_TOTAL - 1))) >> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	2b 4d 0c	 sub	 ecx, DWORD PTR _bit$[ebp]
  0000c	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00012	33 c1		 xor	 eax, ecx
  00014	c1 e8 04	 shr	 eax, 4
  00017	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 33   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_rc_bit_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT _mf_skip
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_mf_skip PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	if (amount != 0) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR _amount$[ebp], 0
  00007	74 22		 je	 SHORT $LN2@mf_skip@3

; 270  : 		mf->skip(mf, amount);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _amount$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00014	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8

; 271  : 		mf->read_ahead += amount;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0001f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00022	03 55 0c	 add	 edx, DWORD PTR _amount$[ebp]
  00025	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00028	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN2@mf_skip@3:

; 272  : 	}
; 273  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_mf_skip ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_position
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_position PROC					; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 254  : 	return mf->read_pos - mf->read_ahead;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00009	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000c	2b 41 18	 sub	 eax, DWORD PTR [ecx+24]

; 255  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mf_position ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT _write32ne
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_num$ = 12						; size = 4
_write32ne PROC						; COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	*(uint32_t *)buf = num;

  00003	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 	return;
; 269  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_write32ne ENDP
PUBLIC	_lzma_lzma_lclppb_encode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
;	COMDAT _lzma_lzma_lclppb_encode
_TEXT	SEGMENT
tv86 = -4						; size = 4
_options$ = 8						; size = 4
_byte$ = 12						; size = 4
_lzma_lzma_lclppb_encode PROC				; COMDAT

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 667  : 	if (!is_lclppb_valid(options))

  00004	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00007	83 78 0c 04	 cmp	 DWORD PTR [eax+12], 4
  0000b	77 2c		 ja	 SHORT $LN6@lzma_lzma_@4
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00010	83 79 10 04	 cmp	 DWORD PTR [ecx+16], 4
  00014	77 23		 ja	 SHORT $LN6@lzma_lzma_@4
  00016	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0001f	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00022	83 f8 04	 cmp	 eax, 4
  00025	77 12		 ja	 SHORT $LN6@lzma_lzma_@4
  00027	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0002a	83 7a 14 04	 cmp	 DWORD PTR [edx+20], 4
  0002e	77 09		 ja	 SHORT $LN6@lzma_lzma_@4
  00030	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  00037	eb 07		 jmp	 SHORT $LN4@lzma_lzma_@4
$LN6@lzma_lzma_@4:
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN4@lzma_lzma_@4:
  00040	0f b6 45 fc	 movzx	 eax, BYTE PTR tv86[ebp]
  00044	85 c0		 test	 eax, eax
  00046	75 04		 jne	 SHORT $LN1@lzma_lzma_@4

; 668  : 		return true;

  00048	b0 01		 mov	 al, 1
  0004a	eb 1f		 jmp	 SHORT $LN2@lzma_lzma_@4
$LN1@lzma_lzma_@4:

; 669  : 
; 670  : 	*byte = (options->pb * 5 + options->lp) * 9 + options->lc;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0004f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00052	6b d2 05	 imul	 edx, 5
  00055	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00058	03 50 10	 add	 edx, DWORD PTR [eax+16]
  0005b	6b d2 09	 imul	 edx, 9
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00061	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  00064	8b 45 0c	 mov	 eax, DWORD PTR _byte$[ebp]
  00067	88 10		 mov	 BYTE PTR [eax], dl

; 671  : 	assert(*byte <= (4 * 5 + 4) * 9 + 8);
; 672  : 
; 673  : 	return false;

  00069	32 c0		 xor	 al, al
$LN2@lzma_lzma_@4:

; 674  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_lzma_lzma_lclppb_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _is_options_valid
_TEXT	SEGMENT
tv76 = -8						; size = 4
tv88 = -4						; size = 4
_options$ = 8						; size = 4
_is_options_valid PROC					; COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 432  : 	// Validate some of the options. LZ encoder validates nice_len too
; 433  : 	// but we need a valid value here earlier.
; 434  : 	return is_lclppb_valid(options)
; 435  : 			&& options->nice_len >= MATCH_LEN_MIN
; 436  : 			&& options->nice_len <= MATCH_LEN_MAX
; 437  : 			&& (options->mode == LZMA_MODE_FAST
; 438  : 				|| options->mode == LZMA_MODE_NORMAL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	83 78 0c 04	 cmp	 DWORD PTR [eax+12], 4
  0000d	77 2c		 ja	 SHORT $LN8@is_options
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00012	83 79 10 04	 cmp	 DWORD PTR [ecx+16], 4
  00016	77 23		 ja	 SHORT $LN8@is_options
  00018	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0001b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00021	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00024	83 f8 04	 cmp	 eax, 4
  00027	77 12		 ja	 SHORT $LN8@is_options
  00029	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0002c	83 7a 14 04	 cmp	 DWORD PTR [edx+20], 4
  00030	77 09		 ja	 SHORT $LN8@is_options
  00032	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00039	eb 07		 jmp	 SHORT $LN6@is_options
$LN8@is_options:
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$LN6@is_options:
  00042	0f b6 45 fc	 movzx	 eax, BYTE PTR tv88[ebp]
  00046	85 c0		 test	 eax, eax
  00048	74 30		 je	 SHORT $LN3@is_options
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0004d	83 79 1c 02	 cmp	 DWORD PTR [ecx+28], 2
  00051	72 27		 jb	 SHORT $LN3@is_options
  00053	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00056	81 7a 1c 11 01
	00 00		 cmp	 DWORD PTR [edx+28], 273	; 00000111H
  0005d	77 1b		 ja	 SHORT $LN3@is_options
  0005f	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00062	83 78 18 01	 cmp	 DWORD PTR [eax+24], 1
  00066	74 09		 je	 SHORT $LN4@is_options
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0006b	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  0006f	75 09		 jne	 SHORT $LN3@is_options
$LN4@is_options:
  00071	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00078	eb 07		 jmp	 SHORT $LN5@is_options
$LN3@is_options:
  0007a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@is_options:
  00081	8a 45 f8	 mov	 al, BYTE PTR tv76[ebp]

; 439  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_is_options_valid ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _literal_matched
_TEXT	SEGMENT
_bit$32800 = -16					; size = 4
_match_bit$32798 = -12					; size = 4
_subcoder_index$32799 = -8				; size = 4
_offset$ = -4						; size = 4
_rc$ = 8						; size = 4
_subcoder$ = 12						; size = 4
_match_byte$ = 16					; size = 4
_symbol$ = 20						; size = 4
_literal_matched PROC					; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 27   : 	uint32_t offset = 0x100;

  00006	c7 45 fc 00 01
	00 00		 mov	 DWORD PTR _offset$[ebp], 256 ; 00000100H

; 28   : 	symbol += UINT32_C(1) << 8;

  0000d	8b 45 14	 mov	 eax, DWORD PTR _symbol$[ebp]
  00010	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00015	89 45 14	 mov	 DWORD PTR _symbol$[ebp], eax
$LN3@literal_ma:

; 29   : 
; 30   : 	do {
; 31   : 		match_byte <<= 1;

  00018	8b 4d 10	 mov	 ecx, DWORD PTR _match_byte$[ebp]
  0001b	d1 e1		 shl	 ecx, 1
  0001d	89 4d 10	 mov	 DWORD PTR _match_byte$[ebp], ecx

; 32   :       {
; 33   : 		const uint32_t match_bit = match_byte & offset;

  00020	8b 55 10	 mov	 edx, DWORD PTR _match_byte$[ebp]
  00023	23 55 fc	 and	 edx, DWORD PTR _offset$[ebp]
  00026	89 55 f4	 mov	 DWORD PTR _match_bit$32798[ebp], edx

; 34   : 		const uint32_t subcoder_index
; 35   : 				= offset + match_bit + (symbol >> 8);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
  0002c	03 45 f4	 add	 eax, DWORD PTR _match_bit$32798[ebp]
  0002f	8b 4d 14	 mov	 ecx, DWORD PTR _symbol$[ebp]
  00032	c1 e9 08	 shr	 ecx, 8
  00035	03 c1		 add	 eax, ecx
  00037	89 45 f8	 mov	 DWORD PTR _subcoder_index$32799[ebp], eax

; 36   : 		const uint32_t bit = (symbol >> 7) & 1;

  0003a	8b 55 14	 mov	 edx, DWORD PTR _symbol$[ebp]
  0003d	c1 ea 07	 shr	 edx, 7
  00040	83 e2 01	 and	 edx, 1
  00043	89 55 f0	 mov	 DWORD PTR _bit$32800[ebp], edx

; 37   : 		rc_bit(rc, &subcoder[subcoder_index], bit);

  00046	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00049	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _bit$32800[ebp]
  00052	89 44 8a 20	 mov	 DWORD PTR [edx+ecx*4+32], eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00059	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _subcoder_index$32799[ebp]
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _subcoder$[ebp]
  00062	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00068	89 84 91 08 01
	00 00		 mov	 DWORD PTR [ecx+edx*4+264], eax
  0006f	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00072	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00075	83 c0 01	 add	 eax, 1
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0007b	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 38   : 
; 39   : 		symbol <<= 1;

  0007e	8b 55 14	 mov	 edx, DWORD PTR _symbol$[ebp]
  00081	d1 e2		 shl	 edx, 1
  00083	89 55 14	 mov	 DWORD PTR _symbol$[ebp], edx

; 40   : 		offset &= ~(match_byte ^ symbol);

  00086	8b 45 10	 mov	 eax, DWORD PTR _match_byte$[ebp]
  00089	33 45 14	 xor	 eax, DWORD PTR _symbol$[ebp]
  0008c	f7 d0		 not	 eax
  0008e	23 45 fc	 and	 eax, DWORD PTR _offset$[ebp]
  00091	89 45 fc	 mov	 DWORD PTR _offset$[ebp], eax

; 41   :       }
; 42   : 	} while (symbol < (UINT32_C(1) << 16));

  00094	81 7d 14 00 00
	01 00		 cmp	 DWORD PTR _symbol$[ebp], 65536 ; 00010000H
  0009b	0f 82 77 ff ff
	ff		 jb	 $LN3@literal_ma

; 43   : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_literal_matched ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
_TEXT	ENDS
;	COMDAT _rc_encode
_TEXT	SEGMENT
tv83 = -16						; size = 4
_prob$32593 = -12					; size = 2
_bound$32594 = -8					; size = 4
_prob$32591 = -4					; size = 2
_rc$ = 8						; size = 4
_out$ = 12						; size = 4
_out_pos$ = 16						; size = 4
_out_size$ = 20						; size = 4
_rc_encode PROC						; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
$LN16@rc_encode:

; 153  : 	assert(rc->count <= RC_SYMBOLS_MAX);
; 154  : 
; 155  : 	while (rc->pos < rc->count) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0000c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0000f	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  00012	0f 83 2e 02 00
	00		 jae	 $LN15@rc_encode

; 156  : 		// Normalize
; 157  : 		if (rc->range < RC_TOP_VALUE) {

  00018	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0001b	81 78 10 00 00
	00 01		 cmp	 DWORD PTR [eax+16], 16777216 ; 01000000H
  00022	73 35		 jae	 SHORT $LN14@rc_encode

; 158  : 			if (rc_shift_low(rc, out, out_pos, out_size))

  00024	8b 4d 14	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _rc_shift_low
  00039	83 c4 10	 add	 esp, 16			; 00000010H
  0003c	0f b6 d0	 movzx	 edx, al
  0003f	85 d2		 test	 edx, edx
  00041	74 07		 je	 SHORT $LN13@rc_encode

; 159  : 				return true;

  00043	b0 01		 mov	 al, 1
  00045	e9 12 02 00 00	 jmp	 $LN17@rc_encode
$LN13@rc_encode:

; 160  : 
; 161  : 			rc->range <<= RC_SHIFT_BITS;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0004d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00050	c1 e1 08	 shl	 ecx, 8
  00053	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00056	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
$LN14@rc_encode:

; 162  : 		}
; 163  : 
; 164  : 		// Encode a bit
; 165  : 		switch (rc->symbols[rc->pos]) {

  00059	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0005c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00062	8b 44 8a 20	 mov	 eax, DWORD PTR [edx+ecx*4+32]
  00066	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  00069	83 7d f0 04	 cmp	 DWORD PTR tv83[ebp], 4
  0006d	0f 87 bf 01 00
	00		 ja	 $LN11@rc_encode
  00073	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00076	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN37@rc_encode[ecx*4]
$LN10@rc_encode:

; 166  : 		case RC_BIT_0: {
; 167  : 			probability prob = *rc->probs[rc->pos];

  0007d	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00080	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00086	8b 94 81 08 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+264]
  0008d	66 8b 02	 mov	 ax, WORD PTR [edx]
  00090	66 89 45 fc	 mov	 WORD PTR _prob$32591[ebp], ax

; 168  : 			rc->range = (rc->range >> RC_BIT_MODEL_TOTAL_BITS)
; 169  : 					* prob;

  00094	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00097	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0009a	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  0009d	0f b7 45 fc	 movzx	 eax, WORD PTR _prob$32591[ebp]
  000a1	0f af d0	 imul	 edx, eax
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000a7	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 170  : 			prob += (RC_BIT_MODEL_TOTAL - prob) >> RC_MOVE_BITS;

  000aa	0f b7 55 fc	 movzx	 edx, WORD PTR _prob$32591[ebp]
  000ae	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  000b3	2b c2		 sub	 eax, edx
  000b5	c1 e8 05	 shr	 eax, 5
  000b8	0f b7 4d fc	 movzx	 ecx, WORD PTR _prob$32591[ebp]
  000bc	03 c8		 add	 ecx, eax
  000be	66 89 4d fc	 mov	 WORD PTR _prob$32591[ebp], cx

; 171  : 			*rc->probs[rc->pos] = prob;

  000c2	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  000c5	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000cb	8b 94 81 08 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+264]
  000d2	66 8b 45 fc	 mov	 ax, WORD PTR _prob$32591[ebp]
  000d6	66 89 02	 mov	 WORD PTR [edx], ax

; 172  : 			break;

  000d9	e9 54 01 00 00	 jmp	 $LN11@rc_encode
$LN9@rc_encode:

; 173  : 		}
; 174  : 
; 175  : 		case RC_BIT_1: {
; 176  : 			probability prob = *rc->probs[rc->pos];

  000de	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000e1	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000e4	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000e7	8b 8c 90 08 01
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+264]
  000ee	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000f1	66 89 55 f4	 mov	 WORD PTR _prob$32593[ebp], dx

; 177  : 			const uint32_t bound = prob * (rc->range
; 178  : 					>> RC_BIT_MODEL_TOTAL_BITS);

  000f5	0f b7 45 f4	 movzx	 eax, WORD PTR _prob$32593[ebp]
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000fc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000ff	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  00102	0f af c2	 imul	 eax, edx
  00105	89 45 f8	 mov	 DWORD PTR _bound$32594[ebp], eax

; 179  : 			rc->low += bound;

  00108	8b 45 f8	 mov	 eax, DWORD PTR _bound$32594[ebp]
  0010b	33 c9		 xor	 ecx, ecx
  0010d	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00110	03 02		 add	 eax, DWORD PTR [edx]
  00112	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00115	13 d1		 adc	 edx, ecx
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0011a	89 01		 mov	 DWORD PTR [ecx], eax
  0011c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 180  : 			rc->range -= bound;

  0011f	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00122	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00125	2b 45 f8	 sub	 eax, DWORD PTR _bound$32594[ebp]
  00128	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0012b	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 181  : 			prob -= prob >> RC_MOVE_BITS;

  0012e	0f b7 55 f4	 movzx	 edx, WORD PTR _prob$32593[ebp]
  00132	c1 fa 05	 sar	 edx, 5
  00135	0f b7 45 f4	 movzx	 eax, WORD PTR _prob$32593[ebp]
  00139	2b c2		 sub	 eax, edx
  0013b	66 89 45 f4	 mov	 WORD PTR _prob$32593[ebp], ax

; 182  : 			*rc->probs[rc->pos] = prob;

  0013f	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00142	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00145	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00148	8b 8c 90 08 01
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+264]
  0014f	66 8b 55 f4	 mov	 dx, WORD PTR _prob$32593[ebp]
  00153	66 89 11	 mov	 WORD PTR [ecx], dx

; 183  : 			break;

  00156	e9 d7 00 00 00	 jmp	 $LN11@rc_encode
$LN8@rc_encode:

; 184  : 		}
; 185  : 
; 186  : 		case RC_DIRECT_0:
; 187  : 			rc->range >>= 1;

  0015b	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0015e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00161	d1 e9		 shr	 ecx, 1
  00163	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00166	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 188  : 			break;

  00169	e9 c4 00 00 00	 jmp	 $LN11@rc_encode
$LN7@rc_encode:

; 189  : 
; 190  : 		case RC_DIRECT_1:
; 191  : 			rc->range >>= 1;

  0016e	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00171	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00174	d1 e9		 shr	 ecx, 1
  00176	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00179	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 192  : 			rc->low += rc->range;

  0017c	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0017f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00182	33 d2		 xor	 edx, edx
  00184	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00187	03 08		 add	 ecx, DWORD PTR [eax]
  00189	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018c	13 c2		 adc	 eax, edx
  0018e	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00191	89 0a		 mov	 DWORD PTR [edx], ecx
  00193	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 193  : 			break;

  00196	e9 97 00 00 00	 jmp	 $LN11@rc_encode
$LN6@rc_encode:

; 194  : 
; 195  : 		case RC_FLUSH:
; 196  : 			// Prevent further normalizations.
; 197  : 			rc->range = UINT32_MAX;

  0019b	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0019e	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN5@rc_encode:

; 198  : 
; 199  : 			// Flush the last five bytes (see rc_flush()).
; 200  : 			do {
; 201  : 				if (rc_shift_low(rc, out, out_pos, out_size))

  001a5	8b 4d 14	 mov	 ecx, DWORD PTR _out_size$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 10	 mov	 edx, DWORD PTR _out_pos$[ebp]
  001ac	52		 push	 edx
  001ad	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 _rc_shift_low
  001ba	83 c4 10	 add	 esp, 16			; 00000010H
  001bd	0f b6 d0	 movzx	 edx, al
  001c0	85 d2		 test	 edx, edx
  001c2	74 07		 je	 SHORT $LN4@rc_encode

; 202  : 					return true;

  001c4	b0 01		 mov	 al, 1
  001c6	e9 91 00 00 00	 jmp	 $LN17@rc_encode
$LN4@rc_encode:

; 203  : 			} while (++rc->pos < rc->count);

  001cb	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  001ce	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001d1	83 c1 01	 add	 ecx, 1
  001d4	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  001d7	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  001da	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  001e0	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  001e3	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  001e6	72 bd		 jb	 SHORT $LN5@rc_encode

; 204  : 
; 205  : 			// Reset the range encoder so we are ready to continue
; 206  : 			// encoding if we weren't finishing the stream.
; 207  : 			rc_reset(rc);

  001e8	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  001eb	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001f1	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  001f8	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  001fb	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
  00202	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00209	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0020c	c7 42 10 ff ff
	ff ff		 mov	 DWORD PTR [edx+16], -1
  00213	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00216	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  0021a	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0021d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00224	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00227	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 208  : 			return false;

  0022e	32 c0		 xor	 al, al
  00230	eb 2a		 jmp	 SHORT $LN17@rc_encode
$LN11@rc_encode:

; 209  : 
; 210  : 		default:
; 211  : 			assert(0);
; 212  : 			break;
; 213  : 		}
; 214  : 
; 215  : 		++rc->pos;

  00232	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00235	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00238	83 c1 01	 add	 ecx, 1
  0023b	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0023e	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 216  : 	}

  00241	e9 c0 fd ff ff	 jmp	 $LN16@rc_encode
$LN15@rc_encode:

; 217  : 
; 218  : 	rc->count = 0;

  00246	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00249	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 219  : 	rc->pos = 0;

  00250	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00253	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 220  : 
; 221  : 	return false;

  0025a	32 c0		 xor	 al, al
$LN17@rc_encode:

; 222  : }

  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c3		 ret	 0
$LN37@rc_encode:
  00260	00 00 00 00	 DD	 $LN10@rc_encode
  00264	00 00 00 00	 DD	 $LN9@rc_encode
  00268	00 00 00 00	 DD	 $LN8@rc_encode
  0026c	00 00 00 00	 DD	 $LN7@rc_encode
  00270	00 00 00 00	 DD	 $LN6@rc_encode
_rc_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bittree_reverse
_TEXT	SEGMENT
_bit$32530 = -8						; size = 4
_model_index$ = -4					; size = 4
_rc$ = 8						; size = 4
_probs$ = 12						; size = 4
_bit_count$ = 16					; size = 4
_symbol$ = 20						; size = 4
_rc_bittree_reverse PROC				; COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 93   : 	uint32_t model_index = 1;

  00006	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _model_index$[ebp], 1
$LN3@rc_bittree@3:

; 94   : 
; 95   : 	do {
; 96   : 		const uint32_t bit = symbol & 1;

  0000d	8b 45 14	 mov	 eax, DWORD PTR _symbol$[ebp]
  00010	83 e0 01	 and	 eax, 1
  00013	89 45 f8	 mov	 DWORD PTR _bit$32530[ebp], eax

; 97   : 		symbol >>= 1;

  00016	8b 4d 14	 mov	 ecx, DWORD PTR _symbol$[ebp]
  00019	d1 e9		 shr	 ecx, 1
  0001b	89 4d 14	 mov	 DWORD PTR _symbol$[ebp], ecx

; 98   : 		rc_bit(rc, &probs[model_index], bit);

  0001e	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00021	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00027	8b 55 f8	 mov	 edx, DWORD PTR _bit$32530[ebp]
  0002a	89 54 81 20	 mov	 DWORD PTR [ecx+eax*4+32], edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00031	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00034	8b 55 fc	 mov	 edx, DWORD PTR _model_index$[ebp]
  00037	8b 45 0c	 mov	 eax, DWORD PTR _probs$[ebp]
  0003a	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00040	89 94 88 08 01
	00 00		 mov	 DWORD PTR [eax+ecx*4+264], edx
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0004a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004d	83 c2 01	 add	 edx, 1
  00050	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00053	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 99   : 		model_index = (model_index << 1) + bit;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _model_index$[ebp]
  00059	8b 55 f8	 mov	 edx, DWORD PTR _bit$32530[ebp]
  0005c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0005f	89 45 fc	 mov	 DWORD PTR _model_index$[ebp], eax

; 100  : 	} while (--bit_count != 0);

  00062	8b 4d 10	 mov	 ecx, DWORD PTR _bit_count$[ebp]
  00065	83 e9 01	 sub	 ecx, 1
  00068	89 4d 10	 mov	 DWORD PTR _bit_count$[ebp], ecx
  0006b	75 a0		 jne	 SHORT $LN3@rc_bittree@3

; 101  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_rc_bittree_reverse ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bittree
_TEXT	SEGMENT
_bit$32515 = -8						; size = 4
_model_index$ = -4					; size = 4
_rc$ = 8						; size = 4
_probs$ = 12						; size = 4
_bit_count$ = 16					; size = 4
_symbol$ = 20						; size = 4
_rc_bittree PROC					; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 79   : 	uint32_t model_index = 1;

  00006	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _model_index$[ebp], 1
$LN3@rc_bittree@4:

; 80   : 
; 81   : 	do {
; 82   : 		const uint32_t bit = (symbol >> --bit_count) & 1;

  0000d	8b 45 10	 mov	 eax, DWORD PTR _bit_count$[ebp]
  00010	83 e8 01	 sub	 eax, 1
  00013	89 45 10	 mov	 DWORD PTR _bit_count$[ebp], eax
  00016	8b 55 14	 mov	 edx, DWORD PTR _symbol$[ebp]
  00019	8b 4d 10	 mov	 ecx, DWORD PTR _bit_count$[ebp]
  0001c	d3 ea		 shr	 edx, cl
  0001e	83 e2 01	 and	 edx, 1
  00021	89 55 f8	 mov	 DWORD PTR _bit$32515[ebp], edx

; 83   : 		rc_bit(rc, &probs[model_index], bit);

  00024	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00027	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0002a	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _bit$32515[ebp]
  00030	89 44 8a 20	 mov	 DWORD PTR [edx+ecx*4+32], eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00037	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _model_index$[ebp]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _probs$[ebp]
  00040	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00046	89 84 91 08 01
	00 00		 mov	 DWORD PTR [ecx+edx*4+264], eax
  0004d	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00050	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00053	83 c0 01	 add	 eax, 1
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00059	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 84   : 		model_index = (model_index << 1) + bit;

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _model_index$[ebp]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _bit$32515[ebp]
  00062	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00065	89 4d fc	 mov	 DWORD PTR _model_index$[ebp], ecx

; 85   : 	} while (bit_count != 0);

  00068	83 7d 10 00	 cmp	 DWORD PTR _bit_count$[ebp], 0
  0006c	75 9f		 jne	 SHORT $LN3@rc_bittree@4

; 86   : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_rc_bittree ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT _rc_bittree_price
_TEXT	SEGMENT
_bit$32454 = -8						; size = 4
_price$ = -4						; size = 4
_probs$ = 8						; size = 4
_bit_levels$ = 12					; size = 4
_symbol$ = 16						; size = 4
_rc_bittree_price PROC					; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 55   : 	uint32_t price = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _price$[ebp], 0

; 56   : 	symbol += UINT32_C(1) << bit_levels;

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _bit_levels$[ebp]
  00015	d3 e0		 shl	 eax, cl
  00017	03 45 10	 add	 eax, DWORD PTR _symbol$[ebp]
  0001a	89 45 10	 mov	 DWORD PTR _symbol$[ebp], eax
$LN3@rc_bittree@5:

; 57   : 
; 58   : 	do {
; 59   : 		const uint32_t bit = symbol & 1;

  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _symbol$[ebp]
  00020	83 e1 01	 and	 ecx, 1
  00023	89 4d f8	 mov	 DWORD PTR _bit$32454[ebp], ecx

; 60   : 		symbol >>= 1;

  00026	8b 55 10	 mov	 edx, DWORD PTR _symbol$[ebp]
  00029	d1 ea		 shr	 edx, 1
  0002b	89 55 10	 mov	 DWORD PTR _symbol$[ebp], edx

; 61   : 		price += rc_bit_price(probs[symbol], bit);

  0002e	33 c0		 xor	 eax, eax
  00030	2b 45 f8	 sub	 eax, DWORD PTR _bit$32454[ebp]
  00033	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _symbol$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR _probs$[ebp]
  0003e	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  00042	33 c8		 xor	 ecx, eax
  00044	c1 e9 04	 shr	 ecx, 4
  00047	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  0004e	03 55 fc	 add	 edx, DWORD PTR _price$[ebp]
  00051	89 55 fc	 mov	 DWORD PTR _price$[ebp], edx

; 62   : 	} while (symbol != 1);

  00054	83 7d 10 01	 cmp	 DWORD PTR _symbol$[ebp], 1
  00058	75 c3		 jne	 SHORT $LN3@rc_bittree@5

; 63   : 
; 64   : 	return price;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _price$[ebp]

; 65   : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_rc_bittree_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
;	COMDAT _lzma_lzma_props_encode
_TEXT	SEGMENT
$T78733 = -8						; size = 4
_opt$ = -4						; size = 4
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_lzma_props_encode PROC				; COMDAT

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 681  : 	const lzma_options_lzma *const opt = options;

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _opt$[ebp], eax

; 682  : 
; 683  : 	if (lzma_lzma_lclppb_encode(opt, out))

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 fc	 mov	 edx, DWORD PTR _opt$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _lzma_lzma_lclppb_encode
  00019	83 c4 08	 add	 esp, 8
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	85 c0		 test	 eax, eax
  00021	74 07		 je	 SHORT $LN1@lzma_lzma_@7

; 684  : 		return LZMA_PROG_ERROR;

  00023	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00028	eb 13		 jmp	 SHORT $LN2@lzma_lzma_@7
$LN1@lzma_lzma_@7:

; 685  : 
; 686  : 	unaligned_write32le(out + 1, opt->dict_size);

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _opt$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	89 55 f8	 mov	 DWORD PTR $T78733[ebp], edx
  00032	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00035	8b 4d f8	 mov	 ecx, DWORD PTR $T78733[ebp]
  00038	89 48 01	 mov	 DWORD PTR [eax+1], ecx

; 687  : 
; 688  : 	return LZMA_OK;

  0003b	33 c0		 xor	 eax, eax
$LN2@lzma_lzma_@7:

; 689  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_lzma_lzma_props_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _encode_init
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_encode_init PROC					; COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 275  : 	assert(mf_position(mf) == 0);
; 276  : 
; 277  : 	if (mf->read_pos == mf->read_limit) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000f	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00012	75 15		 jne	 SHORT $LN3@encode_ini

; 278  : 		if (mf->action == LZMA_RUN)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00017	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0001b	75 07		 jne	 SHORT $LN2@encode_ini

; 279  : 			return false; // We cannot do anything.

  0001d	32 c0		 xor	 al, al
  0001f	e9 9e 00 00 00	 jmp	 $LN4@encode_ini
$LN2@encode_ini:

; 280  : 
; 281  : 		// We are finishing (we cannot get here when flushing).
; 282  : 		assert(mf->write_pos == mf->read_pos);
; 283  : 		assert(mf->action == LZMA_FINISH);
; 284  : 	} else {

  00024	e9 8d 00 00 00	 jmp	 $LN1@encode_ini
$LN3@encode_ini:

; 285  : 		// Do the actual initialization. The first LZMA symbol must
; 286  : 		// always be a literal.
; 287  : 		mf_skip(mf, 1);

  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	85 c9		 test	 ecx, ecx
  00030	74 20		 je	 SHORT $LN7@encode_ini
  00032	6a 01		 push	 1
  00034	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00037	52		 push	 edx
  00038	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0003b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003e	ff d1		 call	 ecx
  00040	83 c4 08	 add	 esp, 8
  00043	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	83 c0 01	 add	 eax, 1
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0004f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN7@encode_ini:

; 288  : 		mf->read_ahead = 0;

  00052	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00055	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 289  : 		rc_bit(&coder->rc, &coder->is_match[0][0], 0);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00062	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00065	c7 44 8a 20 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+32], 0
  0006d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00070	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00073	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00076	81 c2 ac 6a 00
	00		 add	 edx, 27308		; 00006aacH
  0007c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0007f	89 94 88 08 01
	00 00		 mov	 DWORD PTR [eax+ecx*4+264], edx
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00089	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0008c	83 c2 01	 add	 edx, 1
  0008f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00092	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 290  : 		rc_bittree(&coder->rc, coder->literal[0], 8, mf->buffer[0]);

  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0009d	50		 push	 eax
  0009e	6a 08		 push	 8
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a3	81 c1 ac 0a 00
	00		 add	 ecx, 2732		; 00000aacH
  000a9	51		 push	 ecx
  000aa	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _rc_bittree
  000b3	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@encode_ini:

; 291  : 	}
; 292  : 
; 293  : 	// Initialization is done (except if empty file).
; 294  : 	coder->is_initialized = true;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000b9	c6 80 9d 0a 00
	00 01		 mov	 BYTE PTR [eax+2717], 1

; 295  : 
; 296  : 	return true;

  000c0	b0 01		 mov	 al, 1
$LN4@encode_ini:

; 297  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
_encode_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _length_update_prices
_TEXT	SEGMENT
_a0$32821 = -28						; size = 4
_b1$32824 = -24						; size = 4
_prices$32825 = -20					; size = 4
_a1$32822 = -16						; size = 4
_i$32826 = -12						; size = 4
_b0$32823 = -8						; size = 4
_table_size$ = -4					; size = 4
_lc$ = 8						; size = 4
_pos_state$ = 12					; size = 4
_length_update_prices PROC				; COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 81   : 	const uint32_t table_size = lc->table_size;

  00006	8b 45 08	 mov	 eax, DWORD PTR _lc$[ebp]
  00009	8b 88 04 48 00
	00		 mov	 ecx, DWORD PTR [eax+18436]
  0000f	89 4d fc	 mov	 DWORD PTR _table_size$[ebp], ecx

; 82   : 	lc->counters[pos_state] = table_size;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00015	8b 45 08	 mov	 eax, DWORD PTR _lc$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _table_size$[ebp]
  0001b	89 8c 90 08 48
	00 00		 mov	 DWORD PTR [eax+edx*4+18440], ecx

; 83   : 
; 84   :   {
; 85   : 	const uint32_t a0 = rc_bit_0_price(lc->choice);

  00022	8b 55 08	 mov	 edx, DWORD PTR _lc$[ebp]
  00025	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00028	c1 f8 04	 sar	 eax, 4
  0002b	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00032	89 4d e4	 mov	 DWORD PTR _a0$32821[ebp], ecx

; 86   : 	const uint32_t a1 = rc_bit_1_price(lc->choice);

  00035	8b 55 08	 mov	 edx, DWORD PTR _lc$[ebp]
  00038	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0003b	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00040	c1 e8 04	 shr	 eax, 4
  00043	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  0004a	89 4d f0	 mov	 DWORD PTR _a1$32822[ebp], ecx

; 87   : 	const uint32_t b0 = a1 + rc_bit_0_price(lc->choice2);

  0004d	8b 55 08	 mov	 edx, DWORD PTR _lc$[ebp]
  00050	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00054	c1 f8 04	 sar	 eax, 4
  00057	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  0005e	03 4d f0	 add	 ecx, DWORD PTR _a1$32822[ebp]
  00061	89 4d f8	 mov	 DWORD PTR _b0$32823[ebp], ecx

; 88   : 	const uint32_t b1 = a1 + rc_bit_1_price(lc->choice2);

  00064	8b 55 08	 mov	 edx, DWORD PTR _lc$[ebp]
  00067	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0006b	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00070	c1 e8 04	 shr	 eax, 4
  00073	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  0007a	03 4d f0	 add	 ecx, DWORD PTR _a1$32822[ebp]
  0007d	89 4d e8	 mov	 DWORD PTR _b1$32824[ebp], ecx

; 89   : 	uint32_t *const prices = lc->prices[pos_state];

  00080	8b 55 0c	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00083	69 d2 40 04 00
	00		 imul	 edx, 1088		; 00000440H
  00089	8b 45 08	 mov	 eax, DWORD PTR _lc$[ebp]
  0008c	8d 8c 10 04 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1028]
  00093	89 4d ec	 mov	 DWORD PTR _prices$32825[ebp], ecx

; 90   : 
; 91   : 	uint32_t i;
; 92   : 	for (i = 0; i < table_size && i < LEN_LOW_SYMBOLS; ++i)

  00096	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$32826[ebp], 0
  0009d	eb 09		 jmp	 SHORT $LN9@length_upd
$LN8@length_upd:
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _i$32826[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 f4	 mov	 DWORD PTR _i$32826[ebp], edx
$LN9@length_upd:
  000a8	8b 45 f4	 mov	 eax, DWORD PTR _i$32826[ebp]
  000ab	3b 45 fc	 cmp	 eax, DWORD PTR _table_size$[ebp]
  000ae	73 30		 jae	 SHORT $LN7@length_upd
  000b0	83 7d f4 08	 cmp	 DWORD PTR _i$32826[ebp], 8
  000b4	73 2a		 jae	 SHORT $LN7@length_upd

; 93   : 		prices[i] = a0 + rc_bittree_price(lc->low[pos_state],
; 94   : 				LEN_LOW_BITS, i);

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _i$32826[ebp]
  000b9	51		 push	 ecx
  000ba	6a 03		 push	 3
  000bc	8b 55 0c	 mov	 edx, DWORD PTR _pos_state$[ebp]
  000bf	c1 e2 04	 shl	 edx, 4
  000c2	8b 45 08	 mov	 eax, DWORD PTR _lc$[ebp]
  000c5	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _rc_bittree_price
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d2	03 45 e4	 add	 eax, DWORD PTR _a0$32821[ebp]
  000d5	8b 55 f4	 mov	 edx, DWORD PTR _i$32826[ebp]
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR _prices$32825[ebp]
  000db	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  000de	eb bf		 jmp	 SHORT $LN8@length_upd
$LN7@length_upd:

; 95   : 
; 96   : 	for (; i < table_size && i < LEN_LOW_SYMBOLS + LEN_MID_SYMBOLS; ++i)

  000e0	eb 09		 jmp	 SHORT $LN6@length_upd
$LN5@length_upd:
  000e2	8b 55 f4	 mov	 edx, DWORD PTR _i$32826[ebp]
  000e5	83 c2 01	 add	 edx, 1
  000e8	89 55 f4	 mov	 DWORD PTR _i$32826[ebp], edx
$LN6@length_upd:
  000eb	8b 45 f4	 mov	 eax, DWORD PTR _i$32826[ebp]
  000ee	3b 45 fc	 cmp	 eax, DWORD PTR _table_size$[ebp]
  000f1	73 36		 jae	 SHORT $LN4@length_upd
  000f3	83 7d f4 10	 cmp	 DWORD PTR _i$32826[ebp], 16 ; 00000010H
  000f7	73 30		 jae	 SHORT $LN4@length_upd

; 97   : 		prices[i] = b0 + rc_bittree_price(lc->mid[pos_state],
; 98   : 				LEN_MID_BITS, i - LEN_LOW_SYMBOLS);

  000f9	8b 4d f4	 mov	 ecx, DWORD PTR _i$32826[ebp]
  000fc	83 e9 08	 sub	 ecx, 8
  000ff	51		 push	 ecx
  00100	6a 03		 push	 3
  00102	8b 55 0c	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00105	c1 e2 04	 shl	 edx, 4
  00108	8b 45 08	 mov	 eax, DWORD PTR _lc$[ebp]
  0010b	8d 8c 10 04 01
	00 00		 lea	 ecx, DWORD PTR [eax+edx+260]
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 _rc_bittree_price
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	03 45 f8	 add	 eax, DWORD PTR _b0$32823[ebp]
  0011e	8b 55 f4	 mov	 edx, DWORD PTR _i$32826[ebp]
  00121	8b 4d ec	 mov	 ecx, DWORD PTR _prices$32825[ebp]
  00124	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00127	eb b9		 jmp	 SHORT $LN5@length_upd
$LN4@length_upd:

; 99   : 
; 100  : 	for (; i < table_size; ++i)

  00129	eb 09		 jmp	 SHORT $LN3@length_upd
$LN2@length_upd:
  0012b	8b 55 f4	 mov	 edx, DWORD PTR _i$32826[ebp]
  0012e	83 c2 01	 add	 edx, 1
  00131	89 55 f4	 mov	 DWORD PTR _i$32826[ebp], edx
$LN3@length_upd:
  00134	8b 45 f4	 mov	 eax, DWORD PTR _i$32826[ebp]
  00137	3b 45 fc	 cmp	 eax, DWORD PTR _table_size$[ebp]
  0013a	73 29		 jae	 SHORT $LN10@length_upd

; 101  : 		prices[i] = b1 + rc_bittree_price(lc->high, LEN_HIGH_BITS,
; 102  : 				i - LEN_LOW_SYMBOLS - LEN_MID_SYMBOLS);

  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _i$32826[ebp]
  0013f	83 e9 10	 sub	 ecx, 16			; 00000010H
  00142	51		 push	 ecx
  00143	6a 08		 push	 8
  00145	8b 55 08	 mov	 edx, DWORD PTR _lc$[ebp]
  00148	81 c2 04 02 00
	00		 add	 edx, 516		; 00000204H
  0014e	52		 push	 edx
  0014f	e8 00 00 00 00	 call	 _rc_bittree_price
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
  00157	03 45 e8	 add	 eax, DWORD PTR _b1$32824[ebp]
  0015a	8b 4d f4	 mov	 ecx, DWORD PTR _i$32826[ebp]
  0015d	8b 55 ec	 mov	 edx, DWORD PTR _prices$32825[ebp]
  00160	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00163	eb c6		 jmp	 SHORT $LN2@length_upd
$LN10@length_upd:

; 103  :   }
; 104  : 
; 105  : 	return;
; 106  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
_length_update_prices ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _literal
_TEXT	SEGMENT
tv147 = -40						; size = 4
tv148 = -36						; size = 4
_match_byte$32813 = -6					; size = 1
_cur_byte$ = -5						; size = 1
_subcoder$ = -4						; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_position$ = 16						; size = 4
_literal PROC						; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 49   : 	// Locate the literal byte to be encoded and the subcoder.
; 50   : 	const uint8_t cur_byte = mf->buffer[
; 51   : 			mf->read_pos - mf->read_ahead];

  00007	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00010	2b 51 18	 sub	 edx, DWORD PTR [ecx+24]
  00013	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8a 14 0a	 mov	 dl, BYTE PTR [edx+ecx]
  0001b	88 55 fb	 mov	 BYTE PTR _cur_byte$[ebp], dl

; 52   : 	probability *subcoder = literal_subcoder(coder->literal,
; 53   : 			coder->literal_context_bits, coder->literal_pos_mask,
; 54   : 			position, mf->buffer[mf->read_pos - mf->read_ahead - 1]);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00021	8b 55 10	 mov	 edx, DWORD PTR _position$[ebp]
  00024	23 90 a8 0a 00
	00		 and	 edx, DWORD PTR [eax+2728]
  0002a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002d	8b 88 a4 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2724]
  00033	d3 e2		 shl	 edx, cl
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00038	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0003b	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0003e	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	0f b6 44 08 ff	 movzx	 eax, BYTE PTR [eax+ecx-1]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004e	be 08 00 00 00	 mov	 esi, 8
  00053	2b b1 a4 0a 00
	00		 sub	 esi, DWORD PTR [ecx+2724]
  00059	8b ce		 mov	 ecx, esi
  0005b	d3 f8		 sar	 eax, cl
  0005d	03 d0		 add	 edx, eax
  0005f	69 d2 00 06 00
	00		 imul	 edx, 1536		; 00000600H
  00065	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00068	8d 8c 10 ac 0a
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2732]
  0006f	89 4d fc	 mov	 DWORD PTR _subcoder$[ebp], ecx

; 55   : 
; 56   : 	if (is_literal_state(coder->state)) {

  00072	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00075	83 ba f0 01 00
	00 07		 cmp	 DWORD PTR [edx+496], 7
  0007c	7d 19		 jge	 SHORT $LN2@literal

; 57   : 		// Previous LZMA-symbol was a literal. Encode a normal
; 58   : 		// literal without a match byte.
; 59   : 		rc_bittree(&coder->rc, subcoder, 8, cur_byte);

  0007e	0f b6 45 fb	 movzx	 eax, BYTE PTR _cur_byte$[ebp]
  00082	50		 push	 eax
  00083	6a 08		 push	 8
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _subcoder$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 _rc_bittree
  00092	83 c4 10	 add	 esp, 16			; 00000010H

; 60   : 	} else {

  00095	eb 3d		 jmp	 SHORT $LN1@literal
$LN2@literal:

; 61   : 		// Previous LZMA-symbol was a match. Use the last byte of
; 62   : 		// the match as a "match byte". That is, compare the bits
; 63   : 		// of the current literal and the match byte.
; 64   : 		const uint8_t match_byte = mf->buffer[
; 65   : 				mf->read_pos - coder->reps[0] - 1
; 66   : 				- mf->read_ahead];

  00097	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0009d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000a0	2b 91 f4 01 00
	00		 sub	 edx, DWORD PTR [ecx+500]
  000a6	83 ea 01	 sub	 edx, 1
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  000ac	2b 50 18	 sub	 edx, DWORD PTR [eax+24]
  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  000b2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b4	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  000b7	88 4d fa	 mov	 BYTE PTR _match_byte$32813[ebp], cl

; 67   : 		literal_matched(&coder->rc, subcoder, match_byte, cur_byte);

  000ba	0f b6 55 fb	 movzx	 edx, BYTE PTR _cur_byte$[ebp]
  000be	52		 push	 edx
  000bf	0f b6 45 fa	 movzx	 eax, BYTE PTR _match_byte$32813[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _subcoder$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 _literal_matched
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@literal:

; 68   : 	}
; 69   : 
; 70   : 	update_literal(coder->state);

  000d4	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d7	83 b8 f0 01 00
	00 03		 cmp	 DWORD PTR [eax+496], 3
  000de	7f 09		 jg	 SHORT $LN7@literal
  000e0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv148[ebp], 0
  000e7	eb 32		 jmp	 SHORT $LN8@literal
$LN7@literal:
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ec	83 b9 f0 01 00
	00 09		 cmp	 DWORD PTR [ecx+496], 9
  000f3	7f 11		 jg	 SHORT $LN5@literal
  000f5	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000f8	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  000fe	83 e8 03	 sub	 eax, 3
  00101	89 45 d8	 mov	 DWORD PTR tv147[ebp], eax
  00104	eb 0f		 jmp	 SHORT $LN6@literal
$LN5@literal:
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00109	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  0010f	83 ea 06	 sub	 edx, 6
  00112	89 55 d8	 mov	 DWORD PTR tv147[ebp], edx
$LN6@literal:
  00115	8b 45 d8	 mov	 eax, DWORD PTR tv147[ebp]
  00118	89 45 dc	 mov	 DWORD PTR tv148[ebp], eax
$LN8@literal:
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0011e	8b 55 dc	 mov	 edx, DWORD PTR tv148[ebp]
  00121	89 91 f0 01 00
	00		 mov	 DWORD PTR [ecx+496], edx

; 71   : }

  00127	5e		 pop	 esi
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
_literal ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_encoder_memusage
_TEXT	SEGMENT
_lz_memusage$33094 = -48				; size = 8
_lz_options$33093 = -36					; size = 36
_options$ = 8						; size = 4
_lzma_lzma_encoder_memusage PROC			; COMDAT

; 646  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 647  : 	if (!is_options_valid(options))

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _is_options_valid
  0000f	83 c4 04	 add	 esp, 4
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 08		 jne	 SHORT $LN2@lzma_lzma_@8

; 648  : 		return UINT64_MAX;

  00019	83 c8 ff	 or	 eax, -1
  0001c	83 ca ff	 or	 edx, -1
  0001f	eb 43		 jmp	 SHORT $LN3@lzma_lzma_@8
$LN2@lzma_lzma_@8:

; 649  : 
; 650  :   {
; 651  : 	lzma_lz_options lz_options;
; 652  : 	set_lz_options(&lz_options, options);

  00021	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  00024	52		 push	 edx
  00025	8d 45 dc	 lea	 eax, DWORD PTR _lz_options$33093[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _set_lz_options
  0002e	83 c4 08	 add	 esp, 8

; 653  : 
; 654  :   {
; 655  : 	const uint64_t lz_memusage = lzma_lz_encoder_memusage(&lz_options);

  00031	8d 4d dc	 lea	 ecx, DWORD PTR _lz_options$33093[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _lzma_lz_encoder_memusage
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 d0	 mov	 DWORD PTR _lz_memusage$33094[ebp], eax
  00040	89 55 d4	 mov	 DWORD PTR _lz_memusage$33094[ebp+4], edx

; 656  : 	if (lz_memusage == UINT64_MAX)

  00043	8b 55 d0	 mov	 edx, DWORD PTR _lz_memusage$33094[ebp]
  00046	23 55 d4	 and	 edx, DWORD PTR _lz_memusage$33094[ebp+4]
  00049	83 fa ff	 cmp	 edx, -1
  0004c	75 08		 jne	 SHORT $LN1@lzma_lzma_@8

; 657  : 		return UINT64_MAX;

  0004e	83 c8 ff	 or	 eax, -1
  00051	83 ca ff	 or	 edx, -1
  00054	eb 0e		 jmp	 SHORT $LN3@lzma_lzma_@8
$LN1@lzma_lzma_@8:

; 658  : 
; 659  : 	return (uint64_t)(sizeof(lzma_lzma1_encoder)) + lz_memusage;

  00056	8b 45 d0	 mov	 eax, DWORD PTR _lz_memusage$33094[ebp]
  00059	05 f8 cd 03 00	 add	 eax, 249336		; 0003cdf8H
  0005e	8b 55 d4	 mov	 edx, DWORD PTR _lz_memusage$33094[ebp+4]
  00061	83 d2 00	 adc	 edx, 0
$LN3@lzma_lzma_@8:

; 660  :   }}
; 661  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_lzma_lzma_encoder_memusage ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _length_encoder_reset
_TEXT	SEGMENT
_bt_i$33005 = -16					; size = 4
_bt_i$33001 = -12					; size = 4
_bt_i$32997 = -8					; size = 4
_pos_state$32993 = -4					; size = 4
_lencoder$ = 8						; size = 4
_num_pos_states$ = 12					; size = 4
_fast_mode$ = 16					; size = 1
_length_encoder_reset PROC				; COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 464  : 	bit_reset(lencoder->choice);

  00006	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _lencoder$[ebp]
  0000e	66 89 01	 mov	 WORD PTR [ecx], ax

; 465  : 	bit_reset(lencoder->choice2);

  00011	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00016	8b 45 08	 mov	 eax, DWORD PTR _lencoder$[ebp]
  00019	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 466  : 
; 467  :   { size_t pos_state;
; 468  : 
; 469  : 	for (pos_state = 0; pos_state < num_pos_states; ++pos_state) {

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pos_state$32993[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN16@length_enc
$LN15@length_enc:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _pos_state$32993[ebp]
  00029	83 c1 01	 add	 ecx, 1
  0002c	89 4d fc	 mov	 DWORD PTR _pos_state$32993[ebp], ecx
$LN16@length_enc:
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _pos_state$32993[ebp]
  00032	3b 55 0c	 cmp	 edx, DWORD PTR _num_pos_states$[ebp]
  00035	73 6b		 jae	 SHORT $LN14@length_enc

; 470  : 		bittree_reset(lencoder->low[pos_state], LEN_LOW_BITS);

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bt_i$32997[ebp], 0
  0003e	eb 09		 jmp	 SHORT $LN13@length_enc
$LN12@length_enc:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _bt_i$32997[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 f8	 mov	 DWORD PTR _bt_i$32997[ebp], eax
$LN13@length_enc:
  00049	83 7d f8 08	 cmp	 DWORD PTR _bt_i$32997[ebp], 8
  0004d	73 1b		 jae	 SHORT $LN11@length_enc
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _pos_state$32993[ebp]
  00052	c1 e1 04	 shl	 ecx, 4
  00055	8b 55 08	 mov	 edx, DWORD PTR _lencoder$[ebp]
  00058	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0005c	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00061	8b 55 f8	 mov	 edx, DWORD PTR _bt_i$32997[ebp]
  00064	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00068	eb d6		 jmp	 SHORT $LN12@length_enc
$LN11@length_enc:

; 471  : 		bittree_reset(lencoder->mid[pos_state], LEN_MID_BITS);

  0006a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bt_i$33001[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN10@length_enc
$LN9@length_enc:
  00073	8b 45 f4	 mov	 eax, DWORD PTR _bt_i$33001[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 f4	 mov	 DWORD PTR _bt_i$33001[ebp], eax
$LN10@length_enc:
  0007c	83 7d f4 08	 cmp	 DWORD PTR _bt_i$33001[ebp], 8
  00080	73 1e		 jae	 SHORT $LN8@length_enc
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _pos_state$32993[ebp]
  00085	c1 e1 04	 shl	 ecx, 4
  00088	8b 55 08	 mov	 edx, DWORD PTR _lencoder$[ebp]
  0008b	8d 84 0a 04 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+260]
  00092	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00097	8b 55 f4	 mov	 edx, DWORD PTR _bt_i$33001[ebp]
  0009a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  0009e	eb d3		 jmp	 SHORT $LN9@length_enc
$LN8@length_enc:

; 472  : 	}

  000a0	eb 84		 jmp	 SHORT $LN15@length_enc
$LN14@length_enc:

; 473  : 
; 474  : 	bittree_reset(lencoder->high, LEN_HIGH_BITS);

  000a2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bt_i$33005[ebp], 0
  000a9	eb 09		 jmp	 SHORT $LN7@length_enc
$LN6@length_enc:
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _bt_i$33005[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 f0	 mov	 DWORD PTR _bt_i$33005[ebp], eax
$LN7@length_enc:
  000b4	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR _bt_i$33005[ebp], 256 ; 00000100H
  000bb	73 15		 jae	 SHORT $LN5@length_enc
  000bd	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000c2	8b 55 f0	 mov	 edx, DWORD PTR _bt_i$33005[ebp]
  000c5	8b 45 08	 mov	 eax, DWORD PTR _lencoder$[ebp]
  000c8	66 89 8c 50 04
	02 00 00	 mov	 WORD PTR [eax+edx*2+516], cx
  000d0	eb d9		 jmp	 SHORT $LN6@length_enc
$LN5@length_enc:

; 475  : 
; 476  : 	if (!fast_mode)

  000d2	0f b6 4d 10	 movzx	 ecx, BYTE PTR _fast_mode$[ebp]
  000d6	85 c9		 test	 ecx, ecx
  000d8	75 2c		 jne	 SHORT $LN17@length_enc

; 477  : 		for (pos_state = 0; pos_state < num_pos_states;
; 478  : 				++pos_state)

  000da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pos_state$32993[ebp], 0
  000e1	eb 09		 jmp	 SHORT $LN3@length_enc
$LN2@length_enc:
  000e3	8b 55 fc	 mov	 edx, DWORD PTR _pos_state$32993[ebp]
  000e6	83 c2 01	 add	 edx, 1
  000e9	89 55 fc	 mov	 DWORD PTR _pos_state$32993[ebp], edx
$LN3@length_enc:
  000ec	8b 45 fc	 mov	 eax, DWORD PTR _pos_state$32993[ebp]
  000ef	3b 45 0c	 cmp	 eax, DWORD PTR _num_pos_states$[ebp]
  000f2	73 12		 jae	 SHORT $LN17@length_enc

; 479  : 			length_update_prices(lencoder, (const uint32_t)pos_state);

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _pos_state$32993[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 08	 mov	 edx, DWORD PTR _lencoder$[ebp]
  000fb	52		 push	 edx
  000fc	e8 00 00 00 00	 call	 _length_update_prices
  00101	83 c4 08	 add	 esp, 8
  00104	eb dd		 jmp	 SHORT $LN2@length_enc
$LN17@length_enc:

; 480  :   }
; 481  : 
; 482  : 	return;
; 483  : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
_length_encoder_reset ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _length
_TEXT	SEGMENT
_rc$ = 8						; size = 4
_lc$ = 12						; size = 4
_pos_state$ = 16					; size = 4
_len$ = 20						; size = 4
_fast_mode$ = 24					; size = 1
_length	PROC						; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 113  : 	assert(len <= MATCH_LEN_MAX);
; 114  : 	len -= MATCH_LEN_MIN;

  00006	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  00009	83 e8 02	 sub	 eax, 2
  0000c	89 45 14	 mov	 DWORD PTR _len$[ebp], eax

; 115  : 
; 116  : 	if (len < LEN_LOW_SYMBOLS) {

  0000f	83 7d 14 08	 cmp	 DWORD PTR _len$[ebp], 8
  00013	73 58		 jae	 SHORT $LN6@length

; 117  : 		rc_bit(rc, &lc->choice, 0);

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00018	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0001b	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0001e	c7 44 90 20 00
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 0
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00029	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002c	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  00032	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  0003c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0003f	83 c0 01	 add	 eax, 1
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00045	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 118  : 		rc_bittree(rc, lc->low[pos_state], LEN_LOW_BITS, len);

  00048	8b 55 14	 mov	 edx, DWORD PTR _len$[ebp]
  0004b	52		 push	 edx
  0004c	6a 03		 push	 3
  0004e	8b 45 10	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00051	c1 e0 04	 shl	 eax, 4
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  00057	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0005b	52		 push	 edx
  0005c	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _rc_bittree
  00065	83 c4 10	 add	 esp, 16			; 00000010H

; 119  : 	} else {

  00068	e9 f7 00 00 00	 jmp	 $LN5@length
$LN6@length:

; 120  : 		rc_bit(rc, &lc->choice, 1);

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00070	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00073	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00076	c7 44 90 20 01
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 1
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00081	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00084	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  0008a	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx
  00091	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00094	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00097	83 c0 01	 add	 eax, 1
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0009d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 121  : 		len -= LEN_LOW_SYMBOLS;

  000a0	8b 55 14	 mov	 edx, DWORD PTR _len$[ebp]
  000a3	83 ea 08	 sub	 edx, 8
  000a6	89 55 14	 mov	 DWORD PTR _len$[ebp], edx

; 122  : 
; 123  : 		if (len < LEN_MID_SYMBOLS) {

  000a9	83 7d 14 08	 cmp	 DWORD PTR _len$[ebp], 8
  000ad	73 5b		 jae	 SHORT $LN4@length

; 124  : 			rc_bit(rc, &lc->choice2, 0);

  000af	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000b2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b5	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  000b8	c7 44 8a 20 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+32], 0
  000c0	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000c3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _lc$[ebp]
  000c9	83 c2 02	 add	 edx, 2
  000cc	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000cf	89 94 88 08 01
	00 00		 mov	 DWORD PTR [eax+ecx*4+264], edx
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  000d9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000dc	83 c2 01	 add	 edx, 1
  000df	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  000e2	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 125  : 			rc_bittree(rc, lc->mid[pos_state], LEN_MID_BITS, len);

  000e5	8b 4d 14	 mov	 ecx, DWORD PTR _len$[ebp]
  000e8	51		 push	 ecx
  000e9	6a 03		 push	 3
  000eb	8b 55 10	 mov	 edx, DWORD PTR _pos_state$[ebp]
  000ee	c1 e2 04	 shl	 edx, 4
  000f1	8b 45 0c	 mov	 eax, DWORD PTR _lc$[ebp]
  000f4	8d 8c 10 04 01
	00 00		 lea	 ecx, DWORD PTR [eax+edx+260]
  000fb	51		 push	 ecx
  000fc	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 _rc_bittree
  00105	83 c4 10	 add	 esp, 16			; 00000010H

; 126  : 		} else {

  00108	eb 5a		 jmp	 SHORT $LN5@length
$LN4@length:

; 127  : 			rc_bit(rc, &lc->choice2, 1);

  0010a	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0010d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00110	8b 55 08	 mov	 edx, DWORD PTR _rc$[ebp]
  00113	c7 44 8a 20 01
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+32], 1
  0011b	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0011e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00121	8b 55 0c	 mov	 edx, DWORD PTR _lc$[ebp]
  00124	83 c2 02	 add	 edx, 2
  00127	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0012a	89 94 88 08 01
	00 00		 mov	 DWORD PTR [eax+ecx*4+264], edx
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  00134	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00137	83 c2 01	 add	 edx, 1
  0013a	8b 45 08	 mov	 eax, DWORD PTR _rc$[ebp]
  0013d	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 128  : 			len -= LEN_MID_SYMBOLS;

  00140	8b 4d 14	 mov	 ecx, DWORD PTR _len$[ebp]
  00143	83 e9 08	 sub	 ecx, 8
  00146	89 4d 14	 mov	 DWORD PTR _len$[ebp], ecx

; 129  : 			rc_bittree(rc, lc->high, LEN_HIGH_BITS, len);

  00149	8b 55 14	 mov	 edx, DWORD PTR _len$[ebp]
  0014c	52		 push	 edx
  0014d	6a 08		 push	 8
  0014f	8b 45 0c	 mov	 eax, DWORD PTR _lc$[ebp]
  00152	05 04 02 00 00	 add	 eax, 516		; 00000204H
  00157	50		 push	 eax
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _rc$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _rc_bittree
  00161	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@length:

; 130  : 		}
; 131  : 	}
; 132  : 
; 133  : 	// Only getoptimum uses the prices so don't update the table when
; 134  : 	// in fast mode.
; 135  : 	if (!fast_mode)

  00164	0f b6 55 18	 movzx	 edx, BYTE PTR _fast_mode$[ebp]
  00168	85 d2		 test	 edx, edx
  0016a	75 3d		 jne	 SHORT $LN7@length

; 136  : 		if (--lc->counters[pos_state] == 0)

  0016c	8b 45 10	 mov	 eax, DWORD PTR _pos_state$[ebp]
  0016f	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  00172	8b 94 81 08 48
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+18440]
  00179	83 ea 01	 sub	 edx, 1
  0017c	8b 45 10	 mov	 eax, DWORD PTR _pos_state$[ebp]
  0017f	8b 4d 0c	 mov	 ecx, DWORD PTR _lc$[ebp]
  00182	89 94 81 08 48
	00 00		 mov	 DWORD PTR [ecx+eax*4+18440], edx
  00189	8b 55 10	 mov	 edx, DWORD PTR _pos_state$[ebp]
  0018c	8b 45 0c	 mov	 eax, DWORD PTR _lc$[ebp]
  0018f	83 bc 90 08 48
	00 00 00	 cmp	 DWORD PTR [eax+edx*4+18440], 0
  00197	75 10		 jne	 SHORT $LN7@length

; 137  : 			length_update_prices(lc, pos_state);

  00199	8b 4d 10	 mov	 ecx, DWORD PTR _pos_state$[ebp]
  0019c	51		 push	 ecx
  0019d	8b 55 0c	 mov	 edx, DWORD PTR _lc$[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 _length_update_prices
  001a6	83 c4 08	 add	 esp, 8
$LN7@length:

; 138  : }

  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
_length	ENDP
PUBLIC	_lzma_lzma_encoder_reset
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_encoder_reset
_TEXT	SEGMENT
$T79564 = -36						; size = 4
$T79563 = -32						; size = 4
_j$79556 = -28						; size = 4
_coders$79554 = -24					; size = 4
_i$79555 = -20						; size = 4
_bt_i$33041 = -16					; size = 4
_bt_i$33037 = -12					; size = 4
_j$33024 = -8						; size = 4
_i$33020 = -4						; size = 4
_coder$ = 8						; size = 4
_options$ = 12						; size = 4
_lzma_lzma_encoder_reset PROC				; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 490  : 	if (!is_options_valid(options))

  00006	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _is_options_valid
  0000f	83 c4 04	 add	 esp, 4
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 0a		 jne	 SHORT $LN22@lzma_lzma_@11

; 491  : 		return LZMA_OPTIONS_ERROR;

  00019	b8 08 00 00 00	 mov	 eax, 8
  0001e	e9 34 03 00 00	 jmp	 $LN23@lzma_lzma_@11
$LN22@lzma_lzma_@11:

; 492  : 
; 493  : 	coder->pos_mask = (1U << options->pb) - 1;

  00023	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0002e	d3 e0		 shl	 eax, cl
  00030	83 e8 01	 sub	 eax, 1
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00036	89 81 a0 0a 00
	00		 mov	 DWORD PTR [ecx+2720], eax

; 494  : 	coder->literal_context_bits = options->lc;

  0003c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00042	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00045	89 8a a4 0a 00
	00		 mov	 DWORD PTR [edx+2724], ecx

; 495  : 	coder->literal_pos_mask = (1U << options->lp) - 1;

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00056	d3 e0		 shl	 eax, cl
  00058	83 e8 01	 sub	 eax, 1
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0005e	89 81 a8 0a 00
	00		 mov	 DWORD PTR [ecx+2728], eax

; 496  : 
; 497  : 	// Range coder
; 498  : 	rc_reset(&coder->rc);

  00064	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00067	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0006d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00074	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00077	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1
  0007e	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00088	c7 41 10 ff ff
	ff ff		 mov	 DWORD PTR [ecx+16], -1
  0008f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00092	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0
  00096	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00099	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 499  : 
; 500  : 	// State
; 501  : 	coder->state = STATE_LIT_LIT;

  000aa	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ad	c7 82 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+496], 0

; 502  :   { size_t i;
; 503  : 	for (i = 0; i < REPS; ++i)

  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$33020[ebp], 0
  000be	eb 09		 jmp	 SHORT $LN21@lzma_lzma_@11
$LN20@lzma_lzma_@11:
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _i$33020[ebp]
  000c3	83 c0 01	 add	 eax, 1
  000c6	89 45 fc	 mov	 DWORD PTR _i$33020[ebp], eax
$LN21@lzma_lzma_@11:
  000c9	83 7d fc 04	 cmp	 DWORD PTR _i$33020[ebp], 4
  000cd	73 13		 jae	 SHORT $LN19@lzma_lzma_@11

; 504  : 		coder->reps[i] = 0;

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _i$33020[ebp]
  000d2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000d5	c7 84 8a f4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx*4+500], 0
  000e0	eb de		 jmp	 SHORT $LN20@lzma_lzma_@11
$LN19@lzma_lzma_@11:

; 505  : 
; 506  : 	literal_init(coder->literal, options->lc, options->lp);

  000e2	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  000e5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000e8	89 4d dc	 mov	 DWORD PTR $T79564[ebp], ecx
  000eb	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  000ee	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f1	89 45 e0	 mov	 DWORD PTR $T79563[ebp], eax
  000f4	8b 4d e0	 mov	 ecx, DWORD PTR $T79563[ebp]
  000f7	03 4d dc	 add	 ecx, DWORD PTR $T79564[ebp]
  000fa	ba 01 00 00 00	 mov	 edx, 1
  000ff	d3 e2		 shl	 edx, cl
  00101	89 55 e8	 mov	 DWORD PTR _coders$79554[ebp], edx
  00104	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$79555[ebp], 0
  0010b	eb 09		 jmp	 SHORT $LN32@lzma_lzma_@11
$LN31@lzma_lzma_@11:
  0010d	8b 45 ec	 mov	 eax, DWORD PTR _i$79555[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 ec	 mov	 DWORD PTR _i$79555[ebp], eax
$LN32@lzma_lzma_@11:
  00116	8b 4d ec	 mov	 ecx, DWORD PTR _i$79555[ebp]
  00119	3b 4d e8	 cmp	 ecx, DWORD PTR _coders$79554[ebp]
  0011c	73 3e		 jae	 SHORT $LN33@lzma_lzma_@11
  0011e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$79556[ebp], 0
  00125	eb 09		 jmp	 SHORT $LN29@lzma_lzma_@11
$LN28@lzma_lzma_@11:
  00127	8b 55 e4	 mov	 edx, DWORD PTR _j$79556[ebp]
  0012a	83 c2 01	 add	 edx, 1
  0012d	89 55 e4	 mov	 DWORD PTR _j$79556[ebp], edx
$LN29@lzma_lzma_@11:
  00130	81 7d e4 00 03
	00 00		 cmp	 DWORD PTR _j$79556[ebp], 768 ; 00000300H
  00137	73 21		 jae	 SHORT $LN27@lzma_lzma_@11
  00139	8b 45 ec	 mov	 eax, DWORD PTR _i$79555[ebp]
  0013c	69 c0 00 06 00
	00		 imul	 eax, 1536		; 00000600H
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00145	8d 94 01 ac 0a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2732]
  0014c	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00151	8b 4d e4	 mov	 ecx, DWORD PTR _j$79556[ebp]
  00154	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00158	eb cd		 jmp	 SHORT $LN28@lzma_lzma_@11
$LN27@lzma_lzma_@11:
  0015a	eb b1		 jmp	 SHORT $LN31@lzma_lzma_@11
$LN33@lzma_lzma_@11:

; 507  : 
; 508  : 	// Bit encoders
; 509  :   { size_t j;
; 510  : 	for (i = 0; i < STATES; ++i) {

  0015c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$33020[ebp], 0
  00163	eb 09		 jmp	 SHORT $LN18@lzma_lzma_@11
$LN17@lzma_lzma_@11:
  00165	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  00168	83 c2 01	 add	 edx, 1
  0016b	89 55 fc	 mov	 DWORD PTR _i$33020[ebp], edx
$LN18@lzma_lzma_@11:
  0016e	83 7d fc 0c	 cmp	 DWORD PTR _i$33020[ebp], 12 ; 0000000cH
  00172	0f 83 ab 00 00
	00		 jae	 $LN16@lzma_lzma_@11

; 511  : 		for (j = 0; j <= coder->pos_mask; ++j) {

  00178	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$33024[ebp], 0
  0017f	eb 09		 jmp	 SHORT $LN15@lzma_lzma_@11
$LN14@lzma_lzma_@11:
  00181	8b 45 f8	 mov	 eax, DWORD PTR _j$33024[ebp]
  00184	83 c0 01	 add	 eax, 1
  00187	89 45 f8	 mov	 DWORD PTR _j$33024[ebp], eax
$LN15@lzma_lzma_@11:
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0018d	8b 55 f8	 mov	 edx, DWORD PTR _j$33024[ebp]
  00190	3b 91 a0 0a 00
	00		 cmp	 edx, DWORD PTR [ecx+2720]
  00196	77 3a		 ja	 SHORT $LN13@lzma_lzma_@11

; 512  : 			bit_reset(coder->is_match[i][j]);

  00198	8b 45 fc	 mov	 eax, DWORD PTR _i$33020[ebp]
  0019b	c1 e0 05	 shl	 eax, 5
  0019e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001a1	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  001a8	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _j$33024[ebp]
  001b0	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 513  : 			bit_reset(coder->is_rep0_long[i][j]);

  001b4	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  001b7	c1 e2 05	 shl	 edx, 5
  001ba	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001bd	8d 8c 10 8c 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx+27788]
  001c4	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  001c9	8b 45 f8	 mov	 eax, DWORD PTR _j$33024[ebp]
  001cc	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 514  : 		}

  001d0	eb af		 jmp	 SHORT $LN14@lzma_lzma_@11
$LN13@lzma_lzma_@11:

; 515  : 
; 516  : 		bit_reset(coder->is_rep[i]);

  001d2	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001d7	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  001da	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001dd	66 89 8c 50 2c
	6c 00 00	 mov	 WORD PTR [eax+edx*2+27692], cx

; 517  : 		bit_reset(coder->is_rep0[i]);

  001e5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001ea	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  001ed	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001f0	66 89 8c 50 44
	6c 00 00	 mov	 WORD PTR [eax+edx*2+27716], cx

; 518  : 		bit_reset(coder->is_rep1[i]);

  001f8	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001fd	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  00200	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00203	66 89 8c 50 5c
	6c 00 00	 mov	 WORD PTR [eax+edx*2+27740], cx

; 519  : 		bit_reset(coder->is_rep2[i]);

  0020b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00210	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  00213	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00216	66 89 8c 50 74
	6c 00 00	 mov	 WORD PTR [eax+edx*2+27764], cx

; 520  : 	}

  0021e	e9 42 ff ff ff	 jmp	 $LN17@lzma_lzma_@11
$LN16@lzma_lzma_@11:

; 521  :   }
; 522  : 
; 523  : 	for (i = 0; i < FULL_DISTANCES - DIST_MODEL_END; ++i)

  00223	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$33020[ebp], 0
  0022a	eb 09		 jmp	 SHORT $LN12@lzma_lzma_@11
$LN11@lzma_lzma_@11:
  0022c	8b 4d fc	 mov	 ecx, DWORD PTR _i$33020[ebp]
  0022f	83 c1 01	 add	 ecx, 1
  00232	89 4d fc	 mov	 DWORD PTR _i$33020[ebp], ecx
$LN12@lzma_lzma_@11:
  00235	83 7d fc 72	 cmp	 DWORD PTR _i$33020[ebp], 114 ; 00000072H
  00239	73 15		 jae	 SHORT $LN10@lzma_lzma_@11

; 524  : 		bit_reset(coder->dist_special[i]);

  0023b	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00240	8b 45 fc	 mov	 eax, DWORD PTR _i$33020[ebp]
  00243	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00246	66 89 94 41 0c
	70 00 00	 mov	 WORD PTR [ecx+eax*2+28684], dx
  0024e	eb dc		 jmp	 SHORT $LN11@lzma_lzma_@11
$LN10@lzma_lzma_@11:

; 525  : 
; 526  : 	// Bit tree encoders
; 527  : 	for (i = 0; i < DIST_STATES; ++i)

  00250	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$33020[ebp], 0
  00257	eb 09		 jmp	 SHORT $LN9@lzma_lzma_@11
$LN8@lzma_lzma_@11:
  00259	8b 55 fc	 mov	 edx, DWORD PTR _i$33020[ebp]
  0025c	83 c2 01	 add	 edx, 1
  0025f	89 55 fc	 mov	 DWORD PTR _i$33020[ebp], edx
$LN9@lzma_lzma_@11:
  00262	83 7d fc 04	 cmp	 DWORD PTR _i$33020[ebp], 4
  00266	73 38		 jae	 SHORT $LN7@lzma_lzma_@11

; 528  : 		bittree_reset(coder->dist_slot[i], DIST_SLOT_BITS);

  00268	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bt_i$33037[ebp], 0
  0026f	eb 09		 jmp	 SHORT $LN6@lzma_lzma_@11
$LN5@lzma_lzma_@11:
  00271	8b 45 f4	 mov	 eax, DWORD PTR _bt_i$33037[ebp]
  00274	83 c0 01	 add	 eax, 1
  00277	89 45 f4	 mov	 DWORD PTR _bt_i$33037[ebp], eax
$LN6@lzma_lzma_@11:
  0027a	83 7d f4 40	 cmp	 DWORD PTR _bt_i$33037[ebp], 64 ; 00000040H
  0027e	73 1e		 jae	 SHORT $LN4@lzma_lzma_@11
  00280	8b 4d fc	 mov	 ecx, DWORD PTR _i$33020[ebp]
  00283	c1 e1 07	 shl	 ecx, 7
  00286	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00289	8d 84 0a 0c 6e
	00 00		 lea	 eax, DWORD PTR [edx+ecx+28172]
  00290	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00295	8b 55 f4	 mov	 edx, DWORD PTR _bt_i$33037[ebp]
  00298	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  0029c	eb d3		 jmp	 SHORT $LN5@lzma_lzma_@11
$LN4@lzma_lzma_@11:
  0029e	eb b9		 jmp	 SHORT $LN8@lzma_lzma_@11
$LN7@lzma_lzma_@11:

; 529  :   }
; 530  : 
; 531  : 	bittree_reset(coder->dist_align, ALIGN_BITS);

  002a0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bt_i$33041[ebp], 0
  002a7	eb 09		 jmp	 SHORT $LN3@lzma_lzma_@11
$LN2@lzma_lzma_@11:
  002a9	8b 45 f0	 mov	 eax, DWORD PTR _bt_i$33041[ebp]
  002ac	83 c0 01	 add	 eax, 1
  002af	89 45 f0	 mov	 DWORD PTR _bt_i$33041[ebp], eax
$LN3@lzma_lzma_@11:
  002b2	83 7d f0 10	 cmp	 DWORD PTR _bt_i$33041[ebp], 16 ; 00000010H
  002b6	73 15		 jae	 SHORT $LN1@lzma_lzma_@11
  002b8	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002bd	8b 55 f0	 mov	 edx, DWORD PTR _bt_i$33041[ebp]
  002c0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  002c3	66 89 8c 50 f0
	70 00 00	 mov	 WORD PTR [eax+edx*2+28912], cx
  002cb	eb dc		 jmp	 SHORT $LN2@lzma_lzma_@11
$LN1@lzma_lzma_@11:

; 532  : 
; 533  : 	// Length encoders
; 534  : 	length_encoder_reset(&coder->match_len_encoder,
; 535  : 			1U << options->pb, coder->fast_mode);

  002cd	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  002d0	0f b6 91 9c 0a
	00 00		 movzx	 edx, BYTE PTR [ecx+2716]
  002d7	52		 push	 edx
  002d8	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  002db	ba 01 00 00 00	 mov	 edx, 1
  002e0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002e3	d3 e2		 shl	 edx, cl
  002e5	52		 push	 edx
  002e6	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  002e9	05 10 71 00 00	 add	 eax, 28944		; 00007110H
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 _length_encoder_reset
  002f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 536  : 
; 537  : 	length_encoder_reset(&coder->rep_len_encoder,
; 538  : 			1U << options->pb, coder->fast_mode);

  002f7	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  002fa	0f b6 91 9c 0a
	00 00		 movzx	 edx, BYTE PTR [ecx+2716]
  00301	52		 push	 edx
  00302	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00305	ba 01 00 00 00	 mov	 edx, 1
  0030a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0030d	d3 e2		 shl	 edx, cl
  0030f	52		 push	 edx
  00310	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00313	05 58 b9 00 00	 add	 eax, 47448		; 0000b958H
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 _length_encoder_reset
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 539  : 
; 540  : 	// Price counts are incremented every time appropriate probabilities
; 541  : 	// are changed. price counts are set to zero when the price tables
; 542  : 	// are updated, which is done when the appropriate price counts have
; 543  : 	// big enough value, and lzma_mf.read_ahead == 0 which happens at
; 544  : 	// least every OPTS (a few thousand) possible price count increments.
; 545  : 	//
; 546  : 	// By resetting price counts to UINT32_MAX / 2, we make sure that the
; 547  : 	// price tables will be initialized before they will be used (since
; 548  : 	// the value is definitely big enough), and that it is OK to increment
; 549  : 	// price counts without risk of integer overflow (since UINT32_MAX / 2
; 550  : 	// is small enough). The current code doesn't increment price counts
; 551  : 	// before initializing price tables, but it maybe done in future if
; 552  : 	// we add support for saving the state between LZMA2 chunks.
; 553  : 	coder->match_price_count = UINT32_MAX / 2;

  00321	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00324	c7 81 a4 0d 01
	00 ff ff ff 7f	 mov	 DWORD PTR [ecx+69028], 2147483647 ; 7fffffffH

; 554  : 	coder->align_price_count = UINT32_MAX / 2;

  0032e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00331	c7 82 e8 0d 01
	00 ff ff ff 7f	 mov	 DWORD PTR [edx+69096], 2147483647 ; 7fffffffH

; 555  : 
; 556  : 	coder->opts_end_index = 0;

  0033b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0033e	c7 80 ec 0d 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+69100], 0

; 557  : 	coder->opts_current_index = 0;

  00348	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0034b	c7 81 f0 0d 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+69104], 0

; 558  : 
; 559  : 	return LZMA_OK;

  00355	33 c0		 xor	 eax, eax
$LN23@lzma_lzma_@11:

; 560  : }

  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
_lzma_lzma_encoder_reset ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rep_match
_TEXT	SEGMENT
$T79589 = -28						; size = 4
$T79585 = -24						; size = 4
$T79581 = -20						; size = 4
$T79577 = -16						; size = 4
$T79573 = -12						; size = 4
$T79569 = -8						; size = 4
_distance$32885 = -4					; size = 4
_coder$ = 8						; size = 4
_pos_state$ = 12					; size = 4
_rep$ = 16						; size = 4
_len$ = 20						; size = 4
_rep_match PROC						; COMDAT

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 198  : 	if (rep == 0) {

  00006	83 7d 10 00	 cmp	 DWORD PTR _rep$[ebp], 0
  0000a	0f 85 a5 00 00
	00		 jne	 $LN7@rep_match

; 199  : 		rc_bit(&coder->rc, &coder->is_rep0[coder->state], 0);

  00010	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00013	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  00019	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0001c	8d 84 4a 44 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+27716]
  00023	89 45 f8	 mov	 DWORD PTR $T79569[ebp], eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00029	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002f	c7 44 90 20 00
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00040	8b 4d f8	 mov	 ecx, DWORD PTR $T79569[ebp]
  00043	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00050	83 c0 01	 add	 eax, 1
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00056	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 200  : 		rc_bit(&coder->rc,
; 201  : 				&coder->is_rep0_long[coder->state][pos_state],
; 202  : 				len != 1);

  00059	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0005c	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  00062	c1 e0 05	 shl	 eax, 5
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00068	8d 94 01 8c 6c
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27788]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00072	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00075	89 4d f4	 mov	 DWORD PTR $T79573[ebp], ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0007b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0007e	33 c9		 xor	 ecx, ecx
  00080	83 7d 14 01	 cmp	 DWORD PTR _len$[ebp], 1
  00084	0f 95 c1	 setne	 cl
  00087	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0008a	89 4c 82 20	 mov	 DWORD PTR [edx+eax*4+32], ecx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00091	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00094	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00097	8b 45 f4	 mov	 eax, DWORD PTR $T79573[ebp]
  0009a	89 84 8a 08 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+264], eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000a7	83 c2 01	 add	 edx, 1
  000aa	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000ad	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 203  : 	} else {

  000b0	e9 89 01 00 00	 jmp	 $LN6@rep_match
$LN7@rep_match:

; 204  : 		const uint32_t distance = coder->reps[rep];

  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _rep$[ebp]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000bb	8b 84 8a f4 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+500]
  000c2	89 45 fc	 mov	 DWORD PTR _distance$32885[ebp], eax

; 205  : 		rc_bit(&coder->rc, &coder->is_rep0[coder->state], 1);

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000c8	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  000ce	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d1	8d 8c 50 44 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+27716]
  000d8	89 4d f0	 mov	 DWORD PTR $T79577[ebp], ecx
  000db	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000de	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e4	c7 44 81 20 01
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+32], 1
  000ec	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ef	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000f5	8b 55 f0	 mov	 edx, DWORD PTR $T79577[ebp]
  000f8	89 94 81 08 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+264], edx
  000ff	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00102	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00105	83 c1 01	 add	 ecx, 1
  00108	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0010b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 206  : 
; 207  : 		if (rep == 1) {

  0010e	83 7d 10 01	 cmp	 DWORD PTR _rep$[ebp], 1
  00112	75 4e		 jne	 SHORT $LN5@rep_match

; 208  : 			rc_bit(&coder->rc, &coder->is_rep1[coder->state], 0);

  00114	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00117	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  0011d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00120	8d 84 4a 5c 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+27740]
  00127	89 45 ec	 mov	 DWORD PTR $T79581[ebp], eax
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0012d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00130	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00133	c7 44 90 20 00
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 0
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00141	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00144	8b 4d ec	 mov	 ecx, DWORD PTR $T79581[ebp]
  00147	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx
  0014e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00151	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00154	83 c0 01	 add	 eax, 1
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0015a	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 209  : 		} else {

  0015d	e9 be 00 00 00	 jmp	 $LN4@rep_match
$LN5@rep_match:

; 210  : 			rc_bit(&coder->rc, &coder->is_rep1[coder->state], 1);

  00162	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00165	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0016e	8d 94 41 5c 6c
	00 00		 lea	 edx, DWORD PTR [ecx+eax*2+27740]
  00175	89 55 e8	 mov	 DWORD PTR $T79585[ebp], edx
  00178	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0017b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0017e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00181	c7 44 8a 20 01
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+32], 1
  00189	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0018c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0018f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00192	8b 45 e8	 mov	 eax, DWORD PTR $T79585[ebp]
  00195	89 84 8a 08 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+264], eax
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0019f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001a2	83 c2 01	 add	 edx, 1
  001a5	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001a8	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 211  : 			rc_bit(&coder->rc, &coder->is_rep2[coder->state],
; 212  : 					rep - 2);

  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ae	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  001b4	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001b7	8d 8c 50 74 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+27764]
  001be	89 4d e4	 mov	 DWORD PTR $T79589[ebp], ecx
  001c1	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001c4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001c7	8b 4d 10	 mov	 ecx, DWORD PTR _rep$[ebp]
  001ca	83 e9 02	 sub	 ecx, 2
  001cd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001d0	89 4c 82 20	 mov	 DWORD PTR [edx+eax*4+32], ecx
  001d4	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001d7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001da	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001dd	8b 45 e4	 mov	 eax, DWORD PTR $T79589[ebp]
  001e0	89 84 8a 08 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+264], eax
  001e7	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ea	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001ed	83 c2 01	 add	 edx, 1
  001f0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001f3	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 213  : 
; 214  : 			if (rep == 3)

  001f6	83 7d 10 03	 cmp	 DWORD PTR _rep$[ebp], 3
  001fa	75 12		 jne	 SHORT $LN3@rep_match

; 215  : 				coder->reps[3] = coder->reps[2];

  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ff	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00202	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  00208	89 81 00 02 00
	00		 mov	 DWORD PTR [ecx+512], eax
$LN3@rep_match:

; 216  : 
; 217  : 			coder->reps[2] = coder->reps[1];

  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00211	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00214	8b 82 f8 01 00
	00		 mov	 eax, DWORD PTR [edx+504]
  0021a	89 81 fc 01 00
	00		 mov	 DWORD PTR [ecx+508], eax
$LN4@rep_match:

; 218  : 		}
; 219  : 
; 220  : 		coder->reps[1] = coder->reps[0];

  00220	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00223	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00226	8b 82 f4 01 00
	00		 mov	 eax, DWORD PTR [edx+500]
  0022c	89 81 f8 01 00
	00		 mov	 DWORD PTR [ecx+504], eax

; 221  : 		coder->reps[0] = distance;

  00232	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00235	8b 55 fc	 mov	 edx, DWORD PTR _distance$32885[ebp]
  00238	89 91 f4 01 00
	00		 mov	 DWORD PTR [ecx+500], edx
$LN6@rep_match:

; 222  : 	}
; 223  : 
; 224  : 	if (len == 1) {

  0023e	83 7d 14 01	 cmp	 DWORD PTR _len$[ebp], 1
  00242	75 1e		 jne	 SHORT $LN2@rep_match

; 225  : 		update_short_rep(coder->state);

  00244	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00247	33 c9		 xor	 ecx, ecx
  00249	83 b8 f0 01 00
	00 07		 cmp	 DWORD PTR [eax+496], 7
  00250	0f 9d c1	 setge	 cl
  00253	8d 4c 09 09	 lea	 ecx, DWORD PTR [ecx+ecx+9]
  00257	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0025a	89 8a f0 01 00
	00		 mov	 DWORD PTR [edx+496], ecx

; 226  : 	} else {

  00260	eb 4a		 jmp	 SHORT $LN8@rep_match
$LN2@rep_match:

; 227  : 		length(&coder->rc, &coder->rep_len_encoder, pos_state, len,
; 228  : 				coder->fast_mode);

  00262	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00265	0f b6 88 9c 0a
	00 00		 movzx	 ecx, BYTE PTR [eax+2716]
  0026c	51		 push	 ecx
  0026d	8b 55 14	 mov	 edx, DWORD PTR _len$[ebp]
  00270	52		 push	 edx
  00271	8b 45 0c	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00274	50		 push	 eax
  00275	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00278	81 c1 58 b9 00
	00		 add	 ecx, 47448		; 0000b958H
  0027e	51		 push	 ecx
  0027f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00282	52		 push	 edx
  00283	e8 00 00 00 00	 call	 _length
  00288	83 c4 14	 add	 esp, 20			; 00000014H

; 229  : 		update_long_rep(coder->state);

  0028b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0028e	33 c9		 xor	 ecx, ecx
  00290	83 b8 f0 01 00
	00 07		 cmp	 DWORD PTR [eax+496], 7
  00297	0f 9d c1	 setge	 cl
  0029a	83 e9 01	 sub	 ecx, 1
  0029d	83 e1 fd	 and	 ecx, -3			; fffffffdH
  002a0	83 c1 0b	 add	 ecx, 11			; 0000000bH
  002a3	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002a6	89 8a f0 01 00
	00		 mov	 DWORD PTR [edx+496], ecx
$LN8@rep_match:

; 230  : 	}
; 231  : }

  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c3		 ret	 0
_rep_match ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _match
_TEXT	SEGMENT
tv79 = -64						; size = 4
$T79650 = -52						; size = 4
_base$32869 = -20					; size = 4
_footer_bits$32868 = -16				; size = 4
_dist_reduced$32870 = -12				; size = 4
_dist_slot$32865 = -8					; size = 4
_dist_state$32866 = -4					; size = 4
_coder$ = 8						; size = 4
_pos_state$ = 12					; size = 4
_distance$ = 16						; size = 4
_len$ = 20						; size = 4
_match	PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 149  : 	update_match(coder->state);

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	83 b8 f0 01 00
	00 07		 cmp	 DWORD PTR [eax+496], 7
  00012	0f 9d c1	 setge	 cl
  00015	83 e9 01	 sub	 ecx, 1
  00018	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0001b	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0001e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00021	89 8a f0 01 00
	00		 mov	 DWORD PTR [edx+496], ecx

; 150  : 
; 151  : 	length(&coder->rc, &coder->match_len_encoder, pos_state, len,
; 152  : 			coder->fast_mode);

  00027	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002a	0f b6 88 9c 0a
	00 00		 movzx	 ecx, BYTE PTR [eax+2716]
  00031	51		 push	 ecx
  00032	8b 55 14	 mov	 edx, DWORD PTR _len$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003d	81 c1 10 71 00
	00		 add	 ecx, 28944		; 00007110H
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _length
  0004d	83 c4 14	 add	 esp, 20			; 00000014H

; 153  : 
; 154  :   {
; 155  : 	const uint32_t dist_slot = get_dist_slot(distance);

  00050	81 7d 10 00 20
	00 00		 cmp	 DWORD PTR _distance$[ebp], 8192 ; 00002000H
  00057	73 0f		 jae	 SHORT $LN24@match
  00059	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  0005c	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_fastpos[eax]
  00063	89 4d f8	 mov	 DWORD PTR _dist_slot$32865[ebp], ecx
  00066	eb 31		 jmp	 SHORT $LN25@match
$LN24@match:
  00068	81 7d 10 00 00
	00 02		 cmp	 DWORD PTR _distance$[ebp], 33554432 ; 02000000H
  0006f	73 15		 jae	 SHORT $LN23@match
  00071	8b 55 10	 mov	 edx, DWORD PTR _distance$[ebp]
  00074	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  00077	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  0007e	83 c0 18	 add	 eax, 24			; 00000018H
  00081	89 45 f8	 mov	 DWORD PTR _dist_slot$32865[ebp], eax
  00084	eb 13		 jmp	 SHORT $LN25@match
$LN23@match:
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _distance$[ebp]
  00089	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0008c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_fastpos[ecx]
  00093	83 c2 30	 add	 edx, 48			; 00000030H
  00096	89 55 f8	 mov	 DWORD PTR _dist_slot$32865[ebp], edx
$LN25@match:

; 156  : 	const uint32_t dist_state = get_dist_state(len);

  00099	83 7d 14 06	 cmp	 DWORD PTR _len$[ebp], 6
  0009d	73 0b		 jae	 SHORT $LN6@match
  0009f	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  000a2	83 e8 02	 sub	 eax, 2
  000a5	89 45 c0	 mov	 DWORD PTR tv79[ebp], eax
  000a8	eb 07		 jmp	 SHORT $LN7@match
$LN6@match:
  000aa	c7 45 c0 03 00
	00 00		 mov	 DWORD PTR tv79[ebp], 3
$LN7@match:
  000b1	8b 4d c0	 mov	 ecx, DWORD PTR tv79[ebp]
  000b4	89 4d fc	 mov	 DWORD PTR _dist_state$32866[ebp], ecx

; 157  : 	rc_bittree(&coder->rc, coder->dist_slot[dist_state],
; 158  : 			DIST_SLOT_BITS, dist_slot);

  000b7	8b 55 f8	 mov	 edx, DWORD PTR _dist_slot$32865[ebp]
  000ba	52		 push	 edx
  000bb	6a 06		 push	 6
  000bd	8b 45 fc	 mov	 eax, DWORD PTR _dist_state$32866[ebp]
  000c0	c1 e0 07	 shl	 eax, 7
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000c6	8d 94 01 0c 6e
	00 00		 lea	 edx, DWORD PTR [ecx+eax+28172]
  000cd	52		 push	 edx
  000ce	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _rc_bittree
  000d7	83 c4 10	 add	 esp, 16			; 00000010H

; 159  : 
; 160  : 	if (dist_slot >= DIST_MODEL_START) {

  000da	83 7d f8 04	 cmp	 DWORD PTR _dist_slot$32865[ebp], 4
  000de	0f 82 d2 00 00
	00		 jb	 $LN3@match

; 161  : 		const uint32_t footer_bits = (dist_slot >> 1) - 1;

  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _dist_slot$32865[ebp]
  000e7	d1 e9		 shr	 ecx, 1
  000e9	83 e9 01	 sub	 ecx, 1
  000ec	89 4d f0	 mov	 DWORD PTR _footer_bits$32868[ebp], ecx

; 162  : 		const uint32_t base = (2 | (dist_slot & 1)) << footer_bits;

  000ef	8b 55 f8	 mov	 edx, DWORD PTR _dist_slot$32865[ebp]
  000f2	83 e2 01	 and	 edx, 1
  000f5	83 ca 02	 or	 edx, 2
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _footer_bits$32868[ebp]
  000fb	d3 e2		 shl	 edx, cl
  000fd	89 55 ec	 mov	 DWORD PTR _base$32869[ebp], edx

; 163  : 		const uint32_t dist_reduced = distance - base;

  00100	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  00103	2b 45 ec	 sub	 eax, DWORD PTR _base$32869[ebp]
  00106	89 45 f4	 mov	 DWORD PTR _dist_reduced$32870[ebp], eax

; 164  : 
; 165  : 		if (dist_slot < DIST_MODEL_END) {

  00109	83 7d f8 0e	 cmp	 DWORD PTR _dist_slot$32865[ebp], 14 ; 0000000eH
  0010d	73 2e		 jae	 SHORT $LN2@match

; 166  : 			// Careful here: base - dist_slot - 1 can be -1, but
; 167  : 			// rc_bittree_reverse starts at probs[1], not probs[0].
; 168  : 			rc_bittree_reverse(&coder->rc,
; 169  : 				coder->dist_special + base - dist_slot - 1,
; 170  : 				footer_bits, dist_reduced);

  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _dist_reduced$32870[ebp]
  00112	51		 push	 ecx
  00113	8b 55 f0	 mov	 edx, DWORD PTR _footer_bits$32868[ebp]
  00116	52		 push	 edx
  00117	8b 45 ec	 mov	 eax, DWORD PTR _base$32869[ebp]
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0011d	8d 94 41 0c 70
	00 00		 lea	 edx, DWORD PTR [ecx+eax*2+28684]
  00124	8b 45 f8	 mov	 eax, DWORD PTR _dist_slot$32865[ebp]
  00127	d1 e0		 shl	 eax, 1
  00129	2b d0		 sub	 edx, eax
  0012b	83 ea 02	 sub	 edx, 2
  0012e	52		 push	 edx
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 _rc_bittree_reverse
  00138	83 c4 10	 add	 esp, 16			; 00000010H

; 171  : 		} else {

  0013b	eb 79		 jmp	 SHORT $LN3@match
$LN2@match:

; 172  : 			rc_direct(&coder->rc, dist_reduced >> ALIGN_BITS,
; 173  : 					footer_bits - ALIGN_BITS);

  0013d	8b 55 f0	 mov	 edx, DWORD PTR _footer_bits$32868[ebp]
  00140	83 ea 04	 sub	 edx, 4
  00143	89 55 cc	 mov	 DWORD PTR $T79650[ebp], edx
$LN43@match:
  00146	8b 45 cc	 mov	 eax, DWORD PTR $T79650[ebp]
  00149	83 e8 01	 sub	 eax, 1
  0014c	89 45 cc	 mov	 DWORD PTR $T79650[ebp], eax
  0014f	8b 55 f4	 mov	 edx, DWORD PTR _dist_reduced$32870[ebp]
  00152	c1 ea 04	 shr	 edx, 4
  00155	8b 4d cc	 mov	 ecx, DWORD PTR $T79650[ebp]
  00158	d3 ea		 shr	 edx, cl
  0015a	83 e2 01	 and	 edx, 1
  0015d	83 c2 02	 add	 edx, 2
  00160	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00163	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00166	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00169	89 54 88 20	 mov	 DWORD PTR [eax+ecx*4+32], edx
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00170	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00173	83 c2 01	 add	 edx, 1
  00176	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00179	89 50 18	 mov	 DWORD PTR [eax+24], edx
  0017c	83 7d cc 00	 cmp	 DWORD PTR $T79650[ebp], 0
  00180	75 c4		 jne	 SHORT $LN43@match

; 174  : 			rc_bittree_reverse(
; 175  : 					&coder->rc, coder->dist_align,
; 176  : 					ALIGN_BITS, dist_reduced & ALIGN_MASK);

  00182	8b 4d f4	 mov	 ecx, DWORD PTR _dist_reduced$32870[ebp]
  00185	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00188	51		 push	 ecx
  00189	6a 04		 push	 4
  0018b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0018e	81 c2 f0 70 00
	00		 add	 edx, 28912		; 000070f0H
  00194	52		 push	 edx
  00195	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _rc_bittree_reverse
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 177  : 			++coder->align_price_count;

  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001a4	8b 91 e8 0d 01
	00		 mov	 edx, DWORD PTR [ecx+69096]
  001aa	83 c2 01	 add	 edx, 1
  001ad	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001b0	89 90 e8 0d 01
	00		 mov	 DWORD PTR [eax+69096], edx
$LN3@match:

; 178  : 		}
; 179  : 	}
; 180  : 
; 181  : 	coder->reps[3] = coder->reps[2];

  001b6	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001b9	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001bc	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  001c2	89 81 00 02 00
	00		 mov	 DWORD PTR [ecx+512], eax

; 182  : 	coder->reps[2] = coder->reps[1];

  001c8	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001cb	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001ce	8b 82 f8 01 00
	00		 mov	 eax, DWORD PTR [edx+504]
  001d4	89 81 fc 01 00
	00		 mov	 DWORD PTR [ecx+508], eax

; 183  : 	coder->reps[1] = coder->reps[0];

  001da	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001dd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001e0	8b 82 f4 01 00
	00		 mov	 eax, DWORD PTR [edx+500]
  001e6	89 81 f8 01 00
	00		 mov	 DWORD PTR [ecx+504], eax

; 184  : 	coder->reps[0] = distance;

  001ec	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ef	8b 55 10	 mov	 edx, DWORD PTR _distance$[ebp]
  001f2	89 91 f4 01 00
	00		 mov	 DWORD PTR [ecx+500], edx

; 185  : 	++coder->match_price_count;

  001f8	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001fb	8b 88 a4 0d 01
	00		 mov	 ecx, DWORD PTR [eax+69028]
  00201	83 c1 01	 add	 ecx, 1
  00204	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00207	89 8a a4 0d 01
	00		 mov	 DWORD PTR [edx+69028], ecx

; 186  :   }
; 187  : }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
_match	ENDP
PUBLIC	_lzma_lzma_encoder_create
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_encoder_create
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv70 = -12						; size = 4
_log_size$33066 = -8					; size = 4
_coder$33059 = -4					; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_lz_options$ = 20					; size = 4
_lzma_lzma_encoder_create PROC				; COMDAT

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 568  : 	// Allocate lzma_lzma1_encoder if it wasn't already allocated.
; 569  : 	if (*coder_ptr == NULL) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	75 28		 jne	 SHORT $LN9@lzma_lzma_@12

; 570  : 		*coder_ptr = lzma_alloc(sizeof(lzma_lzma1_encoder), allocator);

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00011	51		 push	 ecx
  00012	68 f8 cd 03 00	 push	 249336			; 0003cdf8H
  00017	e8 00 00 00 00	 call	 _lzma_alloc
  0001c	83 c4 08	 add	 esp, 8
  0001f	8b 55 08	 mov	 edx, DWORD PTR _coder_ptr$[ebp]
  00022	89 02		 mov	 DWORD PTR [edx], eax

; 571  : 		if (*coder_ptr == NULL)

  00024	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 0a		 jne	 SHORT $LN9@lzma_lzma_@12

; 572  : 			return LZMA_MEM_ERROR;

  0002c	b8 05 00 00 00	 mov	 eax, 5
  00031	e9 eb 00 00 00	 jmp	 $LN10@lzma_lzma_@12
$LN9@lzma_lzma_@12:

; 573  : 	}
; 574  : 
; 575  :   { lzma_lzma1_encoder *coder = *coder_ptr;

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _coder_ptr$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	89 55 fc	 mov	 DWORD PTR _coder$33059[ebp], edx

; 576  : 
; 577  : 	// Set compression mode. We haven't validates the options yet,
; 578  : 	// but it's OK here, since nothing bad happens with invalid
; 579  : 	// options in the code below, and they will get rejected by
; 580  : 	// lzma_lzma_encoder_reset() call at the end of this function.
; 581  : 	switch (options->mode) {

  0003e	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00041	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00044	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00047	83 7d f4 01	 cmp	 DWORD PTR tv70[ebp], 1
  0004b	74 08		 je	 SHORT $LN5@lzma_lzma_@12
  0004d	83 7d f4 02	 cmp	 DWORD PTR tv70[ebp], 2
  00051	74 0e		 je	 SHORT $LN4@lzma_lzma_@12
  00053	eb 6d		 jmp	 SHORT $LN1@lzma_lzma_@12
$LN5@lzma_lzma_@12:

; 582  : 		case LZMA_MODE_FAST:
; 583  : 			coder->fast_mode = true;

  00055	8b 55 fc	 mov	 edx, DWORD PTR _coder$33059[ebp]
  00058	c6 82 9c 0a 00
	00 01		 mov	 BYTE PTR [edx+2716], 1

; 584  : 			break;

  0005f	eb 68		 jmp	 SHORT $LN6@lzma_lzma_@12
$LN4@lzma_lzma_@12:

; 585  : 
; 586  : 		case LZMA_MODE_NORMAL: {
; 587  : 			coder->fast_mode = false;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  00064	c6 80 9c 0a 00
	00 00		 mov	 BYTE PTR [eax+2716], 0

; 588  : 
; 589  : 			// Set dist_table_size.
; 590  : 			// Round the dictionary size up to next 2^n.
; 591  : 		  { uint32_t log_size = 0;

  0006b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _log_size$33066[ebp], 0
$LN3@lzma_lzma_@12:

; 592  : 			while ((UINT32_C(1) << log_size) < options->dict_size)

  00072	ba 01 00 00 00	 mov	 edx, 1
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _log_size$33066[ebp]
  0007a	d3 e2		 shl	 edx, cl
  0007c	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0007f	3b 10		 cmp	 edx, DWORD PTR [eax]
  00081	73 0b		 jae	 SHORT $LN2@lzma_lzma_@12

; 593  : 				++log_size;

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _log_size$33066[ebp]
  00086	83 c1 01	 add	 ecx, 1
  00089	89 4d f8	 mov	 DWORD PTR _log_size$33066[ebp], ecx
  0008c	eb e4		 jmp	 SHORT $LN3@lzma_lzma_@12
$LN2@lzma_lzma_@12:

; 594  : 
; 595  : 			coder->dist_table_size = log_size * 2;

  0008e	8b 55 f8	 mov	 edx, DWORD PTR _log_size$33066[ebp]
  00091	d1 e2		 shl	 edx, 1
  00093	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  00096	89 90 a0 0d 01
	00		 mov	 DWORD PTR [eax+69024], edx

; 596  : 		  }
; 597  : 
; 598  : 			// Length encoders' price table size
; 599  : 			coder->match_len_encoder.table_size
; 600  : 				= options->nice_len + 1 - MATCH_LEN_MIN;

  0009c	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0009f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a2	83 ea 01	 sub	 edx, 1
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  000a8	89 90 14 b9 00
	00		 mov	 DWORD PTR [eax+47380], edx

; 601  : 			coder->rep_len_encoder.table_size
; 602  : 				= options->nice_len + 1 - MATCH_LEN_MIN;

  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  000b1	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000b4	83 ea 01	 sub	 edx, 1
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  000ba	89 90 5c 01 01
	00		 mov	 DWORD PTR [eax+65884], edx

; 603  : 			break;

  000c0	eb 07		 jmp	 SHORT $LN6@lzma_lzma_@12
$LN1@lzma_lzma_@12:

; 604  : 		}
; 605  : 
; 606  : 		default:
; 607  : 			return LZMA_OPTIONS_ERROR;

  000c2	b8 08 00 00 00	 mov	 eax, 8
  000c7	eb 58		 jmp	 SHORT $LN10@lzma_lzma_@12
$LN6@lzma_lzma_@12:

; 608  : 	}
; 609  : 
; 610  : 	// We don't need to write the first byte as literal if there is
; 611  : 	// a non-empty preset dictionary. encode_init() wouldn't even work
; 612  : 	// if there is a non-empty preset dictionary, because encode_init()
; 613  : 	// assumes that position is zero and previous byte is also zero.
; 614  : 	coder->is_initialized = options->preset_dict != NULL
; 615  : 			&& options->preset_dict_size > 0;

  000c9	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  000cc	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000d0	74 12		 je	 SHORT $LN12@lzma_lzma_@12
  000d2	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  000d5	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000d9	76 09		 jbe	 SHORT $LN12@lzma_lzma_@12
  000db	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  000e2	eb 07		 jmp	 SHORT $LN13@lzma_lzma_@12
$LN12@lzma_lzma_@12:
  000e4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN13@lzma_lzma_@12:
  000eb	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  000ee	8a 4d f0	 mov	 cl, BYTE PTR tv93[ebp]
  000f1	88 88 9d 0a 00
	00		 mov	 BYTE PTR [eax+2717], cl

; 616  : 	coder->is_flushed = false;

  000f7	8b 55 fc	 mov	 edx, DWORD PTR _coder$33059[ebp]
  000fa	c6 82 9e 0a 00
	00 00		 mov	 BYTE PTR [edx+2718], 0

; 617  : 
; 618  : 	set_lz_options(lz_options, options);

  00101	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00104	50		 push	 eax
  00105	8b 4d 14	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00108	51		 push	 ecx
  00109	e8 00 00 00 00	 call	 _set_lz_options
  0010e	83 c4 08	 add	 esp, 8

; 619  : 
; 620  : 	return lzma_lzma_encoder_reset(coder, options);

  00111	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00114	52		 push	 edx
  00115	8b 45 fc	 mov	 eax, DWORD PTR _coder$33059[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _lzma_lzma_encoder_reset
  0011e	83 c4 08	 add	 esp, 8
$LN10@lzma_lzma_@12:

; 621  :   }
; 622  : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
_lzma_lzma_encoder_create ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _encode_eopm
_TEXT	SEGMENT
$T79838 = -12						; size = 4
$T79834 = -8						; size = 4
_pos_state$ = -4					; size = 4
_coder$ = 8						; size = 4
_position$ = 12						; size = 4
_encode_eopm PROC					; COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 303  : 	const uint32_t pos_state = position & coder->pos_mask;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _position$[ebp]
  0000c	23 88 a0 0a 00
	00		 and	 ecx, DWORD PTR [eax+2720]
  00012	89 4d fc	 mov	 DWORD PTR _pos_state$[ebp], ecx

; 304  : 	rc_bit(&coder->rc, &coder->is_match[coder->state][pos_state], 1);

  00015	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00018	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  0001e	c1 e0 05	 shl	 eax, 5
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _pos_state$[ebp]
  0002e	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00031	89 4d f8	 mov	 DWORD PTR $T79834[ebp], ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00037	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003d	c7 44 81 20 01
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+32], 1
  00045	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00048	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004e	8b 55 f8	 mov	 edx, DWORD PTR $T79834[ebp]
  00051	89 94 81 08 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+264], edx
  00058	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005e	83 c1 01	 add	 ecx, 1
  00061	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00064	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 305  : 	rc_bit(&coder->rc, &coder->is_rep[coder->state], 0);

  00067	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0006a	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  00070	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00073	8d 84 4a 2c 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+27692]
  0007a	89 45 f4	 mov	 DWORD PTR $T79838[ebp], eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00080	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00083	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00086	c7 44 90 20 00
	00 00 00	 mov	 DWORD PTR [eax+edx*4+32], 0
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00091	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00094	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00097	8b 4d f4	 mov	 ecx, DWORD PTR $T79838[ebp]
  0009a	89 8c 90 08 01
	00 00		 mov	 DWORD PTR [eax+edx*4+264], ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000a4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a7	83 c0 01	 add	 eax, 1
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ad	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 306  : 	match(coder, pos_state, UINT32_MAX, MATCH_LEN_MIN);

  000b0	6a 02		 push	 2
  000b2	6a ff		 push	 -1
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _pos_state$[ebp]
  000b7	52		 push	 edx
  000b8	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _match
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 307  : }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_encode_eopm ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _encode_symbol
_TEXT	SEGMENT
$T79909 = -52						; size = 4
$T79896 = -36						; size = 4
$T79892 = -32						; size = 4
$T79874 = -8						; size = 4
_pos_state$ = -4					; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_back$ = 16						; size = 4
_len$ = 20						; size = 4
_position$ = 24						; size = 4
_encode_symbol PROC					; COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 242  : 	const uint32_t pos_state = position & coder->pos_mask;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 4d 18	 mov	 ecx, DWORD PTR _position$[ebp]
  0000c	23 88 a0 0a 00
	00		 and	 ecx, DWORD PTR [eax+2720]
  00012	89 4d fc	 mov	 DWORD PTR _pos_state$[ebp], ecx

; 243  : 
; 244  : 	if (back == UINT32_MAX) {

  00015	83 7d 10 ff	 cmp	 DWORD PTR _back$[ebp], -1
  00019	75 6b		 jne	 SHORT $LN4@encode_sym

; 245  : 		// Literal i.e. eight-bit byte
; 246  : 		assert(len == 1);
; 247  : 		rc_bit(&coder->rc,
; 248  : 				&coder->is_match[coder->state][pos_state], 0);

  0001b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0001e	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  00024	c1 e0 05	 shl	 eax, 5
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0002a	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  00031	8b 45 fc	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00034	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00037	89 4d f8	 mov	 DWORD PTR $T79874[ebp], ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00043	c7 44 81 20 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+32], 0
  0004b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00054	8b 55 f8	 mov	 edx, DWORD PTR $T79874[ebp]
  00057	89 94 81 08 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+264], edx
  0005e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00061	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00064	83 c1 01	 add	 ecx, 1
  00067	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0006a	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 249  : 		literal(coder, mf, position);

  0006d	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _literal
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 250  : 	} else {

  00081	e9 1f 01 00 00	 jmp	 $LN3@encode_sym
$LN4@encode_sym:

; 251  : 		// Some type of match
; 252  : 		rc_bit(&coder->rc,
; 253  : 			&coder->is_match[coder->state][pos_state], 1);

  00086	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00089	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  0008f	c1 e1 05	 shl	 ecx, 5
  00092	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00095	8d 84 0a ac 6a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27308]
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _pos_state$[ebp]
  0009f	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000a2	89 55 e0	 mov	 DWORD PTR $T79892[ebp], edx
  000a5	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000a8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ab	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ae	c7 44 8a 20 01
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+32], 1
  000b6	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000b9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000bc	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000bf	8b 45 e0	 mov	 eax, DWORD PTR $T79892[ebp]
  000c2	89 84 8a 08 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+264], eax
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000cc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000cf	83 c2 01	 add	 edx, 1
  000d2	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d5	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 254  : 
; 255  : 		if (back < REPS) {

  000d8	83 7d 10 04	 cmp	 DWORD PTR _back$[ebp], 4
  000dc	73 63		 jae	 SHORT $LN2@encode_sym

; 256  : 			// It's a repeated match i.e. the same distance
; 257  : 			// has been used earlier.
; 258  : 			rc_bit(&coder->rc, &coder->is_rep[coder->state], 1);

  000de	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e1	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  000e7	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000ea	8d 8c 50 2c 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+27692]
  000f1	89 4d dc	 mov	 DWORD PTR $T79896[ebp], ecx
  000f4	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000f7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000fd	c7 44 81 20 01
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+32], 1
  00105	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00108	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0010e	8b 55 dc	 mov	 edx, DWORD PTR $T79896[ebp]
  00111	89 94 81 08 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+264], edx
  00118	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0011b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0011e	83 c1 01	 add	 ecx, 1
  00121	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00124	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 259  : 			rep_match(coder, pos_state, back, len);

  00127	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d 10	 mov	 ecx, DWORD PTR _back$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 fc	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00132	52		 push	 edx
  00133	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _rep_match
  0013c	83 c4 10	 add	 esp, 16			; 00000010H

; 260  : 		} else {

  0013f	eb 64		 jmp	 SHORT $LN3@encode_sym
$LN2@encode_sym:

; 261  : 			// Normal match
; 262  : 			rc_bit(&coder->rc, &coder->is_rep[coder->state], 0);

  00141	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00144	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  0014a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0014d	8d 8c 50 2c 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+27692]
  00154	89 4d cc	 mov	 DWORD PTR $T79909[ebp], ecx
  00157	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0015a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00160	c7 44 81 20 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+32], 0
  00168	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0016b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00171	8b 55 cc	 mov	 edx, DWORD PTR $T79909[ebp]
  00174	89 94 81 08 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+264], edx
  0017b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0017e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00181	83 c1 01	 add	 ecx, 1
  00184	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00187	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 263  : 			match(coder, pos_state, back - REPS, len);

  0018a	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0018d	50		 push	 eax
  0018e	8b 4d 10	 mov	 ecx, DWORD PTR _back$[ebp]
  00191	83 e9 04	 sub	 ecx, 4
  00194	51		 push	 ecx
  00195	8b 55 fc	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00198	52		 push	 edx
  00199	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _match
  001a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@encode_sym:

; 264  : 		}
; 265  : 	}
; 266  : 
; 267  : 	assert(mf->read_ahead >= len);
; 268  : 	mf->read_ahead -= len;

  001a5	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  001a8	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001ab	2b 55 14	 sub	 edx, DWORD PTR _len$[ebp]
  001ae	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  001b1	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 269  : }

  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
_encode_symbol ENDP
PUBLIC	_lzma_lzma_encode
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_encode
_TEXT	SEGMENT
tv196 = -48						; size = 8
_back$32955 = -12					; size = 4
_len$32954 = -8						; size = 4
_position$32943 = -4					; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_out$ = 16						; size = 4
_out_pos$ = 20						; size = 4
_out_size$ = 24						; size = 4
_limit$ = 28						; size = 4
_lzma_lzma_encode PROC					; COMDAT

; 320  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi

; 321  : 	// Initialize the stream if no data has been encoded yet.
; 322  : 	if (!coder->is_initialized && !encode_init(coder, mf))

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0000a	0f b6 88 9d 0a
	00 00		 movzx	 ecx, BYTE PTR [eax+2717]
  00011	85 c9		 test	 ecx, ecx
  00013	75 1e		 jne	 SHORT $LN17@lzma_lzma_@13
  00015	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _encode_init
  00022	83 c4 08	 add	 esp, 8
  00025	0f b6 c8	 movzx	 ecx, al
  00028	85 c9		 test	 ecx, ecx
  0002a	75 07		 jne	 SHORT $LN17@lzma_lzma_@13

; 323  : 		return LZMA_OK;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 96 01 00 00	 jmp	 $LN15@lzma_lzma_@13

; 324  : 
; 325  : 	// Get the lowest bits of the uncompressed offset from the LZ layer.
; 326  :   { uint32_t position = mf_position(mf);

$LN17@lzma_lzma_@13:
  00033	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00036	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00039	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0003c	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  0003f	89 4d fc	 mov	 DWORD PTR _position$32943[ebp], ecx
$LN13@lzma_lzma_@13:

; 327  : 
; 328  : 	while (true) {

  00042	ba 01 00 00 00	 mov	 edx, 1
  00047	85 d2		 test	 edx, edx
  00049	0f 84 0e 01 00
	00		 je	 $LN12@lzma_lzma_@13

; 329  : 		// Encode pending bits, if any. Calling this before encoding
; 330  : 		// the next symbol is needed only with plain LZMA, since
; 331  : 		// LZMA2 always provides big enough buffer to flush
; 332  : 		// everything out from the range encoder. For the same reason,
; 333  : 		// rc_encode() never returns true when this function is used
; 334  : 		// as part of LZMA2 encoder.
; 335  : 		if (rc_encode(&coder->rc, out, out_pos, out_size)) {

  0004f	8b 45 18	 mov	 eax, DWORD PTR _out_size$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 14	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _rc_encode
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	0f b6 c8	 movzx	 ecx, al
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 07		 je	 SHORT $LN11@lzma_lzma_@13

; 336  : 			assert(limit == UINT32_MAX);
; 337  : 			return LZMA_OK;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 54 01 00 00	 jmp	 $LN15@lzma_lzma_@13
$LN11@lzma_lzma_@13:

; 338  : 		}
; 339  : 
; 340  : 		// With LZMA2 we need to take care that compressed size of
; 341  : 		// a chunk doesn't get too big.
; 342  : 		// FIXME? Check if this could be improved.
; 343  : 		if (limit != UINT32_MAX
; 344  : 				&& (mf->read_pos - mf->read_ahead >= limit
; 345  : 					|| *out_pos + rc_pending(&coder->rc)
; 346  : 						>= LZMA2_CHUNK_MAX
; 347  : 							- LOOP_INPUT_MAX))

  00075	83 7d 1c ff	 cmp	 DWORD PTR _limit$[ebp], -1
  00079	74 4b		 je	 SHORT $LN10@lzma_lzma_@13
  0007b	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00081	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00084	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00087	3b 4d 1c	 cmp	 ecx, DWORD PTR _limit$[ebp]
  0008a	73 35		 jae	 SHORT $LN9@lzma_lzma_@13
  0008c	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0008f	8b 02		 mov	 eax, DWORD PTR [edx]
  00091	33 c9		 xor	 ecx, ecx
  00093	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00096	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00099	83 c6 05	 add	 esi, 5
  0009c	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0009f	83 d2 00	 adc	 edx, 0
  000a2	83 ee 01	 sub	 esi, 1
  000a5	83 da 00	 sbb	 edx, 0
  000a8	03 c6		 add	 eax, esi
  000aa	13 ca		 adc	 ecx, edx
  000ac	89 45 d0	 mov	 DWORD PTR tv196[ebp], eax
  000af	89 4d d4	 mov	 DWORD PTR tv196[ebp+4], ecx
  000b2	83 7d d4 00	 cmp	 DWORD PTR tv196[ebp+4], 0
  000b6	77 09		 ja	 SHORT $LN9@lzma_lzma_@13
  000b8	81 7d d0 ff ef
	00 00		 cmp	 DWORD PTR tv196[ebp], 61439 ; 0000efffH
  000bf	72 05		 jb	 SHORT $LN10@lzma_lzma_@13
$LN9@lzma_lzma_@13:

; 348  : 			break;

  000c1	e9 97 00 00 00	 jmp	 $LN12@lzma_lzma_@13
$LN10@lzma_lzma_@13:

; 349  : 
; 350  : 		// Check that there is some input to process.
; 351  : 		if (mf->read_pos >= mf->read_limit) {

  000c6	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  000c9	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  000cc	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000cf	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  000d2	72 1b		 jb	 SHORT $LN8@lzma_lzma_@13

; 352  : 			if (mf->action == LZMA_RUN)

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  000d7	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  000db	75 07		 jne	 SHORT $LN7@lzma_lzma_@13

; 353  : 				return LZMA_OK;

  000dd	33 c0		 xor	 eax, eax
  000df	e9 e5 00 00 00	 jmp	 $LN15@lzma_lzma_@13
$LN7@lzma_lzma_@13:

; 354  : 
; 355  : 			if (mf->read_ahead == 0)

  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  000e7	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000eb	75 02		 jne	 SHORT $LN8@lzma_lzma_@13

; 356  : 				break;

  000ed	eb 6e		 jmp	 SHORT $LN12@lzma_lzma_@13
$LN8@lzma_lzma_@13:

; 357  : 		}
; 358  : 
; 359  : 		// Get optimal match (repeat position and length).
; 360  : 		// Value ranges for pos:
; 361  : 		//   - [0, REPS): repeated match
; 362  : 		//   - [REPS, UINT32_MAX):
; 363  : 		//     match at (pos - REPS)
; 364  : 		//   - UINT32_MAX: not a match but a literal
; 365  : 		// Value ranges for len:
; 366  : 		//   - [MATCH_LEN_MIN, MATCH_LEN_MAX]
; 367  :       {
; 368  : 		uint32_t len;
; 369  : 		uint32_t back;
; 370  : 
; 371  : 		if (coder->fast_mode)

  000ef	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000f2	0f b6 82 9c 0a
	00 00		 movzx	 eax, BYTE PTR [edx+2716]
  000f9	85 c0		 test	 eax, eax
  000fb	74 1a		 je	 SHORT $LN5@lzma_lzma_@13

; 372  : 			lzma_lzma_optimum_fast(coder, mf, &back, &len);

  000fd	8d 4d f8	 lea	 ecx, DWORD PTR _len$32954[ebp]
  00100	51		 push	 ecx
  00101	8d 55 f4	 lea	 edx, DWORD PTR _back$32955[ebp]
  00104	52		 push	 edx
  00105	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00108	50		 push	 eax
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _lzma_lzma_optimum_fast
  00112	83 c4 10	 add	 esp, 16			; 00000010H

; 373  : 		else

  00115	eb 1c		 jmp	 SHORT $LN4@lzma_lzma_@13
$LN5@lzma_lzma_@13:

; 374  : 			lzma_lzma_optimum_normal(
; 375  : 					coder, mf, &back, &len, position);

  00117	8b 55 fc	 mov	 edx, DWORD PTR _position$32943[ebp]
  0011a	52		 push	 edx
  0011b	8d 45 f8	 lea	 eax, DWORD PTR _len$32954[ebp]
  0011e	50		 push	 eax
  0011f	8d 4d f4	 lea	 ecx, DWORD PTR _back$32955[ebp]
  00122	51		 push	 ecx
  00123	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00126	52		 push	 edx
  00127	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _lzma_lzma_optimum_normal
  00130	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@lzma_lzma_@13:

; 376  : 
; 377  : 		encode_symbol(coder, mf, back, len, position);

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _position$32943[ebp]
  00136	51		 push	 ecx
  00137	8b 55 f8	 mov	 edx, DWORD PTR _len$32954[ebp]
  0013a	52		 push	 edx
  0013b	8b 45 f4	 mov	 eax, DWORD PTR _back$32955[ebp]
  0013e	50		 push	 eax
  0013f	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00142	51		 push	 ecx
  00143	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 _encode_symbol
  0014c	83 c4 14	 add	 esp, 20			; 00000014H

; 378  : 
; 379  : 		position += len;

  0014f	8b 45 fc	 mov	 eax, DWORD PTR _position$32943[ebp]
  00152	03 45 f8	 add	 eax, DWORD PTR _len$32954[ebp]
  00155	89 45 fc	 mov	 DWORD PTR _position$32943[ebp], eax

; 380  : 	  }
; 381  : 	}

  00158	e9 e5 fe ff ff	 jmp	 $LN13@lzma_lzma_@13
$LN12@lzma_lzma_@13:

; 382  : 
; 383  : 	if (!coder->is_flushed) {

  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00160	0f b6 91 9e 0a
	00 00		 movzx	 edx, BYTE PTR [ecx+2718]
  00167	85 d2		 test	 edx, edx
  00169	75 4f		 jne	 SHORT $LN3@lzma_lzma_@13

; 384  : 		coder->is_flushed = true;

  0016b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0016e	c6 80 9e 0a 00
	00 01		 mov	 BYTE PTR [eax+2718], 1

; 385  : 
; 386  : 		// We don't support encoding plain LZMA streams without EOPM,
; 387  : 		// and LZMA2 doesn't use EOPM at LZMA level.
; 388  : 		if (limit == UINT32_MAX)

  00175	83 7d 1c ff	 cmp	 DWORD PTR _limit$[ebp], -1
  00179	75 10		 jne	 SHORT $LN2@lzma_lzma_@13

; 389  : 			encode_eopm(coder, position);

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _position$32943[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00182	52		 push	 edx
  00183	e8 00 00 00 00	 call	 _encode_eopm
  00188	83 c4 08	 add	 esp, 8
$LN2@lzma_lzma_@13:

; 390  : 
; 391  : 		// Flush the remaining bytes from the range encoder.
; 392  : 		rc_flush(&coder->rc);

  0018b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _rc_flush
  00194	83 c4 04	 add	 esp, 4

; 393  : 
; 394  : 		// Copy the remaining bytes to the output buffer. If there
; 395  : 		// isn't enough output space, we will copy out the remaining
; 396  : 		// bytes on the next call to this function by using
; 397  : 		// the rc_encode() call in the encoding loop above.
; 398  : 		if (rc_encode(&coder->rc, out, out_pos, out_size)) {

  00197	8b 4d 18	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0019e	52		 push	 edx
  0019f	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  001a2	50		 push	 eax
  001a3	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001a6	51		 push	 ecx
  001a7	e8 00 00 00 00	 call	 _rc_encode
  001ac	83 c4 10	 add	 esp, 16			; 00000010H
  001af	0f b6 d0	 movzx	 edx, al
  001b2	85 d2		 test	 edx, edx
  001b4	74 04		 je	 SHORT $LN3@lzma_lzma_@13

; 399  : 			assert(limit == UINT32_MAX);
; 400  : 			return LZMA_OK;

  001b6	33 c0		 xor	 eax, eax
  001b8	eb 0f		 jmp	 SHORT $LN15@lzma_lzma_@13
$LN3@lzma_lzma_@13:

; 401  : 		}
; 402  :   }
; 403  :   }
; 404  : 
; 405  : 	// Make it ready for the next LZMA2 chunk.
; 406  : 	coder->is_flushed = false;

  001ba	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001bd	c6 80 9e 0a 00
	00 00		 mov	 BYTE PTR [eax+2718], 0

; 407  : 
; 408  : 	return LZMA_STREAM_END;

  001c4	b8 01 00 00 00	 mov	 eax, 1
$LN15@lzma_lzma_@13:

; 409  : }

  001c9	5e		 pop	 esi
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
_lzma_lzma_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_encode
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_out$ = 16						; size = 4
_out_pos$ = 20						; size = 4
_out_size$ = 24						; size = 4
_lzma_encode PROC					; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  : 	// Plain LZMA has no support for sync-flushing.
; 418  : 	if (unlikely(mf->action == LZMA_SYNC_FLUSH))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	83 78 50 01	 cmp	 DWORD PTR [eax+80], 1
  0000a	75 07		 jne	 SHORT $LN1@lzma_encod

; 419  : 		return LZMA_OPTIONS_ERROR;

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	eb 1e		 jmp	 SHORT $LN2@lzma_encod
$LN1@lzma_encod:

; 420  : 
; 421  : 	return lzma_lzma_encode(coder, mf, out, out_pos, out_size, UINT32_MAX);

  00013	6a ff		 push	 -1
  00015	8b 4d 18	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 14	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 10	 mov	 eax, DWORD PTR _out$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 _lzma_lzma_encode
  0002e	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@lzma_encod:

; 422  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_lzma_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_encoder_init
_TEXT	SEGMENT
_lz$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_lz_options$ = 20					; size = 4
_lzma_encoder_init PROC					; COMDAT

; 628  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 629  : 	lz->code = &lzma_encode;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _lzma_encode

; 630  : 	return lzma_lzma_encoder_create(
; 631  : 			&lz->coder, allocator, options, lz_options);

  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _lz$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _lzma_lzma_encoder_create
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 632  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_lzma_encoder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_encoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_lzma_encoder_init PROC				; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  : 	return lzma_lz_encoder_init(
; 640  : 			next, allocator, filters, &lzma_encoder_init);

  00003	68 00 00 00 00	 push	 OFFSET _lzma_encoder_init
  00008	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _lzma_lz_encoder_init
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 641  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_lzma_lzma_encoder_init ENDP
END
