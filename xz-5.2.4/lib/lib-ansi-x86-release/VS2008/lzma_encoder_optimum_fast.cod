; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_fast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
;	COMDAT _lzma_memcmplen
_TEXT	SEGMENT
tv77 = -8						; size = 4
_x$32766 = -4						; size = 4
_buf1$ = 8						; size = 4
_buf2$ = 12						; size = 4
_len$ = 16						; size = 4
_limit$ = 20						; size = 4
_lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_memcm@2:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {
; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);
; 66   : 		if (x != 0) {
; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);
; 70   : 			len += (uint32_t)tmp >> 3;
; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);
; 75   : 		}
; 76   : 
; 77   : 		len += 8;
; 78   : 	}
; 79   : 
; 80   : 	return limit;
; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0000c	73 6c		 jae	 SHORT $LN4@lzma_memcm@2

; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buf1$[ebp]
  00011	03 4d 10	 add	 ecx, DWORD PTR _len$[ebp]
  00014	8b 55 0c	 mov	 edx, DWORD PTR _buf2$[ebp]
  00017	03 55 10	 add	 edx, DWORD PTR _len$[ebp]
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	2b 02		 sub	 eax, DWORD PTR [edx]
  0001e	89 45 fc	 mov	 DWORD PTR _x$32766[ebp], eax

; 125  : 		if (x != 0) {

  00021	74 4c		 je	 SHORT $LN3@lzma_memcm@2

; 126  : 			if ((x & 0xFFFF) == 0) {

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _x$32766[ebp]
  00026	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0002c	75 12		 jne	 SHORT $LN2@lzma_memcm@2

; 127  : 				len += 2;

  0002e	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00031	83 c2 02	 add	 edx, 2
  00034	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 128  : 				x >>= 16;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _x$32766[ebp]
  0003a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003d	89 45 fc	 mov	 DWORD PTR _x$32766[ebp], eax
$LN2@lzma_memcm@2:

; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _x$32766[ebp]
  00043	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00049	75 09		 jne	 SHORT $LN1@lzma_memcm@2

; 132  : 				++len;

  0004b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
$LN1@lzma_memcm@2:

; 133  : 
; 134  : 			return my_min(len, limit);

  00054	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00057	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0005a	73 08		 jae	 SHORT $LN8@lzma_memcm@2
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
  00062	eb 06		 jmp	 SHORT $LN9@lzma_memcm@2
$LN8@lzma_memcm@2:
  00064	8b 55 14	 mov	 edx, DWORD PTR _limit$[ebp]
  00067	89 55 f8	 mov	 DWORD PTR tv77[ebp], edx
$LN9@lzma_memcm@2:
  0006a	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0006d	eb 0e		 jmp	 SHORT $LN6@lzma_memcm@2
$LN3@lzma_memcm@2:

; 135  : 		}
; 136  : 
; 137  : 		len += 4;

  0006f	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 138  : 	}

  00078	eb 8c		 jmp	 SHORT $LN5@lzma_memcm@2
$LN4@lzma_memcm@2:

; 139  : 
; 140  : 	return limit;

  0007a	8b 45 14	 mov	 eax, DWORD PTR _limit$[ebp]
$LN6@lzma_memcm@2:

; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_lzma_memcmplen ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT _mf_skip
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_mf_skip PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	if (amount != 0) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR _amount$[ebp], 0
  00007	74 22		 je	 SHORT $LN2@mf_skip

; 270  : 		mf->skip(mf, amount);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _amount$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00014	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8

; 271  : 		mf->read_ahead += amount;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0001f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00022	03 55 0c	 add	 edx, DWORD PTR _amount$[ebp]
  00025	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00028	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN2@mf_skip:

; 272  : 	}
; 273  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_mf_skip ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_avail
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_avail PROC						; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  : 	return mf->write_pos - mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00009	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000c	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]

; 232  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_ptr
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_ptr	PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 	return mf->buffer + mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000b	03 41 14	 add	 eax, DWORD PTR [ecx+20]

; 224  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_mf_ptr	ENDP
PUBLIC	_lzma_lzma_optimum_fast
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_fast.c
;	COMDAT _lzma_lzma_optimum_fast
_TEXT	SEGMENT
tv230 = -88						; size = 4
tv265 = -84						; size = 4
tv84 = -80						; size = 4
$T76942 = -76						; size = 4
$T76937 = -72						; size = 4
$T76932 = -68						; size = 4
$T76927 = -64						; size = 4
$T76922 = -60						; size = 4
_x$76921 = -56						; size = 4
_limit$32823 = -52					; size = 4
_new_dist$32818 = -48					; size = 4
_back_main$32804 = -44					; size = 4
_len$32800 = -40					; size = 4
_buf_back$32796 = -36					; size = 4
_rep_index$32791 = -32					; size = 4
_rep_len$32790 = -28					; size = 4
_i$32792 = -24						; size = 4
_buf_avail$32788 = -20					; size = 4
_buf$32787 = -16					; size = 4
_nice_len$ = -12					; size = 4
_len_main$ = -8						; size = 4
_matches_count$ = -4					; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_back_res$ = 16						; size = 4
_len_res$ = 20						; size = 4
_lzma_lzma_optimum_fast PROC				; COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H

; 25   : 	const uint32_t nice_len = mf->nice_len;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0000c	89 4d f4	 mov	 DWORD PTR _nice_len$[ebp], ecx

; 26   : 
; 27   : 	uint32_t len_main;
; 28   : 	uint32_t matches_count;
; 29   : 	if (mf->read_ahead == 0) {

  0000f	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00012	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00016	75 1e		 jne	 SHORT $LN30@lzma_lzma_@3

; 30   : 		len_main = mf_find(mf, &matches_count, coder->matches);

  00018	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001b	05 04 02 00 00	 add	 eax, 516		; 00000204H
  00020	50		 push	 eax
  00021	8d 4d fc	 lea	 ecx, DWORD PTR _matches_count$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 _lzma_mf_find
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	89 45 f8	 mov	 DWORD PTR _len_main$[ebp], eax

; 31   : 	} else {

  00034	eb 18		 jmp	 SHORT $LN37@lzma_lzma_@3
$LN30@lzma_lzma_@3:

; 32   : 		assert(mf->read_ahead == 1);
; 33   : 		len_main = coder->longest_match_length;

  00036	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00039	8b 88 98 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2712]
  0003f	89 4d f8	 mov	 DWORD PTR _len_main$[ebp], ecx

; 34   : 		matches_count = coder->matches_count;

  00042	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00045	8b 82 94 0a 00
	00		 mov	 eax, DWORD PTR [edx+2708]
  0004b	89 45 fc	 mov	 DWORD PTR _matches_count$[ebp], eax

; 35   : 	}
; 36   : 
; 37   :   {
; 38   : 	const uint8_t *buf = mf_ptr(mf) - 1;

$LN37@lzma_lzma_@3:
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00051	8b 11		 mov	 edx, DWORD PTR [ecx]
  00053	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00056	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00059	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  0005d	89 55 f0	 mov	 DWORD PTR _buf$32787[ebp], edx

; 39   : 	const uint32_t buf_avail = my_min(mf_avail(mf) + 1, MATCH_LEN_MAX);

  00060	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00066	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00069	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  0006c	83 c2 01	 add	 edx, 1
  0006f	81 fa 11 01 00
	00		 cmp	 edx, 273		; 00000111H
  00075	73 14		 jae	 SHORT $LN33@lzma_lzma_@3
  00077	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0007d	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00080	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00083	83 c2 01	 add	 edx, 1
  00086	89 55 b0	 mov	 DWORD PTR tv84[ebp], edx
  00089	eb 07		 jmp	 SHORT $LN34@lzma_lzma_@3
$LN33@lzma_lzma_@3:
  0008b	c7 45 b0 11 01
	00 00		 mov	 DWORD PTR tv84[ebp], 273 ; 00000111H
$LN34@lzma_lzma_@3:
  00092	8b 45 b0	 mov	 eax, DWORD PTR tv84[ebp]
  00095	89 45 ec	 mov	 DWORD PTR _buf_avail$32788[ebp], eax

; 40   : 
; 41   : 	if (buf_avail < 2) {

  00098	83 7d ec 02	 cmp	 DWORD PTR _buf_avail$32788[ebp], 2
  0009c	73 17		 jae	 SHORT $LN28@lzma_lzma_@3

; 42   : 		// There's not enough input left to encode a match.
; 43   : 		*back_res = UINT32_MAX;

  0009e	8b 4d 10	 mov	 ecx, DWORD PTR _back_res$[ebp]
  000a1	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 44   : 		*len_res = 1;

  000a7	8b 55 14	 mov	 edx, DWORD PTR _len_res$[ebp]
  000aa	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 45   : 		return;

  000b0	e9 4c 04 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN28@lzma_lzma_@3:

; 46   : 	}
; 47   : 
; 48   : 	// Look for repeated matches; scan the previous four match distances
; 49   :   {
; 50   : 	uint32_t rep_len = 0;

  000b5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _rep_len$32790[ebp], 0

; 51   : 	uint32_t rep_index = 0;

  000bc	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _rep_index$32791[ebp], 0

; 52   : 	uint32_t i;
; 53   : 
; 54   : 	for (i = 0; i < REPS; ++i) {

  000c3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$32792[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN27@lzma_lzma_@3
$LN26@lzma_lzma_@3:
  000cc	8b 45 e8	 mov	 eax, DWORD PTR _i$32792[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 e8	 mov	 DWORD PTR _i$32792[ebp], eax
$LN27@lzma_lzma_@3:
  000d5	83 7d e8 04	 cmp	 DWORD PTR _i$32792[ebp], 4
  000d9	0f 83 0d 01 00
	00		 jae	 $LN25@lzma_lzma_@3

; 55   : 		// Pointer to the beginning of the match candidate
; 56   : 		const uint8_t *const buf_back = buf - coder->reps[i] - 1;

  000df	8b 4d e8	 mov	 ecx, DWORD PTR _i$32792[ebp]
  000e2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000e5	8b 45 f0	 mov	 eax, DWORD PTR _buf$32787[ebp]
  000e8	2b 84 8a f4 01
	00 00		 sub	 eax, DWORD PTR [edx+ecx*4+500]
  000ef	83 e8 01	 sub	 eax, 1
  000f2	89 45 dc	 mov	 DWORD PTR _buf_back$32796[ebp], eax

; 57   : 
; 58   : 		// If the first two bytes (2 == MATCH_LEN_MIN) do not match,
; 59   : 		// this rep is not useful.
; 60   : 		if (not_equal_16(buf, buf_back))

  000f5	8b 4d f0	 mov	 ecx, DWORD PTR _buf$32787[ebp]
  000f8	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000fb	8b 45 dc	 mov	 eax, DWORD PTR _buf_back$32796[ebp]
  000fe	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00101	3b d1		 cmp	 edx, ecx
  00103	74 02		 je	 SHORT $LN24@lzma_lzma_@3

; 61   : 			continue;

  00105	eb c5		 jmp	 SHORT $LN26@lzma_lzma_@3
$LN24@lzma_lzma_@3:

; 62   : 
; 63   : 		// The first two bytes matched.
; 64   : 		// Calculate the length of the match.
; 65   : 	  { const uint32_t len = lzma_memcmplen(
; 66   : 				buf, buf_back, 2, buf_avail);

  00107	c7 45 c4 02 00
	00 00		 mov	 DWORD PTR $T76922[ebp], 2
$LN47@lzma_lzma_@3:
  0010e	8b 55 c4	 mov	 edx, DWORD PTR $T76922[ebp]
  00111	3b 55 ec	 cmp	 edx, DWORD PTR _buf_avail$32788[ebp]
  00114	73 6d		 jae	 SHORT $LN46@lzma_lzma_@3
  00116	8b 45 f0	 mov	 eax, DWORD PTR _buf$32787[ebp]
  00119	03 45 c4	 add	 eax, DWORD PTR $T76922[ebp]
  0011c	8b 4d dc	 mov	 ecx, DWORD PTR _buf_back$32796[ebp]
  0011f	03 4d c4	 add	 ecx, DWORD PTR $T76922[ebp]
  00122	8b 10		 mov	 edx, DWORD PTR [eax]
  00124	2b 11		 sub	 edx, DWORD PTR [ecx]
  00126	89 55 c8	 mov	 DWORD PTR _x$76921[ebp], edx
  00129	74 4d		 je	 SHORT $LN45@lzma_lzma_@3
  0012b	8b 45 c8	 mov	 eax, DWORD PTR _x$76921[ebp]
  0012e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00133	75 12		 jne	 SHORT $LN44@lzma_lzma_@3
  00135	8b 4d c4	 mov	 ecx, DWORD PTR $T76922[ebp]
  00138	83 c1 02	 add	 ecx, 2
  0013b	89 4d c4	 mov	 DWORD PTR $T76922[ebp], ecx
  0013e	8b 55 c8	 mov	 edx, DWORD PTR _x$76921[ebp]
  00141	c1 ea 10	 shr	 edx, 16			; 00000010H
  00144	89 55 c8	 mov	 DWORD PTR _x$76921[ebp], edx
$LN44@lzma_lzma_@3:
  00147	8b 45 c8	 mov	 eax, DWORD PTR _x$76921[ebp]
  0014a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014f	75 09		 jne	 SHORT $LN43@lzma_lzma_@3
  00151	8b 4d c4	 mov	 ecx, DWORD PTR $T76922[ebp]
  00154	83 c1 01	 add	 ecx, 1
  00157	89 4d c4	 mov	 DWORD PTR $T76922[ebp], ecx
$LN43@lzma_lzma_@3:
  0015a	8b 55 c4	 mov	 edx, DWORD PTR $T76922[ebp]
  0015d	3b 55 ec	 cmp	 edx, DWORD PTR _buf_avail$32788[ebp]
  00160	73 08		 jae	 SHORT $LN50@lzma_lzma_@3
  00162	8b 45 c4	 mov	 eax, DWORD PTR $T76922[ebp]
  00165	89 45 ac	 mov	 DWORD PTR tv265[ebp], eax
  00168	eb 06		 jmp	 SHORT $LN51@lzma_lzma_@3
$LN50@lzma_lzma_@3:
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _buf_avail$32788[ebp]
  0016d	89 4d ac	 mov	 DWORD PTR tv265[ebp], ecx
$LN51@lzma_lzma_@3:
  00170	8b 55 ac	 mov	 edx, DWORD PTR tv265[ebp]
  00173	89 55 d8	 mov	 DWORD PTR _len$32800[ebp], edx
  00176	eb 11		 jmp	 SHORT $LN48@lzma_lzma_@3
$LN45@lzma_lzma_@3:
  00178	8b 45 c4	 mov	 eax, DWORD PTR $T76922[ebp]
  0017b	83 c0 04	 add	 eax, 4
  0017e	89 45 c4	 mov	 DWORD PTR $T76922[ebp], eax
  00181	eb 8b		 jmp	 SHORT $LN47@lzma_lzma_@3
$LN46@lzma_lzma_@3:
  00183	8b 4d ec	 mov	 ecx, DWORD PTR _buf_avail$32788[ebp]
  00186	89 4d d8	 mov	 DWORD PTR _len$32800[ebp], ecx
$LN48@lzma_lzma_@3:

; 67   : 
; 68   : 		// If we have found a repeated match that is at least
; 69   : 		// nice_len long, return it immediately.
; 70   : 		if (len >= nice_len) {

  00189	8b 55 d8	 mov	 edx, DWORD PTR _len$32800[ebp]
  0018c	3b 55 f4	 cmp	 edx, DWORD PTR _nice_len$[ebp]
  0018f	72 42		 jb	 SHORT $LN23@lzma_lzma_@3

; 71   : 			*back_res = i;

  00191	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  00194	8b 4d e8	 mov	 ecx, DWORD PTR _i$32792[ebp]
  00197	89 08		 mov	 DWORD PTR [eax], ecx

; 72   : 			*len_res = len;

  00199	8b 55 14	 mov	 edx, DWORD PTR _len_res$[ebp]
  0019c	8b 45 d8	 mov	 eax, DWORD PTR _len$32800[ebp]
  0019f	89 02		 mov	 DWORD PTR [edx], eax

; 73   : 			mf_skip(mf, len - 1);

  001a1	8b 4d d8	 mov	 ecx, DWORD PTR _len$32800[ebp]
  001a4	83 e9 01	 sub	 ecx, 1
  001a7	89 4d c0	 mov	 DWORD PTR $T76927[ebp], ecx
  001aa	74 22		 je	 SHORT $LN53@lzma_lzma_@3
  001ac	8b 55 c0	 mov	 edx, DWORD PTR $T76927[ebp]
  001af	52		 push	 edx
  001b0	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  001b7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001ba	ff d2		 call	 edx
  001bc	83 c4 08	 add	 esp, 8
  001bf	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  001c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001c5	03 4d c0	 add	 ecx, DWORD PTR $T76927[ebp]
  001c8	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  001cb	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN53@lzma_lzma_@3:

; 74   : 			return;

  001ce	e9 2e 03 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN23@lzma_lzma_@3:

; 75   : 		}
; 76   : 
; 77   : 		if (len > rep_len) {

  001d3	8b 45 d8	 mov	 eax, DWORD PTR _len$32800[ebp]
  001d6	3b 45 e4	 cmp	 eax, DWORD PTR _rep_len$32790[ebp]
  001d9	76 0c		 jbe	 SHORT $LN22@lzma_lzma_@3

; 78   : 			rep_index = i;

  001db	8b 4d e8	 mov	 ecx, DWORD PTR _i$32792[ebp]
  001de	89 4d e0	 mov	 DWORD PTR _rep_index$32791[ebp], ecx

; 79   : 			rep_len = len;

  001e1	8b 55 d8	 mov	 edx, DWORD PTR _len$32800[ebp]
  001e4	89 55 e4	 mov	 DWORD PTR _rep_len$32790[ebp], edx
$LN22@lzma_lzma_@3:

; 80   : 		}
; 81   : 	  }
; 82   : 	}

  001e7	e9 e0 fe ff ff	 jmp	 $LN26@lzma_lzma_@3
$LN25@lzma_lzma_@3:

; 83   : 
; 84   : 	// We didn't find a long enough repeated match. Encode it as a normal
; 85   : 	// match if the match length is at least nice_len.
; 86   : 	if (len_main >= nice_len) {

  001ec	8b 45 f8	 mov	 eax, DWORD PTR _len_main$[ebp]
  001ef	3b 45 f4	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  001f2	72 4f		 jb	 SHORT $LN21@lzma_lzma_@3

; 87   : 		*back_res = coder->matches[matches_count - 1].dist + REPS;

  001f4	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  001f7	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001fa	8b 84 ca 00 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+512]
  00201	83 c0 04	 add	 eax, 4
  00204	8b 4d 10	 mov	 ecx, DWORD PTR _back_res$[ebp]
  00207	89 01		 mov	 DWORD PTR [ecx], eax

; 88   : 		*len_res = len_main;

  00209	8b 55 14	 mov	 edx, DWORD PTR _len_res$[ebp]
  0020c	8b 45 f8	 mov	 eax, DWORD PTR _len_main$[ebp]
  0020f	89 02		 mov	 DWORD PTR [edx], eax

; 89   : 		mf_skip(mf, len_main - 1);

  00211	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  00214	83 e9 01	 sub	 ecx, 1
  00217	89 4d bc	 mov	 DWORD PTR $T76932[ebp], ecx
  0021a	74 22		 je	 SHORT $LN56@lzma_lzma_@3
  0021c	8b 55 bc	 mov	 edx, DWORD PTR $T76932[ebp]
  0021f	52		 push	 edx
  00220	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00223	50		 push	 eax
  00224	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00227	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0022a	ff d2		 call	 edx
  0022c	83 c4 08	 add	 esp, 8
  0022f	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00232	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00235	03 4d bc	 add	 ecx, DWORD PTR $T76932[ebp]
  00238	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0023b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN56@lzma_lzma_@3:

; 90   : 		return;

  0023e	e9 be 02 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN21@lzma_lzma_@3:

; 91   : 	}
; 92   : 
; 93   :   { uint32_t back_main = 0;

  00243	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _back_main$32804[ebp], 0

; 94   : 	if (len_main >= 2) {

  0024a	83 7d f8 02	 cmp	 DWORD PTR _len_main$[ebp], 2
  0024e	0f 82 83 00 00
	00		 jb	 $LN20@lzma_lzma_@3

; 95   : 		back_main = coder->matches[matches_count - 1].dist;

  00254	8b 45 fc	 mov	 eax, DWORD PTR _matches_count$[ebp]
  00257	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0025a	8b 94 c1 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+512]
  00261	89 55 d4	 mov	 DWORD PTR _back_main$32804[ebp], edx
$LN19@lzma_lzma_@3:

; 96   : 
; 97   : 		while (matches_count > 1 && len_main ==
; 98   : 				coder->matches[matches_count - 2].len + 1) {

  00264	83 7d fc 01	 cmp	 DWORD PTR _matches_count$[ebp], 1
  00268	76 57		 jbe	 SHORT $LN18@lzma_lzma_@3
  0026a	8b 45 fc	 mov	 eax, DWORD PTR _matches_count$[ebp]
  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00270	8b 94 c1 f4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+500]
  00277	83 c2 01	 add	 edx, 1
  0027a	39 55 f8	 cmp	 DWORD PTR _len_main$[ebp], edx
  0027d	75 42		 jne	 SHORT $LN18@lzma_lzma_@3

; 99   : 			if (!change_pair(coder->matches[
; 100  : 						matches_count - 2].dist,
; 101  : 					back_main))

  0027f	8b 45 d4	 mov	 eax, DWORD PTR _back_main$32804[ebp]
  00282	c1 e8 07	 shr	 eax, 7
  00285	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  00288	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0028b	3b 84 ca f8 01
	00 00		 cmp	 eax, DWORD PTR [edx+ecx*8+504]
  00292	77 02		 ja	 SHORT $LN17@lzma_lzma_@3

; 102  : 				break;

  00294	eb 2b		 jmp	 SHORT $LN18@lzma_lzma_@3
$LN17@lzma_lzma_@3:

; 103  : 
; 104  : 			--matches_count;

  00296	8b 45 fc	 mov	 eax, DWORD PTR _matches_count$[ebp]
  00299	83 e8 01	 sub	 eax, 1
  0029c	89 45 fc	 mov	 DWORD PTR _matches_count$[ebp], eax

; 105  : 			len_main = coder->matches[matches_count - 1].len;

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  002a2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002a5	8b 84 ca fc 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+508]
  002ac	89 45 f8	 mov	 DWORD PTR _len_main$[ebp], eax

; 106  : 			back_main = coder->matches[matches_count - 1].dist;

  002af	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  002b2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002b5	8b 84 ca 00 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+512]
  002bc	89 45 d4	 mov	 DWORD PTR _back_main$32804[ebp], eax

; 107  : 		}

  002bf	eb a3		 jmp	 SHORT $LN19@lzma_lzma_@3
$LN18@lzma_lzma_@3:

; 108  : 
; 109  : 		if (len_main == 2 && back_main >= 0x80)

  002c1	83 7d f8 02	 cmp	 DWORD PTR _len_main$[ebp], 2
  002c5	75 10		 jne	 SHORT $LN20@lzma_lzma_@3
  002c7	81 7d d4 80 00
	00 00		 cmp	 DWORD PTR _back_main$32804[ebp], 128 ; 00000080H
  002ce	72 07		 jb	 SHORT $LN20@lzma_lzma_@3

; 110  : 			len_main = 1;

  002d0	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _len_main$[ebp], 1
$LN20@lzma_lzma_@3:

; 111  : 	}
; 112  : 
; 113  : 	if (rep_len >= 2) {

  002d7	83 7d e4 02	 cmp	 DWORD PTR _rep_len$32790[ebp], 2
  002db	72 75		 jb	 SHORT $LN15@lzma_lzma_@3

; 114  : 		if (rep_len + 1 >= len_main
; 115  : 				|| (rep_len + 2 >= len_main
; 116  : 					&& back_main > (UINT32_C(1) << 9))
; 117  : 				|| (rep_len + 3 >= len_main
; 118  : 					&& back_main > (UINT32_C(1) << 15))) {

  002dd	8b 4d e4	 mov	 ecx, DWORD PTR _rep_len$32790[ebp]
  002e0	83 c1 01	 add	 ecx, 1
  002e3	3b 4d f8	 cmp	 ecx, DWORD PTR _len_main$[ebp]
  002e6	73 28		 jae	 SHORT $LN13@lzma_lzma_@3
  002e8	8b 55 e4	 mov	 edx, DWORD PTR _rep_len$32790[ebp]
  002eb	83 c2 02	 add	 edx, 2
  002ee	3b 55 f8	 cmp	 edx, DWORD PTR _len_main$[ebp]
  002f1	72 09		 jb	 SHORT $LN12@lzma_lzma_@3
  002f3	81 7d d4 00 02
	00 00		 cmp	 DWORD PTR _back_main$32804[ebp], 512 ; 00000200H
  002fa	77 14		 ja	 SHORT $LN13@lzma_lzma_@3
$LN12@lzma_lzma_@3:
  002fc	8b 45 e4	 mov	 eax, DWORD PTR _rep_len$32790[ebp]
  002ff	83 c0 03	 add	 eax, 3
  00302	3b 45 f8	 cmp	 eax, DWORD PTR _len_main$[ebp]
  00305	72 4b		 jb	 SHORT $LN15@lzma_lzma_@3
  00307	81 7d d4 00 80
	00 00		 cmp	 DWORD PTR _back_main$32804[ebp], 32768 ; 00008000H
  0030e	76 42		 jbe	 SHORT $LN15@lzma_lzma_@3
$LN13@lzma_lzma_@3:

; 119  : 			*back_res = rep_index;

  00310	8b 4d 10	 mov	 ecx, DWORD PTR _back_res$[ebp]
  00313	8b 55 e0	 mov	 edx, DWORD PTR _rep_index$32791[ebp]
  00316	89 11		 mov	 DWORD PTR [ecx], edx

; 120  : 			*len_res = rep_len;

  00318	8b 45 14	 mov	 eax, DWORD PTR _len_res$[ebp]
  0031b	8b 4d e4	 mov	 ecx, DWORD PTR _rep_len$32790[ebp]
  0031e	89 08		 mov	 DWORD PTR [eax], ecx

; 121  : 			mf_skip(mf, rep_len - 1);

  00320	8b 55 e4	 mov	 edx, DWORD PTR _rep_len$32790[ebp]
  00323	83 ea 01	 sub	 edx, 1
  00326	89 55 b8	 mov	 DWORD PTR $T76937[ebp], edx
  00329	74 22		 je	 SHORT $LN59@lzma_lzma_@3
  0032b	8b 45 b8	 mov	 eax, DWORD PTR $T76937[ebp]
  0032e	50		 push	 eax
  0032f	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00332	51		 push	 ecx
  00333	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00336	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00339	ff d0		 call	 eax
  0033b	83 c4 08	 add	 esp, 8
  0033e	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00341	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00344	03 55 b8	 add	 edx, DWORD PTR $T76937[ebp]
  00347	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0034a	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN59@lzma_lzma_@3:

; 122  : 			return;

  0034d	e9 af 01 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN15@lzma_lzma_@3:

; 123  : 		}
; 124  : 	}
; 125  : 
; 126  : 	if (len_main < 2 || buf_avail <= 2) {

  00352	83 7d f8 02	 cmp	 DWORD PTR _len_main$[ebp], 2
  00356	72 06		 jb	 SHORT $LN10@lzma_lzma_@3
  00358	83 7d ec 02	 cmp	 DWORD PTR _buf_avail$32788[ebp], 2
  0035c	77 17		 ja	 SHORT $LN11@lzma_lzma_@3
$LN10@lzma_lzma_@3:

; 127  : 		*back_res = UINT32_MAX;

  0035e	8b 4d 10	 mov	 ecx, DWORD PTR _back_res$[ebp]
  00361	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 128  : 		*len_res = 1;

  00367	8b 55 14	 mov	 edx, DWORD PTR _len_res$[ebp]
  0036a	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 129  : 		return;

  00370	e9 8c 01 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN11@lzma_lzma_@3:

; 130  : 	}
; 131  : 
; 132  : 	// Get the matches for the next byte. If we find a better match,
; 133  : 	// the current byte is encoded as a literal.
; 134  : 	coder->longest_match_length = mf_find(mf,
; 135  : 			&coder->matches_count, coder->matches);

  00375	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00378	05 04 02 00 00	 add	 eax, 516		; 00000204H
  0037d	50		 push	 eax
  0037e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00381	81 c1 94 0a 00
	00		 add	 ecx, 2708		; 00000a94H
  00387	51		 push	 ecx
  00388	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0038b	52		 push	 edx
  0038c	e8 00 00 00 00	 call	 _lzma_mf_find
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH
  00394	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00397	89 81 98 0a 00
	00		 mov	 DWORD PTR [ecx+2712], eax

; 136  : 
; 137  : 	if (coder->longest_match_length >= 2) {

  0039d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  003a0	83 ba 98 0a 00
	00 02		 cmp	 DWORD PTR [edx+2712], 2
  003a7	0f 82 92 00 00
	00		 jb	 $LN9@lzma_lzma_@3

; 138  : 		const uint32_t new_dist = coder->matches[
; 139  : 				coder->matches_count - 1].dist;

  003ad	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  003b0	8b 88 94 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2708]
  003b6	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  003b9	8b 84 ca 00 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+512]
  003c0	89 45 d0	 mov	 DWORD PTR _new_dist$32818[ebp], eax

; 140  : 
; 141  : 		if ((coder->longest_match_length >= len_main
; 142  : 					&& new_dist < back_main)
; 143  : 				|| (coder->longest_match_length == len_main + 1
; 144  : 					&& !change_pair(back_main, new_dist))
; 145  : 				|| (coder->longest_match_length > len_main + 1)
; 146  : 				|| (coder->longest_match_length + 1 >= len_main
; 147  : 					&& len_main >= 3
; 148  : 					&& change_pair(new_dist, back_main))) {

  003c3	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  003c6	8b 91 98 0a 00
	00		 mov	 edx, DWORD PTR [ecx+2712]
  003cc	3b 55 f8	 cmp	 edx, DWORD PTR _len_main$[ebp]
  003cf	72 08		 jb	 SHORT $LN6@lzma_lzma_@3
  003d1	8b 45 d0	 mov	 eax, DWORD PTR _new_dist$32818[ebp]
  003d4	3b 45 d4	 cmp	 eax, DWORD PTR _back_main$32804[ebp]
  003d7	72 4f		 jb	 SHORT $LN7@lzma_lzma_@3
$LN6@lzma_lzma_@3:
  003d9	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  003dc	83 c1 01	 add	 ecx, 1
  003df	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  003e2	39 8a 98 0a 00
	00		 cmp	 DWORD PTR [edx+2712], ecx
  003e8	75 0b		 jne	 SHORT $LN5@lzma_lzma_@3
  003ea	8b 45 d0	 mov	 eax, DWORD PTR _new_dist$32818[ebp]
  003ed	c1 e8 07	 shr	 eax, 7
  003f0	3b 45 d4	 cmp	 eax, DWORD PTR _back_main$32804[ebp]
  003f3	76 33		 jbe	 SHORT $LN7@lzma_lzma_@3
$LN5@lzma_lzma_@3:
  003f5	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  003f8	83 c1 01	 add	 ecx, 1
  003fb	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  003fe	39 8a 98 0a 00
	00		 cmp	 DWORD PTR [edx+2712], ecx
  00404	77 22		 ja	 SHORT $LN7@lzma_lzma_@3
  00406	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00409	8b 88 98 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2712]
  0040f	83 c1 01	 add	 ecx, 1
  00412	3b 4d f8	 cmp	 ecx, DWORD PTR _len_main$[ebp]
  00415	72 28		 jb	 SHORT $LN9@lzma_lzma_@3
  00417	83 7d f8 03	 cmp	 DWORD PTR _len_main$[ebp], 3
  0041b	72 22		 jb	 SHORT $LN9@lzma_lzma_@3
  0041d	8b 55 d4	 mov	 edx, DWORD PTR _back_main$32804[ebp]
  00420	c1 ea 07	 shr	 edx, 7
  00423	3b 55 d0	 cmp	 edx, DWORD PTR _new_dist$32818[ebp]
  00426	76 17		 jbe	 SHORT $LN9@lzma_lzma_@3
$LN7@lzma_lzma_@3:

; 149  : 			*back_res = UINT32_MAX;

  00428	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  0042b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 150  : 			*len_res = 1;

  00431	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  00434	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 151  : 			return;

  0043a	e9 c2 00 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN9@lzma_lzma_@3:

; 152  : 		}
; 153  : 	}
; 154  : 
; 155  : 	// In contrast to LZMA SDK, dictionary could not have been moved
; 156  : 	// between mf_find() calls, thus it is safe to just increment
; 157  : 	// the old buf pointer instead of recalculating it with mf_ptr().
; 158  : 	++buf;

  0043f	8b 55 f0	 mov	 edx, DWORD PTR _buf$32787[ebp]
  00442	83 c2 01	 add	 edx, 1
  00445	89 55 f0	 mov	 DWORD PTR _buf$32787[ebp], edx

; 159  : 
; 160  :   {
; 161  : 	const uint32_t limit = my_max(2, len_main - 1);

  00448	8b 45 f8	 mov	 eax, DWORD PTR _len_main$[ebp]
  0044b	83 e8 01	 sub	 eax, 1
  0044e	83 f8 02	 cmp	 eax, 2
  00451	73 09		 jae	 SHORT $LN35@lzma_lzma_@3
  00453	c7 45 a8 02 00
	00 00		 mov	 DWORD PTR tv230[ebp], 2
  0045a	eb 09		 jmp	 SHORT $LN36@lzma_lzma_@3
$LN35@lzma_lzma_@3:
  0045c	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  0045f	83 e9 01	 sub	 ecx, 1
  00462	89 4d a8	 mov	 DWORD PTR tv230[ebp], ecx
$LN36@lzma_lzma_@3:
  00465	8b 55 a8	 mov	 edx, DWORD PTR tv230[ebp]
  00468	89 55 cc	 mov	 DWORD PTR _limit$32823[ebp], edx

; 162  : 
; 163  : 	for (i = 0; i < REPS; ++i) {

  0046b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$32792[ebp], 0
  00472	eb 09		 jmp	 SHORT $LN4@lzma_lzma_@3
$LN3@lzma_lzma_@3:
  00474	8b 45 e8	 mov	 eax, DWORD PTR _i$32792[ebp]
  00477	83 c0 01	 add	 eax, 1
  0047a	89 45 e8	 mov	 DWORD PTR _i$32792[ebp], eax
$LN4@lzma_lzma_@3:
  0047d	83 7d e8 04	 cmp	 DWORD PTR _i$32792[ebp], 4
  00481	73 3e		 jae	 SHORT $LN2@lzma_lzma_@3

; 164  : 		if (memcmp(buf, buf - coder->reps[i] - 1, limit) == 0) {

  00483	8b 4d cc	 mov	 ecx, DWORD PTR _limit$32823[ebp]
  00486	51		 push	 ecx
  00487	8b 55 e8	 mov	 edx, DWORD PTR _i$32792[ebp]
  0048a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0048d	8b 4d f0	 mov	 ecx, DWORD PTR _buf$32787[ebp]
  00490	2b 8c 90 f4 01
	00 00		 sub	 ecx, DWORD PTR [eax+edx*4+500]
  00497	83 e9 01	 sub	 ecx, 1
  0049a	51		 push	 ecx
  0049b	8b 55 f0	 mov	 edx, DWORD PTR _buf$32787[ebp]
  0049e	52		 push	 edx
  0049f	e8 00 00 00 00	 call	 _memcmp
  004a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a7	85 c0		 test	 eax, eax
  004a9	75 14		 jne	 SHORT $LN1@lzma_lzma_@3

; 165  : 			*back_res = UINT32_MAX;

  004ab	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  004ae	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 166  : 			*len_res = 1;

  004b4	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  004b7	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 167  : 			return;

  004bd	eb 42		 jmp	 SHORT $LN31@lzma_lzma_@3
$LN1@lzma_lzma_@3:

; 168  : 		}
; 169  : 	}

  004bf	eb b3		 jmp	 SHORT $LN3@lzma_lzma_@3
$LN2@lzma_lzma_@3:

; 170  :   }
; 171  : 
; 172  : 	*back_res = back_main + REPS;

  004c1	8b 55 d4	 mov	 edx, DWORD PTR _back_main$32804[ebp]
  004c4	83 c2 04	 add	 edx, 4
  004c7	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  004ca	89 10		 mov	 DWORD PTR [eax], edx

; 173  :   }}}
; 174  : 	*len_res = len_main;

  004cc	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  004cf	8b 55 f8	 mov	 edx, DWORD PTR _len_main$[ebp]
  004d2	89 11		 mov	 DWORD PTR [ecx], edx

; 175  : 	mf_skip(mf, len_main - 2);

  004d4	8b 45 f8	 mov	 eax, DWORD PTR _len_main$[ebp]
  004d7	83 e8 02	 sub	 eax, 2
  004da	89 45 b4	 mov	 DWORD PTR $T76942[ebp], eax
  004dd	74 22		 je	 SHORT $LN31@lzma_lzma_@3
  004df	8b 4d b4	 mov	 ecx, DWORD PTR $T76942[ebp]
  004e2	51		 push	 ecx
  004e3	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  004e6	52		 push	 edx
  004e7	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  004ea	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  004ed	ff d1		 call	 ecx
  004ef	83 c4 08	 add	 esp, 8
  004f2	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  004f5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  004f8	03 45 b4	 add	 eax, DWORD PTR $T76942[ebp]
  004fb	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  004fe	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN31@lzma_lzma_@3:

; 176  : 	return;
; 177  : }

  00501	8b e5		 mov	 esp, ebp
  00503	5d		 pop	 ebp
  00504	c3		 ret	 0
_lzma_lzma_optimum_fast ENDP
END
