; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_lzma2_props_decode
PUBLIC	_lzma_lzma2_decoder_memusage
PUBLIC	_lzma_lzma2_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
;	COMDAT _lzma_lzma2_decoder_memusage
_TEXT	SEGMENT
_options$ = 8						; size = 4
_lzma_lzma2_decoder_memusage PROC			; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	return sizeof(lzma_lzma2_coder)
; 275  : 			+ lzma_lzma_decoder_memusage_nocheck(options);

  00003	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _lzma_lzma_decoder_memusage_nocheck
  0000c	83 c4 04	 add	 esp, 4
  0000f	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00014	83 d2 00	 adc	 edx, 0

; 276  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_lzma_lzma2_decoder_memusage ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.h
_TEXT	ENDS
;	COMDAT _dict_reset
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_dict_reset PROC					; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  : 	dict->need_reset = true;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00006	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 236  : 	return;
; 237  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_dict_reset ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
;	COMDAT _lzma_lzma2_props_decode
_TEXT	SEGMENT
_opt$32533 = -4						; size = 4
_options$ = 8						; size = 4
_allocator$ = 12					; size = 4
_props$ = 16						; size = 4
_props_size$ = 20					; size = 4
_lzma_lzma2_props_decode PROC				; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 283  : 	if (props_size != 1)

  00004	83 7d 14 01	 cmp	 DWORD PTR _props_size$[ebp], 1
  00008	74 0a		 je	 SHORT $LN6@lzma_lzma2

; 284  : 		return LZMA_OPTIONS_ERROR;

  0000a	b8 08 00 00 00	 mov	 eax, 8
  0000f	e9 a9 00 00 00	 jmp	 $LN7@lzma_lzma2
$LN6@lzma_lzma2:

; 285  : 
; 286  : 	// Check that reserved bits are unset.
; 287  : 	if (props[0] & 0xC0)

  00014	8b 45 10	 mov	 eax, DWORD PTR _props$[ebp]
  00017	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0001a	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  00020	74 0a		 je	 SHORT $LN5@lzma_lzma2

; 288  : 		return LZMA_OPTIONS_ERROR;

  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	e9 91 00 00 00	 jmp	 $LN7@lzma_lzma2
$LN5@lzma_lzma2:

; 289  : 
; 290  : 	// Decode the dictionary size.
; 291  : 	if (props[0] > 40)

  0002c	8b 55 10	 mov	 edx, DWORD PTR _props$[ebp]
  0002f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00032	83 f8 28	 cmp	 eax, 40			; 00000028H
  00035	7e 07		 jle	 SHORT $LN4@lzma_lzma2

; 292  : 		return LZMA_OPTIONS_ERROR;

  00037	b8 08 00 00 00	 mov	 eax, 8
  0003c	eb 7f		 jmp	 SHORT $LN7@lzma_lzma2
$LN4@lzma_lzma2:

; 293  : 
; 294  :   {
; 295  : 	lzma_options_lzma *opt = lzma_alloc(
; 296  : 			sizeof(lzma_options_lzma), allocator);

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00041	51		 push	 ecx
  00042	6a 60		 push	 96			; 00000060H
  00044	e8 00 00 00 00	 call	 _lzma_alloc
  00049	83 c4 08	 add	 esp, 8
  0004c	89 45 fc	 mov	 DWORD PTR _opt$32533[ebp], eax

; 297  : 	if (opt == NULL)

  0004f	83 7d fc 00	 cmp	 DWORD PTR _opt$32533[ebp], 0
  00053	75 07		 jne	 SHORT $LN3@lzma_lzma2

; 298  : 		return LZMA_MEM_ERROR;

  00055	b8 05 00 00 00	 mov	 eax, 5
  0005a	eb 61		 jmp	 SHORT $LN7@lzma_lzma2
$LN3@lzma_lzma2:

; 299  : 
; 300  : 	if (props[0] == 40) {

  0005c	8b 55 10	 mov	 edx, DWORD PTR _props$[ebp]
  0005f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00062	83 f8 28	 cmp	 eax, 40			; 00000028H
  00065	75 0b		 jne	 SHORT $LN2@lzma_lzma2

; 301  : 		opt->dict_size = UINT32_MAX;

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32533[ebp]
  0006a	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 302  : 	} else {

  00070	eb 2d		 jmp	 SHORT $LN1@lzma_lzma2
$LN2@lzma_lzma2:

; 303  : 		opt->dict_size = 2 | (props[0] & 1);

  00072	8b 55 10	 mov	 edx, DWORD PTR _props$[ebp]
  00075	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00078	83 e0 01	 and	 eax, 1
  0007b	83 c8 02	 or	 eax, 2
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32533[ebp]
  00081	89 01		 mov	 DWORD PTR [ecx], eax

; 304  : 		opt->dict_size <<= props[0] / 2 + 11;

  00083	8b 55 10	 mov	 edx, DWORD PTR _props$[ebp]
  00086	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00089	99		 cdq
  0008a	2b c2		 sub	 eax, edx
  0008c	d1 f8		 sar	 eax, 1
  0008e	83 c0 0b	 add	 eax, 11			; 0000000bH
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32533[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	8b c8		 mov	 ecx, eax
  00098	d3 e2		 shl	 edx, cl
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _opt$32533[ebp]
  0009d	89 10		 mov	 DWORD PTR [eax], edx
$LN1@lzma_lzma2:

; 305  : 	}
; 306  : 
; 307  : 	opt->preset_dict = NULL;

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32533[ebp]
  000a2	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 308  : 	opt->preset_dict_size = 0;

  000a9	8b 55 fc	 mov	 edx, DWORD PTR _opt$32533[ebp]
  000ac	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 309  : 
; 310  : 	*options = opt;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _opt$32533[ebp]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx

; 311  :   }
; 312  : 
; 313  : 	return LZMA_OK;

  000bb	33 c0		 xor	 eax, eax
$LN7@lzma_lzma2:

; 314  : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_lzma_lzma2_props_decode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _lzma2_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma2_decoder_end PROC					; COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 216  : 	lzma_lzma2_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 217  : 
; 218  : 	assert(coder->lzma.end == NULL);
; 219  : 	lzma_free(coder->lzma.coder, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _lzma_free
  0001a	83 c4 08	 add	 esp, 8

; 220  : 
; 221  : 	lzma_free(coder, allocator);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 _lzma_free
  0002a	83 c4 08	 add	 esp, 8

; 222  : 
; 223  : 	return;
; 224  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_lzma2_decoder_end ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.h
_TEXT	ENDS
;	COMDAT _dict_write
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_in$ = 12						; size = 4
_in_pos$ = 16						; size = 4
_in_size$ = 20						; size = 4
_left$ = 24						; size = 4
_dict_write PROC					; COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 212  : 	// NOTE: If we are being given more data than the size of the
; 213  : 	// dictionary, it could be possible to optimize the LZ decoder
; 214  : 	// so that not everything needs to go through the dictionary.
; 215  : 	// This shouldn't be very common thing in practice though, and
; 216  : 	// the slowdown of one extra memcpy() isn't bad compared to how
; 217  : 	// much time it would have taken if the data were compressed.
; 218  : 
; 219  : 	if (in_size - *in_pos > *left)

  00003	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00006	8b 4d 14	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00009	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000b	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  0000e	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00010	76 0d		 jbe	 SHORT $LN2@dict_write

; 220  : 		in_size = *in_pos + *left;

  00012	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  0001a	03 0a		 add	 ecx, DWORD PTR [edx]
  0001c	89 4d 14	 mov	 DWORD PTR _in_size$[ebp], ecx
$LN2@dict_write:

; 221  : 
; 222  : 	*left -= lzma_bufcpy(in, in_pos, in_size,
; 223  : 			dict->buf, &dict->pos, dict->limit);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _dict$[ebp]
  00029	83 c2 04	 add	 edx, 4
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	51		 push	 ecx
  00033	8b 55 14	 mov	 edx, DWORD PTR _in_size$[ebp]
  00036	52		 push	 edx
  00037	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _lzma_bufcpy
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  0004a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0004c	2b c8		 sub	 ecx, eax
  0004e	8b 55 18	 mov	 edx, DWORD PTR _left$[ebp]
  00051	89 0a		 mov	 DWORD PTR [edx], ecx

; 224  : 
; 225  : 	if (dict->pos > dict->full)

  00053	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _dict$[ebp]
  00059	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0005f	76 0c		 jbe	 SHORT $LN3@dict_write

; 226  : 		dict->full = dict->pos;

  00061	8b 45 08	 mov	 eax, DWORD PTR _dict$[ebp]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _dict$[ebp]
  00067	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN3@dict_write:

; 227  : 
; 228  : 	return;
; 229  : }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_dict_write ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
;	COMDAT _lzma2_decode
_TEXT	SEGMENT
tv170 = -33						; size = 1
tv66 = -32						; size = 4
$T36028 = -28						; size = 4
$T36027 = -24						; size = 4
_in_start$32473 = -20					; size = 4
_ret$32474 = -16					; size = 4
_in_used$32475 = -12					; size = 4
_control$32449 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_dict$ = 12						; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_lzma2_decode PROC					; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 61   : 	lzma_lzma2_coder *restrict coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN33@lzma2_deco:

; 62   : 
; 63   : 	// With SEQ_LZMA it is possible that no new input is needed to do
; 64   : 	// some progress. The rest of the sequences assume that there is
; 65   : 	// at least one byte of input.
; 66   : 	while (*in_pos < in_size || coder->sequence == SEQ_LZMA)

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00014	72 0c		 jb	 SHORT $LN31@lzma2_deco
  00016	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00019	83 38 06	 cmp	 DWORD PTR [eax], 6
  0001c	0f 85 c7 03 00
	00		 jne	 $LN32@lzma2_deco
$LN31@lzma2_deco:

; 67   : 	switch (coder->sequence) {

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	89 55 e0	 mov	 DWORD PTR tv66[ebp], edx
  0002a	83 7d e0 07	 cmp	 DWORD PTR tv66[ebp], 7
  0002e	0f 87 a9 03 00
	00		 ja	 $LN1@lzma2_deco
  00034	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  00037	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@lzma2_deco[eax*4]
$LN28@lzma2_deco:

; 68   : 	case SEQ_CONTROL: {
; 69   : 		const uint32_t control = in[*in_pos];

  0003e	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00046	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0004a	89 4d f8	 mov	 DWORD PTR _control$32449[ebp], ecx

; 70   : 		++*in_pos;

  0004d	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	83 c0 01	 add	 eax, 1
  00055	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00058	89 01		 mov	 DWORD PTR [ecx], eax

; 71   : 
; 72   : 		// End marker
; 73   : 		if (control == 0x00)

  0005a	83 7d f8 00	 cmp	 DWORD PTR _control$32449[ebp], 0
  0005e	75 0a		 jne	 SHORT $LN27@lzma2_deco

; 74   : 			return LZMA_STREAM_END;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	e9 81 03 00 00	 jmp	 $LN34@lzma2_deco
$LN27@lzma2_deco:

; 75   : 
; 76   : 		if (control >= 0xE0 || control == 1) {

  0006a	81 7d f8 e0 00
	00 00		 cmp	 DWORD PTR _control$32449[ebp], 224 ; 000000e0H
  00071	73 06		 jae	 SHORT $LN25@lzma2_deco
  00073	83 7d f8 01	 cmp	 DWORD PTR _control$32449[ebp], 1
  00077	75 10		 jne	 SHORT $LN26@lzma2_deco
$LN25@lzma2_deco:

; 77   : 			// Dictionary reset implies that next LZMA chunk has
; 78   : 			// to set new properties.
; 79   : 			coder->need_properties = true;

  00079	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0007c	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 80   : 			coder->need_dictionary_reset = true;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00083	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1
  00087	eb 15		 jmp	 SHORT $LN24@lzma2_deco
$LN26@lzma2_deco:

; 81   : 		} else if (coder->need_dictionary_reset) {

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0008c	0f b6 51 25	 movzx	 edx, BYTE PTR [ecx+37]
  00090	85 d2		 test	 edx, edx
  00092	74 0a		 je	 SHORT $LN24@lzma2_deco

; 82   : 			return LZMA_DATA_ERROR;

  00094	b8 09 00 00 00	 mov	 eax, 9
  00099	e9 4d 03 00 00	 jmp	 $LN34@lzma2_deco
$LN24@lzma2_deco:

; 83   : 		}
; 84   : 
; 85   : 		if (control >= 0x80) {

  0009e	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _control$32449[ebp], 128 ; 00000080H
  000a5	72 79		 jb	 SHORT $LN22@lzma2_deco

; 86   : 			// LZMA chunk. The highest five bits of the
; 87   : 			// uncompressed size are taken from the control byte.
; 88   : 			coder->uncompressed_size = (control & 0x1F) << 16;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _control$32449[ebp]
  000aa	83 e0 1f	 and	 eax, 31			; 0000001fH
  000ad	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000b3	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 89   : 			coder->sequence = SEQ_UNCOMPRESSED_1;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000b9	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 90   : 
; 91   : 			// See if there are new properties or if we need to
; 92   : 			// reset the state.
; 93   : 			if (control >= 0xC0) {

  000bf	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR _control$32449[ebp], 192 ; 000000c0H
  000c6	72 13		 jb	 SHORT $LN21@lzma2_deco

; 94   : 				// When there are new properties, state reset
; 95   : 				// is done at SEQ_PROPERTIES.
; 96   : 				coder->need_properties = false;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000cb	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0

; 97   : 				coder->next_sequence = SEQ_PROPERTIES;

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d2	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  000d9	eb 43		 jmp	 SHORT $LN20@lzma2_deco
$LN21@lzma2_deco:

; 98   : 
; 99   : 			} else if (coder->need_properties) {

  000db	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000de	0f b6 42 24	 movzx	 eax, BYTE PTR [edx+36]
  000e2	85 c0		 test	 eax, eax
  000e4	74 0c		 je	 SHORT $LN19@lzma2_deco

; 100  : 				return LZMA_DATA_ERROR;

  000e6	b8 09 00 00 00	 mov	 eax, 9
  000eb	e9 fb 02 00 00	 jmp	 $LN34@lzma2_deco

; 101  : 
; 102  : 			} else {

  000f0	eb 2c		 jmp	 SHORT $LN20@lzma2_deco
$LN19@lzma2_deco:

; 103  : 				coder->next_sequence = SEQ_LZMA;

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000f5	c7 41 04 06 00
	00 00		 mov	 DWORD PTR [ecx+4], 6

; 104  : 
; 105  : 				// If only state reset is wanted with old
; 106  : 				// properties, do the resetting here for
; 107  : 				// simplicity.
; 108  : 				if (control >= 0xA0)

  000fc	81 7d f8 a0 00
	00 00		 cmp	 DWORD PTR _control$32449[ebp], 160 ; 000000a0H
  00103	72 19		 jb	 SHORT $LN20@lzma2_deco

; 109  : 					coder->lzma.reset(coder->lzma.coder,
; 110  : 							&coder->options);

  00105	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00108	83 c2 28	 add	 edx, 40			; 00000028H
  0010b	52		 push	 edx
  0010c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0010f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00112	51		 push	 ecx
  00113	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00116	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00119	ff d0		 call	 eax
  0011b	83 c4 08	 add	 esp, 8
$LN20@lzma2_deco:

; 111  : 			}
; 112  : 		} else {

  0011e	eb 23		 jmp	 SHORT $LN16@lzma2_deco
$LN22@lzma2_deco:

; 113  : 			// Invalid control values
; 114  : 			if (control > 2)

  00120	83 7d f8 02	 cmp	 DWORD PTR _control$32449[ebp], 2
  00124	76 0a		 jbe	 SHORT $LN15@lzma2_deco

; 115  : 				return LZMA_DATA_ERROR;

  00126	b8 09 00 00 00	 mov	 eax, 9
  0012b	e9 bb 02 00 00	 jmp	 $LN34@lzma2_deco
$LN15@lzma2_deco:

; 116  : 
; 117  : 			// It's uncompressed chunk
; 118  : 			coder->sequence = SEQ_COMPRESSED_0;

  00130	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00133	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 119  : 			coder->next_sequence = SEQ_COPY;

  00139	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0013c	c7 42 04 07 00
	00 00		 mov	 DWORD PTR [edx+4], 7
$LN16@lzma2_deco:

; 120  : 		}
; 121  : 
; 122  : 		if (coder->need_dictionary_reset) {

  00143	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00146	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  0014a	85 c9		 test	 ecx, ecx
  0014c	74 15		 je	 SHORT $LN14@lzma2_deco

; 123  : 			// Finish the dictionary reset and let the caller
; 124  : 			// flush the dictionary to the actual output buffer.
; 125  : 			coder->need_dictionary_reset = false;

  0014e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00151	c6 42 25 00	 mov	 BYTE PTR [edx+37], 0

; 126  : 			dict_reset(dict);

  00155	8b 45 0c	 mov	 eax, DWORD PTR _dict$[ebp]
  00158	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 127  : 			return LZMA_OK;

  0015c	33 c0		 xor	 eax, eax
  0015e	e9 88 02 00 00	 jmp	 $LN34@lzma2_deco
$LN14@lzma2_deco:

; 128  : 		}
; 129  : 
; 130  : 		break;

  00163	e9 7c 02 00 00	 jmp	 $LN29@lzma2_deco
$LN13@lzma2_deco:

; 131  : 	}
; 132  : 
; 133  : 	case SEQ_UNCOMPRESSED_1:
; 134  : 		coder->uncompressed_size += (uint32_t)(in[(*in_pos)++]) << 8;

  00168	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0016b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016d	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00170	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00174	c1 e1 08	 shl	 ecx, 8
  00177	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0017a	03 4a 1c	 add	 ecx, DWORD PTR [edx+28]
  0017d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00180	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00183	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00186	8b 11		 mov	 edx, DWORD PTR [ecx]
  00188	83 c2 01	 add	 edx, 1
  0018b	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0018e	89 10		 mov	 DWORD PTR [eax], edx

; 135  : 		coder->sequence = SEQ_UNCOMPRESSED_2;

  00190	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00193	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 136  : 		break;

  00199	e9 46 02 00 00	 jmp	 $LN29@lzma2_deco
$LN12@lzma2_deco:

; 137  : 
; 138  : 	case SEQ_UNCOMPRESSED_2:
; 139  : 		coder->uncompressed_size += in[(*in_pos)++] + 1;

  0019e	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  001a1	8b 02		 mov	 eax, DWORD PTR [edx]
  001a3	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  001a6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001aa	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001ad	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001b0	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  001b4	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001b7	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  001ba	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  001bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bf	83 c2 01	 add	 edx, 1
  001c2	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  001c5	89 10		 mov	 DWORD PTR [eax], edx

; 140  : 		coder->sequence = SEQ_COMPRESSED_0;

  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ca	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 141  : 		coder->lzma.set_uncompressed(coder->lzma.coder,
; 142  : 				coder->uncompressed_size);

  001d0	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001d3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001d6	33 c9		 xor	 ecx, ecx
  001d8	51		 push	 ecx
  001d9	50		 push	 eax
  001da	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001dd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001e0	50		 push	 eax
  001e1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001e4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001e7	ff d2		 call	 edx
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 		break;

  001ec	e9 f3 01 00 00	 jmp	 $LN29@lzma2_deco
$LN11@lzma2_deco:

; 144  : 
; 145  : 	case SEQ_COMPRESSED_0:
; 146  : 		coder->compressed_size = (uint32_t)(in[(*in_pos)++]) << 8;

  001f1	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  001f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f6	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  001f9	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001fd	c1 e0 08	 shl	 eax, 8
  00200	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00203	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00206	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00209	8b 02		 mov	 eax, DWORD PTR [edx]
  0020b	83 c0 01	 add	 eax, 1
  0020e	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00211	89 01		 mov	 DWORD PTR [ecx], eax

; 147  : 		coder->sequence = SEQ_COMPRESSED_1;

  00213	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00216	c7 02 04 00 00
	00		 mov	 DWORD PTR [edx], 4

; 148  : 		break;

  0021c	e9 c3 01 00 00	 jmp	 $LN29@lzma2_deco
$LN10@lzma2_deco:

; 149  : 
; 150  : 	case SEQ_COMPRESSED_1:
; 151  : 		coder->compressed_size += in[(*in_pos)++] + 1;

  00221	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00224	8b 08		 mov	 ecx, DWORD PTR [eax]
  00226	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00229	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00230	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00233	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  00237	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0023a	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0023d	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00240	8b 02		 mov	 eax, DWORD PTR [edx]
  00242	83 c0 01	 add	 eax, 1
  00245	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00248	89 01		 mov	 DWORD PTR [ecx], eax

; 152  : 		coder->sequence = coder->next_sequence;

  0024a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0024d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00250	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00253	89 0a		 mov	 DWORD PTR [edx], ecx

; 153  : 		break;

  00255	e9 8a 01 00 00	 jmp	 $LN29@lzma2_deco
$LN9@lzma2_deco:

; 154  : 
; 155  : 	case SEQ_PROPERTIES:
; 156  : 		if (lzma_lzma_lclppb_decode(&coder->options, in[(*in_pos)++]))

  0025a	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0025d	8b 02		 mov	 eax, DWORD PTR [edx]
  0025f	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00262	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00265	88 55 df	 mov	 BYTE PTR tv170[ebp], dl
  00268	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0026b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026d	83 c1 01	 add	 ecx, 1
  00270	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00273	89 0a		 mov	 DWORD PTR [edx], ecx
  00275	0f b6 45 df	 movzx	 eax, BYTE PTR tv170[ebp]
  00279	50		 push	 eax
  0027a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0027d	83 c1 28	 add	 ecx, 40			; 00000028H
  00280	51		 push	 ecx
  00281	e8 00 00 00 00	 call	 _lzma_lzma_lclppb_decode
  00286	83 c4 08	 add	 esp, 8
  00289	0f b6 d0	 movzx	 edx, al
  0028c	85 d2		 test	 edx, edx
  0028e	74 0a		 je	 SHORT $LN8@lzma2_deco

; 157  : 			return LZMA_DATA_ERROR;

  00290	b8 09 00 00 00	 mov	 eax, 9
  00295	e9 51 01 00 00	 jmp	 $LN34@lzma2_deco
$LN8@lzma2_deco:

; 158  : 
; 159  : 		coder->lzma.reset(coder->lzma.coder, &coder->options);

  0029a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0029d	83 c0 28	 add	 eax, 40			; 00000028H
  002a0	50		 push	 eax
  002a1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002a4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002a7	52		 push	 edx
  002a8	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002ab	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002ae	ff d1		 call	 ecx
  002b0	83 c4 08	 add	 esp, 8

; 160  : 
; 161  : 		coder->sequence = SEQ_LZMA;

  002b3	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002b6	c7 02 06 00 00
	00		 mov	 DWORD PTR [edx], 6

; 162  : 		break;

  002bc	e9 23 01 00 00	 jmp	 $LN29@lzma2_deco
$LN7@lzma2_deco:

; 163  : 
; 164  : 	case SEQ_LZMA: {
; 165  : 		// Store the start offset so that we can update
; 166  : 		// coder->compressed_size later.
; 167  : 		const size_t in_start = *in_pos;

  002c1	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  002c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c6	89 4d ec	 mov	 DWORD PTR _in_start$32473[ebp], ecx

; 168  : 
; 169  : 		// Decode from in[] to *dict.
; 170  : 		const lzma_ret ret = coder->lzma.code(coder->lzma.coder,
; 171  : 				dict, in, in_pos, in_size);

  002c9	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  002cc	52		 push	 edx
  002cd	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  002d0	50		 push	 eax
  002d1	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  002d4	51		 push	 ecx
  002d5	8b 55 0c	 mov	 edx, DWORD PTR _dict$[ebp]
  002d8	52		 push	 edx
  002d9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002dc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002df	51		 push	 ecx
  002e0	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002e3	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002e6	ff d0		 call	 eax
  002e8	83 c4 14	 add	 esp, 20			; 00000014H
  002eb	89 45 f0	 mov	 DWORD PTR _ret$32474[ebp], eax

; 172  : 
; 173  : 		// Validate and update coder->compressed_size.
; 174  : 		const size_t in_used = *in_pos - in_start;

  002ee	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  002f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f3	2b 55 ec	 sub	 edx, DWORD PTR _in_start$32473[ebp]
  002f6	89 55 f4	 mov	 DWORD PTR _in_used$32475[ebp], edx

; 175  : 		if (in_used > coder->compressed_size)

  002f9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002fc	8b 4d f4	 mov	 ecx, DWORD PTR _in_used$32475[ebp]
  002ff	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00302	76 0a		 jbe	 SHORT $LN6@lzma2_deco

; 176  : 			return LZMA_DATA_ERROR;

  00304	b8 09 00 00 00	 mov	 eax, 9
  00309	e9 dd 00 00 00	 jmp	 $LN34@lzma2_deco
$LN6@lzma2_deco:

; 177  : 
; 178  : 		coder->compressed_size -= in_used;

  0030e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00311	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00314	2b 45 f4	 sub	 eax, DWORD PTR _in_used$32475[ebp]
  00317	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0031a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 179  : 
; 180  : 		// Return if we didn't finish the chunk, or an error occurred.
; 181  : 		if (ret != LZMA_STREAM_END)

  0031d	83 7d f0 01	 cmp	 DWORD PTR _ret$32474[ebp], 1
  00321	74 08		 je	 SHORT $LN5@lzma2_deco

; 182  : 			return ret;

  00323	8b 45 f0	 mov	 eax, DWORD PTR _ret$32474[ebp]
  00326	e9 c0 00 00 00	 jmp	 $LN34@lzma2_deco
$LN5@lzma2_deco:

; 183  : 
; 184  : 		// The LZMA decoder must have consumed the whole chunk now.
; 185  : 		// We don't need to worry about uncompressed size since it
; 186  : 		// is checked by the LZMA decoder.
; 187  : 		if (coder->compressed_size != 0)

  0032b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0032e	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00332	74 0a		 je	 SHORT $LN4@lzma2_deco

; 188  : 			return LZMA_DATA_ERROR;

  00334	b8 09 00 00 00	 mov	 eax, 9
  00339	e9 ad 00 00 00	 jmp	 $LN34@lzma2_deco
$LN4@lzma2_deco:

; 189  : 
; 190  : 		coder->sequence = SEQ_CONTROL;

  0033e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00341	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 191  : 		break;

  00347	e9 98 00 00 00	 jmp	 $LN29@lzma2_deco
$LN3@lzma2_deco:

; 192  : 	}
; 193  : 
; 194  : 	case SEQ_COPY: {
; 195  : 		// Copy from input to the dictionary as is.
; 196  : 		dict_write(dict, in, in_pos, in_size, &coder->compressed_size);

  0034c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0034f	83 c1 20	 add	 ecx, 32			; 00000020H
  00352	89 4d e4	 mov	 DWORD PTR $T36028[ebp], ecx
  00355	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  00358	89 55 e8	 mov	 DWORD PTR $T36027[ebp], edx
  0035b	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0035e	8b 4d e8	 mov	 ecx, DWORD PTR $T36027[ebp]
  00361	2b 08		 sub	 ecx, DWORD PTR [eax]
  00363	8b 55 e4	 mov	 edx, DWORD PTR $T36028[ebp]
  00366	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00368	76 0d		 jbe	 SHORT $LN39@lzma2_deco
  0036a	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0036d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036f	8b 55 e4	 mov	 edx, DWORD PTR $T36028[ebp]
  00372	03 0a		 add	 ecx, DWORD PTR [edx]
  00374	89 4d e8	 mov	 DWORD PTR $T36027[ebp], ecx
$LN39@lzma2_deco:
  00377	8b 45 0c	 mov	 eax, DWORD PTR _dict$[ebp]
  0037a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0037d	51		 push	 ecx
  0037e	8b 55 0c	 mov	 edx, DWORD PTR _dict$[ebp]
  00381	83 c2 04	 add	 edx, 4
  00384	52		 push	 edx
  00385	8b 45 0c	 mov	 eax, DWORD PTR _dict$[ebp]
  00388	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038a	51		 push	 ecx
  0038b	8b 55 e8	 mov	 edx, DWORD PTR $T36027[ebp]
  0038e	52		 push	 edx
  0038f	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00392	50		 push	 eax
  00393	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00396	51		 push	 ecx
  00397	e8 00 00 00 00	 call	 _lzma_bufcpy
  0039c	83 c4 18	 add	 esp, 24			; 00000018H
  0039f	8b 55 e4	 mov	 edx, DWORD PTR $T36028[ebp]
  003a2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003a4	2b c8		 sub	 ecx, eax
  003a6	8b 55 e4	 mov	 edx, DWORD PTR $T36028[ebp]
  003a9	89 0a		 mov	 DWORD PTR [edx], ecx
  003ab	8b 45 0c	 mov	 eax, DWORD PTR _dict$[ebp]
  003ae	8b 4d 0c	 mov	 ecx, DWORD PTR _dict$[ebp]
  003b1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b4	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  003b7	76 0c		 jbe	 SHORT $LN40@lzma2_deco
  003b9	8b 45 0c	 mov	 eax, DWORD PTR _dict$[ebp]
  003bc	8b 4d 0c	 mov	 ecx, DWORD PTR _dict$[ebp]
  003bf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003c2	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN40@lzma2_deco:

; 197  : 		if (coder->compressed_size != 0)

  003c5	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  003c8	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  003cc	74 04		 je	 SHORT $LN2@lzma2_deco

; 198  : 			return LZMA_OK;

  003ce	33 c0		 xor	 eax, eax
  003d0	eb 19		 jmp	 SHORT $LN34@lzma2_deco
$LN2@lzma2_deco:

; 199  : 
; 200  : 		coder->sequence = SEQ_CONTROL;

  003d2	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  003d5	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 201  : 		break;

  003db	eb 07		 jmp	 SHORT $LN29@lzma2_deco
$LN1@lzma2_deco:

; 202  : 	}
; 203  : 
; 204  : 	default:
; 205  : 		assert(0);
; 206  : 		return LZMA_PROG_ERROR;

  003dd	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  003e2	eb 07		 jmp	 SHORT $LN34@lzma2_deco
$LN29@lzma2_deco:

; 207  : 	}

  003e4	e9 23 fc ff ff	 jmp	 $LN33@lzma2_deco
$LN32@lzma2_deco:

; 208  : 
; 209  : 	return LZMA_OK;

  003e9	33 c0		 xor	 eax, eax
$LN34@lzma2_deco:

; 210  : }

  003eb	8b e5		 mov	 esp, ebp
  003ed	5d		 pop	 ebp
  003ee	c3		 ret	 0
  003ef	90		 npad	 1
$LN42@lzma2_deco:
  003f0	00 00 00 00	 DD	 $LN28@lzma2_deco
  003f4	00 00 00 00	 DD	 $LN13@lzma2_deco
  003f8	00 00 00 00	 DD	 $LN12@lzma2_deco
  003fc	00 00 00 00	 DD	 $LN11@lzma2_deco
  00400	00 00 00 00	 DD	 $LN10@lzma2_deco
  00404	00 00 00 00	 DD	 $LN9@lzma2_deco
  00408	00 00 00 00	 DD	 $LN7@lzma2_deco
  0040c	00 00 00 00	 DD	 $LN3@lzma2_deco
_lzma2_decode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma2_decoder_init
_TEXT	SEGMENT
tv78 = -12						; size = 4
_options$32507 = -8					; size = 4
_coder$ = -4						; size = 4
_lz$ = 8						; size = 4
_allocator$ = 12					; size = 4
_opt$ = 16						; size = 4
_lz_options$ = 20					; size = 4
_lzma2_decoder_init PROC				; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 231  : 	lzma_lzma2_coder *coder = lz->coder;

  00006	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _coder$[ebp], ecx

; 232  : 	if (coder == NULL) {

  0000e	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00012	75 70		 jne	 SHORT $LN2@lzma2_deco@2

; 233  : 		coder = lzma_alloc(sizeof(lzma_lzma2_coder), allocator);

  00014	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00017	52		 push	 edx
  00018	68 88 00 00 00	 push	 136			; 00000088H
  0001d	e8 00 00 00 00	 call	 _lzma_alloc
  00022	83 c4 08	 add	 esp, 8
  00025	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 234  : 		if (coder == NULL)

  00028	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  0002c	75 0a		 jne	 SHORT $LN1@lzma2_deco@2

; 235  : 			return LZMA_MEM_ERROR;

  0002e	b8 05 00 00 00	 mov	 eax, 5
  00033	e9 a8 00 00 00	 jmp	 $LN3@lzma2_deco@2
$LN1@lzma2_deco@2:

; 236  : 
; 237  : 		lz->coder = coder;

  00038	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003e	89 08		 mov	 DWORD PTR [eax], ecx

; 238  : 		lz->code = &lzma2_decode;

  00040	8b 55 08	 mov	 edx, DWORD PTR _lz$[ebp]
  00043	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], OFFSET _lzma2_decode

; 239  : 		lz->end = &lzma2_decoder_end;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lz$[ebp]
  0004d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma2_decoder_end

; 240  : 
; 241  : 		coder->lzma = LZMA_LZ_DECODER_INIT;

  00054	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00057	83 c1 08	 add	 ecx, 8
  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _LZMA_LZ_DECODER_INIT
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	a1 04 00 00 00	 mov	 eax, DWORD PTR _LZMA_LZ_DECODER_INIT+4
  00067	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0006a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _LZMA_LZ_DECODER_INIT+8
  00070	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00073	a1 0c 00 00 00	 mov	 eax, DWORD PTR _LZMA_LZ_DECODER_INIT+12
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0007b	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _LZMA_LZ_DECODER_INIT+16
  00081	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN2@lzma2_deco@2:

; 242  : 	}
; 243  : 
; 244  :   {
; 245  : 	const lzma_options_lzma *options = opt;

  00084	8b 45 10	 mov	 eax, DWORD PTR _opt$[ebp]
  00087	89 45 f8	 mov	 DWORD PTR _options$32507[ebp], eax

; 246  : 
; 247  : 	coder->sequence = SEQ_CONTROL;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0008d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 248  : 	coder->need_properties = true;

  00093	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00096	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 249  : 	coder->need_dictionary_reset = options->preset_dict == NULL
; 250  : 			|| options->preset_dict_size == 0;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _options$32507[ebp]
  0009d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a1	74 12		 je	 SHORT $LN5@lzma2_deco@2
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _options$32507[ebp]
  000a6	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000aa	74 09		 je	 SHORT $LN5@lzma2_deco@2
  000ac	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  000b3	eb 07		 jmp	 SHORT $LN6@lzma2_deco@2
$LN5@lzma2_deco@2:
  000b5	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN6@lzma2_deco@2:
  000bc	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000bf	8a 45 f4	 mov	 al, BYTE PTR tv78[ebp]
  000c2	88 42 25	 mov	 BYTE PTR [edx+37], al

; 251  : 
; 252  : 	return lzma_lzma_decoder_create(&coder->lzma,
; 253  : 			allocator, options, lz_options);

  000c5	8b 4d 14	 mov	 ecx, DWORD PTR _lz_options$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 f8	 mov	 edx, DWORD PTR _options$32507[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d4	83 c1 08	 add	 ecx, 8
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _lzma_lzma_decoder_create
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@lzma2_deco@2:

; 254  :   }
; 255  : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_lzma2_decoder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma2_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_lzma2_decoder_init PROC				; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	// LZMA2 can only be the last filter in the chain. This is enforced
; 263  : 	// by the raw_decoder initialization.
; 264  : 	assert(filters[1].init == NULL);
; 265  : 
; 266  : 	return lzma_lz_decoder_init(next, allocator, filters,
; 267  : 			&lzma2_decoder_init);

  00003	68 00 00 00 00	 push	 OFFSET _lzma2_decoder_init
  00008	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _lzma_lz_decoder_init
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 268  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_lzma_lzma2_decoder_init ENDP
END
