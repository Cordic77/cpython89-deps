; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\delta\delta_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_delta_props_encode
PUBLIC	_lzma_delta_encoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\delta\delta_encoder.c
;	COMDAT _encode_in_place
_TEXT	SEGMENT
_tmp$32274 = -9						; size = 1
_distance$ = -8						; size = 4
_i$ = -4						; size = 4
_coder$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_encode_in_place PROC					; COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 41   : 	const size_t distance = coder->distance;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000c	89 4d f8	 mov	 DWORD PTR _distance$[ebp], ecx

; 42   : 	size_t i;
; 43   : 
; 44   : 	for (i = 0; i < size; ++i) {

  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN3@encode_in_
$LN2@encode_in_:
  00018	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@encode_in_:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	3b 45 10	 cmp	 eax, DWORD PTR _size$[ebp]
  00027	73 5c		 jae	 SHORT $LN4@encode_in_

; 45   : 		const uint8_t tmp = coder->history[
; 46   : 				(distance + coder->pos) & 0xFF];

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0002c	0f b6 51 34	 movzx	 edx, BYTE PTR [ecx+52]
  00030	03 55 f8	 add	 edx, DWORD PTR _distance$[ebp]
  00033	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00039	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003c	8a 4c 10 35	 mov	 cl, BYTE PTR [eax+edx+53]
  00040	88 4d f7	 mov	 BYTE PTR _tmp$32274[ebp], cl

; 47   : 		coder->history[coder->pos-- & 0xFF] = buffer[i];

  00043	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00046	0f b6 42 34	 movzx	 eax, BYTE PTR [edx+52]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00052	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00055	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00058	8a 09		 mov	 cl, BYTE PTR [ecx]
  0005a	88 4c 02 35	 mov	 BYTE PTR [edx+eax+53], cl
  0005e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00061	8a 42 34	 mov	 al, BYTE PTR [edx+52]
  00064	2c 01		 sub	 al, 1
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00069	88 41 34	 mov	 BYTE PTR [ecx+52], al

; 48   : 		buffer[i] -= tmp;

  0006c	0f b6 55 f7	 movzx	 edx, BYTE PTR _tmp$32274[ebp]
  00070	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00073	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00076	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00079	2b ca		 sub	 ecx, edx
  0007b	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0007e	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00081	88 0a		 mov	 BYTE PTR [edx], cl

; 49   : 	}

  00083	eb 93		 jmp	 SHORT $LN2@encode_in_
$LN4@encode_in_:

; 50   : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_encode_in_place ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _copy_and_encode
_TEXT	SEGMENT
_tmp$32260 = -9						; size = 1
_distance$ = -8						; size = 4
_i$ = -4						; size = 4
_coder$ = 8						; size = 4
_in$ = 12						; size = 4
_out$ = 16						; size = 4
_size$ = 20						; size = 4
_copy_and_encode PROC					; COMDAT

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 24   : 	const size_t distance = coder->distance;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000c	89 4d f8	 mov	 DWORD PTR _distance$[ebp], ecx

; 25   : 	size_t i;
; 26   : 
; 27   : 	for (i = 0; i < size; ++i) {

  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN3@copy_and_e
$LN2@copy_and_e:
  00018	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0001b	83 c2 01	 add	 edx, 1
  0001e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@copy_and_e:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  00027	73 5c		 jae	 SHORT $LN4@copy_and_e

; 28   : 		const uint8_t tmp = coder->history[
; 29   : 				(distance + coder->pos) & 0xFF];

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0002c	0f b6 51 34	 movzx	 edx, BYTE PTR [ecx+52]
  00030	03 55 f8	 add	 edx, DWORD PTR _distance$[ebp]
  00033	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00039	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003c	8a 4c 10 35	 mov	 cl, BYTE PTR [eax+edx+53]
  00040	88 4d f7	 mov	 BYTE PTR _tmp$32260[ebp], cl

; 30   : 		coder->history[coder->pos-- & 0xFF] = in[i];

  00043	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00046	0f b6 42 34	 movzx	 eax, BYTE PTR [edx+52]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  00052	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00055	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00058	8a 09		 mov	 cl, BYTE PTR [ecx]
  0005a	88 4c 02 35	 mov	 BYTE PTR [edx+eax+53], cl
  0005e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00061	8a 42 34	 mov	 al, BYTE PTR [edx+52]
  00064	2c 01		 sub	 al, 1
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00069	88 41 34	 mov	 BYTE PTR [ecx+52], al

; 31   : 		out[i] = in[i] - tmp;

  0006c	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0006f	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00072	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00075	0f b6 4d f7	 movzx	 ecx, BYTE PTR _tmp$32260[ebp]
  00079	2b c1		 sub	 eax, ecx
  0007b	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  0007e	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00081	88 02		 mov	 BYTE PTR [edx], al

; 32   : 	}

  00083	eb 93		 jmp	 SHORT $LN2@copy_and_e
$LN4@copy_and_e:

; 33   : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_copy_and_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_delta_props_encode
_TEXT	SEGMENT
tv77 = -12						; size = 8
_opt$32328 = -4						; size = 4
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_delta_props_encode PROC				; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 118  : 	// The caller must have already validated the options, so it's
; 119  : 	// LZMA_PROG_ERROR if they are invalid.
; 120  : 	if (lzma_delta_coder_memusage(options) == UINT64_MAX)

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_delta_coder_memusage
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  00015	89 55 f8	 mov	 DWORD PTR tv77[ebp+4], edx
  00018	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0001b	23 4d f8	 and	 ecx, DWORD PTR tv77[ebp+4]
  0001e	83 f9 ff	 cmp	 ecx, -1
  00021	75 07		 jne	 SHORT $LN1@lzma_delta@2

; 121  : 		return LZMA_PROG_ERROR;

  00023	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00028	eb 16		 jmp	 SHORT $LN2@lzma_delta@2
$LN1@lzma_delta@2:

; 122  : 
; 123  :   {
; 124  : 	const lzma_options_delta *opt = options;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _options$[ebp]
  0002d	89 55 fc	 mov	 DWORD PTR _opt$32328[ebp], edx

; 125  : 	out[0] = opt->dist - LZMA_DELTA_DIST_MIN;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _opt$32328[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	83 e9 01	 sub	 ecx, 1
  00039	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0003c	88 0a		 mov	 BYTE PTR [edx], cl

; 126  :   }
; 127  : 
; 128  : 	return LZMA_OK;

  0003e	33 c0		 xor	 eax, eax
$LN2@lzma_delta@2:

; 129  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_lzma_delta_props_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _delta_encoder_update
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters_null$ = 16					; size = 4
_reversed_filters$ = 20					; size = 4
_delta_encoder_update PROC				; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 95   : 	lzma_delta_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 96   : 
; 97   : 	// Delta doesn't and will never support changing the options in
; 98   : 	// the middle of encoding. If the app tries to change them, we
; 99   : 	// simply ignore them.
; 100  : 	return lzma_next_filter_update(
; 101  : 			&coder->next, allocator, reversed_filters + 1);

  0000a	8b 4d 14	 mov	 ecx, DWORD PTR _reversed_filters$[ebp]
  0000d	83 c1 10	 add	 ecx, 16			; 00000010H
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00014	52		 push	 edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _lzma_next_filter_update
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_delta_encoder_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _delta_encode
_TEXT	SEGMENT
tv80 = -32						; size = 4
tv69 = -28						; size = 4
_out_start$32303 = -24					; size = 4
_size$32301 = -20					; size = 4
_in_avail$32299 = -16					; size = 4
_out_avail$32300 = -12					; size = 4
_coder$ = -8						; size = 4
_ret$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_delta_encode PROC					; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 59   : 	lzma_delta_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _coder$[ebp], eax

; 60   : 
; 61   : 	lzma_ret ret;
; 62   : 
; 63   : 	if (coder->next.code == NULL) {

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00013	0f 85 96 00 00
	00		 jne	 $LN2@delta_enco

; 64   : 		const size_t in_avail = in_size - *in_pos;

  00019	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0001c	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  0001f	2b 02		 sub	 eax, DWORD PTR [edx]
  00021	89 45 f0	 mov	 DWORD PTR _in_avail$32299[ebp], eax

; 65   : 		const size_t out_avail = out_size - *out_pos;

  00024	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00027	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  0002a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0002c	89 55 f4	 mov	 DWORD PTR _out_avail$32300[ebp], edx

; 66   : 		const size_t size = my_min(in_avail, out_avail);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _in_avail$32299[ebp]
  00032	3b 45 f4	 cmp	 eax, DWORD PTR _out_avail$32300[ebp]
  00035	73 08		 jae	 SHORT $LN5@delta_enco
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _in_avail$32299[ebp]
  0003a	89 4d e4	 mov	 DWORD PTR tv69[ebp], ecx
  0003d	eb 06		 jmp	 SHORT $LN6@delta_enco
$LN5@delta_enco:
  0003f	8b 55 f4	 mov	 edx, DWORD PTR _out_avail$32300[ebp]
  00042	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
$LN6@delta_enco:
  00045	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]
  00048	89 45 ec	 mov	 DWORD PTR _size$32301[ebp], eax

; 67   : 
; 68   : 		copy_and_encode(coder, in + *in_pos, out + *out_pos, size);

  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _size$32301[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00052	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00055	03 02		 add	 eax, DWORD PTR [edx]
  00057	50		 push	 eax
  00058	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0005b	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  0005e	03 11		 add	 edx, DWORD PTR [ecx]
  00060	52		 push	 edx
  00061	8b 45 f8	 mov	 eax, DWORD PTR _coder$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _copy_and_encode
  0006a	83 c4 10	 add	 esp, 16			; 00000010H

; 69   : 
; 70   : 		*in_pos += size;

  0006d	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00070	8b 11		 mov	 edx, DWORD PTR [ecx]
  00072	03 55 ec	 add	 edx, DWORD PTR _size$32301[ebp]
  00075	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00078	89 10		 mov	 DWORD PTR [eax], edx

; 71   : 		*out_pos += size;

  0007a	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	03 55 ec	 add	 edx, DWORD PTR _size$32301[ebp]
  00082	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00085	89 10		 mov	 DWORD PTR [eax], edx

; 72   : 
; 73   : 		ret = action != LZMA_RUN && *in_pos == in_size
; 74   : 				? LZMA_STREAM_END : LZMA_OK;

  00087	83 7d 28 00	 cmp	 DWORD PTR _action$[ebp], 0
  0008b	74 13		 je	 SHORT $LN7@delta_enco
  0008d	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00090	8b 11		 mov	 edx, DWORD PTR [ecx]
  00092	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00095	75 09		 jne	 SHORT $LN7@delta_enco
  00097	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  0009e	eb 07		 jmp	 SHORT $LN8@delta_enco
$LN7@delta_enco:
  000a0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN8@delta_enco:
  000a7	8b 45 e0	 mov	 eax, DWORD PTR tv80[ebp]
  000aa	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 75   : 
; 76   : 	} else {

  000ad	eb 58		 jmp	 SHORT $LN1@delta_enco
$LN2@delta_enco:

; 77   : 		const size_t out_start = *out_pos;

  000af	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  000b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b4	89 55 e8	 mov	 DWORD PTR _out_start$32303[ebp], edx

; 78   : 
; 79   : 		ret = coder->next.code(coder->next.coder, allocator,
; 80   : 				in, in_pos, in_size, out, out_pos, out_size,
; 81   : 				action);

  000b7	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000c2	52		 push	 edx
  000c3	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  000ce	52		 push	 edx
  000cf	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _coder$[ebp]
  000da	8b 02		 mov	 eax, DWORD PTR [edx]
  000dc	50		 push	 eax
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e0	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000e3	ff d2		 call	 edx
  000e5	83 c4 24	 add	 esp, 36			; 00000024H
  000e8	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 82   : 
; 83   : 		encode_in_place(coder, out + out_start, *out_pos - out_start);

  000eb	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	2b 4d e8	 sub	 ecx, DWORD PTR _out_start$32303[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  000f7	03 55 e8	 add	 edx, DWORD PTR _out_start$32303[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _coder$[ebp]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 _encode_in_place
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@delta_enco:

; 84   : 	}
; 85   : 
; 86   : 	return ret;

  00107	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 87   : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_delta_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_delta_encoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_delta_encoder_init PROC				; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 109  : 	next->code = &delta_encode;

  00003	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00006	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _delta_encode

; 110  : 	next->update = &delta_encoder_update;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00010	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _delta_encoder_update

; 111  : 	return lzma_delta_coder_init(next, allocator, filters);

  00017	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 _lzma_delta_coder_init
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_lzma_delta_encoder_init ENDP
END
