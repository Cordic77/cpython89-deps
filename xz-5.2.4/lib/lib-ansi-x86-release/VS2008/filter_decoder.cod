; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\filter_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_decoders DQ	4000000000000001H
	DD	FLAT:_lzma_lzma_decoder_init
	DD	FLAT:_lzma_lzma_decoder_memusage
	DD	FLAT:_lzma_lzma_props_decode
	ORG $+4
	DQ	0000000000000021H
	DD	FLAT:_lzma_lzma2_decoder_init
	DD	FLAT:_lzma_lzma2_decoder_memusage
	DD	FLAT:_lzma_lzma2_props_decode
	ORG $+4
	DQ	0000000000000004H
	DD	FLAT:_lzma_simple_x86_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000005H
	DD	FLAT:_lzma_simple_powerpc_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000006H
	DD	FLAT:_lzma_simple_ia64_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000007H
	DD	FLAT:_lzma_simple_arm_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000008H
	DD	FLAT:_lzma_simple_armthumb_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000009H
	DD	FLAT:_lzma_simple_sparc_decoder_init
	DD	00H
	DD	FLAT:_lzma_simple_props_decode
	ORG $+4
	DQ	0000000000000003H
	DD	FLAT:_lzma_delta_decoder_init
	DD	FLAT:_lzma_delta_coder_memusage
	DD	FLAT:_lzma_delta_props_decode
	ORG $+4
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\filter_decoder.c
;	COMDAT _decoder_find
_TEXT	SEGMENT
tv73 = -8						; size = 4
_i$ = -4						; size = 4
_id$ = 8						; size = 8
_decoder_find PROC					; COMDAT

; 205  : {	size_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 206  : 
; 207  : 	for (i = 0; i < ARRAY_SIZE(decoders); ++i)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@decoder_fi
$LN3@decoder_fi:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@decoder_fi:
  00018	83 7d fc 09	 cmp	 DWORD PTR _i$[ebp], 9
  0001c	73 34		 jae	 SHORT $LN2@decoder_fi

; 208  : 		if (decoders[i].id == id)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	6b c9 18	 imul	 ecx, 24			; 00000018H
  00024	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00027	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  0002a	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _decoders[edx]
  00030	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  00033	75 1b		 jne	 SHORT $LN1@decoder_fi
  00035	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  00038	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _decoders[ecx+4]
  0003e	3b 55 0c	 cmp	 edx, DWORD PTR _id$[ebp+4]
  00041	75 0d		 jne	 SHORT $LN1@decoder_fi

; 209  : 			return decoders + i;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	6b c0 18	 imul	 eax, 24			; 00000018H
  00049	05 00 00 00 00	 add	 eax, OFFSET _decoders
  0004e	eb 04		 jmp	 SHORT $LN5@decoder_fi
$LN1@decoder_fi:

; 210  : 
; 211  : 	return NULL;

  00050	eb bd		 jmp	 SHORT $LN3@decoder_fi
$LN2@decoder_fi:
  00052	33 c0		 xor	 eax, eax
$LN5@decoder_fi:

; 212  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_decoder_find ENDP
PUBLIC	_lzma_properties_decode
; Function compile flags: /Odtp
;	COMDAT _lzma_properties_decode
_TEXT	SEGMENT
_fd$32484 = -4						; size = 4
_filter$ = 8						; size = 4
_allocator$ = 12					; size = 4
_props$ = 16						; size = 4
_props_size$ = 20					; size = 4
_lzma_properties_decode PROC				; COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 255  : 	// Make it always NULL so that the caller can always safely free() it.
; 256  : 	filter->options = NULL;

  00004	8b 45 08	 mov	 eax, DWORD PTR _filter$[ebp]
  00007	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 257  : 
; 258  :   {
; 259  : 	const lzma_filter_decoder *const fd = decoder_find(filter->id);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _filter$[ebp]
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	52		 push	 edx
  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _decoder_find
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 fc	 mov	 DWORD PTR _fd$32484[ebp], eax

; 260  : 	if (fd == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _fd$32484[ebp], 0
  00027	75 07		 jne	 SHORT $LN2@lzma_prope

; 261  : 		return LZMA_OPTIONS_ERROR;

  00029	b8 08 00 00 00	 mov	 eax, 8
  0002e	eb 33		 jmp	 SHORT $LN3@lzma_prope
$LN2@lzma_prope:

; 262  : 
; 263  : 	if (fd->props_decode == NULL)

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _fd$32484[ebp]
  00033	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00037	75 0c		 jne	 SHORT $LN1@lzma_prope

; 264  : 		return props_size == 0 ? LZMA_OK : LZMA_OPTIONS_ERROR;

  00039	8b 45 14	 mov	 eax, DWORD PTR _props_size$[ebp]
  0003c	f7 d8		 neg	 eax
  0003e	1b c0		 sbb	 eax, eax
  00040	83 e0 08	 and	 eax, 8
  00043	eb 1e		 jmp	 SHORT $LN3@lzma_prope
$LN1@lzma_prope:

; 265  : 
; 266  : 	return fd->props_decode(
; 267  : 			&filter->options, allocator, props, props_size);

  00045	8b 55 14	 mov	 edx, DWORD PTR _props_size$[ebp]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _props$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 08	 mov	 edx, DWORD PTR _filter$[ebp]
  00054	83 c2 08	 add	 edx, 8
  00057	52		 push	 edx
  00058	8b 45 fc	 mov	 eax, DWORD PTR _fd$32484[ebp]
  0005b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005e	ff d1		 call	 ecx
  00060	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@lzma_prope:

; 268  :   }
; 269  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_lzma_properties_decode ENDP
_TEXT	ENDS
PUBLIC	_lzma_raw_decoder_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_raw_decoder_memusage
_TEXT	SEGMENT
_filters$ = 8						; size = 4
_lzma_raw_decoder_memusage PROC				; COMDAT

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 246  : 	return lzma_raw_coder_memusage(
; 247  : 			(lzma_filter_find)(&decoder_find), filters);

  00003	8b 45 08	 mov	 eax, DWORD PTR _filters$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET _decoder_find
  0000c	e8 00 00 00 00	 call	 _lzma_raw_coder_memusage
  00011	83 c4 08	 add	 esp, 8

; 248  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_lzma_raw_decoder_memusage ENDP
PUBLIC	_lzma_raw_decoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_raw_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_options$ = 16						; size = 4
_lzma_raw_decoder_init PROC				; COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  : 	return lzma_raw_coder_init(next, allocator,
; 227  : 			options, (lzma_filter_find)(&decoder_find), false);

  00003	6a 00		 push	 0
  00005	68 00 00 00 00	 push	 OFFSET _decoder_find
  0000a	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _lzma_raw_coder_init
  0001b	83 c4 14	 add	 esp, 20			; 00000014H

; 228  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_lzma_raw_decoder_init ENDP
END
