; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\outqueue.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_outq_is_readable
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\outqueue.c
;	COMDAT _lzma_outq_is_readable
_TEXT	SEGMENT
_i$ = -4						; size = 4
_outq$ = 8						; size = 4
_lzma_outq_is_readable PROC				; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 140  : 	uint32_t i = outq->bufs_pos - outq->bufs_used;

  00004	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  0000a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0000d	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00010	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 141  : 	if (outq->bufs_pos < outq->bufs_used)

  00013	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00019	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0001c	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  0001f	73 0c		 jae	 SHORT $LN1@lzma_outq_

; 142  : 		i += outq->bufs_allocated;

  00021	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  0002a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN1@lzma_outq_:

; 143  : 
; 144  : 	return outq->bufs[i].finished;

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00030	c1 e2 05	 shl	 edx, 5
  00033	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	8a 44 11 18	 mov	 al, BYTE PTR [ecx+edx+24]

; 145  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_lzma_outq_is_readable ENDP
_TEXT	ENDS
PUBLIC	_lzma_outq_get_buf
; Function compile flags: /Odtp
;	COMDAT _lzma_outq_get_buf
_TEXT	SEGMENT
_buf$32336 = -4						; size = 4
_outq$ = 8						; size = 4
_lzma_outq_get_buf PROC					; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : 	// Caller must have checked it with lzma_outq_has_buf().
; 117  : 	assert(outq->bufs_used < outq->bufs_allocated);
; 118  : 
; 119  : 	// Initialize the new buffer.
; 120  :   {
; 121  : 	lzma_outbuf *buf = &outq->bufs[outq->bufs_pos];

  00004	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00007	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000a	c1 e1 05	 shl	 ecx, 5
  0000d	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00010	03 0a		 add	 ecx, DWORD PTR [edx]
  00012	89 4d fc	 mov	 DWORD PTR _buf$32336[ebp], ecx

; 122  : 	buf->buf = outq->bufs_mem + outq->bufs_pos * outq->buf_size_max;

  00015	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  0001b	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0001e	0f af 51 08	 imul	 edx, DWORD PTR [ecx+8]
  00022	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00025	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _buf$32336[ebp]
  0002b	89 11		 mov	 DWORD PTR [ecx], edx

; 123  : 	buf->size = 0;

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _buf$32336[ebp]
  00030	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 124  : 	buf->finished = false;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _buf$32336[ebp]
  0003a	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 125  : 
; 126  : 	// Update the queue state.
; 127  : 	if (++outq->bufs_pos == outq->bufs_allocated)

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00041	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00044	83 c2 01	 add	 edx, 1
  00047	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  0004a	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00053	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00056	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00059	75 0a		 jne	 SHORT $LN1@lzma_outq_@2

; 128  : 		outq->bufs_pos = 0;

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  0005e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
$LN1@lzma_outq_@2:

; 129  : 
; 130  : 	++outq->bufs_used;

  00065	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00068	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006b	83 c0 01	 add	 eax, 1
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00071	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 131  : 
; 132  : 	return buf;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _buf$32336[ebp]

; 133  :   }
; 134  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_lzma_outq_get_buf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_options
_TEXT	SEGMENT
_bufs_alloc_size$ = 8					; size = 4
_bufs_count$ = 12					; size = 4
_buf_size_max$ = 16					; size = 8
_threads$ = 24						; size = 4
_get_options PROC					; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	if (threads > LZMA_THREADS_MAX || buf_size_max > BUF_SIZE_MAX)

  00003	81 7d 18 00 40
	00 00		 cmp	 DWORD PTR _threads$[ebp], 16384 ; 00004000H
  0000a	77 11		 ja	 SHORT $LN1@get_option
  0000c	81 7d 14 ff ff
	00 00		 cmp	 DWORD PTR _buf_size_max$[ebp+4], 65535 ; 0000ffffH
  00013	72 0f		 jb	 SHORT $LN2@get_option
  00015	77 06		 ja	 SHORT $LN1@get_option
  00017	83 7d 10 ff	 cmp	 DWORD PTR _buf_size_max$[ebp], -1
  0001b	76 07		 jbe	 SHORT $LN2@get_option
$LN1@get_option:

; 27   : 		return LZMA_OPTIONS_ERROR;

  0001d	b8 08 00 00 00	 mov	 eax, 8
  00022	eb 2a		 jmp	 SHORT $LN3@get_option
$LN2@get_option:

; 28   : 
; 29   : 	// The number of buffers is twice the number of threads.
; 30   : 	// This wastes RAM but keeps the threads busy when buffers
; 31   : 	// finish out of order.
; 32   : 	//
; 33   : 	// NOTE: If this is changed, update BUF_SIZE_MAX too.
; 34   : 	*bufs_count = threads * 2;

  00024	8b 45 18	 mov	 eax, DWORD PTR _threads$[ebp]
  00027	d1 e0		 shl	 eax, 1
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _bufs_count$[ebp]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax

; 35   : 	*bufs_alloc_size = *bufs_count * buf_size_max;

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _bufs_count$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	33 c9		 xor	 ecx, ecx
  00035	8b 55 14	 mov	 edx, DWORD PTR _buf_size_max$[ebp+4]
  00038	52		 push	 edx
  00039	8b 55 10	 mov	 edx, DWORD PTR _buf_size_max$[ebp]
  0003c	52		 push	 edx
  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __allmul
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _bufs_alloc_size$[ebp]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 36   : 
; 37   : 	return LZMA_OK;

  0004c	33 c0		 xor	 eax, eax
$LN3@get_option:

; 38   : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_get_options ENDP
PUBLIC	_lzma_outq_read
; Function compile flags: /Odtp
;	COMDAT _lzma_outq_read
_TEXT	SEGMENT
_buf$32359 = -8						; size = 4
_i$32357 = -4						; size = 4
_outq$ = 8						; size = 4
_out$ = 12						; size = 4
_out_pos$ = 16						; size = 4
_out_size$ = 20						; size = 4
_unpadded_size$ = 24					; size = 4
_uncompressed_size$ = 28				; size = 4
_lzma_outq_read PROC					; COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 154  : 	// There must be at least one buffer from which to read.
; 155  : 	if (outq->bufs_used == 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00009	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000d	75 07		 jne	 SHORT $LN4@lzma_outq_@3

; 156  : 		return LZMA_OK;

  0000f	33 c0		 xor	 eax, eax
  00011	e9 c0 00 00 00	 jmp	 $LN5@lzma_outq_@3
$LN4@lzma_outq_@3:

; 157  : 
; 158  : 	// Get the buffer.
; 159  :   {
; 160  : 	uint32_t i = outq->bufs_pos - outq->bufs_used;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00019	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  0001c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001f	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00022	89 45 fc	 mov	 DWORD PTR _i$32357[ebp], eax

; 161  : 	if (outq->bufs_pos < outq->bufs_used)

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00028	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  0002b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002e	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00031	73 0c		 jae	 SHORT $LN3@lzma_outq_@3

; 162  : 		i += outq->bufs_allocated;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00036	8b 55 fc	 mov	 edx, DWORD PTR _i$32357[ebp]
  00039	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  0003c	89 55 fc	 mov	 DWORD PTR _i$32357[ebp], edx
$LN3@lzma_outq_@3:

; 163  : 
; 164  :   {
; 165  : 	lzma_outbuf *buf = &outq->bufs[i];

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _i$32357[ebp]
  00042	c1 e0 05	 shl	 eax, 5
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00048	03 01		 add	 eax, DWORD PTR [ecx]
  0004a	89 45 f8	 mov	 DWORD PTR _buf$32359[ebp], eax

; 166  : 
; 167  : 	// If it isn't finished yet, we cannot read from it.
; 168  : 	if (!buf->finished)

  0004d	8b 55 f8	 mov	 edx, DWORD PTR _buf$32359[ebp]
  00050	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  00054	85 c0		 test	 eax, eax
  00056	75 04		 jne	 SHORT $LN2@lzma_outq_@3

; 169  : 		return LZMA_OK;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 7a		 jmp	 SHORT $LN5@lzma_outq_@3
$LN2@lzma_outq_@3:

; 170  : 
; 171  : 	// Copy from the buffer to output.
; 172  : 	lzma_bufcpy(buf->buf, &outq->read_pos, buf->size,
; 173  : 			out, out_pos, out_size);

  0005c	8b 4d 14	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 10	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00063	52		 push	 edx
  00064	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00067	50		 push	 eax
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _buf$32359[ebp]
  0006b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006e	52		 push	 edx
  0006f	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00072	83 c0 18	 add	 eax, 24			; 00000018H
  00075	50		 push	 eax
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _buf$32359[ebp]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _lzma_bufcpy
  00081	83 c4 18	 add	 esp, 24			; 00000018H

; 174  : 
; 175  : 	// Return if we didn't get all the data from the buffer.
; 176  : 	if (outq->read_pos < buf->size)

  00084	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _buf$32359[ebp]
  0008a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0008d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00090	73 04		 jae	 SHORT $LN1@lzma_outq_@3

; 177  : 		return LZMA_OK;

  00092	33 c0		 xor	 eax, eax
  00094	eb 40		 jmp	 SHORT $LN5@lzma_outq_@3
$LN1@lzma_outq_@3:

; 178  : 
; 179  : 	// The buffer was finished. Tell the caller its size information.
; 180  : 	*unpadded_size = buf->unpadded_size;

  00096	8b 45 18	 mov	 eax, DWORD PTR _unpadded_size$[ebp]
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _buf$32359[ebp]
  0009c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009f	89 10		 mov	 DWORD PTR [eax], edx
  000a1	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000a4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 181  : 	*uncompressed_size = buf->uncompressed_size;

  000a7	8b 55 1c	 mov	 edx, DWORD PTR _uncompressed_size$[ebp]
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _buf$32359[ebp]
  000ad	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b0	89 0a		 mov	 DWORD PTR [edx], ecx
  000b2	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000b5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 182  :   }}
; 183  : 
; 184  : 	// Free this buffer for further use.
; 185  : 	--outq->bufs_used;

  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  000bb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000be	83 ea 01	 sub	 edx, 1
  000c1	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  000c4	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 186  : 	outq->read_pos = 0;

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  000ca	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 187  : 
; 188  : 	return LZMA_STREAM_END;

  000d1	b8 01 00 00 00	 mov	 eax, 1
$LN5@lzma_outq_@3:

; 189  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
_lzma_outq_read ENDP
_TEXT	ENDS
PUBLIC	_lzma_outq_end
; Function compile flags: /Odtp
;	COMDAT _lzma_outq_end
_TEXT	SEGMENT
_outq$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma_outq_end PROC					; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 	lzma_free(outq->bufs, allocator);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 _lzma_free
  00012	83 c4 08	 add	 esp, 8

; 104  : 	outq->bufs = NULL;

  00015	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 105  : 
; 106  : 	lzma_free(outq->bufs_mem, allocator);

  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _lzma_free
  0002e	83 c4 08	 add	 esp, 8

; 107  : 	outq->bufs_mem = NULL;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00034	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 108  : 
; 109  : 	return;
; 110  : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_lzma_outq_end ENDP
_TEXT	ENDS
PUBLIC	_lzma_outq_init
; Function compile flags: /Odtp
;	COMDAT _lzma_outq_init
_TEXT	SEGMENT
tv144 = -24						; size = 8
_ret_$32313 = -16					; size = 4
_bufs_count$ = -12					; size = 4
_bufs_alloc_size$ = -8					; size = 8
_outq$ = 8						; size = 4
_allocator$ = 12					; size = 4
_buf_size_max$ = 16					; size = 8
_threads$ = 24						; size = 4
_lzma_outq_init PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
$LN9@lzma_outq_@4:

; 60   : 	uint64_t bufs_alloc_size;
; 61   : 	uint32_t bufs_count;
; 62   : 
; 63   : 	// Set bufs_count and bufs_alloc_size.
; 64   : 	return_if_error(get_options(&bufs_alloc_size, &bufs_count,
; 65   : 			buf_size_max, threads));

  00006	8b 45 18	 mov	 eax, DWORD PTR _threads$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 14	 mov	 ecx, DWORD PTR _buf_size_max$[ebp+4]
  0000d	51		 push	 ecx
  0000e	8b 55 10	 mov	 edx, DWORD PTR _buf_size_max$[ebp]
  00011	52		 push	 edx
  00012	8d 45 f4	 lea	 eax, DWORD PTR _bufs_count$[ebp]
  00015	50		 push	 eax
  00016	8d 4d f8	 lea	 ecx, DWORD PTR _bufs_alloc_size$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _get_options
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	89 45 f0	 mov	 DWORD PTR _ret_$32313[ebp], eax
  00025	83 7d f0 00	 cmp	 DWORD PTR _ret_$32313[ebp], 0
  00029	74 08		 je	 SHORT $LN8@lzma_outq_@4
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _ret_$32313[ebp]
  0002e	e9 db 00 00 00	 jmp	 $LN10@lzma_outq_@4
$LN8@lzma_outq_@4:
  00033	33 d2		 xor	 edx, edx
  00035	75 cf		 jne	 SHORT $LN9@lzma_outq_@4

; 66   : 
; 67   : 	// Allocate memory if needed.
; 68   : 	if (outq->buf_size_max != buf_size_max
; 69   : 			|| outq->bufs_allocated != bufs_count) {

  00037	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  0003a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003d	33 d2		 xor	 edx, edx
  0003f	89 4d e8	 mov	 DWORD PTR tv144[ebp], ecx
  00042	89 55 ec	 mov	 DWORD PTR tv144[ebp+4], edx
  00045	8b 45 e8	 mov	 eax, DWORD PTR tv144[ebp]
  00048	3b 45 10	 cmp	 eax, DWORD PTR _buf_size_max$[ebp]
  0004b	75 13		 jne	 SHORT $LN4@lzma_outq_@4
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp+4]
  00050	3b 4d 14	 cmp	 ecx, DWORD PTR _buf_size_max$[ebp+4]
  00053	75 0b		 jne	 SHORT $LN4@lzma_outq_@4
  00055	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00058	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005b	3b 45 f4	 cmp	 eax, DWORD PTR _bufs_count$[ebp]
  0005e	74 7c		 je	 SHORT $LN5@lzma_outq_@4
$LN4@lzma_outq_@4:

; 70   : 		lzma_outq_end(outq, allocator);

  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _lzma_outq_end
  0006d	83 c4 08	 add	 esp, 8

; 71   : 
; 72   : #if SIZE_MAX < UINT64_MAX
; 73   : 		if (bufs_alloc_size > SIZE_MAX)

  00070	83 7d fc 00	 cmp	 DWORD PTR _bufs_alloc_size$[ebp+4], 0
  00074	77 06		 ja	 SHORT $LN12@lzma_outq_@4
  00076	83 7d f8 ff	 cmp	 DWORD PTR _bufs_alloc_size$[ebp], -1
  0007a	76 0a		 jbe	 SHORT $LN3@lzma_outq_@4
$LN12@lzma_outq_@4:

; 74   : 			return LZMA_MEM_ERROR;

  0007c	b8 05 00 00 00	 mov	 eax, 5
  00081	e9 88 00 00 00	 jmp	 $LN10@lzma_outq_@4
$LN3@lzma_outq_@4:

; 75   : #endif
; 76   : 
; 77   : 		outq->bufs = lzma_alloc(bufs_count * sizeof(lzma_outbuf),
; 78   : 				allocator);

  00086	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _bufs_count$[ebp]
  0008d	c1 e1 05	 shl	 ecx, 5
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _lzma_alloc
  00096	83 c4 08	 add	 esp, 8
  00099	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  0009c	89 02		 mov	 DWORD PTR [edx], eax

; 79   : 		outq->bufs_mem = lzma_alloc((size_t)(bufs_alloc_size),
; 80   : 				allocator);

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _bufs_alloc_size$[ebp]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _lzma_alloc
  000ab	83 c4 08	 add	 esp, 8
  000ae	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  000b1	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 81   : 
; 82   : 		if (outq->bufs == NULL || outq->bufs_mem == NULL) {

  000b4	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  000b7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ba	74 09		 je	 SHORT $LN1@lzma_outq_@4
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  000bf	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000c3	75 17		 jne	 SHORT $LN5@lzma_outq_@4
$LN1@lzma_outq_@4:

; 83   : 			lzma_outq_end(outq, allocator);

  000c5	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _lzma_outq_end
  000d2	83 c4 08	 add	 esp, 8

; 84   : 			return LZMA_MEM_ERROR;

  000d5	b8 05 00 00 00	 mov	 eax, 5
  000da	eb 32		 jmp	 SHORT $LN10@lzma_outq_@4
$LN5@lzma_outq_@4:

; 85   : 		}
; 86   : 	}
; 87   : 
; 88   : 	// Initialize the rest of the main structure. Initialization of
; 89   : 	// outq->bufs[] is done when they are actually needed.
; 90   : 	outq->buf_size_max = (size_t)(buf_size_max);

  000dc	8b 4d 10	 mov	 ecx, DWORD PTR _buf_size_max$[ebp]
  000df	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  000e2	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 91   : 	outq->bufs_allocated = bufs_count;

  000e5	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR _bufs_count$[ebp]
  000eb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 92   : 	outq->bufs_pos = 0;

  000ee	8b 55 08	 mov	 edx, DWORD PTR _outq$[ebp]
  000f1	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 93   : 	outq->bufs_used = 0;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _outq$[ebp]
  000fb	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 94   : 	outq->read_pos = 0;

  00102	8b 4d 08	 mov	 ecx, DWORD PTR _outq$[ebp]
  00105	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 95   : 
; 96   : 	return LZMA_OK;

  0010c	33 c0		 xor	 eax, eax
$LN10@lzma_outq_@4:

; 97   : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_lzma_outq_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_outq_memusage
; Function compile flags: /Odtp
;	COMDAT _lzma_outq_memusage
_TEXT	SEGMENT
_bufs_count$ = -12					; size = 4
_bufs_alloc_size$ = -8					; size = 8
_buf_size_max$ = 8					; size = 8
_threads$ = 16						; size = 4
_lzma_outq_memusage PROC				; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 44   : 	uint64_t bufs_alloc_size;
; 45   : 	uint32_t bufs_count;
; 46   : 
; 47   : 	if (get_options(&bufs_alloc_size, &bufs_count, buf_size_max, threads)
; 48   : 			!= LZMA_OK)

  00006	8b 45 10	 mov	 eax, DWORD PTR _threads$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _buf_size_max$[ebp+4]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _buf_size_max$[ebp]
  00011	52		 push	 edx
  00012	8d 45 f4	 lea	 eax, DWORD PTR _bufs_count$[ebp]
  00015	50		 push	 eax
  00016	8d 4d f8	 lea	 ecx, DWORD PTR _bufs_alloc_size$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _get_options
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	85 c0		 test	 eax, eax
  00024	74 08		 je	 SHORT $LN1@lzma_outq_@5

; 49   : 		return UINT64_MAX;

  00026	83 c8 ff	 or	 eax, -1
  00029	83 ca ff	 or	 edx, -1
  0002c	eb 13		 jmp	 SHORT $LN2@lzma_outq_@5
$LN1@lzma_outq_@5:

; 50   : 
; 51   : 	return sizeof(lzma_outq) + bufs_count * sizeof(lzma_outbuf)
; 52   : 			+ bufs_alloc_size;

  0002e	8b 55 f4	 mov	 edx, DWORD PTR _bufs_count$[ebp]
  00031	c1 e2 05	 shl	 edx, 5
  00034	83 c2 1c	 add	 edx, 28			; 0000001cH
  00037	8b c2		 mov	 eax, edx
  00039	33 d2		 xor	 edx, edx
  0003b	03 45 f8	 add	 eax, DWORD PTR _bufs_alloc_size$[ebp]
  0003e	13 55 fc	 adc	 edx, DWORD PTR _bufs_alloc_size$[ebp+4]
$LN2@lzma_outq_@5:

; 53   : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_lzma_outq_memusage ENDP
END
