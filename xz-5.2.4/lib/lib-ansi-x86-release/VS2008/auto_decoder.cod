; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\Projects\MPython\cpython89\externals\xz-5.2.3\src\c89\liblzma\common\auto_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\projects\mpython\cpython89\externals\xz-5.2.3\src\c89\liblzma\common\auto_decoder.c
;	COMDAT _auto_decoder_memconfig
_TEXT	SEGMENT
_coder$ = -8						; size = 4
_ret$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_memusage$ = 12						; size = 4
_old_memlimit$ = 16					; size = 4
_new_memlimit$ = 20					; size = 8
_auto_decoder_memconfig PROC				; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 129  : 	lzma_auto_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _coder$[ebp], eax

; 130  : 
; 131  : 	lzma_ret ret;
; 132  : 
; 133  : 	if (coder->next.memconfig != NULL) {

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00013	74 26		 je	 SHORT $LN3@auto_decod

; 134  : 		ret = coder->next.memconfig(coder->next.coder,
; 135  : 				memusage, old_memlimit, new_memlimit);

  00015	8b 55 18	 mov	 edx, DWORD PTR _new_memlimit$[ebp+4]
  00018	52		 push	 edx
  00019	8b 45 14	 mov	 eax, DWORD PTR _new_memlimit$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _old_memlimit$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR _memusage$[ebp]
  00024	52		 push	 edx
  00025	8b 45 f8	 mov	 eax, DWORD PTR _coder$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 f8	 mov	 edx, DWORD PTR _coder$[ebp]
  0002e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00031	ff d0		 call	 eax
  00033	83 c4 14	 add	 esp, 20			; 00000014H
  00036	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 136  : 		assert(*old_memlimit == coder->memlimit);
; 137  : 	} else {

  00039	eb 28		 jmp	 SHORT $LN2@auto_decod
$LN3@auto_decod:

; 138  : 		// No coder is configured yet. Use the base value as
; 139  : 		// the current memory usage.
; 140  : 		*memusage = LZMA_MEMUSAGE_BASE;

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _memusage$[ebp]
  0003e	c7 01 00 80 00
	00		 mov	 DWORD PTR [ecx], 32768	; 00008000H
  00044	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 141  : 		*old_memlimit = coder->memlimit;

  0004b	8b 55 10	 mov	 edx, DWORD PTR _old_memlimit$[ebp]
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _coder$[ebp]
  00051	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00054	89 0a		 mov	 DWORD PTR [edx], ecx
  00056	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00059	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 142  : 		ret = LZMA_OK;

  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN2@auto_decod:

; 143  : 	}
; 144  : 
; 145  : 	if (ret == LZMA_OK && new_memlimit != 0)

  00063	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00067	75 17		 jne	 SHORT $LN1@auto_decod
  00069	8b 4d 14	 mov	 ecx, DWORD PTR _new_memlimit$[ebp]
  0006c	0b 4d 18	 or	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  0006f	74 0f		 je	 SHORT $LN1@auto_decod

; 146  : 		coder->memlimit = new_memlimit;

  00071	8b 55 f8	 mov	 edx, DWORD PTR _coder$[ebp]
  00074	8b 45 14	 mov	 eax, DWORD PTR _new_memlimit$[ebp]
  00077	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0007a	8b 4d 18	 mov	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  0007d	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
$LN1@auto_decod:

; 147  : 
; 148  : 	return ret;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 149  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_auto_decoder_memconfig ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _auto_decoder_get_check
_TEXT	SEGMENT
tv69 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_auto_decoder_get_check PROC				; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 117  : 	const lzma_auto_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 118  : 
; 119  : 	// It is LZMA_Alone if get_check is NULL.
; 120  : 	return coder->next.get_check == NULL ? LZMA_CHECK_NONE
; 121  : 			: coder->next.get_check(coder->next.coder);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00013	75 09		 jne	 SHORT $LN3@auto_decod@2
  00015	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0001c	eb 14		 jmp	 SHORT $LN4@auto_decod@2
$LN3@auto_decod@2:
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00027	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0002a	ff d2		 call	 edx
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
$LN4@auto_decod@2:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 122  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_auto_decoder_get_check ENDP
; Function compile flags: /Odtp
;	COMDAT _auto_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_auto_decoder_end PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 107  : 	lzma_auto_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 108  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 109  : 	lzma_free(coder, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _lzma_free
  00027	83 c4 08	 add	 esp, 8

; 110  : 	return;
; 111  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_auto_decoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _auto_decode
_TEXT	SEGMENT
tv65 = -20						; size = 4
_ret$32301 = -16					; size = 4
_ret_$32296 = -12					; size = 4
_ret_$32290 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_auto_decode PROC					; COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 38   : 	lzma_auto_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 39   : 
; 40   : 	switch (coder->sequence) {

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00012	89 55 ec	 mov	 DWORD PTR tv65[ebp], edx
  00015	83 7d ec 00	 cmp	 DWORD PTR tv65[ebp], 0
  00019	74 19		 je	 SHORT $LN20@auto_decod@3
  0001b	83 7d ec 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001f	0f 84 cf 00 00
	00		 je	 $LN6@auto_decod@3
  00025	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00029	0f 84 19 01 00
	00		 je	 $LN3@auto_decod@3
  0002f	e9 30 01 00 00	 jmp	 $LN1@auto_decod@3
$LN20@auto_decod@3:

; 41   : 	case SEQ_INIT:
; 42   : 		if (*in_pos >= in_size)

  00034	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  0003c	72 07		 jb	 SHORT $LN19@auto_decod@3

; 43   : 			return LZMA_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 24 01 00 00	 jmp	 $LN23@auto_decod@3
$LN19@auto_decod@3:

; 44   : 
; 45   : 		// Update the sequence now, because we want to continue from
; 46   : 		// SEQ_CODE even if we return some LZMA_*_CHECK.
; 47   : 		coder->sequence = SEQ_CODE;

  00045	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00048	c7 42 3c 01 00
	00 00		 mov	 DWORD PTR [edx+60], 1

; 48   : 
; 49   : 		// Detect the file format. For now this is simple, since if
; 50   : 		// it doesn't start with 0xFD (the first magic byte of the
; 51   : 		// new format), it has to be LZMA_Alone, or something that
; 52   : 		// we don't support at all.
; 53   : 		if (in[*in_pos] == 0xFD) {

  0004f	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00057	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0005b	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  00060	75 39		 jne	 SHORT $LN12@auto_decod@3
$LN17@auto_decod@3:

; 54   : 			return_if_error(lzma_stream_decoder_init(
; 55   : 					&coder->next, allocator,
; 56   : 					coder->memlimit, coder->flags));

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00065	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00068	52		 push	 edx
  00069	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0006c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006f	51		 push	 ecx
  00070	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00073	52		 push	 edx
  00074	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00077	50		 push	 eax
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _lzma_stream_decoder_init
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	89 45 f8	 mov	 DWORD PTR _ret_$32290[ebp], eax
  00087	83 7d f8 00	 cmp	 DWORD PTR _ret_$32290[ebp], 0
  0008b	74 08		 je	 SHORT $LN16@auto_decod@3
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32290[ebp]
  00090	e9 d4 00 00 00	 jmp	 $LN23@auto_decod@3
$LN16@auto_decod@3:
  00095	33 d2		 xor	 edx, edx
  00097	75 c9		 jne	 SHORT $LN17@auto_decod@3

; 57   : 		} else {

  00099	eb 59		 jmp	 SHORT $LN6@auto_decod@3
$LN12@auto_decod@3:

; 58   : 			return_if_error(lzma_alone_decoder_init(&coder->next,
; 59   : 					allocator, coder->memlimit, true));

  0009b	6a 01		 push	 1
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000a0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a3	51		 push	 ecx
  000a4	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  000a7	52		 push	 edx
  000a8	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _lzma_alone_decoder_init
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
  000b8	89 45 f4	 mov	 DWORD PTR _ret_$32296[ebp], eax
  000bb	83 7d f4 00	 cmp	 DWORD PTR _ret_$32296[ebp], 0
  000bf	74 08		 je	 SHORT $LN11@auto_decod@3
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32296[ebp]
  000c4	e9 a0 00 00 00	 jmp	 $LN23@auto_decod@3
$LN11@auto_decod@3:
  000c9	33 d2		 xor	 edx, edx
  000cb	75 ce		 jne	 SHORT $LN12@auto_decod@3

; 60   : 
; 61   : 			// If the application wants to know about missing
; 62   : 			// integrity check or about the check in general, we
; 63   : 			// need to handle it here, because LZMA_Alone decoder
; 64   : 			// doesn't accept any flags.
; 65   : 			if (coder->flags & LZMA_TELL_NO_CHECK)

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000d0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000d3	83 e1 01	 and	 ecx, 1
  000d6	74 0a		 je	 SHORT $LN8@auto_decod@3

; 66   : 				return LZMA_NO_CHECK;

  000d8	b8 02 00 00 00	 mov	 eax, 2
  000dd	e9 87 00 00 00	 jmp	 $LN23@auto_decod@3
$LN8@auto_decod@3:

; 67   : 
; 68   : 			if (coder->flags & LZMA_TELL_ANY_CHECK)

  000e2	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000e5	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000e8	83 e0 04	 and	 eax, 4
  000eb	74 07		 je	 SHORT $LN6@auto_decod@3

; 69   : 				return LZMA_GET_CHECK;

  000ed	b8 04 00 00 00	 mov	 eax, 4
  000f2	eb 75		 jmp	 SHORT $LN23@auto_decod@3
$LN6@auto_decod@3:

; 70   : 		}
; 71   : 
; 72   : 	// Fall through
; 73   : 
; 74   : 	case SEQ_CODE: {
; 75   : 		const lzma_ret ret = coder->next.code(
; 76   : 				coder->next.coder, allocator,
; 77   : 				in, in_pos, in_size,
; 78   : 				out, out_pos, out_size, action);

  000f4	8b 4d 28	 mov	 ecx, DWORD PTR _action$[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00103	51		 push	 ecx
  00104	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  00107	52		 push	 edx
  00108	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00113	52		 push	 edx
  00114	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00117	8b 08		 mov	 ecx, DWORD PTR [eax]
  00119	51		 push	 ecx
  0011a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0011d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00120	ff d0		 call	 eax
  00122	83 c4 24	 add	 esp, 36			; 00000024H
  00125	89 45 f0	 mov	 DWORD PTR _ret$32301[ebp], eax

; 79   : 		if (ret != LZMA_STREAM_END
; 80   : 				|| (coder->flags & LZMA_CONCATENATED) == 0)

  00128	83 7d f0 01	 cmp	 DWORD PTR _ret$32301[ebp], 1
  0012c	75 0b		 jne	 SHORT $LN4@auto_decod@3
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00131	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00134	83 e2 08	 and	 edx, 8
  00137	75 05		 jne	 SHORT $LN5@auto_decod@3
$LN4@auto_decod@3:

; 81   : 			return ret;

  00139	8b 45 f0	 mov	 eax, DWORD PTR _ret$32301[ebp]
  0013c	eb 2b		 jmp	 SHORT $LN23@auto_decod@3
$LN5@auto_decod@3:

; 82   : 
; 83   : 		coder->sequence = SEQ_FINISH;

  0013e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00141	c7 40 3c 02 00
	00 00		 mov	 DWORD PTR [eax+60], 2
$LN3@auto_decod@3:

; 84   : 	}
; 85   : 
; 86   : 	// Fall through
; 87   : 
; 88   : 	case SEQ_FINISH:
; 89   : 		// When LZMA_DECODE_CONCATENATED was used and we were decoding
; 90   : 		// LZMA_Alone file, we need to check check that there is no
; 91   : 		// trailing garbage and wait for LZMA_FINISH.
; 92   : 		if (*in_pos < in_size)

  00148	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0014b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014d	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00150	73 07		 jae	 SHORT $LN2@auto_decod@3

; 93   : 			return LZMA_DATA_ERROR;

  00152	b8 09 00 00 00	 mov	 eax, 9
  00157	eb 10		 jmp	 SHORT $LN23@auto_decod@3
$LN2@auto_decod@3:

; 94   : 
; 95   : 		return action == LZMA_FINISH ? LZMA_STREAM_END : LZMA_OK;

  00159	33 c0		 xor	 eax, eax
  0015b	83 7d 28 03	 cmp	 DWORD PTR _action$[ebp], 3
  0015f	0f 94 c0	 sete	 al
  00162	eb 05		 jmp	 SHORT $LN23@auto_decod@3
$LN1@auto_decod@3:

; 96   : 
; 97   : 	default:
; 98   : 		assert(0);
; 99   : 		return LZMA_PROG_ERROR;

  00164	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN23@auto_decod@3:

; 100  : 	}
; 101  : }

  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
_auto_decode ENDP
; Function compile flags: /Odtp
;	COMDAT _auto_decoder_init
_TEXT	SEGMENT
_coder$32356 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_memlimit$ = 16						; size = 8
_flags$ = 24						; size = 4
_auto_decoder_init PROC					; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
$LN8@auto_decod@4:

; 156  : 	lzma_next_coder_init(&auto_decoder_init, next, allocator);

  00006	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00009	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _auto_decoder_init
  00010	74 10		 je	 SHORT $LN5@auto_decod@4
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 _lzma_next_end
  0001f	83 c4 08	 add	 esp, 8
$LN5@auto_decod@4:
  00022	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00025	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _auto_decoder_init
  0002c	33 c9		 xor	 ecx, ecx
  0002e	75 d6		 jne	 SHORT $LN8@auto_decod@4

; 157  : 
; 158  : 	if (memlimit == 0)

  00030	8b 55 10	 mov	 edx, DWORD PTR _memlimit$[ebp]
  00033	0b 55 14	 or	 edx, DWORD PTR _memlimit$[ebp+4]
  00036	75 0a		 jne	 SHORT $LN4@auto_decod@4

; 159  : 		return LZMA_PROG_ERROR;

  00038	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0003d	e9 a1 00 00 00	 jmp	 $LN9@auto_decod@4
$LN4@auto_decod@4:

; 160  : 
; 161  : 	if (flags & ~LZMA_SUPPORTED_FLAGS)

  00042	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00045	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00048	74 0a		 je	 SHORT $LN3@auto_decod@4

; 162  : 		return LZMA_OPTIONS_ERROR;

  0004a	b8 08 00 00 00	 mov	 eax, 8
  0004f	e9 8f 00 00 00	 jmp	 $LN9@auto_decod@4
$LN3@auto_decod@4:

; 163  : 
; 164  :   {
; 165  : 	lzma_auto_coder *coder = next->coder;

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	89 55 fc	 mov	 DWORD PTR _coder$32356[ebp], edx

; 166  : 	if (coder == NULL) {

  0005c	83 7d fc 00	 cmp	 DWORD PTR _coder$32356[ebp], 0
  00060	75 5d		 jne	 SHORT $LN2@auto_decod@4

; 167  : 		coder = lzma_alloc(sizeof(lzma_auto_coder), allocator);

  00062	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00065	50		 push	 eax
  00066	6a 40		 push	 64			; 00000040H
  00068	e8 00 00 00 00	 call	 _lzma_alloc
  0006d	83 c4 08	 add	 esp, 8
  00070	89 45 fc	 mov	 DWORD PTR _coder$32356[ebp], eax

; 168  : 		if (coder == NULL)

  00073	83 7d fc 00	 cmp	 DWORD PTR _coder$32356[ebp], 0
  00077	75 07		 jne	 SHORT $LN1@auto_decod@4

; 169  : 			return LZMA_MEM_ERROR;

  00079	b8 05 00 00 00	 mov	 eax, 5
  0007e	eb 63		 jmp	 SHORT $LN9@auto_decod@4
$LN1@auto_decod@4:

; 170  : 
; 171  : 		next->coder = coder;

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00083	8b 55 fc	 mov	 edx, DWORD PTR _coder$32356[ebp]
  00086	89 11		 mov	 DWORD PTR [ecx], edx

; 172  : 		next->code = &auto_decode;

  00088	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0008b	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _auto_decode

; 173  : 		next->end = &auto_decoder_end;

  00092	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00095	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _auto_decoder_end

; 174  : 		next->get_check = &auto_decoder_get_check;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0009f	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _auto_decoder_get_check

; 175  : 		next->memconfig = &auto_decoder_memconfig;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  000a9	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _auto_decoder_memconfig

; 176  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000b0	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000b5	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000ba	8b 7d fc	 mov	 edi, DWORD PTR _coder$32356[ebp]
  000bd	f3 a5		 rep movsd
$LN2@auto_decod@4:

; 177  : 	}
; 178  : 
; 179  : 	coder->memlimit = memlimit;

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32356[ebp]
  000c2	8b 55 10	 mov	 edx, DWORD PTR _memlimit$[ebp]
  000c5	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  000c8	8b 45 14	 mov	 eax, DWORD PTR _memlimit$[ebp+4]
  000cb	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 180  : 	coder->flags = flags;

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32356[ebp]
  000d1	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  000d4	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 181  : 	coder->sequence = SEQ_INIT;

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _coder$32356[ebp]
  000da	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 182  :   }
; 183  : 
; 184  : 	return LZMA_OK;

  000e1	33 c0		 xor	 eax, eax
$LN9@auto_decod@4:

; 185  : }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_auto_decoder_init ENDP
PUBLIC	_lzma_auto_decoder
; Function compile flags: /Odtp
;	COMDAT _lzma_auto_decoder
_TEXT	SEGMENT
_ret_$32377 = -8					; size = 4
_ret_$32375 = -4					; size = 4
_strm$ = 8						; size = 4
_memlimit$ = 12						; size = 8
_flags$ = 20						; size = 4
_lzma_auto_decoder PROC					; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_auto_:

; 191  : 	lzma_next_strm_init(auto_decoder_init, strm, memlimit, flags);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32375[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32375[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_auto_
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32375[ebp]
  0001e	eb 5a		 jmp	 SHORT $LN9@lzma_auto_
$LN4@lzma_auto_:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_auto_
  00024	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  00027	52		 push	 edx
  00028	8b 45 10	 mov	 eax, DWORD PTR _memlimit$[ebp+4]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _memlimit$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00033	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _auto_decoder_init
  00043	83 c4 14	 add	 esp, 20			; 00000014H
  00046	89 45 f8	 mov	 DWORD PTR _ret_$32377[ebp], eax
  00049	83 7d f8 00	 cmp	 DWORD PTR _ret_$32377[ebp], 0
  0004d	74 11		 je	 SHORT $LN7@lzma_auto_
  0004f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _lzma_end
  00058	83 c4 04	 add	 esp, 4
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32377[ebp]
  0005e	eb 1a		 jmp	 SHORT $LN9@lzma_auto_
$LN7@lzma_auto_:
  00060	33 c9		 xor	 ecx, ecx
  00062	75 a2		 jne	 SHORT $LN5@lzma_auto_

; 192  : 
; 193  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00064	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00067	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006a	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1

; 194  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00071	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00074	c6 42 3b 01	 mov	 BYTE PTR [edx+59], 1

; 195  : 
; 196  : 	return LZMA_OK;

  00078	33 c0		 xor	 eax, eax
$LN9@lzma_auto_:

; 197  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_lzma_auto_decoder ENDP
END
