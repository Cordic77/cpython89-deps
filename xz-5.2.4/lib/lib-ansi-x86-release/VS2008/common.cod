; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\common.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_LZMA_NEXT_CODER_INIT
PUBLIC	??_C@_05LHKAPBBA@5?42?44?$AA@			; `string'
EXTRN	_malloc:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_05LHKAPBBA@5?42?44?$AA@
CONST	SEGMENT
??_C@_05LHKAPBBA@5?42?44?$AA@ DB '5.2.4', 00H		; `string'
	ORG $+16
_LZMA_NEXT_CODER_INIT DD 00H
	ORG $+4
	DQ	ffffffffffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
PUBLIC	_lzma_code
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\common.c
;	COMDAT _lzma_code
_TEXT	SEGMENT
tv208 = -32						; size = 4
tv137 = -28						; size = 4
tv136 = -24						; size = 4
tv286 = -20						; size = 4
tv279 = -16						; size = 4
_ret$32374 = -12					; size = 4
_in_pos$32372 = -8					; size = 4
_out_pos$32373 = -4					; size = 4
_strm$ = 8						; size = 4
_action$ = 12						; size = 4
_lzma_code PROC						; COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 215  : 	// Sanity checks
; 216  : 	if ((strm->next_in == NULL && strm->avail_in != 0)
; 217  : 			|| (strm->next_out == NULL && strm->avail_out != 0)
; 218  : 			|| strm->internal == NULL
; 219  : 			|| strm->internal->next.code == NULL
; 220  : 			|| (unsigned int)(action) > LZMA_ACTION_MAX
; 221  : 			|| !strm->internal->supported_actions[action])

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	75 09		 jne	 SHORT $LN42@lzma_code
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00011	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00015	75 3f		 jne	 SHORT $LN43@lzma_code
$LN42@lzma_code:
  00017	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0001a	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0001e	75 09		 jne	 SHORT $LN41@lzma_code
  00020	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00023	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00027	75 2d		 jne	 SHORT $LN43@lzma_code
$LN41@lzma_code:
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002c	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00030	74 24		 je	 SHORT $LN43@lzma_code
  00032	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00035	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00038	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0003c	74 18		 je	 SHORT $LN43@lzma_code
  0003e	83 7d 0c 04	 cmp	 DWORD PTR _action$[ebp], 4
  00042	77 12		 ja	 SHORT $LN43@lzma_code
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00047	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _action$[ebp]
  0004d	0f b6 4c 02 38	 movzx	 ecx, BYTE PTR [edx+eax+56]
  00052	85 c9		 test	 ecx, ecx
  00054	75 0a		 jne	 SHORT $LN44@lzma_code
$LN43@lzma_code:

; 222  : 		return LZMA_PROG_ERROR;

  00056	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0005b	e9 36 03 00 00	 jmp	 $LN45@lzma_code
$LN44@lzma_code:

; 223  : 
; 224  : 	// Check if unsupported members have been set to non-zero or non-NULL,
; 225  : 	// which would indicate that some new feature is wanted.
; 226  : 	if (strm->reserved_ptr1 != NULL
; 227  : 			|| strm->reserved_ptr2 != NULL
; 228  : 			|| strm->reserved_ptr3 != NULL
; 229  : 			|| strm->reserved_ptr4 != NULL
; 230  : 			|| strm->reserved_int1 != 0
; 231  : 			|| strm->reserved_int2 != 0
; 232  : 			|| strm->reserved_int3 != 0
; 233  : 			|| strm->reserved_int4 != 0
; 234  : 			|| strm->reserved_enum1 != LZMA_RESERVED_ENUM
; 235  : 			|| strm->reserved_enum2 != LZMA_RESERVED_ENUM)

  00060	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00063	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00067	75 67		 jne	 SHORT $LN39@lzma_code
  00069	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006c	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00070	75 5e		 jne	 SHORT $LN39@lzma_code
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00075	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00079	75 55		 jne	 SHORT $LN39@lzma_code
  0007b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0007e	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00082	75 4c		 jne	 SHORT $LN39@lzma_code
  00084	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00087	89 45 f0	 mov	 DWORD PTR tv279[ebp], eax
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR tv279[ebp]
  0008d	8b 55 f0	 mov	 edx, DWORD PTR tv279[ebp]
  00090	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00093	0b 42 3c	 or	 eax, DWORD PTR [edx+60]
  00096	75 38		 jne	 SHORT $LN39@lzma_code
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0009b	89 4d ec	 mov	 DWORD PTR tv286[ebp], ecx
  0009e	8b 55 ec	 mov	 edx, DWORD PTR tv286[ebp]
  000a1	8b 45 ec	 mov	 eax, DWORD PTR tv286[ebp]
  000a4	8b 4a 40	 mov	 ecx, DWORD PTR [edx+64]
  000a7	0b 48 44	 or	 ecx, DWORD PTR [eax+68]
  000aa	75 24		 jne	 SHORT $LN39@lzma_code
  000ac	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000af	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  000b3	75 1b		 jne	 SHORT $LN39@lzma_code
  000b5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000b8	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000bc	75 12		 jne	 SHORT $LN39@lzma_code
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c1	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  000c5	75 09		 jne	 SHORT $LN39@lzma_code
  000c7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000ca	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  000ce	74 0a		 je	 SHORT $LN40@lzma_code
$LN39@lzma_code:

; 236  : 		return LZMA_OPTIONS_ERROR;

  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	e9 bc 02 00 00	 jmp	 $LN45@lzma_code
$LN40@lzma_code:

; 237  : 
; 238  : 	switch (strm->internal->sequence) {

  000da	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000dd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e0	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000e3	89 55 e8	 mov	 DWORD PTR tv136[ebp], edx
  000e6	83 7d e8 05	 cmp	 DWORD PTR tv136[ebp], 5
  000ea	0f 87 00 01 00
	00		 ja	 $LN15@lzma_code
  000f0	8b 45 e8	 mov	 eax, DWORD PTR tv136[ebp]
  000f3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@lzma_code[eax*4]
$LN36@lzma_code:

; 239  : 	case ISEQ_RUN:
; 240  : 		switch (action) {

  000fa	8b 4d 0c	 mov	 ecx, DWORD PTR _action$[ebp]
  000fd	89 4d e4	 mov	 DWORD PTR tv137[ebp], ecx
  00100	8b 55 e4	 mov	 edx, DWORD PTR tv137[ebp]
  00103	83 ea 01	 sub	 edx, 1
  00106	89 55 e4	 mov	 DWORD PTR tv137[ebp], edx
  00109	83 7d e4 03	 cmp	 DWORD PTR tv137[ebp], 3
  0010d	77 46		 ja	 SHORT $LN34@lzma_code
  0010f	8b 45 e4	 mov	 eax, DWORD PTR tv137[ebp]
  00112	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN49@lzma_code[eax*4]

; 241  : 		case LZMA_RUN:
; 242  : 			break;

  00119	eb 3a		 jmp	 SHORT $LN34@lzma_code
$LN32@lzma_code:

; 243  : 
; 244  : 		case LZMA_SYNC_FLUSH:
; 245  : 			strm->internal->sequence = ISEQ_SYNC_FLUSH;

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0011e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00121	c7 42 30 01 00
	00 00		 mov	 DWORD PTR [edx+48], 1

; 246  : 			break;

  00128	eb 2b		 jmp	 SHORT $LN34@lzma_code
$LN31@lzma_code:

; 247  : 
; 248  : 		case LZMA_FULL_FLUSH:
; 249  : 			strm->internal->sequence = ISEQ_FULL_FLUSH;

  0012a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0012d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00130	c7 41 30 02 00
	00 00		 mov	 DWORD PTR [ecx+48], 2

; 250  : 			break;

  00137	eb 1c		 jmp	 SHORT $LN34@lzma_code
$LN30@lzma_code:

; 251  : 
; 252  : 		case LZMA_FINISH:
; 253  : 			strm->internal->sequence = ISEQ_FINISH;

  00139	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0013c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0013f	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [eax+48], 3

; 254  : 			break;

  00146	eb 0d		 jmp	 SHORT $LN34@lzma_code
$LN29@lzma_code:

; 255  : 
; 256  : 		case LZMA_FULL_BARRIER:
; 257  : 			strm->internal->sequence = ISEQ_FULL_BARRIER;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0014b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0014e	c7 42 30 04 00
	00 00		 mov	 DWORD PTR [edx+48], 4
$LN34@lzma_code:

; 258  : 			break;
; 259  : 		}
; 260  : 
; 261  : 		break;

  00155	e9 a0 00 00 00	 jmp	 $LN37@lzma_code
$LN28@lzma_code:

; 262  : 
; 263  : 	case ISEQ_SYNC_FLUSH:
; 264  : 		// The same action must be used until we return
; 265  : 		// LZMA_STREAM_END, and the amount of input must not change.
; 266  : 		if (action != LZMA_SYNC_FLUSH
; 267  : 				|| strm->internal->avail_in != strm->avail_in)

  0015a	83 7d 0c 01	 cmp	 DWORD PTR _action$[ebp], 1
  0015e	75 11		 jne	 SHORT $LN26@lzma_code
  00160	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00163	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00166	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00169	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0016c	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0016f	74 0a		 je	 SHORT $LN27@lzma_code
$LN26@lzma_code:

; 268  : 			return LZMA_PROG_ERROR;

  00171	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00176	e9 1b 02 00 00	 jmp	 $LN45@lzma_code
$LN27@lzma_code:

; 269  : 
; 270  : 		break;

  0017b	eb 7d		 jmp	 SHORT $LN37@lzma_code
$LN25@lzma_code:

; 271  : 
; 272  : 	case ISEQ_FULL_FLUSH:
; 273  : 		if (action != LZMA_FULL_FLUSH
; 274  : 				|| strm->internal->avail_in != strm->avail_in)

  0017d	83 7d 0c 02	 cmp	 DWORD PTR _action$[ebp], 2
  00181	75 11		 jne	 SHORT $LN23@lzma_code
  00183	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00186	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00189	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0018c	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0018f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00192	74 0a		 je	 SHORT $LN24@lzma_code
$LN23@lzma_code:

; 275  : 			return LZMA_PROG_ERROR;

  00194	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00199	e9 f8 01 00 00	 jmp	 $LN45@lzma_code
$LN24@lzma_code:

; 276  : 
; 277  : 		break;

  0019e	eb 5a		 jmp	 SHORT $LN37@lzma_code
$LN22@lzma_code:

; 278  : 
; 279  : 	case ISEQ_FINISH:
; 280  : 		if (action != LZMA_FINISH
; 281  : 				|| strm->internal->avail_in != strm->avail_in)

  001a0	83 7d 0c 03	 cmp	 DWORD PTR _action$[ebp], 3
  001a4	75 11		 jne	 SHORT $LN20@lzma_code
  001a6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001a9	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001ac	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001af	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  001b2	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b5	74 0a		 je	 SHORT $LN21@lzma_code
$LN20@lzma_code:

; 282  : 			return LZMA_PROG_ERROR;

  001b7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001bc	e9 d5 01 00 00	 jmp	 $LN45@lzma_code
$LN21@lzma_code:

; 283  : 
; 284  : 		break;

  001c1	eb 37		 jmp	 SHORT $LN37@lzma_code
$LN19@lzma_code:

; 285  : 
; 286  : 	case ISEQ_FULL_BARRIER:
; 287  : 		if (action != LZMA_FULL_BARRIER
; 288  : 				|| strm->internal->avail_in != strm->avail_in)

  001c3	83 7d 0c 04	 cmp	 DWORD PTR _action$[ebp], 4
  001c7	75 11		 jne	 SHORT $LN17@lzma_code
  001c9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001cc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001cf	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d2	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  001d5	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  001d8	74 0a		 je	 SHORT $LN18@lzma_code
$LN17@lzma_code:

; 289  : 			return LZMA_PROG_ERROR;

  001da	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001df	e9 b2 01 00 00	 jmp	 $LN45@lzma_code
$LN18@lzma_code:

; 290  : 
; 291  : 		break;

  001e4	eb 14		 jmp	 SHORT $LN37@lzma_code
$LN16@lzma_code:

; 292  : 
; 293  : 	case ISEQ_END:
; 294  : 		return LZMA_STREAM_END;

  001e6	b8 01 00 00 00	 mov	 eax, 1
  001eb	e9 a6 01 00 00	 jmp	 $LN45@lzma_code
$LN15@lzma_code:

; 295  : 
; 296  : 	case ISEQ_ERROR:
; 297  : 	default:
; 298  : 		return LZMA_PROG_ERROR;

  001f0	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001f5	e9 9c 01 00 00	 jmp	 $LN45@lzma_code
$LN37@lzma_code:

; 299  : 	}
; 300  : 
; 301  :   {
; 302  : 	size_t in_pos = 0;

  001fa	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _in_pos$32372[ebp], 0

; 303  : 	size_t out_pos = 0;

  00201	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _out_pos$32373[ebp], 0

; 304  : 	lzma_ret ret = strm->internal->next.code(
; 305  : 			strm->internal->next.coder, strm->allocator,
; 306  : 			strm->next_in, &in_pos, strm->avail_in,
; 307  : 			strm->next_out, &out_pos, strm->avail_out, action);

  00208	8b 4d 0c	 mov	 ecx, DWORD PTR _action$[ebp]
  0020b	51		 push	 ecx
  0020c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0020f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00212	50		 push	 eax
  00213	8d 4d fc	 lea	 ecx, DWORD PTR _out_pos$32373[ebp]
  00216	51		 push	 ecx
  00217	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0021a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0021d	50		 push	 eax
  0021e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00221	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00224	52		 push	 edx
  00225	8d 45 f8	 lea	 eax, DWORD PTR _in_pos$32372[ebp]
  00228	50		 push	 eax
  00229	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0022c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0022e	52		 push	 edx
  0022f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00232	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00235	51		 push	 ecx
  00236	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00239	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0023c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023e	51		 push	 ecx
  0023f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00242	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00245	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00248	ff d1		 call	 ecx
  0024a	83 c4 24	 add	 esp, 36			; 00000024H
  0024d	89 45 f4	 mov	 DWORD PTR _ret$32374[ebp], eax

; 308  : 
; 309  : 	strm->next_in += in_pos;

  00250	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00253	8b 02		 mov	 eax, DWORD PTR [edx]
  00255	03 45 f8	 add	 eax, DWORD PTR _in_pos$32372[ebp]
  00258	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0025b	89 01		 mov	 DWORD PTR [ecx], eax

; 310  : 	strm->avail_in -= in_pos;

  0025d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00260	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00263	2b 45 f8	 sub	 eax, DWORD PTR _in_pos$32372[ebp]
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00269	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 311  : 	strm->total_in += in_pos;

  0026c	8b 55 f8	 mov	 edx, DWORD PTR _in_pos$32372[ebp]
  0026f	33 c0		 xor	 eax, eax
  00271	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00274	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00277	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0027a	13 c8		 adc	 ecx, eax
  0027c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0027f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00282	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 312  : 
; 313  : 	strm->next_out += out_pos;

  00285	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00288	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0028b	03 55 fc	 add	 edx, DWORD PTR _out_pos$32373[ebp]
  0028e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00291	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 314  : 	strm->avail_out -= out_pos;

  00294	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00297	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0029a	2b 55 fc	 sub	 edx, DWORD PTR _out_pos$32373[ebp]
  0029d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  002a0	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 315  : 	strm->total_out += out_pos;

  002a3	8b 4d fc	 mov	 ecx, DWORD PTR _out_pos$32373[ebp]
  002a6	33 d2		 xor	 edx, edx
  002a8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  002ab	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  002ae	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  002b1	13 c2		 adc	 eax, edx
  002b3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  002b6	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  002b9	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 316  : 
; 317  : 	strm->internal->avail_in = strm->avail_in;

  002bc	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  002bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002c2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  002c5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002c8	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 318  : 
; 319  : 	// Cast is needed to silence a warning about LZMA_TIMED_OUT, which
; 320  : 	// isn't part of lzma_ret enumeration.
; 321  : 	switch ((unsigned int)(ret)) {

  002cb	8b 4d f4	 mov	 ecx, DWORD PTR _ret$32374[ebp]
  002ce	89 4d e0	 mov	 DWORD PTR tv208[ebp], ecx
  002d1	83 7d e0 20	 cmp	 DWORD PTR tv208[ebp], 32 ; 00000020H
  002d5	0f 87 ab 00 00
	00		 ja	 $LN1@lzma_code
  002db	8b 55 e0	 mov	 edx, DWORD PTR tv208[ebp]
  002de	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@lzma_code[edx]
  002e5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN50@lzma_code[eax*4]
$LN12@lzma_code:

; 322  : 	case LZMA_OK:
; 323  : 		// Don't return LZMA_BUF_ERROR when it happens the first time.
; 324  : 		// This is to avoid returning LZMA_BUF_ERROR when avail_out
; 325  : 		// was zero but still there was no more data left to written
; 326  : 		// to next_out.
; 327  : 		if (out_pos == 0 && in_pos == 0) {

  002ec	83 7d fc 00	 cmp	 DWORD PTR _out_pos$32373[ebp], 0
  002f0	75 29		 jne	 SHORT $LN11@lzma_code
  002f2	83 7d f8 00	 cmp	 DWORD PTR _in_pos$32372[ebp], 0
  002f6	75 23		 jne	 SHORT $LN11@lzma_code

; 328  : 			if (strm->internal->allow_buf_error)

  002f8	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002fb	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002fe	0f b6 42 3d	 movzx	 eax, BYTE PTR [edx+61]
  00302	85 c0		 test	 eax, eax
  00304	74 09		 je	 SHORT $LN10@lzma_code

; 329  : 				ret = LZMA_BUF_ERROR;

  00306	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _ret$32374[ebp], 10 ; 0000000aH

; 330  : 			else

  0030d	eb 0a		 jmp	 SHORT $LN9@lzma_code
$LN10@lzma_code:

; 331  : 				strm->internal->allow_buf_error = true;

  0030f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00312	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00315	c6 42 3d 01	 mov	 BYTE PTR [edx+61], 1
$LN9@lzma_code:

; 332  : 		} else {

  00319	eb 0a		 jmp	 SHORT $LN8@lzma_code
$LN11@lzma_code:

; 333  : 			strm->internal->allow_buf_error = false;

  0031b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0031e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00321	c6 41 3d 00	 mov	 BYTE PTR [ecx+61], 0
$LN8@lzma_code:

; 334  : 		}
; 335  : 		break;

  00325	eb 6c		 jmp	 SHORT $LN13@lzma_code
$LN7@lzma_code:

; 336  : 
; 337  : 	case LZMA_TIMED_OUT:
; 338  : 		strm->internal->allow_buf_error = false;

  00327	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0032a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0032d	c6 40 3d 00	 mov	 BYTE PTR [eax+61], 0

; 339  : 		ret = LZMA_OK;

  00331	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$32374[ebp], 0

; 340  : 		break;

  00338	eb 59		 jmp	 SHORT $LN13@lzma_code
$LN6@lzma_code:

; 341  : 
; 342  : 	case LZMA_STREAM_END:
; 343  : 		if (strm->internal->sequence == ISEQ_SYNC_FLUSH
; 344  : 				|| strm->internal->sequence == ISEQ_FULL_FLUSH
; 345  : 				|| strm->internal->sequence
; 346  : 					== ISEQ_FULL_BARRIER)

  0033a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0033d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00340	83 7a 30 01	 cmp	 DWORD PTR [edx+48], 1
  00344	74 18		 je	 SHORT $LN4@lzma_code
  00346	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00349	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0034c	83 79 30 02	 cmp	 DWORD PTR [ecx+48], 2
  00350	74 0c		 je	 SHORT $LN4@lzma_code
  00352	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00355	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00358	83 78 30 04	 cmp	 DWORD PTR [eax+48], 4
  0035c	75 0f		 jne	 SHORT $LN5@lzma_code
$LN4@lzma_code:

; 347  : 			strm->internal->sequence = ISEQ_RUN;

  0035e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00361	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00364	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 348  : 		else

  0036b	eb 0d		 jmp	 SHORT $LN2@lzma_code
$LN5@lzma_code:

; 349  : 			strm->internal->sequence = ISEQ_END;

  0036d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00370	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00373	c7 41 30 05 00
	00 00		 mov	 DWORD PTR [ecx+48], 5
$LN2@lzma_code:

; 350  : 
; 351  : 	// Fall through
; 352  : 
; 353  : 	case LZMA_NO_CHECK:
; 354  : 	case LZMA_UNSUPPORTED_CHECK:
; 355  : 	case LZMA_GET_CHECK:
; 356  : 	case LZMA_MEMLIMIT_ERROR:
; 357  : 		// Something else than LZMA_OK, but not a fatal error,
; 358  : 		// that is, coding may be continued (except if ISEQ_END).
; 359  : 		strm->internal->allow_buf_error = false;

  0037a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0037d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00380	c6 40 3d 00	 mov	 BYTE PTR [eax+61], 0

; 360  : 		break;

  00384	eb 0d		 jmp	 SHORT $LN13@lzma_code
$LN1@lzma_code:

; 361  : 
; 362  : 	default:
; 363  : 		// All the other errors are fatal; coding cannot be continued.
; 364  : 		assert(ret != LZMA_BUF_ERROR);
; 365  : 		strm->internal->sequence = ISEQ_ERROR;

  00386	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00389	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0038c	c7 42 30 06 00
	00 00		 mov	 DWORD PTR [edx+48], 6
$LN13@lzma_code:

; 366  : 		break;
; 367  : 	}
; 368  : 
; 369  : 	return ret;

  00393	8b 45 f4	 mov	 eax, DWORD PTR _ret$32374[ebp]
$LN45@lzma_code:

; 370  :   }
; 371  : }

  00396	8b e5		 mov	 esp, ebp
  00398	5d		 pop	 ebp
  00399	c3		 ret	 0
  0039a	8b ff		 npad	 2
$LN48@lzma_code:
  0039c	00 00 00 00	 DD	 $LN36@lzma_code
  003a0	00 00 00 00	 DD	 $LN28@lzma_code
  003a4	00 00 00 00	 DD	 $LN25@lzma_code
  003a8	00 00 00 00	 DD	 $LN22@lzma_code
  003ac	00 00 00 00	 DD	 $LN19@lzma_code
  003b0	00 00 00 00	 DD	 $LN16@lzma_code
$LN49@lzma_code:
  003b4	00 00 00 00	 DD	 $LN32@lzma_code
  003b8	00 00 00 00	 DD	 $LN31@lzma_code
  003bc	00 00 00 00	 DD	 $LN30@lzma_code
  003c0	00 00 00 00	 DD	 $LN29@lzma_code
$LN50@lzma_code:
  003c4	00 00 00 00	 DD	 $LN12@lzma_code
  003c8	00 00 00 00	 DD	 $LN6@lzma_code
  003cc	00 00 00 00	 DD	 $LN2@lzma_code
  003d0	00 00 00 00	 DD	 $LN7@lzma_code
  003d4	00 00 00 00	 DD	 $LN1@lzma_code
$LN47@lzma_code:
  003d8	00		 DB	 0
  003d9	01		 DB	 1
  003da	02		 DB	 2
  003db	02		 DB	 2
  003dc	02		 DB	 2
  003dd	04		 DB	 4
  003de	02		 DB	 2
  003df	04		 DB	 4
  003e0	04		 DB	 4
  003e1	04		 DB	 4
  003e2	04		 DB	 4
  003e3	04		 DB	 4
  003e4	04		 DB	 4
  003e5	04		 DB	 4
  003e6	04		 DB	 4
  003e7	04		 DB	 4
  003e8	04		 DB	 4
  003e9	04		 DB	 4
  003ea	04		 DB	 4
  003eb	04		 DB	 4
  003ec	04		 DB	 4
  003ed	04		 DB	 4
  003ee	04		 DB	 4
  003ef	04		 DB	 4
  003f0	04		 DB	 4
  003f1	04		 DB	 4
  003f2	04		 DB	 4
  003f3	04		 DB	 4
  003f4	04		 DB	 4
  003f5	04		 DB	 4
  003f6	04		 DB	 4
  003f7	04		 DB	 4
  003f8	03		 DB	 3
_lzma_code ENDP
_TEXT	ENDS
PUBLIC	_lzma_next_filter_update
; Function compile flags: /Odtp
;	COMDAT _lzma_next_filter_update
_TEXT	SEGMENT
tv86 = -12						; size = 4
tv76 = -8						; size = 4
tv75 = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_reversed_filters$ = 16					; size = 4
_lzma_next_filter_update PROC				; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 146  : 	// Check that the application isn't trying to change the Filter ID.
; 147  : 	// End of filters is indicated with LZMA_VLI_UNKNOWN in both
; 148  : 	// reversed_filters[0].id and next->id.
; 149  : 	if (reversed_filters[0].id != next->id)

  00006	8b 45 10	 mov	 eax, DWORD PTR _reversed_filters$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0000f	89 4d f8	 mov	 DWORD PTR tv76[ebp], ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  00018	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0001d	75 0e		 jne	 SHORT $LN5@lzma_next_
  0001f	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  00022	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  00025	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00028	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0002b	74 07		 je	 SHORT $LN2@lzma_next_
$LN5@lzma_next_:

; 150  : 		return LZMA_PROG_ERROR;

  0002d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00032	eb 35		 jmp	 SHORT $LN3@lzma_next_
$LN2@lzma_next_:

; 151  : 
; 152  : 	if (reversed_filters[0].id == LZMA_VLI_UNKNOWN)

  00034	8b 55 10	 mov	 edx, DWORD PTR _reversed_filters$[ebp]
  00037	89 55 f4	 mov	 DWORD PTR tv86[ebp], edx
  0003a	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR tv86[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	23 51 04	 and	 edx, DWORD PTR [ecx+4]
  00045	83 fa ff	 cmp	 edx, -1
  00048	75 04		 jne	 SHORT $LN1@lzma_next_

; 153  : 		return LZMA_OK;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 1b		 jmp	 SHORT $LN3@lzma_next_
$LN1@lzma_next_:

; 154  : 
; 155  : 	assert(next->update != NULL);
; 156  : 	return next->update(next->coder, allocator, NULL, reversed_filters);

  0004e	8b 45 10	 mov	 eax, DWORD PTR _reversed_filters$[ebp]
  00051	50		 push	 eax
  00052	6a 00		 push	 0
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00061	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00064	ff d2		 call	 edx
  00066	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@lzma_next_:

; 157  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_lzma_next_filter_update ENDP
_TEXT	ENDS
PUBLIC	_lzma_bufcpy
; Function compile flags: /Odtp
;	COMDAT _lzma_bufcpy
_TEXT	SEGMENT
tv67 = -16						; size = 4
_copy_size$ = -12					; size = 4
_in_avail$ = -8						; size = 4
_out_avail$ = -4					; size = 4
_in$ = 8						; size = 4
_in_pos$ = 12						; size = 4
_in_size$ = 16						; size = 4
_out$ = 20						; size = 4
_out_pos$ = 24						; size = 4
_out_size$ = 28						; size = 4
_lzma_bufcpy PROC					; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 118  : 	const size_t in_avail = in_size - *in_pos;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _in_size$[ebp]
  0000c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _in_avail$[ebp], ecx

; 119  : 	const size_t out_avail = out_size - *out_pos;

  00011	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00014	8b 45 1c	 mov	 eax, DWORD PTR _out_size$[ebp]
  00017	2b 02		 sub	 eax, DWORD PTR [edx]
  00019	89 45 fc	 mov	 DWORD PTR _out_avail$[ebp], eax

; 120  : 	const size_t copy_size = my_min(in_avail, out_avail);

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _in_avail$[ebp]
  0001f	3b 4d fc	 cmp	 ecx, DWORD PTR _out_avail$[ebp]
  00022	73 08		 jae	 SHORT $LN3@lzma_bufcp
  00024	8b 55 f8	 mov	 edx, DWORD PTR _in_avail$[ebp]
  00027	89 55 f0	 mov	 DWORD PTR tv67[ebp], edx
  0002a	eb 06		 jmp	 SHORT $LN4@lzma_bufcp
$LN3@lzma_bufcp:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _out_avail$[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR tv67[ebp], eax
$LN4@lzma_bufcp:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR tv67[ebp]
  00035	89 4d f4	 mov	 DWORD PTR _copy_size$[ebp], ecx

; 121  : 
; 122  : 	memcpy(out + *out_pos, in + *in_pos, copy_size);

  00038	8b 55 f4	 mov	 edx, DWORD PTR _copy_size$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00042	03 08		 add	 ecx, DWORD PTR [eax]
  00044	51		 push	 ecx
  00045	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00048	8b 45 14	 mov	 eax, DWORD PTR _out$[ebp]
  0004b	03 02		 add	 eax, DWORD PTR [edx]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _memcpy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 
; 124  : 	*in_pos += copy_size;

  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	03 55 f4	 add	 edx, DWORD PTR _copy_size$[ebp]
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00061	89 10		 mov	 DWORD PTR [eax], edx

; 125  : 	*out_pos += copy_size;

  00063	8b 4d 18	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	03 55 f4	 add	 edx, DWORD PTR _copy_size$[ebp]
  0006b	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0006e	89 10		 mov	 DWORD PTR [eax], edx

; 126  : 
; 127  : 	return copy_size;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _copy_size$[ebp]

; 128  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_lzma_bufcpy ENDP
_TEXT	ENDS
PUBLIC	_lzma_free
; Function compile flags: /Odtp
;	COMDAT _lzma_free
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma_free PROC						; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if (allocator != NULL && allocator->free != NULL)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _allocator$[ebp], 0
  00007	74 21		 je	 SHORT $LN2@lzma_free
  00009	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 18		 je	 SHORT $LN2@lzma_free

; 101  : 		allocator->free(allocator->opaque, ptr);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	50		 push	 eax
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00020	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00023	ff d2		 call	 edx
  00025	83 c4 08	 add	 esp, 8

; 102  : 	else

  00028	eb 0c		 jmp	 SHORT $LN3@lzma_free
$LN2@lzma_free:

; 103  : 		free(ptr);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _free
  00033	83 c4 04	 add	 esp, 4
$LN3@lzma_free:

; 104  : 
; 105  : 	return;
; 106  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_lzma_free ENDP
_TEXT	ENDS
PUBLIC	_lzma_alloc
; Function compile flags: /Odtp
;	COMDAT _lzma_alloc
_TEXT	SEGMENT
_ptr$32234 = -4						; size = 4
_size$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma_alloc PROC					; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 57   : 	// Some malloc() variants return NULL if called with size == 0.
; 58   : 	if (size == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  00008	75 07		 jne	 SHORT $LN3@lzma_alloc

; 59   : 		size = 1;

  0000a	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _size$[ebp], 1
$LN3@lzma_alloc:

; 60   : 
; 61   :   {
; 62   : 	void *ptr;
; 63   : 
; 64   : 	if (allocator != NULL && allocator->alloc != NULL)

  00011	83 7d 0c 00	 cmp	 DWORD PTR _allocator$[ebp], 0
  00015	74 24		 je	 SHORT $LN2@lzma_alloc
  00017	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 1c		 je	 SHORT $LN2@lzma_alloc

; 65   : 		ptr = allocator->alloc(allocator->opaque, 1, size);

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00022	51		 push	 ecx
  00023	6a 01		 push	 1
  00025	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00028	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	ff d2		 call	 edx
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	89 45 fc	 mov	 DWORD PTR _ptr$32234[ebp], eax

; 66   : 	else

  00039	eb 0f		 jmp	 SHORT $LN1@lzma_alloc
$LN2@lzma_alloc:

; 67   : 		ptr = malloc(size);

  0003b	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _malloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 fc	 mov	 DWORD PTR _ptr$32234[ebp], eax
$LN1@lzma_alloc:

; 68   : 
; 69   : 	return ptr;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _ptr$32234[ebp]

; 70   :   }
; 71   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_lzma_alloc ENDP
_TEXT	ENDS
PUBLIC	_lzma_version_string
; Function compile flags: /Odtp
;	COMDAT _lzma_version_string
_TEXT	SEGMENT
_lzma_version_string PROC				; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 	return LZMA_VERSION_STRING;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05LHKAPBBA@5?42?44?$AA@

; 47   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_lzma_version_string ENDP
PUBLIC	_lzma_strm_init
; Function compile flags: /Odtp
;	COMDAT _lzma_strm_init
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_lzma_strm_init PROC					; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 188  : 	if (strm == NULL)

  00005	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00009	75 0a		 jne	 SHORT $LN3@lzma_strm_

; 189  : 		return LZMA_PROG_ERROR;

  0000b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00010	e9 93 00 00 00	 jmp	 $LN4@lzma_strm_
$LN3@lzma_strm_:

; 190  : 
; 191  : 	if (strm->internal == NULL) {

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0001c	75 39		 jne	 SHORT $LN2@lzma_strm_

; 192  : 		strm->internal = lzma_alloc(sizeof(lzma_internal),
; 193  : 				strm->allocator);

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00021	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00024	52		 push	 edx
  00025	6a 40		 push	 64			; 00000040H
  00027	e8 00 00 00 00	 call	 _lzma_alloc
  0002c	83 c4 08	 add	 esp, 8
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00032	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 194  : 		if (strm->internal == NULL)

  00035	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00038	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0003c	75 07		 jne	 SHORT $LN1@lzma_strm_

; 195  : 			return LZMA_MEM_ERROR;

  0003e	b8 05 00 00 00	 mov	 eax, 5
  00043	eb 63		 jmp	 SHORT $LN4@lzma_strm_
$LN1@lzma_strm_:

; 196  : 
; 197  : 		strm->internal->next = LZMA_NEXT_CODER_INIT;

  00045	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00048	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  0004b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00050	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00055	f3 a5		 rep movsd
$LN2@lzma_strm_:

; 198  : 	}
; 199  : 
; 200  : 	memzero(strm->internal->supported_actions,
; 201  : 			sizeof(strm->internal->supported_actions));

  00057	6a 05		 push	 5
  00059	6a 00		 push	 0
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00061	83 c2 38	 add	 edx, 56			; 00000038H
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 	strm->internal->sequence = ISEQ_RUN;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00070	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00073	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 203  : 	strm->internal->allow_buf_error = false;

  0007a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0007d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00080	c6 40 3d 00	 mov	 BYTE PTR [eax+61], 0

; 204  : 
; 205  : 	strm->total_in = 0;

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00087	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0008e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 206  : 	strm->total_out = 0;

  00095	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00098	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
  0009f	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 207  : 
; 208  : 	return LZMA_OK;

  000a6	33 c0		 xor	 eax, eax
$LN4@lzma_strm_:

; 209  : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_lzma_strm_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_next_end
; Function compile flags: /Odtp
;	COMDAT _lzma_next_end
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_lzma_next_end PROC					; COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 163  : 	if (next->init != (uintptr_t)(NULL)) {

  00005	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00008	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000c	74 41		 je	 SHORT $LN4@lzma_next_@2

; 164  : 		// To avoid tiny end functions that simply call
; 165  : 		// lzma_free(coder, allocator), we allow leaving next->end
; 166  : 		// NULL and call lzma_free() here.
; 167  : 		if (next->end != NULL)

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00011	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00015	74 17		 je	 SHORT $LN2@lzma_next_@2

; 168  : 			next->end(next->coder, allocator);

  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	51		 push	 ecx
  00021	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00024	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00027	ff d0		 call	 eax
  00029	83 c4 08	 add	 esp, 8

; 169  : 		else

  0002c	eb 12		 jmp	 SHORT $LN1@lzma_next_@2
$LN2@lzma_next_@2:

; 170  : 			lzma_free(next->coder, allocator);

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _lzma_free
  0003d	83 c4 08	 add	 esp, 8
$LN1@lzma_next_@2:

; 171  : 
; 172  : 		// Reset the variables so the we don't accidentally think
; 173  : 		// that it is an already initialized coder.
; 174  : 		*next = LZMA_NEXT_CODER_INIT;

  00040	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00045	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  0004a	8b 7d 08	 mov	 edi, DWORD PTR _next$[ebp]
  0004d	f3 a5		 rep movsd
$LN4@lzma_next_@2:

; 175  : 	}
; 176  : 
; 177  : 	return;
; 178  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_lzma_next_end ENDP
_TEXT	ENDS
PUBLIC	_lzma_next_filter_init
; Function compile flags: /Odtp
;	COMDAT _lzma_next_filter_init
_TEXT	SEGMENT
tv80 = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_next_filter_init PROC				; COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN4@lzma_next_@3:

; 135  : 	lzma_next_coder_init(filters[0].init, next, allocator);

  00004	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0000a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000d	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00010	74 10		 je	 SHORT $LN1@lzma_next_@3
  00012	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _lzma_next_end
  0001f	83 c4 08	 add	 esp, 8
$LN1@lzma_next_@3:
  00022	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00025	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00028	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0002e	33 d2		 xor	 edx, edx
  00030	75 d2		 jne	 SHORT $LN4@lzma_next_@3

; 136  : 	next->id = filters[0].id;

  00032	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00035	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0003d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00040	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 137  : 	return filters[0].init == NULL
; 138  : 			? LZMA_OK : filters[0].init(next, allocator, filters);

  00043	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  00046	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0004a	75 09		 jne	 SHORT $LN7@lzma_next_@3
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00053	eb 1a		 jmp	 SHORT $LN8@lzma_next_@3
$LN7@lzma_next_@3:
  00055	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00060	52		 push	 edx
  00061	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	ff d1		 call	 ecx
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	89 45 fc	 mov	 DWORD PTR tv80[ebp], eax
$LN8@lzma_next_@3:
  0006f	8b 45 fc	 mov	 eax, DWORD PTR tv80[ebp]

; 139  : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_lzma_next_filter_init ENDP
PUBLIC	_lzma_end
; Function compile flags: /Odtp
;	COMDAT _lzma_end
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_lzma_end PROC						; COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 	if (strm != NULL && strm->internal != NULL) {

  00003	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00007	74 3f		 je	 SHORT $LN2@lzma_end
  00009	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000c	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00010	74 36		 je	 SHORT $LN2@lzma_end

; 378  : 		lzma_next_end(&strm->internal->next, strm->allocator);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00015	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0001c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _lzma_next_end
  00025	83 c4 08	 add	 esp, 8

; 379  : 		lzma_free(strm->internal, strm->allocator);

  00028	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0002b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00032	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _lzma_free
  0003b	83 c4 08	 add	 esp, 8

; 380  : 		strm->internal = NULL;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00041	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN2@lzma_end:

; 381  : 	}
; 382  : 
; 383  : 	return;
; 384  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_lzma_end ENDP
END
