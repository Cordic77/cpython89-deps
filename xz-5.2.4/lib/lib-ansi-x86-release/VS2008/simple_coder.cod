; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\simple_coder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\simple_coder.c
;	COMDAT _call_filter
_TEXT	SEGMENT
_filtered$ = -4						; size = 4
_coder$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_call_filter PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 60   : 	const size_t filtered = coder->filter(coder->simple,
; 61   : 			coder->now_pos, coder->is_encoder,
; 62   : 			buffer, size);

  00004	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0000f	0f b6 42 31	 movzx	 eax, BYTE PTR [edx+49]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00017	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00025	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00028	ff d0		 call	 eax
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	89 45 fc	 mov	 DWORD PTR _filtered$[ebp], eax

; 63   : //W coder->now_pos += filtered;
; 64   :     coder->now_pos = (uint32_t)(coder->now_pos + filtered);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00033	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00036	03 55 fc	 add	 edx, DWORD PTR _filtered$[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003c	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 65   : 	return filtered;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _filtered$[ebp]

; 66   : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_call_filter ENDP
; Function compile flags: /Odtp
;	COMDAT _simple_coder_update
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters_null$ = 16					; size = 4
_reversed_filters$ = 20					; size = 4
_simple_coder_update PROC				; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 223  : 	lzma_simple_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 224  : 
; 225  : 	// No update support, just call the next filter in the chain.
; 226  : 	return lzma_next_filter_update(
; 227  : 			&coder->next, allocator, reversed_filters + 1);

  0000a	8b 4d 14	 mov	 ecx, DWORD PTR _reversed_filters$[ebp]
  0000d	83 c1 10	 add	 ecx, 16			; 00000010H
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00014	52		 push	 edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _lzma_next_filter_update
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_simple_coder_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _copy_or_code
_TEXT	SEGMENT
_ret$32375 = -4						; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_copy_or_code PROC					; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 26   : 	assert(!coder->end_was_reached);
; 27   : 
; 28   : 	if (coder->next.code == NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00007	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000b	75 44		 jne	 SHORT $LN6@copy_or_co

; 29   : 		lzma_bufcpy(in, in_pos, in_size, out, out_pos, out_size);

  0000d	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00014	52		 push	 edx
  00015	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _lzma_bufcpy
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 30   : 
; 31   : 		// Check if end of stream was reached.
; 32   : 		if (coder->is_encoder && action == LZMA_FINISH
; 33   : 				&& *in_pos == in_size)

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00030	0f b6 51 31	 movzx	 edx, BYTE PTR [ecx+49]
  00034	85 d2		 test	 edx, edx
  00036	74 17		 je	 SHORT $LN5@copy_or_co
  00038	83 7d 28 03	 cmp	 DWORD PTR _action$[ebp], 3
  0003c	75 11		 jne	 SHORT $LN5@copy_or_co
  0003e	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  00046	75 07		 jne	 SHORT $LN5@copy_or_co

; 34   : 			coder->end_was_reached = true;

  00048	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004b	c6 42 30 01	 mov	 BYTE PTR [edx+48], 1
$LN5@copy_or_co:

; 35   : 
; 36   : 	} else {

  0004f	eb 4e		 jmp	 SHORT $LN4@copy_or_co
$LN6@copy_or_co:

; 37   : 		// Call the next coder in the chain to provide us some data.
; 38   : 		const lzma_ret ret = coder->next.code(
; 39   : 				coder->next.coder, allocator,
; 40   : 				in, in_pos, in_size,
; 41   : 				out, out_pos, out_size, action);

  00051	8b 45 28	 mov	 eax, DWORD PTR _action$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00060	50		 push	 eax
  00061	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00064	51		 push	 ecx
  00065	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00068	52		 push	 edx
  00069	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	50		 push	 eax
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0007d	ff d2		 call	 edx
  0007f	83 c4 24	 add	 esp, 36			; 00000024H
  00082	89 45 fc	 mov	 DWORD PTR _ret$32375[ebp], eax

; 42   : 
; 43   : 		if (ret == LZMA_STREAM_END) {

  00085	83 7d fc 01	 cmp	 DWORD PTR _ret$32375[ebp], 1
  00089	75 09		 jne	 SHORT $LN3@copy_or_co

; 44   : 			assert(!coder->is_encoder
; 45   : 					|| action == LZMA_FINISH);
; 46   : 			coder->end_was_reached = true;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0008e	c6 40 30 01	 mov	 BYTE PTR [eax+48], 1
  00092	eb 0b		 jmp	 SHORT $LN4@copy_or_co
$LN3@copy_or_co:

; 47   : 
; 48   : 		} else if (ret != LZMA_OK) {

  00094	83 7d fc 00	 cmp	 DWORD PTR _ret$32375[ebp], 0
  00098	74 05		 je	 SHORT $LN4@copy_or_co

; 49   : 			return ret;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _ret$32375[ebp]
  0009d	eb 02		 jmp	 SHORT $LN7@copy_or_co
$LN4@copy_or_co:

; 50   : 		}
; 51   : 	}
; 52   : 
; 53   : 	return LZMA_OK;

  0009f	33 c0		 xor	 eax, eax
$LN7@copy_or_co:

; 54   : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_copy_or_code ENDP
; Function compile flags: /Odtp
;	COMDAT _simple_coder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_simple_coder_end PROC					; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 210  : 	lzma_simple_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 211  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 212  : 	lzma_free(coder->simple, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 _lzma_free
  0002a	83 c4 08	 add	 esp, 8

; 213  : 	lzma_free(coder, allocator);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _lzma_free
  0003a	83 c4 08	 add	 esp, 8

; 214  : 	return;
; 215  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_simple_coder_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _simple_code
_TEXT	SEGMENT
_ret$32436 = -36					; size = 4
_unfiltered$32427 = -32					; size = 4
_size$32425 = -28					; size = 4
_filtered$32426 = -24					; size = 4
_ret$32422 = -20					; size = 4
_out_start$32421 = -16					; size = 4
_buf_avail$32418 = -12					; size = 4
_out_avail$32417 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_simple_code PROC					; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 75   : 	lzma_simple_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 76   : 
; 77   : 	// TODO: Add partial support for LZMA_SYNC_FLUSH. We can support it
; 78   : 	// in cases when the filter is able to filter everything. With most
; 79   : 	// simple filters it can be done at offset that is a multiple of 2,
; 80   : 	// 4, or 16. With x86 filter, it needs good luck, and thus cannot
; 81   : 	// be made to work predictably.
; 82   : 	if (action == LZMA_SYNC_FLUSH)

  0000c	83 7d 28 01	 cmp	 DWORD PTR _action$[ebp], 1
  00010	75 0a		 jne	 SHORT $LN16@simple_cod

; 83   : 		return LZMA_OPTIONS_ERROR;

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	e9 b0 02 00 00	 jmp	 $LN17@simple_cod
$LN16@simple_cod:

; 84   : 
; 85   : 	// Flush already filtered data from coder->buffer[] to out[].
; 86   : 	if (coder->pos < coder->filtered) {

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00022	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00025	3b 42 48	 cmp	 eax, DWORD PTR [edx+72]
  00028	73 53		 jae	 SHORT $LN15@simple_cod

; 87   : 		lzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,
; 88   : 				out, out_pos, out_size);

  0002a	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00031	52		 push	 edx
  00032	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00039	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0003c	52		 push	 edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00040	83 c0 44	 add	 eax, 68			; 00000044H
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00047	83 c1 50	 add	 ecx, 80			; 00000050H
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _lzma_bufcpy
  00050	83 c4 18	 add	 esp, 24			; 00000018H

; 89   : 
; 90   : 		// If we couldn't flush all the filtered data, return to
; 91   : 		// application immediately.
; 92   : 		if (coder->pos < coder->filtered)

  00053	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00056	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00059	8b 4a 44	 mov	 ecx, DWORD PTR [edx+68]
  0005c	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  0005f	73 07		 jae	 SHORT $LN14@simple_cod

; 93   : 			return LZMA_OK;

  00061	33 c0		 xor	 eax, eax
  00063	e9 64 02 00 00	 jmp	 $LN17@simple_cod
$LN14@simple_cod:

; 94   : 
; 95   : 		if (coder->end_was_reached) {

  00068	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0006b	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  0006f	85 c0		 test	 eax, eax
  00071	74 0a		 je	 SHORT $LN15@simple_cod

; 96   : 			assert(coder->filtered == coder->size);
; 97   : 			return LZMA_STREAM_END;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	e9 4f 02 00 00	 jmp	 $LN17@simple_cod
$LN15@simple_cod:

; 98   : 		}
; 99   : 	}
; 100  : 
; 101  : 	// If we get here, there is no filtered data left in the buffer.
; 102  : 	coder->filtered = 0;

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00080	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 103  : 
; 104  : 	assert(!coder->end_was_reached);
; 105  : 
; 106  : 	// If there is more output space left than there is unfiltered data
; 107  : 	// in coder->buffer[], flush coder->buffer[] to out[], and copy/code
; 108  : 	// more data to out[] hopefully filling it completely. Then filter
; 109  : 	// the data in out[]. This step is where most of the data gets
; 110  : 	// filtered if the buffer sizes used by the application are reasonable.
; 111  :   {
; 112  : 	const size_t out_avail = out_size - *out_pos;

  00087	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0008a	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  0008d	2b 02		 sub	 eax, DWORD PTR [edx]
  0008f	89 45 f8	 mov	 DWORD PTR _out_avail$32417[ebp], eax

; 113  : 	const size_t buf_avail = coder->size - coder->pos;

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00095	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00098	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0009b	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  0009e	89 45 f4	 mov	 DWORD PTR _buf_avail$32418[ebp], eax

; 114  : 	if (out_avail > buf_avail || buf_avail == 0) {

  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _out_avail$32417[ebp]
  000a4	3b 4d f4	 cmp	 ecx, DWORD PTR _buf_avail$32418[ebp]
  000a7	77 0a		 ja	 SHORT $LN11@simple_cod
  000a9	83 7d f4 00	 cmp	 DWORD PTR _buf_avail$32418[ebp], 0
  000ad	0f 85 fe 00 00
	00		 jne	 $LN12@simple_cod
$LN11@simple_cod:

; 115  : 		// Store the old position so that we know from which byte
; 116  : 		// to start filtering.
; 117  : 		const size_t out_start = *out_pos;

  000b3	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000b6	8b 02		 mov	 eax, DWORD PTR [edx]
  000b8	89 45 f0	 mov	 DWORD PTR _out_start$32421[ebp], eax

; 118  : 
; 119  : 		// Flush data from coder->buffer[] to out[], but don't reset
; 120  : 		// coder->pos and coder->size yet. This way the coder can be
; 121  : 		// restarted if the next filter in the chain returns e.g.
; 122  : 		// LZMA_MEM_ERROR.
; 123  : 		memcpy(out + *out_pos, coder->buffer + coder->pos, buf_avail);

  000bb	8b 4d f4	 mov	 ecx, DWORD PTR _buf_avail$32418[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000c2	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000c8	8d 54 01 50	 lea	 edx, DWORD PTR [ecx+eax+80]
  000cc	52		 push	 edx
  000cd	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000d0	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  000d3	03 08		 add	 ecx, DWORD PTR [eax]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 _memcpy
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 		*out_pos += buf_avail;

  000de	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000e1	8b 02		 mov	 eax, DWORD PTR [edx]
  000e3	03 45 f4	 add	 eax, DWORD PTR _buf_avail$32418[ebp]
  000e6	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  000e9	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 
; 126  : 		// Copy/Encode/Decode more data to out[].
; 127  : 		{
; 128  : 			const lzma_ret ret = copy_or_code(coder, allocator,
; 129  : 					in, in_pos, in_size,
; 130  : 					out, out_pos, out_size, action);

  000eb	8b 55 28	 mov	 edx, DWORD PTR _action$[ebp]
  000ee	52		 push	 edx
  000ef	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00106	52		 push	 edx
  00107	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _copy_or_code
  00114	83 c4 24	 add	 esp, 36			; 00000024H
  00117	89 45 ec	 mov	 DWORD PTR _ret$32422[ebp], eax

; 131  : 			assert(ret != LZMA_STREAM_END);
; 132  : 			if (ret != LZMA_OK)

  0011a	83 7d ec 00	 cmp	 DWORD PTR _ret$32422[ebp], 0
  0011e	74 08		 je	 SHORT $LN10@simple_cod

; 133  : 				return ret;

  00120	8b 45 ec	 mov	 eax, DWORD PTR _ret$32422[ebp]
  00123	e9 a4 01 00 00	 jmp	 $LN17@simple_cod
$LN10@simple_cod:

; 134  : 		}
; 135  : 
; 136  : 		// Filter out[].
; 137  :       {
; 138  : 		const size_t size = *out_pos - out_start;

  00128	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0012b	8b 02		 mov	 eax, DWORD PTR [edx]
  0012d	2b 45 f0	 sub	 eax, DWORD PTR _out_start$32421[ebp]
  00130	89 45 e4	 mov	 DWORD PTR _size$32425[ebp], eax

; 139  : 		const size_t filtered = call_filter(
; 140  : 				coder, out + out_start, size);

  00133	8b 4d e4	 mov	 ecx, DWORD PTR _size$32425[ebp]
  00136	51		 push	 ecx
  00137	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  0013a	03 55 f0	 add	 edx, DWORD PTR _out_start$32421[ebp]
  0013d	52		 push	 edx
  0013e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _call_filter
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	89 45 e8	 mov	 DWORD PTR _filtered$32426[ebp], eax

; 141  : 
; 142  : 		const size_t unfiltered = size - filtered;

  0014d	8b 4d e4	 mov	 ecx, DWORD PTR _size$32425[ebp]
  00150	2b 4d e8	 sub	 ecx, DWORD PTR _filtered$32426[ebp]
  00153	89 4d e0	 mov	 DWORD PTR _unfiltered$32427[ebp], ecx

; 143  : 		assert(unfiltered <= coder->allocated / 2);
; 144  : 
; 145  : 		// Now we can update coder->pos and coder->size, because
; 146  : 		// the next coder in the chain (if any) was successful.
; 147  : 		coder->pos = 0;

  00156	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00159	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 148  : 		coder->size = unfiltered;

  00160	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00163	8b 4d e0	 mov	 ecx, DWORD PTR _unfiltered$32427[ebp]
  00166	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 149  : 
; 150  : 		if (coder->end_was_reached) {

  00169	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0016c	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  00170	85 c0		 test	 eax, eax
  00172	74 0c		 je	 SHORT $LN9@simple_cod

; 151  : 			// The last byte has been copied to out[] already.
; 152  : 			// They are left as is.
; 153  : 			coder->size = 0;

  00174	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00177	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  0017e	eb 2f		 jmp	 SHORT $LN8@simple_cod
$LN9@simple_cod:

; 154  : 
; 155  : 		} else if (unfiltered > 0) {

  00180	83 7d e0 00	 cmp	 DWORD PTR _unfiltered$32427[ebp], 0
  00184	76 29		 jbe	 SHORT $LN8@simple_cod

; 156  : 			// There is unfiltered data left in out[]. Copy it to
; 157  : 			// coder->buffer[] and rewind *out_pos appropriately.
; 158  : 			*out_pos -= unfiltered;

  00186	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00189	8b 02		 mov	 eax, DWORD PTR [edx]
  0018b	2b 45 e0	 sub	 eax, DWORD PTR _unfiltered$32427[ebp]
  0018e	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00191	89 01		 mov	 DWORD PTR [ecx], eax

; 159  : 			memcpy(coder->buffer, out + *out_pos, unfiltered);

  00193	8b 55 e0	 mov	 edx, DWORD PTR _unfiltered$32427[ebp]
  00196	52		 push	 edx
  00197	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0019a	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0019d	03 08		 add	 ecx, DWORD PTR [eax]
  0019f	51		 push	 ecx
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001a3	83 c2 50	 add	 edx, 80			; 00000050H
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _memcpy
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@simple_cod:

; 160  : 		}

  001af	eb 46		 jmp	 SHORT $LN6@simple_cod
$LN12@simple_cod:

; 161  : 	  }
; 162  : 	} else if (coder->pos > 0) {

  001b1	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001b4	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  001b8	76 3d		 jbe	 SHORT $LN6@simple_cod

; 163  : 		memmove(coder->buffer, coder->buffer + coder->pos, buf_avail);

  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _buf_avail$32418[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001c1	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c7	8d 54 01 50	 lea	 edx, DWORD PTR [ecx+eax+80]
  001cb	52		 push	 edx
  001cc	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001cf	83 c0 50	 add	 eax, 80			; 00000050H
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _memmove
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 		coder->size -= coder->pos;

  001db	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001de	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001e1	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  001e4	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  001e7	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001ea	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 165  : 		coder->pos = 0;

  001ed	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001f0	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
$LN6@simple_cod:

; 166  : 	}
; 167  :   }
; 168  : 
; 169  : 	assert(coder->pos == 0);
; 170  : 
; 171  : 	// If coder->buffer[] isn't empty, try to fill it by copying/decoding
; 172  : 	// more data. Then filter coder->buffer[] and copy the successfully
; 173  : 	// filtered data to out[]. It is probable, that some filtered and
; 174  : 	// unfiltered data will be left to coder->buffer[].
; 175  : 	if (coder->size > 0) {

  001f7	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001fa	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  001fe	0f 86 a6 00 00
	00		 jbe	 $LN4@simple_cod

; 176  : 		{
; 177  : 			const lzma_ret ret = copy_or_code(coder, allocator,
; 178  : 					in, in_pos, in_size,
; 179  : 					coder->buffer, &coder->size,
; 180  : 					coder->allocated, action);

  00204	8b 4d 28	 mov	 ecx, DWORD PTR _action$[ebp]
  00207	51		 push	 ecx
  00208	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0020b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0020e	50		 push	 eax
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00212	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00215	51		 push	 ecx
  00216	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00219	83 c2 50	 add	 edx, 80			; 00000050H
  0021c	52		 push	 edx
  0021d	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  00220	50		 push	 eax
  00221	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00224	51		 push	 ecx
  00225	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00228	52		 push	 edx
  00229	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0022c	50		 push	 eax
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00230	51		 push	 ecx
  00231	e8 00 00 00 00	 call	 _copy_or_code
  00236	83 c4 24	 add	 esp, 36			; 00000024H
  00239	89 45 dc	 mov	 DWORD PTR _ret$32436[ebp], eax

; 181  : 			assert(ret != LZMA_STREAM_END);
; 182  : 			if (ret != LZMA_OK)

  0023c	83 7d dc 00	 cmp	 DWORD PTR _ret$32436[ebp], 0
  00240	74 08		 je	 SHORT $LN3@simple_cod

; 183  : 				return ret;

  00242	8b 45 dc	 mov	 eax, DWORD PTR _ret$32436[ebp]
  00245	e9 82 00 00 00	 jmp	 $LN17@simple_cod
$LN3@simple_cod:

; 184  : 		}
; 185  : 
; 186  : 		coder->filtered = call_filter(
; 187  : 				coder, coder->buffer, coder->size);

  0024a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0024d	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00250	50		 push	 eax
  00251	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00254	83 c1 50	 add	 ecx, 80			; 00000050H
  00257	51		 push	 ecx
  00258	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0025b	52		 push	 edx
  0025c	e8 00 00 00 00	 call	 _call_filter
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH
  00264	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00267	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 188  : 
; 189  : 		// Everything is considered to be filtered if coder->buffer[]
; 190  : 		// contains the last bytes of the data.
; 191  : 		if (coder->end_was_reached)

  0026a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0026d	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  00271	85 c0		 test	 eax, eax
  00273	74 0c		 je	 SHORT $LN2@simple_cod

; 192  : 			coder->filtered = coder->size;

  00275	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00278	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0027b	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0027e	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$LN2@simple_cod:

; 193  : 
; 194  : 		// Flush as much as possible.
; 195  : 		lzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,
; 196  : 				out, out_pos, out_size);

  00281	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00284	51		 push	 ecx
  00285	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00288	52		 push	 edx
  00289	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  0028c	50		 push	 eax
  0028d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00290	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00293	52		 push	 edx
  00294	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00297	83 c0 44	 add	 eax, 68			; 00000044H
  0029a	50		 push	 eax
  0029b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0029e	83 c1 50	 add	 ecx, 80			; 00000050H
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 _lzma_bufcpy
  002a7	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@simple_cod:

; 197  : 	}
; 198  : 
; 199  : 	// Check if we got everything done.
; 200  : 	if (coder->end_was_reached && coder->pos == coder->size)

  002aa	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002ad	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  002b1	85 c0		 test	 eax, eax
  002b3	74 15		 je	 SHORT $LN1@simple_cod
  002b5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002b8	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002bb	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  002be	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  002c1	75 07		 jne	 SHORT $LN1@simple_cod

; 201  : 		return LZMA_STREAM_END;

  002c3	b8 01 00 00 00	 mov	 eax, 1
  002c8	eb 02		 jmp	 SHORT $LN17@simple_cod
$LN1@simple_cod:

; 202  : 
; 203  : 	return LZMA_OK;

  002ca	33 c0		 xor	 eax, eax
$LN17@simple_cod:

; 204  : }

  002cc	8b e5		 mov	 esp, ebp
  002ce	5d		 pop	 ebp
  002cf	c3		 ret	 0
_simple_code ENDP
PUBLIC	_lzma_simple_coder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_coder_init
_TEXT	SEGMENT
_simple$32499 = -8					; size = 4
_coder$ = -4						; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_filter$ = 20						; size = 4
_simple_size$ = 24					; size = 4
_unfiltered_max$ = 28					; size = 4
_alignment$ = 32					; size = 4
_is_encoder$ = 36					; size = 1
_lzma_simple_coder_init PROC				; COMDAT

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 239  : 	// Allocate memory for the lzma_simple_coder structure if needed.
; 240  : 	lzma_simple_coder *coder = next->coder;

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	89 4d fc	 mov	 DWORD PTR _coder$[ebp], ecx

; 241  : 	if (coder == NULL) {

  00010	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00014	0f 85 ab 00 00
	00		 jne	 $LN8@lzma_simpl@2

; 242  : 		// Here we allocate space also for the temporary buffer. We
; 243  : 		// need twice the size of unfiltered_max, because then it
; 244  : 		// is always possible to filter at least unfiltered_max bytes
; 245  : 		// more data in coder->buffer[] if it can be filled completely.
; 246  : 		coder = lzma_alloc(sizeof(lzma_simple_coder)
; 247  : 				+ 2 * unfiltered_max, allocator);

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 1c	 mov	 eax, DWORD PTR _unfiltered_max$[ebp]
  00021	8d 4c 00 50	 lea	 ecx, DWORD PTR [eax+eax+80]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _lzma_alloc
  0002b	83 c4 08	 add	 esp, 8
  0002e	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 248  : 		if (coder == NULL)

  00031	83 7d fc 00	 cmp	 DWORD PTR _coder$[ebp], 0
  00035	75 0a		 jne	 SHORT $LN7@lzma_simpl@2

; 249  : 			return LZMA_MEM_ERROR;

  00037	b8 05 00 00 00	 mov	 eax, 5
  0003c	e9 07 01 00 00	 jmp	 $LN9@lzma_simpl@2
$LN7@lzma_simpl@2:

; 250  : 
; 251  : 		next->coder = coder;

  00041	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00044	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00047	89 02		 mov	 DWORD PTR [edx], eax

; 252  : 		next->code = &simple_code;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  0004c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _simple_code

; 253  : 		next->end = &simple_coder_end;

  00053	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00056	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _simple_coder_end

; 254  : 		next->update = &simple_coder_update;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00060	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _simple_coder_update

; 255  : 
; 256  : 		coder->next = LZMA_NEXT_CODER_INIT;

  00067	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0006c	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  00071	8b 7d fc	 mov	 edi, DWORD PTR _coder$[ebp]
  00074	f3 a5		 rep movsd

; 257  : 		coder->filter = filter;

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00079	8b 55 14	 mov	 edx, DWORD PTR _filter$[ebp]
  0007c	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 258  : 		coder->allocated = 2 * unfiltered_max;

  0007f	8b 45 1c	 mov	 eax, DWORD PTR _unfiltered_max$[ebp]
  00082	d1 e0		 shl	 eax, 1
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00087	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 259  : 
; 260  : 		// Allocate memory for filter-specific data structure.
; 261  : 		if (simple_size > 0) {

  0008a	83 7d 18 00	 cmp	 DWORD PTR _simple_size$[ebp], 0
  0008e	76 2b		 jbe	 SHORT $LN6@lzma_simpl@2

; 262  : 			coder->simple = lzma_alloc(simple_size, allocator);

  00090	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00093	52		 push	 edx
  00094	8b 45 18	 mov	 eax, DWORD PTR _simple_size$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _lzma_alloc
  0009d	83 c4 08	 add	 esp, 8
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a3	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 263  : 			if (coder->simple == NULL)

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000a9	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  000ad	75 0a		 jne	 SHORT $LN5@lzma_simpl@2

; 264  : 				return LZMA_MEM_ERROR;

  000af	b8 05 00 00 00	 mov	 eax, 5
  000b4	e9 8f 00 00 00	 jmp	 $LN9@lzma_simpl@2
$LN5@lzma_simpl@2:

; 265  : 		} else {

  000b9	eb 0a		 jmp	 SHORT $LN8@lzma_simpl@2
$LN6@lzma_simpl@2:

; 266  : 			coder->simple = NULL;

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000be	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@lzma_simpl@2:

; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	if (filters[0].options != NULL) {

  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  000c8	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000cc	74 2b		 je	 SHORT $LN3@lzma_simpl@2

; 271  : 		const lzma_options_bcj *simple = filters[0].options;

  000ce	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  000d1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000d4	89 45 f8	 mov	 DWORD PTR _simple$32499[ebp], eax

; 272  : 		coder->now_pos = simple->start_offset;

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000da	8b 55 f8	 mov	 edx, DWORD PTR _simple$32499[ebp]
  000dd	8b 02		 mov	 eax, DWORD PTR [edx]
  000df	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 273  : 		if (coder->now_pos & (alignment - 1))

  000e2	8b 4d 20	 mov	 ecx, DWORD PTR _alignment$[ebp]
  000e5	83 e9 01	 sub	 ecx, 1
  000e8	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000eb	23 4a 3c	 and	 ecx, DWORD PTR [edx+60]
  000ee	74 07		 je	 SHORT $LN2@lzma_simpl@2

; 274  : 			return LZMA_OPTIONS_ERROR;

  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	eb 51		 jmp	 SHORT $LN9@lzma_simpl@2
$LN2@lzma_simpl@2:

; 275  : 	} else {

  000f7	eb 0a		 jmp	 SHORT $LN1@lzma_simpl@2
$LN3@lzma_simpl@2:

; 276  : 		coder->now_pos = 0;

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000fc	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN1@lzma_simpl@2:

; 277  : 	}
; 278  : 
; 279  : 	// Reset variables.
; 280  : 	coder->is_encoder = is_encoder;

  00103	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00106	8a 55 24	 mov	 dl, BYTE PTR _is_encoder$[ebp]
  00109	88 51 31	 mov	 BYTE PTR [ecx+49], dl

; 281  : 	coder->end_was_reached = false;

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0010f	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0

; 282  : 	coder->pos = 0;

  00113	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00116	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 283  : 	coder->filtered = 0;

  0011d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00120	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 284  : 	coder->size = 0;

  00127	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0012a	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 285  : 
; 286  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  00131	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00134	83 c1 10	 add	 ecx, 16			; 00000010H
  00137	51		 push	 ecx
  00138	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0013b	52		 push	 edx
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _lzma_next_filter_init
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@lzma_simpl@2:

; 287  : }

  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
_lzma_simple_coder_init ENDP
END
