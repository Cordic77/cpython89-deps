; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\stream_decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_decoder.c
;	COMDAT _stream_decoder_memconfig
_TEXT	SEGMENT
tv87 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_memusage$ = 12						; size = 4
_old_memlimit$ = 16					; size = 4
_new_memlimit$ = 20					; size = 8
_stream_decoder_memconfig PROC				; COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 413  : 	lzma_stream_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 414  : 
; 415  : 	*memusage = coder->memusage;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _memusage$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00012	8b 82 40 01 00
	00		 mov	 eax, DWORD PTR [edx+320]
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	8b 92 44 01 00
	00		 mov	 edx, DWORD PTR [edx+324]
  00020	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 416  : 	*old_memlimit = coder->memlimit;

  00023	8b 45 10	 mov	 eax, DWORD PTR _old_memlimit$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00029	8b 91 38 01 00
	00		 mov	 edx, DWORD PTR [ecx+312]
  0002f	89 10		 mov	 DWORD PTR [eax], edx
  00031	8b 89 3c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+316]
  00037	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 417  : 
; 418  : 	if (new_memlimit != 0) {

  0003a	8b 55 14	 mov	 edx, DWORD PTR _new_memlimit$[ebp]
  0003d	0b 55 18	 or	 edx, DWORD PTR _new_memlimit$[ebp+4]
  00040	74 40		 je	 SHORT $LN2@stream_dec

; 419  : 		if (new_memlimit < coder->memusage)

  00042	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00045	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR tv87[ebp]
  0004b	8b 55 18	 mov	 edx, DWORD PTR _new_memlimit$[ebp+4]
  0004e	3b 91 44 01 00
	00		 cmp	 edx, DWORD PTR [ecx+324]
  00054	77 17		 ja	 SHORT $LN1@stream_dec
  00056	72 0e		 jb	 SHORT $LN5@stream_dec
  00058	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  0005b	8b 4d 14	 mov	 ecx, DWORD PTR _new_memlimit$[ebp]
  0005e	3b 88 40 01 00
	00		 cmp	 ecx, DWORD PTR [eax+320]
  00064	73 07		 jae	 SHORT $LN1@stream_dec
$LN5@stream_dec:

; 420  : 			return LZMA_MEMLIMIT_ERROR;

  00066	b8 06 00 00 00	 mov	 eax, 6
  0006b	eb 17		 jmp	 SHORT $LN3@stream_dec
$LN1@stream_dec:

; 421  : 
; 422  : 		coder->memlimit = new_memlimit;

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00070	8b 45 14	 mov	 eax, DWORD PTR _new_memlimit$[ebp]
  00073	89 82 38 01 00
	00		 mov	 DWORD PTR [edx+312], eax
  00079	8b 4d 18	 mov	 ecx, DWORD PTR _new_memlimit$[ebp+4]
  0007c	89 8a 3c 01 00
	00		 mov	 DWORD PTR [edx+316], ecx
$LN2@stream_dec:

; 423  : 	}
; 424  : 
; 425  : 	return LZMA_OK;

  00082	33 c0		 xor	 eax, eax
$LN3@stream_dec:

; 426  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_stream_decoder_memconfig ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _stream_decoder_get_check
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_stream_decoder_get_check PROC				; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 404  : 	const lzma_stream_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 405  : 	return coder->stream_flags.check;

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000d	8b 81 08 01 00
	00		 mov	 eax, DWORD PTR [ecx+264]

; 406  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_stream_decoder_get_check ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_decoder_reset
_TEXT	SEGMENT
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_stream_decoder_reset PROC				; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   : 	// Initialize the Index hash used to verify the Index.
; 90   : 	coder->index_hash = lzma_index_hash_init(coder->index_hash, allocator);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000a	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR [ecx+304]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _lzma_index_hash_init
  00016	83 c4 08	 add	 esp, 8
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0001c	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax

; 91   : 	if (coder->index_hash == NULL)

  00022	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00025	83 ba 30 01 00
	00 00		 cmp	 DWORD PTR [edx+304], 0
  0002c	75 07		 jne	 SHORT $LN1@stream_dec@2

; 92   : 		return LZMA_MEM_ERROR;

  0002e	b8 05 00 00 00	 mov	 eax, 5
  00033	eb 18		 jmp	 SHORT $LN2@stream_dec@2
$LN1@stream_dec@2:

; 93   : 
; 94   : 	// Reset the rest of the variables.
; 95   : 	coder->sequence = SEQ_STREAM_HEADER;

  00035	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 96   : 	coder->pos = 0;

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00041	c7 81 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+336], 0

; 97   : 
; 98   : 	return LZMA_OK;

  0004b	33 c0		 xor	 eax, eax
$LN2@stream_dec@2:

; 99   : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_stream_decoder_reset ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_decoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_stream_decoder_end PROC				; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 393  : 	lzma_stream_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 394  : 	lzma_next_end(&coder->block_decoder, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	83 c2 08	 add	 edx, 8
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _lzma_next_end
  0001a	83 c4 08	 add	 esp, 8

; 395  : 	lzma_index_hash_end(coder->index_hash, allocator);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00024	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR [ecx+304]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 _lzma_index_hash_end
  00030	83 c4 08	 add	 esp, 8

; 396  : 	lzma_free(coder, allocator);

  00033	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _lzma_free
  00040	83 c4 08	 add	 esp, 8

; 397  : 	return;
; 398  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_stream_decoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_decode
_TEXT	SEGMENT
tv453 = -216						; size = 8
tv245 = -208						; size = 4
tv370 = -204						; size = 4
tv87 = -200						; size = 4
tv65 = -196						; size = 4
_ret_$32359 = -192					; size = 4
_ret_$32344 = -188					; size = 4
_footer_flags$32337 = -184				; size = 56
_ret$32338 = -128					; size = 4
_ret$32333 = -124					; size = 4
_ret_$32329 = -120					; size = 4
_ret$32324 = -116					; size = 4
_i$32317 = -112						; size = 4
_ret$32312 = -108					; size = 4
_memusage$32311 = -104					; size = 8
_ret_$32309 = -92					; size = 4
_filters$32305 = -88					; size = 80
_ret$32294 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_stream_decode PROC					; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H

; 108  : 	lzma_stream_coder *coder = coder_ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN57@stream_dec@3:

; 109  : 
; 110  : 	// When decoding the actual Block, it may be able to produce more
; 111  : 	// output even if we don't give it any new input.
; 112  : 	while (true)

  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	85 c9		 test	 ecx, ecx
  00016	0f 84 08 06 00
	00		 je	 $LN58@stream_dec@3

; 113  : 	switch (coder->sequence) {

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00027	83 bd 3c ff ff
	ff 05		 cmp	 DWORD PTR tv65[ebp], 5
  0002e	0f 87 e4 05 00
	00		 ja	 $LN1@stream_dec@3
  00034	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  0003a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN66@stream_dec@3[ecx*4]
$LN53@stream_dec@3:

; 114  : 	case SEQ_STREAM_HEADER: {
; 115  : 		// Copy the Stream Header to the internal buffer.
; 116  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 117  : 				LZMA_STREAM_HEADER_SIZE);

  00041	6a 0c		 push	 12			; 0000000cH
  00043	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00046	81 c2 50 01 00
	00		 add	 edx, 336		; 00000150H
  0004c	52		 push	 edx
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00050	05 54 01 00 00	 add	 eax, 340		; 00000154H
  00055	50		 push	 eax
  00056	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0005d	52		 push	 edx
  0005e	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _lzma_bufcpy
  00067	83 c4 18	 add	 esp, 24			; 00000018H

; 118  : 
; 119  : 		// Return if we didn't get the whole Stream Header yet.
; 120  : 		if (coder->pos < LZMA_STREAM_HEADER_SIZE)

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006d	83 b9 50 01 00
	00 0c		 cmp	 DWORD PTR [ecx+336], 12	; 0000000cH
  00074	73 07		 jae	 SHORT $LN52@stream_dec@3

; 121  : 			return LZMA_OK;

  00076	33 c0		 xor	 eax, eax
  00078	e9 a7 05 00 00	 jmp	 $LN58@stream_dec@3
$LN52@stream_dec@3:

; 122  : 
; 123  : 		coder->pos = 0;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00080	c7 82 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+336], 0

; 124  : 
; 125  : 		// Decode the Stream Header.
; 126  : 	  {
; 127  : 		const lzma_ret ret = lzma_stream_header_decode(
; 128  : 				&coder->stream_flags, coder->buffer);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0008d	05 54 01 00 00	 add	 eax, 340		; 00000154H
  00092	50		 push	 eax
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00096	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _lzma_stream_header_decode
  000a2	83 c4 08	 add	 esp, 8
  000a5	89 45 f8	 mov	 DWORD PTR _ret$32294[ebp], eax

; 129  : 		if (ret != LZMA_OK)

  000a8	83 7d f8 00	 cmp	 DWORD PTR _ret$32294[ebp], 0
  000ac	74 34		 je	 SHORT $LN51@stream_dec@3

; 130  : 			return ret == LZMA_FORMAT_ERROR && !coder->first_stream
; 131  : 					? LZMA_DATA_ERROR : ret;

  000ae	83 7d f8 07	 cmp	 DWORD PTR _ret$32294[ebp], 7
  000b2	75 1a		 jne	 SHORT $LN60@stream_dec@3
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000b7	0f b6 82 4d 01
	00 00		 movzx	 eax, BYTE PTR [edx+333]
  000be	85 c0		 test	 eax, eax
  000c0	75 0c		 jne	 SHORT $LN60@stream_dec@3
  000c2	c7 85 38 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR tv87[ebp], 9
  000cc	eb 09		 jmp	 SHORT $LN61@stream_dec@3
$LN60@stream_dec@3:
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _ret$32294[ebp]
  000d1	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv87[ebp], ecx
$LN61@stream_dec@3:
  000d7	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  000dd	e9 42 05 00 00	 jmp	 $LN58@stream_dec@3
$LN51@stream_dec@3:

; 132  : 
; 133  : 		// If we are decoding concatenated Streams, and the later
; 134  : 		// Streams have invalid Header Magic Bytes, we give
; 135  : 		// LZMA_DATA_ERROR instead of LZMA_FORMAT_ERROR.
; 136  : 		coder->first_stream = false;

  000e2	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000e5	c6 82 4d 01 00
	00 00		 mov	 BYTE PTR [edx+333], 0

; 137  : 
; 138  : 		// Copy the type of the Check so that Block Header and Block
; 139  : 		// decoders see it.
; 140  : 		coder->block_options.check = coder->stream_flags.check;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000f2	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  000f8	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 141  : 
; 142  : 		// Even if we return LZMA_*_CHECK below, we want
; 143  : 		// to continue from Block Header decoding.
; 144  : 		coder->sequence = SEQ_BLOCK_HEADER;

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000fe	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 145  : 
; 146  : 		// Detect if there's no integrity check or if it is
; 147  : 		// unsupported if those were requested by the application.
; 148  : 		if (coder->tell_no_check && coder->stream_flags.check
; 149  : 				== LZMA_CHECK_NONE)

  00104	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00107	0f b6 91 48 01
	00 00		 movzx	 edx, BYTE PTR [ecx+328]
  0010e	85 d2		 test	 edx, edx
  00110	74 16		 je	 SHORT $LN50@stream_dec@3
  00112	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00115	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [eax+264], 0
  0011c	75 0a		 jne	 SHORT $LN50@stream_dec@3

; 150  : 			return LZMA_NO_CHECK;

  0011e	b8 02 00 00 00	 mov	 eax, 2
  00123	e9 fc 04 00 00	 jmp	 $LN58@stream_dec@3
$LN50@stream_dec@3:

; 151  : 
; 152  : 		if (coder->tell_unsupported_check
; 153  : 				&& !lzma_check_is_supported(
; 154  : 					coder->stream_flags.check))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0012b	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  00132	85 d2		 test	 edx, edx
  00134	74 23		 je	 SHORT $LN49@stream_dec@3
  00136	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00139	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 _lzma_check_is_supported
  00145	83 c4 04	 add	 esp, 4
  00148	0f b6 d0	 movzx	 edx, al
  0014b	85 d2		 test	 edx, edx
  0014d	75 0a		 jne	 SHORT $LN49@stream_dec@3

; 155  : 			return LZMA_UNSUPPORTED_CHECK;

  0014f	b8 03 00 00 00	 mov	 eax, 3
  00154	e9 cb 04 00 00	 jmp	 $LN58@stream_dec@3
$LN49@stream_dec@3:

; 156  : 
; 157  : 		if (coder->tell_any_check)

  00159	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0015c	0f b6 88 4a 01
	00 00		 movzx	 ecx, BYTE PTR [eax+330]
  00163	85 c9		 test	 ecx, ecx
  00165	74 0a		 je	 SHORT $LN47@stream_dec@3

; 158  : 			return LZMA_GET_CHECK;

  00167	b8 04 00 00 00	 mov	 eax, 4
  0016c	e9 b3 04 00 00	 jmp	 $LN58@stream_dec@3
$LN47@stream_dec@3:

; 159  : 	  }
; 160  : 	}
; 161  : 
; 162  : 	// Fall through
; 163  : 
; 164  : 	case SEQ_BLOCK_HEADER: {
; 165  : 		if (*in_pos >= in_size)

  00171	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00174	8b 02		 mov	 eax, DWORD PTR [edx]
  00176	3b 45 18	 cmp	 eax, DWORD PTR _in_size$[ebp]
  00179	72 07		 jb	 SHORT $LN46@stream_dec@3

; 166  : 			return LZMA_OK;

  0017b	33 c0		 xor	 eax, eax
  0017d	e9 a2 04 00 00	 jmp	 $LN58@stream_dec@3
$LN46@stream_dec@3:

; 167  : 
; 168  : 		if (coder->pos == 0) {

  00182	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00185	83 b9 50 01 00
	00 00		 cmp	 DWORD PTR [ecx+336], 0
  0018c	75 37		 jne	 SHORT $LN45@stream_dec@3

; 169  : 			// Detect if it's Index.
; 170  : 			if (in[*in_pos] == 0x00) {

  0018e	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  00191	8b 02		 mov	 eax, DWORD PTR [edx]
  00193	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00196	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0019a	85 d2		 test	 edx, edx
  0019c	75 0e		 jne	 SHORT $LN44@stream_dec@3

; 171  : 				coder->sequence = SEQ_INDEX;

  0019e	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001a1	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3

; 172  : 				break;

  001a7	e9 73 04 00 00	 jmp	 $LN54@stream_dec@3
$LN44@stream_dec@3:

; 173  : 			}
; 174  : 
; 175  : 			// Calculate the size of the Block Header. Note that
; 176  : 			// Block Header decoder wants to see this byte too
; 177  : 			// so don't advance *in_pos.
; 178  : 			coder->block_options.header_size
; 179  : 					= lzma_block_header_size_decode(
; 180  : 						in[*in_pos]);

  001ac	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  001af	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b1	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  001b4	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  001b8	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  001bf	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001c2	89 50 3c	 mov	 DWORD PTR [eax+60], edx
$LN45@stream_dec@3:

; 181  : 		}
; 182  : 
; 183  : 		// Copy the Block Header to the internal buffer.
; 184  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 185  : 				coder->block_options.header_size);

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c8	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001cb	52		 push	 edx
  001cc	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001cf	05 50 01 00 00	 add	 eax, 336		; 00000150H
  001d4	50		 push	 eax
  001d5	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001d8	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  001de	51		 push	 ecx
  001df	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  001e2	52		 push	 edx
  001e3	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  001e6	50		 push	 eax
  001e7	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 _lzma_bufcpy
  001f0	83 c4 18	 add	 esp, 24			; 00000018H

; 186  : 
; 187  : 		// Return if we didn't get the whole Block Header yet.
; 188  : 		if (coder->pos < coder->block_options.header_size)

  001f3	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001f6	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001f9	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  001ff	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00202	73 07		 jae	 SHORT $LN43@stream_dec@3

; 189  : 			return LZMA_OK;

  00204	33 c0		 xor	 eax, eax
  00206	e9 19 04 00 00	 jmp	 $LN58@stream_dec@3
$LN43@stream_dec@3:

; 190  : 
; 191  : 		coder->pos = 0;

  0020b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0020e	c7 82 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+336], 0

; 192  : 
; 193  : 		// Version 1 is needed to support the .ignore_check option.
; 194  : 		coder->block_options.version = 1;

  00218	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0021b	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1

; 195  : 
; 196  : 		// Set up a buffer to hold the filter chain. Block Header
; 197  : 		// decoder will initialize all members of this array so
; 198  : 		// we don't need to do it here.
; 199  : 	  {
; 200  : 		lzma_filter filters[LZMA_FILTERS_MAX + 1];
; 201  : 		coder->block_options.filters = filters;

  00222	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00225	8d 55 a8	 lea	 edx, DWORD PTR _filters$32305[ebp]
  00228	89 51 58	 mov	 DWORD PTR [ecx+88], edx
$LN42@stream_dec@3:

; 202  : 
; 203  : 		// Decode the Block Header.
; 204  : 		return_if_error(lzma_block_header_decode(&coder->block_options,
; 205  : 				allocator, coder->buffer));

  0022b	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0022e	05 54 01 00 00	 add	 eax, 340		; 00000154H
  00233	50		 push	 eax
  00234	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00237	51		 push	 ecx
  00238	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0023b	83 c2 38	 add	 edx, 56			; 00000038H
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _lzma_block_header_decode
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
  00247	89 45 a4	 mov	 DWORD PTR _ret_$32309[ebp], eax
  0024a	83 7d a4 00	 cmp	 DWORD PTR _ret_$32309[ebp], 0
  0024e	74 08		 je	 SHORT $LN41@stream_dec@3
  00250	8b 45 a4	 mov	 eax, DWORD PTR _ret_$32309[ebp]
  00253	e9 cc 03 00 00	 jmp	 $LN58@stream_dec@3
$LN41@stream_dec@3:
  00258	33 c0		 xor	 eax, eax
  0025a	75 cf		 jne	 SHORT $LN42@stream_dec@3

; 206  : 
; 207  : 		// If LZMA_IGNORE_CHECK was used, this flag needs to be set.
; 208  : 		// It has to be set after lzma_block_header_decode() because
; 209  : 		// it always resets this to false.
; 210  : 		coder->block_options.ignore_check = coder->ignore_check;

  0025c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0025f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00262	8a 82 4b 01 00
	00		 mov	 al, BYTE PTR [edx+331]
  00268	88 81 f0 00 00
	00		 mov	 BYTE PTR [ecx+240], al

; 211  : 
; 212  : 		// Check the memory usage limit.
; 213  : 	  {
; 214  : 		const uint64_t memusage = lzma_raw_decoder_memusage(filters);

  0026e	8d 4d a8	 lea	 ecx, DWORD PTR _filters$32305[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 _lzma_raw_decoder_memusage
  00277	83 c4 04	 add	 esp, 4
  0027a	89 45 98	 mov	 DWORD PTR _memusage$32311[ebp], eax
  0027d	89 55 9c	 mov	 DWORD PTR _memusage$32311[ebp+4], edx

; 215  : 		lzma_ret ret;
; 216  : 
; 217  : 		if (memusage == UINT64_MAX) {

  00280	8b 55 98	 mov	 edx, DWORD PTR _memusage$32311[ebp]
  00283	23 55 9c	 and	 edx, DWORD PTR _memusage$32311[ebp+4]
  00286	83 fa ff	 cmp	 edx, -1
  00289	75 09		 jne	 SHORT $LN38@stream_dec@3

; 218  : 			// One or more unknown Filter IDs.
; 219  : 			ret = LZMA_OPTIONS_ERROR;

  0028b	c7 45 94 08 00
	00 00		 mov	 DWORD PTR _ret$32312[ebp], 8

; 220  : 		} else {

  00292	eb 68		 jmp	 SHORT $LN37@stream_dec@3
$LN38@stream_dec@3:

; 221  : 			// Now we can set coder->memusage since we know that
; 222  : 			// the filter chain is valid. We don't want
; 223  : 			// lzma_memusage() to return UINT64_MAX in case of
; 224  : 			// invalid filter chain.
; 225  : 			coder->memusage = memusage;

  00294	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00297	8b 4d 98	 mov	 ecx, DWORD PTR _memusage$32311[ebp]
  0029a	89 88 40 01 00
	00		 mov	 DWORD PTR [eax+320], ecx
  002a0	8b 55 9c	 mov	 edx, DWORD PTR _memusage$32311[ebp+4]
  002a3	89 90 44 01 00
	00		 mov	 DWORD PTR [eax+324], edx

; 226  : 
; 227  : 			if (memusage > coder->memlimit) {

  002a9	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002ac	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv370[ebp], eax
  002b2	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv370[ebp]
  002b8	8b 55 9c	 mov	 edx, DWORD PTR _memusage$32311[ebp+4]
  002bb	3b 91 3c 01 00
	00		 cmp	 edx, DWORD PTR [ecx+316]
  002c1	72 1c		 jb	 SHORT $LN36@stream_dec@3
  002c3	77 11		 ja	 SHORT $LN64@stream_dec@3
  002c5	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv370[ebp]
  002cb	8b 4d 98	 mov	 ecx, DWORD PTR _memusage$32311[ebp]
  002ce	3b 88 38 01 00
	00		 cmp	 ecx, DWORD PTR [eax+312]
  002d4	76 09		 jbe	 SHORT $LN36@stream_dec@3
$LN64@stream_dec@3:

; 228  : 				// The chain would need too much memory.
; 229  : 				ret = LZMA_MEMLIMIT_ERROR;

  002d6	c7 45 94 06 00
	00 00		 mov	 DWORD PTR _ret$32312[ebp], 6

; 230  : 			} else {

  002dd	eb 1d		 jmp	 SHORT $LN37@stream_dec@3
$LN36@stream_dec@3:

; 231  : 				// Memory usage is OK.
; 232  : 				// Initialize the Block decoder.
; 233  : 				ret = lzma_block_decoder_init(
; 234  : 						&coder->block_decoder,
; 235  : 						allocator,
; 236  : 						&coder->block_options);

  002df	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002e2	83 c2 38	 add	 edx, 56			; 00000038H
  002e5	52		 push	 edx
  002e6	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  002e9	50		 push	 eax
  002ea	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002ed	83 c1 08	 add	 ecx, 8
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 _lzma_block_decoder_init
  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f9	89 45 94	 mov	 DWORD PTR _ret$32312[ebp], eax
$LN37@stream_dec@3:

; 237  : 			}
; 238  : 		}
; 239  : 
; 240  : 		// Free the allocated filter options since they are needed
; 241  : 		// only to initialize the Block decoder.
; 242  : 	  { size_t i;
; 243  : 		for (i = 0; i < LZMA_FILTERS_MAX; ++i)

  002fc	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _i$32317[ebp], 0
  00303	eb 09		 jmp	 SHORT $LN34@stream_dec@3
$LN33@stream_dec@3:
  00305	8b 55 90	 mov	 edx, DWORD PTR _i$32317[ebp]
  00308	83 c2 01	 add	 edx, 1
  0030b	89 55 90	 mov	 DWORD PTR _i$32317[ebp], edx
$LN34@stream_dec@3:
  0030e	83 7d 90 04	 cmp	 DWORD PTR _i$32317[ebp], 4
  00312	73 19		 jae	 SHORT $LN32@stream_dec@3

; 244  : 			lzma_free(filters[i].options, allocator);

  00314	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00317	50		 push	 eax
  00318	8b 4d 90	 mov	 ecx, DWORD PTR _i$32317[ebp]
  0031b	c1 e1 04	 shl	 ecx, 4
  0031e	8b 54 0d b0	 mov	 edx, DWORD PTR _filters$32305[ebp+ecx+8]
  00322	52		 push	 edx
  00323	e8 00 00 00 00	 call	 _lzma_free
  00328	83 c4 08	 add	 esp, 8
  0032b	eb d8		 jmp	 SHORT $LN33@stream_dec@3
$LN32@stream_dec@3:

; 245  : 	  }
; 246  : 
; 247  : 		coder->block_options.filters = NULL;

  0032d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00330	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 248  : 
; 249  : 		// Check if memory usage calculation and Block enocoder
; 250  : 		// initialization succeeded.
; 251  : 		if (ret != LZMA_OK)

  00337	83 7d 94 00	 cmp	 DWORD PTR _ret$32312[ebp], 0
  0033b	74 08		 je	 SHORT $LN31@stream_dec@3

; 252  : 			return ret;

  0033d	8b 45 94	 mov	 eax, DWORD PTR _ret$32312[ebp]
  00340	e9 df 02 00 00	 jmp	 $LN58@stream_dec@3
$LN31@stream_dec@3:

; 253  : 
; 254  : 		coder->sequence = SEQ_BLOCK;

  00345	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00348	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN30@stream_dec@3:

; 255  : 	  }}
; 256  : 	}
; 257  : 
; 258  : 	// Fall through
; 259  : 
; 260  : 	case SEQ_BLOCK: {
; 261  : 		const lzma_ret ret = coder->block_decoder.code(
; 262  : 				coder->block_decoder.coder, allocator,
; 263  : 				in, in_pos, in_size, out, out_pos, out_size,
; 264  : 				action);

  0034e	8b 55 28	 mov	 edx, DWORD PTR _action$[ebp]
  00351	52		 push	 edx
  00352	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  00355	50		 push	 eax
  00356	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00359	51		 push	 ecx
  0035a	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  0035d	52		 push	 edx
  0035e	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  00361	50		 push	 eax
  00362	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00365	51		 push	 ecx
  00366	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00369	52		 push	 edx
  0036a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0036d	50		 push	 eax
  0036e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00371	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00374	52		 push	 edx
  00375	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00378	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0037b	ff d1		 call	 ecx
  0037d	83 c4 24	 add	 esp, 36			; 00000024H
  00380	89 45 8c	 mov	 DWORD PTR _ret$32324[ebp], eax

; 265  : 
; 266  : 		if (ret != LZMA_STREAM_END)

  00383	83 7d 8c 01	 cmp	 DWORD PTR _ret$32324[ebp], 1
  00387	74 08		 je	 SHORT $LN28@stream_dec@3

; 267  : 			return ret;

  00389	8b 45 8c	 mov	 eax, DWORD PTR _ret$32324[ebp]
  0038c	e9 93 02 00 00	 jmp	 $LN58@stream_dec@3
$LN28@stream_dec@3:

; 268  : 
; 269  : 		// Block decoded successfully. Add the new size pair to
; 270  : 		// the Index hash.
; 271  : 		return_if_error(lzma_index_hash_append(coder->index_hash,
; 272  : 				lzma_block_unpadded_size(
; 273  : 					&coder->block_options),
; 274  : 				coder->block_options.uncompressed_size));

  00391	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00394	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00397	50		 push	 eax
  00398	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0039b	51		 push	 ecx
  0039c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0039f	83 c2 38	 add	 edx, 56			; 00000038H
  003a2	52		 push	 edx
  003a3	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  003a8	83 c4 04	 add	 esp, 4
  003ab	52		 push	 edx
  003ac	50		 push	 eax
  003ad	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  003b0	8b 88 30 01 00
	00		 mov	 ecx, DWORD PTR [eax+304]
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 _lzma_index_hash_append
  003bc	83 c4 14	 add	 esp, 20			; 00000014H
  003bf	89 45 88	 mov	 DWORD PTR _ret_$32329[ebp], eax
  003c2	83 7d 88 00	 cmp	 DWORD PTR _ret_$32329[ebp], 0
  003c6	74 08		 je	 SHORT $LN27@stream_dec@3
  003c8	8b 45 88	 mov	 eax, DWORD PTR _ret_$32329[ebp]
  003cb	e9 54 02 00 00	 jmp	 $LN58@stream_dec@3
$LN27@stream_dec@3:
  003d0	33 d2		 xor	 edx, edx
  003d2	75 bd		 jne	 SHORT $LN28@stream_dec@3

; 275  : 
; 276  : 		coder->sequence = SEQ_BLOCK_HEADER;

  003d4	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  003d7	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 277  : 		break;

  003dd	e9 3d 02 00 00	 jmp	 $LN54@stream_dec@3
$LN24@stream_dec@3:

; 278  : 	}
; 279  : 
; 280  : 	case SEQ_INDEX: {
; 281  : 		// If we don't have any input, don't call
; 282  : 		// lzma_index_hash_decode() since it would return
; 283  : 		// LZMA_BUF_ERROR, which we must not do here.
; 284  : 		if (*in_pos >= in_size)

  003e2	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  003e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  003e7	3b 55 18	 cmp	 edx, DWORD PTR _in_size$[ebp]
  003ea	72 07		 jb	 SHORT $LN23@stream_dec@3

; 285  : 			return LZMA_OK;

  003ec	33 c0		 xor	 eax, eax
  003ee	e9 31 02 00 00	 jmp	 $LN58@stream_dec@3
$LN23@stream_dec@3:

; 286  : 
; 287  : 		// Decode the Index and compare it to the hash calculated
; 288  : 		// from the sizes of the Blocks (if any).
; 289  : 	  {
; 290  : 		const lzma_ret ret = lzma_index_hash_decode(coder->index_hash,
; 291  : 				in, in_pos, in_size);

  003f3	8b 45 18	 mov	 eax, DWORD PTR _in_size$[ebp]
  003f6	50		 push	 eax
  003f7	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  003fa	51		 push	 ecx
  003fb	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  003fe	52		 push	 edx
  003ff	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00402	8b 88 30 01 00
	00		 mov	 ecx, DWORD PTR [eax+304]
  00408	51		 push	 ecx
  00409	e8 00 00 00 00	 call	 _lzma_index_hash_decode
  0040e	83 c4 10	 add	 esp, 16			; 00000010H
  00411	89 45 84	 mov	 DWORD PTR _ret$32333[ebp], eax

; 292  : 		if (ret != LZMA_STREAM_END)

  00414	83 7d 84 01	 cmp	 DWORD PTR _ret$32333[ebp], 1
  00418	74 08		 je	 SHORT $LN22@stream_dec@3

; 293  : 			return ret;

  0041a	8b 45 84	 mov	 eax, DWORD PTR _ret$32333[ebp]
  0041d	e9 02 02 00 00	 jmp	 $LN58@stream_dec@3
$LN22@stream_dec@3:

; 294  : 	  }
; 295  : 
; 296  : 		coder->sequence = SEQ_STREAM_FOOTER;

  00422	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00425	c7 02 04 00 00
	00		 mov	 DWORD PTR [edx], 4
$LN21@stream_dec@3:

; 297  : 	}
; 298  : 
; 299  : 	// Fall through
; 300  : 
; 301  : 	case SEQ_STREAM_FOOTER: {
; 302  : 		// Copy the Stream Footer to the internal buffer.
; 303  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 304  : 				LZMA_STREAM_HEADER_SIZE);

  0042b	6a 0c		 push	 12			; 0000000cH
  0042d	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00430	05 50 01 00 00	 add	 eax, 336		; 00000150H
  00435	50		 push	 eax
  00436	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00439	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  0043f	51		 push	 ecx
  00440	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  00443	52		 push	 edx
  00444	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00447	50		 push	 eax
  00448	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0044b	51		 push	 ecx
  0044c	e8 00 00 00 00	 call	 _lzma_bufcpy
  00451	83 c4 18	 add	 esp, 24			; 00000018H

; 305  : 
; 306  : 		// Return if we didn't get the whole Stream Footer yet.
; 307  : 		if (coder->pos < LZMA_STREAM_HEADER_SIZE)

  00454	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00457	83 ba 50 01 00
	00 0c		 cmp	 DWORD PTR [edx+336], 12	; 0000000cH
  0045e	73 07		 jae	 SHORT $LN20@stream_dec@3

; 308  : 			return LZMA_OK;

  00460	33 c0		 xor	 eax, eax
  00462	e9 bd 01 00 00	 jmp	 $LN58@stream_dec@3
$LN20@stream_dec@3:

; 309  : 
; 310  : 		coder->pos = 0;

  00467	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0046a	c7 80 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+336], 0

; 311  : 
; 312  : 		// Decode the Stream Footer. The decoder gives
; 313  : 		// LZMA_FORMAT_ERROR if the magic bytes don't match,
; 314  : 		// so convert that return code to LZMA_DATA_ERROR.
; 315  : 	  {
; 316  : 		lzma_stream_flags footer_flags;
; 317  : 		const lzma_ret ret = lzma_stream_footer_decode(
; 318  : 				&footer_flags, coder->buffer);

  00474	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00477	81 c1 54 01 00
	00		 add	 ecx, 340		; 00000154H
  0047d	51		 push	 ecx
  0047e	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _footer_flags$32337[ebp]
  00484	52		 push	 edx
  00485	e8 00 00 00 00	 call	 _lzma_stream_footer_decode
  0048a	83 c4 08	 add	 esp, 8
  0048d	89 45 80	 mov	 DWORD PTR _ret$32338[ebp], eax

; 319  : 		if (ret != LZMA_OK)

  00490	83 7d 80 00	 cmp	 DWORD PTR _ret$32338[ebp], 0
  00494	74 26		 je	 SHORT $LN19@stream_dec@3

; 320  : 			return ret == LZMA_FORMAT_ERROR
; 321  : 					? LZMA_DATA_ERROR : ret;

  00496	83 7d 80 07	 cmp	 DWORD PTR _ret$32338[ebp], 7
  0049a	75 0c		 jne	 SHORT $LN62@stream_dec@3
  0049c	c7 85 30 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR tv245[ebp], 9
  004a6	eb 09		 jmp	 SHORT $LN63@stream_dec@3
$LN62@stream_dec@3:
  004a8	8b 45 80	 mov	 eax, DWORD PTR _ret$32338[ebp]
  004ab	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
$LN63@stream_dec@3:
  004b1	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv245[ebp]
  004b7	e9 68 01 00 00	 jmp	 $LN58@stream_dec@3
$LN19@stream_dec@3:

; 322  : 
; 323  : 		// Check that Index Size stored in the Stream Footer matches
; 324  : 		// the real size of the Index field.
; 325  : 		if (lzma_index_hash_size(coder->index_hash)
; 326  : 				!= footer_flags.backward_size)

  004bc	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  004bf	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR [ecx+304]
  004c5	52		 push	 edx
  004c6	e8 00 00 00 00	 call	 _lzma_index_hash_size
  004cb	83 c4 04	 add	 esp, 4
  004ce	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv453[ebp], eax
  004d4	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv453[ebp+4], edx
  004da	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv453[ebp]
  004e0	3b 85 50 ff ff
	ff		 cmp	 eax, DWORD PTR _footer_flags$32337[ebp+8]
  004e6	75 0e		 jne	 SHORT $LN65@stream_dec@3
  004e8	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv453[ebp+4]
  004ee	3b 8d 54 ff ff
	ff		 cmp	 ecx, DWORD PTR _footer_flags$32337[ebp+12]
  004f4	74 0a		 je	 SHORT $LN17@stream_dec@3
$LN65@stream_dec@3:

; 327  : 			return LZMA_DATA_ERROR;

  004f6	b8 09 00 00 00	 mov	 eax, 9
  004fb	e9 24 01 00 00	 jmp	 $LN58@stream_dec@3
$LN17@stream_dec@3:

; 328  : 
; 329  : 		// Compare that the Stream Flags fields are identical in
; 330  : 		// both Stream Header and Stream Footer.
; 331  : 		return_if_error(lzma_stream_flags_compare(
; 332  : 				&coder->stream_flags, &footer_flags));

  00500	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR _footer_flags$32337[ebp]
  00506	52		 push	 edx
  00507	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0050a	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  0050f	50		 push	 eax
  00510	e8 00 00 00 00	 call	 _lzma_stream_flags_compare
  00515	83 c4 08	 add	 esp, 8
  00518	89 85 44 ff ff
	ff		 mov	 DWORD PTR _ret_$32344[ebp], eax
  0051e	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32344[ebp], 0
  00525	74 0b		 je	 SHORT $LN16@stream_dec@3
  00527	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32344[ebp]
  0052d	e9 f2 00 00 00	 jmp	 $LN58@stream_dec@3
$LN16@stream_dec@3:
  00532	33 c9		 xor	 ecx, ecx
  00534	75 ca		 jne	 SHORT $LN17@stream_dec@3

; 333  : 
; 334  : 		if (!coder->concatenated)

  00536	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00539	0f b6 82 4c 01
	00 00		 movzx	 eax, BYTE PTR [edx+332]
  00540	85 c0		 test	 eax, eax
  00542	75 0a		 jne	 SHORT $LN13@stream_dec@3

; 335  : 			return LZMA_STREAM_END;

  00544	b8 01 00 00 00	 mov	 eax, 1
  00549	e9 d6 00 00 00	 jmp	 $LN58@stream_dec@3
$LN13@stream_dec@3:

; 336  : 
; 337  : 		coder->sequence = SEQ_STREAM_PADDING;

  0054e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00551	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN11@stream_dec@3:

; 338  : 	  }		
; 339  : 	}
; 340  : 
; 341  : 	// Fall through
; 342  : 
; 343  : 	case SEQ_STREAM_PADDING:
; 344  : 		assert(coder->concatenated);
; 345  : 
; 346  : 		// Skip over possible Stream Padding.
; 347  : 		while (true) {

  00557	ba 01 00 00 00	 mov	 edx, 1
  0055c	85 d2		 test	 edx, edx
  0055e	74 6b		 je	 SHORT $LN10@stream_dec@3

; 348  : 			if (*in_pos >= in_size) {

  00560	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00563	8b 08		 mov	 ecx, DWORD PTR [eax]
  00565	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  00568	72 28		 jb	 SHORT $LN9@stream_dec@3

; 349  : 				// Unless LZMA_FINISH was used, we cannot
; 350  : 				// know if there's more input coming later.
; 351  : 				if (action != LZMA_FINISH)

  0056a	83 7d 28 03	 cmp	 DWORD PTR _action$[ebp], 3
  0056e	74 07		 je	 SHORT $LN8@stream_dec@3

; 352  : 					return LZMA_OK;

  00570	33 c0		 xor	 eax, eax
  00572	e9 ad 00 00 00	 jmp	 $LN58@stream_dec@3
$LN8@stream_dec@3:

; 353  : 
; 354  : 				// Stream Padding must be a multiple of
; 355  : 				// four bytes.
; 356  : 				return coder->pos == 0
; 357  : 						? LZMA_STREAM_END
; 358  : 						: LZMA_DATA_ERROR;

  00577	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0057a	33 c0		 xor	 eax, eax
  0057c	83 ba 50 01 00
	00 00		 cmp	 DWORD PTR [edx+336], 0
  00583	0f 95 c0	 setne	 al
  00586	8d 04 c5 01 00
	00 00		 lea	 eax, DWORD PTR [eax*8+1]
  0058d	e9 92 00 00 00	 jmp	 $LN58@stream_dec@3
$LN9@stream_dec@3:

; 359  : 			}
; 360  : 
; 361  : 			// If the byte is not zero, it probably indicates
; 362  : 			// beginning of a new Stream (or the file is corrupt).
; 363  : 			if (in[*in_pos] != 0x00)

  00592	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00595	8b 08		 mov	 ecx, DWORD PTR [eax]
  00597	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  0059a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0059e	85 c0		 test	 eax, eax
  005a0	74 02		 je	 SHORT $LN7@stream_dec@3

; 364  : 				break;

  005a2	eb 27		 jmp	 SHORT $LN10@stream_dec@3
$LN7@stream_dec@3:

; 365  : 
; 366  : 			++*in_pos;

  005a4	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  005a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  005a9	83 c2 01	 add	 edx, 1
  005ac	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  005af	89 10		 mov	 DWORD PTR [eax], edx

; 367  : 			coder->pos = (coder->pos + 1) & 3;

  005b1	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  005b4	8b 91 50 01 00
	00		 mov	 edx, DWORD PTR [ecx+336]
  005ba	83 c2 01	 add	 edx, 1
  005bd	83 e2 03	 and	 edx, 3
  005c0	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  005c3	89 90 50 01 00
	00		 mov	 DWORD PTR [eax+336], edx

; 368  : 		}

  005c9	eb 8c		 jmp	 SHORT $LN11@stream_dec@3
$LN10@stream_dec@3:

; 369  : 
; 370  : 		// Stream Padding must be a multiple of four bytes (empty
; 371  : 		// Stream Padding is OK).
; 372  : 		if (coder->pos != 0) {

  005cb	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  005ce	83 b9 50 01 00
	00 00		 cmp	 DWORD PTR [ecx+336], 0
  005d5	74 14		 je	 SHORT $LN5@stream_dec@3

; 373  : 			++*in_pos;

  005d7	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  005da	8b 02		 mov	 eax, DWORD PTR [edx]
  005dc	83 c0 01	 add	 eax, 1
  005df	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  005e2	89 01		 mov	 DWORD PTR [ecx], eax

; 374  : 			return LZMA_DATA_ERROR;

  005e4	b8 09 00 00 00	 mov	 eax, 9
  005e9	eb 39		 jmp	 SHORT $LN58@stream_dec@3
$LN5@stream_dec@3:

; 375  : 		}
; 376  : 
; 377  : 		// Prepare to decode the next Stream.
; 378  : 		return_if_error(stream_decoder_reset(coder, allocator));

  005eb	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  005ee	52		 push	 edx
  005ef	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  005f2	50		 push	 eax
  005f3	e8 00 00 00 00	 call	 _stream_decoder_reset
  005f8	83 c4 08	 add	 esp, 8
  005fb	89 85 40 ff ff
	ff		 mov	 DWORD PTR _ret_$32359[ebp], eax
  00601	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _ret_$32359[ebp], 0
  00608	74 08		 je	 SHORT $LN4@stream_dec@3
  0060a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _ret_$32359[ebp]
  00610	eb 12		 jmp	 SHORT $LN58@stream_dec@3
$LN4@stream_dec@3:
  00612	33 c9		 xor	 ecx, ecx
  00614	75 d5		 jne	 SHORT $LN5@stream_dec@3

; 379  : 		break;

  00616	eb 07		 jmp	 SHORT $LN54@stream_dec@3
$LN1@stream_dec@3:

; 380  : 
; 381  : 	default:
; 382  : 		assert(0);
; 383  : 		return LZMA_PROG_ERROR;

  00618	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0061d	eb 05		 jmp	 SHORT $LN58@stream_dec@3
$LN54@stream_dec@3:

; 384  : 	}

  0061f	e9 eb f9 ff ff	 jmp	 $LN57@stream_dec@3
$LN58@stream_dec@3:

; 385  : 
; 386  : 	// Never reached
; 387  : }

  00624	8b e5		 mov	 esp, ebp
  00626	5d		 pop	 ebp
  00627	c3		 ret	 0
$LN66@stream_dec@3:
  00628	00 00 00 00	 DD	 $LN53@stream_dec@3
  0062c	00 00 00 00	 DD	 $LN47@stream_dec@3
  00630	00 00 00 00	 DD	 $LN30@stream_dec@3
  00634	00 00 00 00	 DD	 $LN24@stream_dec@3
  00638	00 00 00 00	 DD	 $LN21@stream_dec@3
  0063c	00 00 00 00	 DD	 $LN11@stream_dec@3
_stream_decode ENDP
_TEXT	ENDS
PUBLIC	_lzma_stream_decoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_decoder_init
_TEXT	SEGMENT
tv85 = -12						; size = 8
_coder$32404 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_memlimit$ = 16						; size = 8
_flags$ = 24						; size = 4
_lzma_stream_decoder_init PROC				; COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN7@lzma_strea@4:

; 434  : 	lzma_next_coder_init(&lzma_stream_decoder_init, next, allocator);

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _lzma_stream_decoder_init
  00012	74 10		 je	 SHORT $LN4@lzma_strea@4
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _lzma_next_end
  00021	83 c4 08	 add	 esp, 8
$LN4@lzma_strea@4:
  00024	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma_stream_decoder_init
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 d6		 jne	 SHORT $LN7@lzma_strea@4

; 435  : 
; 436  : 	if (flags & ~LZMA_SUPPORTED_FLAGS)

  00032	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  00035	83 e2 e0	 and	 edx, -32		; ffffffe0H
  00038	74 0a		 je	 SHORT $LN3@lzma_strea@4

; 437  : 		return LZMA_OPTIONS_ERROR;

  0003a	b8 08 00 00 00	 mov	 eax, 8
  0003f	e9 5a 01 00 00	 jmp	 $LN8@lzma_strea@4
$LN3@lzma_strea@4:

; 438  : 
; 439  :   {
; 440  : 	lzma_stream_coder *coder = next->coder;

  00044	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4d fc	 mov	 DWORD PTR _coder$32404[ebp], ecx

; 441  : 	if (coder == NULL) {

  0004c	83 7d fc 00	 cmp	 DWORD PTR _coder$32404[ebp], 0
  00050	75 73		 jne	 SHORT $LN2@lzma_strea@4

; 442  : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00055	52		 push	 edx
  00056	68 58 05 00 00	 push	 1368			; 00000558H
  0005b	e8 00 00 00 00	 call	 _lzma_alloc
  00060	83 c4 08	 add	 esp, 8
  00063	89 45 fc	 mov	 DWORD PTR _coder$32404[ebp], eax

; 443  : 		if (coder == NULL)

  00066	83 7d fc 00	 cmp	 DWORD PTR _coder$32404[ebp], 0
  0006a	75 0a		 jne	 SHORT $LN1@lzma_strea@4

; 444  : 			return LZMA_MEM_ERROR;

  0006c	b8 05 00 00 00	 mov	 eax, 5
  00071	e9 28 01 00 00	 jmp	 $LN8@lzma_strea@4
$LN1@lzma_strea@4:

; 445  : 
; 446  : 		next->coder = coder;

  00076	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32404[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 447  : 		next->code = &stream_decode;

  0007e	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00081	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _stream_decode

; 448  : 		next->end = &stream_decoder_end;

  00088	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0008b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _stream_decoder_end

; 449  : 		next->get_check = &stream_decoder_get_check;

  00092	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00095	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _stream_decoder_get_check

; 450  : 		next->memconfig = &stream_decoder_memconfig;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0009f	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _stream_decoder_memconfig

; 451  : 
; 452  : 		coder->block_decoder = LZMA_NEXT_CODER_INIT;

  000a6	8b 7d fc	 mov	 edi, DWORD PTR _coder$32404[ebp]
  000a9	83 c7 08	 add	 edi, 8
  000ac	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000b1	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000b6	f3 a5		 rep movsd

; 453  : 		coder->index_hash = NULL;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _coder$32404[ebp]
  000bb	c7 80 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+304], 0
$LN2@lzma_strea@4:

; 454  : 	}
; 455  : 
; 456  : 	coder->memlimit = my_max(1, memlimit);

  000c5	83 7d 14 00	 cmp	 DWORD PTR _memlimit$[ebp+4], 0
  000c9	77 18		 ja	 SHORT $LN10@lzma_strea@4
  000cb	72 06		 jb	 SHORT $LN12@lzma_strea@4
  000cd	83 7d 10 01	 cmp	 DWORD PTR _memlimit$[ebp], 1
  000d1	73 10		 jae	 SHORT $LN10@lzma_strea@4
$LN12@lzma_strea@4:
  000d3	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  000da	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv85[ebp+4], 0
  000e1	eb 0c		 jmp	 SHORT $LN11@lzma_strea@4
$LN10@lzma_strea@4:
  000e3	8b 4d 10	 mov	 ecx, DWORD PTR _memlimit$[ebp]
  000e6	89 4d f4	 mov	 DWORD PTR tv85[ebp], ecx
  000e9	8b 55 14	 mov	 edx, DWORD PTR _memlimit$[ebp+4]
  000ec	89 55 f8	 mov	 DWORD PTR tv85[ebp+4], edx
$LN11@lzma_strea@4:
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _coder$32404[ebp]
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  000f5	89 88 38 01 00
	00		 mov	 DWORD PTR [eax+312], ecx
  000fb	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp+4]
  000fe	89 90 3c 01 00
	00		 mov	 DWORD PTR [eax+316], edx

; 457  : 	coder->memusage = LZMA_MEMUSAGE_BASE;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _coder$32404[ebp]
  00107	c7 80 40 01 00
	00 00 80 00 00	 mov	 DWORD PTR [eax+320], 32768 ; 00008000H
  00111	c7 80 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+324], 0

; 458  : 	coder->tell_no_check = (flags & LZMA_TELL_NO_CHECK) != 0;

  0011b	8b 4d 18	 mov	 ecx, DWORD PTR _flags$[ebp]
  0011e	83 e1 01	 and	 ecx, 1
  00121	f7 d9		 neg	 ecx
  00123	1b c9		 sbb	 ecx, ecx
  00125	f7 d9		 neg	 ecx
  00127	8b 55 fc	 mov	 edx, DWORD PTR _coder$32404[ebp]
  0012a	88 8a 48 01 00
	00		 mov	 BYTE PTR [edx+328], cl

; 459  : 	coder->tell_unsupported_check
; 460  : 			= (flags & LZMA_TELL_UNSUPPORTED_CHECK) != 0;

  00130	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00133	83 e0 02	 and	 eax, 2
  00136	f7 d8		 neg	 eax
  00138	1b c0		 sbb	 eax, eax
  0013a	f7 d8		 neg	 eax
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32404[ebp]
  0013f	88 81 49 01 00
	00		 mov	 BYTE PTR [ecx+329], al

; 461  : 	coder->tell_any_check = (flags & LZMA_TELL_ANY_CHECK) != 0;

  00145	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  00148	83 e2 04	 and	 edx, 4
  0014b	f7 da		 neg	 edx
  0014d	1b d2		 sbb	 edx, edx
  0014f	f7 da		 neg	 edx
  00151	8b 45 fc	 mov	 eax, DWORD PTR _coder$32404[ebp]
  00154	88 90 4a 01 00
	00		 mov	 BYTE PTR [eax+330], dl

; 462  : 	coder->ignore_check = (flags & LZMA_IGNORE_CHECK) != 0;

  0015a	8b 4d 18	 mov	 ecx, DWORD PTR _flags$[ebp]
  0015d	83 e1 10	 and	 ecx, 16			; 00000010H
  00160	f7 d9		 neg	 ecx
  00162	1b c9		 sbb	 ecx, ecx
  00164	f7 d9		 neg	 ecx
  00166	8b 55 fc	 mov	 edx, DWORD PTR _coder$32404[ebp]
  00169	88 8a 4b 01 00
	00		 mov	 BYTE PTR [edx+331], cl

; 463  : 	coder->concatenated = (flags & LZMA_CONCATENATED) != 0;

  0016f	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00172	83 e0 08	 and	 eax, 8
  00175	f7 d8		 neg	 eax
  00177	1b c0		 sbb	 eax, eax
  00179	f7 d8		 neg	 eax
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32404[ebp]
  0017e	88 81 4c 01 00
	00		 mov	 BYTE PTR [ecx+332], al

; 464  : 	coder->first_stream = true;

  00184	8b 55 fc	 mov	 edx, DWORD PTR _coder$32404[ebp]
  00187	c6 82 4d 01 00
	00 01		 mov	 BYTE PTR [edx+333], 1

; 465  : 
; 466  : 	return stream_decoder_reset(coder, allocator);

  0018e	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00191	50		 push	 eax
  00192	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32404[ebp]
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 _stream_decoder_reset
  0019b	83 c4 08	 add	 esp, 8
$LN8@lzma_strea@4:

; 467  :   }
; 468  : }

  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c3		 ret	 0
_lzma_stream_decoder_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_stream_decoder
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_decoder
_TEXT	SEGMENT
_ret_$32426 = -8					; size = 4
_ret_$32424 = -4					; size = 4
_strm$ = 8						; size = 4
_memlimit$ = 12						; size = 8
_flags$ = 20						; size = 4
_lzma_stream_decoder PROC				; COMDAT

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_strea@5:

; 474  : 	lzma_next_strm_init(lzma_stream_decoder_init, strm, memlimit, flags);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32424[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32424[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_strea@5
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32424[ebp]
  0001e	eb 5a		 jmp	 SHORT $LN9@lzma_strea@5
$LN4@lzma_strea@5:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_strea@5
  00024	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  00027	52		 push	 edx
  00028	8b 45 10	 mov	 eax, DWORD PTR _memlimit$[ebp+4]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _memlimit$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00033	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _lzma_stream_decoder_init
  00043	83 c4 14	 add	 esp, 20			; 00000014H
  00046	89 45 f8	 mov	 DWORD PTR _ret_$32426[ebp], eax
  00049	83 7d f8 00	 cmp	 DWORD PTR _ret_$32426[ebp], 0
  0004d	74 11		 je	 SHORT $LN7@lzma_strea@5
  0004f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _lzma_end
  00058	83 c4 04	 add	 esp, 4
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32426[ebp]
  0005e	eb 1a		 jmp	 SHORT $LN9@lzma_strea@5
$LN7@lzma_strea@5:
  00060	33 c9		 xor	 ecx, ecx
  00062	75 a2		 jne	 SHORT $LN5@lzma_strea@5

; 475  : 
; 476  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00064	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00067	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0006a	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1

; 477  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00071	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00074	c6 42 3b 01	 mov	 BYTE PTR [edx+59], 1

; 478  : 
; 479  : 	return LZMA_OK;

  00078	33 c0		 xor	 eax, eax
$LN9@lzma_strea@5:

; 480  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_lzma_stream_decoder ENDP
_TEXT	ENDS
END
