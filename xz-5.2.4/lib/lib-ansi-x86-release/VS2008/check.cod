; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\check\check.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?available_checks@?2??lzma_check_is_supported@@9@9 DB 01H ; `lzma_check_is_supported'::`3'::available_checks
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?check_sizes@?2??lzma_check_size@@9@9 DB 00H		; `lzma_check_size'::`3'::check_sizes
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	010H
	DB	010H
	DB	010H
	DB	020H
	DB	020H
	DB	020H
	DB	040H
	DB	040H
	DB	040H
PUBLIC	_lzma_check_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\check\check.c
;	COMDAT _lzma_check_init
_TEXT	SEGMENT
tv64 = -4						; size = 4
_check$ = 8						; size = 4
_type$ = 12						; size = 4
_lzma_check_init PROC					; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 90   : 	switch (type) {

  00004	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  0000e	74 10		 je	 SHORT $LN4@lzma_check
  00010	83 7d fc 04	 cmp	 DWORD PTR tv64[ebp], 4
  00014	74 16		 je	 SHORT $LN3@lzma_check
  00016	83 7d fc 0a	 cmp	 DWORD PTR tv64[ebp], 10	; 0000000aH
  0001a	74 23		 je	 SHORT $LN2@lzma_check
  0001c	eb 2d		 jmp	 SHORT $LN8@lzma_check

; 91   : 	case LZMA_CHECK_NONE:
; 92   : 		break;

  0001e	eb 2b		 jmp	 SHORT $LN8@lzma_check
$LN4@lzma_check:

; 93   : 
; 94   : #ifdef HAVE_CHECK_CRC32
; 95   : 	case LZMA_CHECK_CRC32:
; 96   : 		check->state.crc32 = 0;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _check$[ebp]
  00023	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 97   : 		break;

  0002a	eb 1f		 jmp	 SHORT $LN8@lzma_check
$LN3@lzma_check:

; 98   : #endif
; 99   : 
; 100  : #ifdef HAVE_CHECK_CRC64
; 101  : 	case LZMA_CHECK_CRC64:
; 102  : 		check->state.crc64 = 0;

  0002c	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  0002f	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0
  00036	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 103  : 		break;

  0003d	eb 0c		 jmp	 SHORT $LN8@lzma_check
$LN2@lzma_check:

; 104  : #endif
; 105  : 
; 106  : #ifdef HAVE_CHECK_SHA256
; 107  : 	case LZMA_CHECK_SHA256:
; 108  : 		lzma_sha256_init(check);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _check$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _lzma_sha256_init
  00048	83 c4 04	 add	 esp, 4
$LN8@lzma_check:

; 109  : 		break;
; 110  : #endif
; 111  : 
; 112  : 	default:
; 113  : 		break;
; 114  : 	}
; 115  : 
; 116  : 	return;
; 117  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_lzma_check_init ENDP
_TEXT	ENDS
PUBLIC	_lzma_check_size
; Function compile flags: /Odtp
;	COMDAT _lzma_check_size
_TEXT	SEGMENT
_type$ = 8						; size = 4
_lzma_check_size PROC					; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)

  00003	83 7d 08 0f	 cmp	 DWORD PTR _type$[ebp], 15 ; 0000000fH
  00007	76 05		 jbe	 SHORT $LN1@lzma_check@2

; 69   : 		return UINT32_MAX;

  00009	83 c8 ff	 or	 eax, -1
  0000c	eb 0a		 jmp	 SHORT $LN2@lzma_check@2
$LN1@lzma_check@2:

; 70   : 
; 71   : 	// See file-format.txt section 2.1.1.2.
; 72   :   {
; 73   : 	static const uint8_t check_sizes[LZMA_CHECK_ID_MAX + 1] = {
; 74   : 		0,
; 75   : 		4, 4, 4,
; 76   : 		8, 8, 8,
; 77   : 		16, 16, 16,
; 78   : 		32, 32, 32,
; 79   : 		64, 64, 64
; 80   : 	};
; 81   : 
; 82   : 	return check_sizes[(unsigned int)(type)];

  0000e	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00011	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR ?check_sizes@?2??lzma_check_size@@9@9[eax]
$LN2@lzma_check@2:

; 83   :   }
; 84   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_lzma_check_size ENDP
_TEXT	ENDS
PUBLIC	_lzma_check_is_supported
; Function compile flags: /Odtp
;	COMDAT _lzma_check_is_supported
_TEXT	SEGMENT
_type$ = 8						; size = 4
_lzma_check_is_supported PROC				; COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)

  00003	83 7d 08 0f	 cmp	 DWORD PTR _type$[ebp], 15 ; 0000000fH
  00007	76 04		 jbe	 SHORT $LN1@lzma_check@3

; 20   : 		return false;

  00009	32 c0		 xor	 al, al
  0000b	eb 09		 jmp	 SHORT $LN2@lzma_check@3
$LN1@lzma_check@3:

; 21   : 
; 22   :   {
; 23   : 	static const lzma_bool available_checks[LZMA_CHECK_ID_MAX + 1] = {
; 24   : 		true,   // LZMA_CHECK_NONE
; 25   : 
; 26   : #ifdef HAVE_CHECK_CRC32
; 27   : 		true,
; 28   : #else
; 29   : 		false,
; 30   : #endif
; 31   : 
; 32   : 		false,  // Reserved
; 33   : 		false,  // Reserved
; 34   : 
; 35   : #ifdef HAVE_CHECK_CRC64
; 36   : 		true,
; 37   : #else
; 38   : 		false,
; 39   : #endif
; 40   : 
; 41   : 		false,  // Reserved
; 42   : 		false,  // Reserved
; 43   : 		false,  // Reserved
; 44   : 		false,  // Reserved
; 45   : 		false,  // Reserved
; 46   : 
; 47   : #ifdef HAVE_CHECK_SHA256
; 48   : 		true,
; 49   : #else
; 50   : 		false,
; 51   : #endif
; 52   : 
; 53   : 		false,  // Reserved
; 54   : 		false,  // Reserved
; 55   : 		false,  // Reserved
; 56   : 		false,  // Reserved
; 57   : 		false,  // Reserved
; 58   : 	};
; 59   : 
; 60   : 	return available_checks[(unsigned int)(type)];

  0000d	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00010	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?available_checks@?2??lzma_check_is_supported@@9@9[eax]
$LN2@lzma_check@3:

; 61   :   }
; 62   : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_lzma_check_is_supported ENDP
PUBLIC	_lzma_check_finish
; Function compile flags: /Odtp
;	COMDAT _lzma_check_finish
_TEXT	SEGMENT
tv64 = -4						; size = 4
_check$ = 8						; size = 4
_type$ = 12						; size = 4
_lzma_check_finish PROC					; COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 154  : 	switch (type) {

  00004	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  0000e	74 0e		 je	 SHORT $LN4@lzma_check@4
  00010	83 7d fc 04	 cmp	 DWORD PTR tv64[ebp], 4
  00014	74 15		 je	 SHORT $LN3@lzma_check@4
  00016	83 7d fc 0a	 cmp	 DWORD PTR tv64[ebp], 10	; 0000000aH
  0001a	74 22		 je	 SHORT $LN2@lzma_check@4
  0001c	eb 2c		 jmp	 SHORT $LN7@lzma_check@4
$LN4@lzma_check@4:

; 155  : #ifdef HAVE_CHECK_CRC32
; 156  : 	case LZMA_CHECK_CRC32:
; 157  : 		check->buffer.u32[0] = conv32le(check->state.crc32);

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _check$[ebp]
  00021	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  00024	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00027	89 01		 mov	 DWORD PTR [ecx], eax

; 158  : 		break;

  00029	eb 1f		 jmp	 SHORT $LN7@lzma_check@4
$LN3@lzma_check@4:

; 159  : #endif
; 160  : 
; 161  : #ifdef HAVE_CHECK_CRC64
; 162  : 	case LZMA_CHECK_CRC64:
; 163  : 		check->buffer.u64[0] = conv64le(check->state.crc64);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _check$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  00031	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00034	89 01		 mov	 DWORD PTR [ecx], eax
  00036	8b 52 44	 mov	 edx, DWORD PTR [edx+68]
  00039	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		break;

  0003c	eb 0c		 jmp	 SHORT $LN7@lzma_check@4
$LN2@lzma_check@4:

; 165  : #endif
; 166  : 
; 167  : #ifdef HAVE_CHECK_SHA256
; 168  : 	case LZMA_CHECK_SHA256:
; 169  : 		lzma_sha256_finish(check);

  0003e	8b 45 08	 mov	 eax, DWORD PTR _check$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _lzma_sha256_finish
  00047	83 c4 04	 add	 esp, 4
$LN7@lzma_check@4:

; 170  : 		break;
; 171  : #endif
; 172  : 
; 173  : 	default:
; 174  : 		break;
; 175  : 	}
; 176  : 
; 177  : 	return;
; 178  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_lzma_check_finish ENDP
_TEXT	ENDS
PUBLIC	_lzma_check_update
; Function compile flags: /Odtp
;	COMDAT _lzma_check_update
_TEXT	SEGMENT
tv64 = -4						; size = 4
_check$ = 8						; size = 4
_type$ = 12						; size = 4
_buf$ = 16						; size = 4
_size$ = 20						; size = 4
_lzma_check_update PROC					; COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 124  : 	switch (type) {

  00004	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  0000e	74 0e		 je	 SHORT $LN4@lzma_check@5
  00010	83 7d fc 04	 cmp	 DWORD PTR tv64[ebp], 4
  00014	74 27		 je	 SHORT $LN3@lzma_check@5
  00016	83 7d fc 0a	 cmp	 DWORD PTR tv64[ebp], 10	; 0000000aH
  0001a	74 47		 je	 SHORT $LN2@lzma_check@5
  0001c	eb 59		 jmp	 SHORT $LN7@lzma_check@5
$LN4@lzma_check@5:

; 125  : #ifdef HAVE_CHECK_CRC32
; 126  : 	case LZMA_CHECK_CRC32:
; 127  : 		check->state.crc32 = lzma_crc32(buf, size, check->state.crc32);

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _check$[ebp]
  00021	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00024	52		 push	 edx
  00025	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _lzma_crc32
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  00038	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 128  : 		break;

  0003b	eb 3a		 jmp	 SHORT $LN7@lzma_check@5
$LN3@lzma_check@5:

; 129  : #endif
; 130  : 
; 131  : #ifdef HAVE_CHECK_CRC64
; 132  : 	case LZMA_CHECK_CRC64:
; 133  : 		check->state.crc64 = lzma_crc64(buf, size, check->state.crc64);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _check$[ebp]
  00040	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00043	51		 push	 ecx
  00044	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00047	52		 push	 edx
  00048	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _lzma_crc64
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _check$[ebp]
  0005b	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  0005e	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 134  : 		break;

  00061	eb 14		 jmp	 SHORT $LN7@lzma_check@5
$LN2@lzma_check@5:

; 135  : #endif
; 136  : 
; 137  : #ifdef HAVE_CHECK_SHA256
; 138  : 	case LZMA_CHECK_SHA256:
; 139  : 		lzma_sha256_update(buf, size, check);

  00063	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  00066	52		 push	 edx
  00067	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _lzma_sha256_update
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@lzma_check@5:

; 140  : 		break;
; 141  : #endif
; 142  : 
; 143  : 	default:
; 144  : 		break;
; 145  : 	}
; 146  : 
; 147  : 	return;
; 148  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_lzma_check_update ENDP
END
