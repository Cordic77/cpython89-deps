; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\sparc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_sparc_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\sparc.c
;	COMDAT _sparc_code
_TEXT	SEGMENT
_dest$32374 = -12					; size = 4
_src$32369 = -8						; size = 4
_i$ = -4						; size = 4
_simple$ = 8						; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_sparc_code PROC					; COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 4) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN8@sparc_code
$LN7@sparc_code:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN8@sparc_code:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp]
  00021	0f 87 20 01 00
	00		 ja	 $LN6@sparc_code

; 24   : 
; 25   : 		if ((buffer[i] == 0x40 && (buffer[i + 1] & 0xC0) == 0x00)
; 26   : 				|| (buffer[i] == 0x7F
; 27   : 				&& (buffer[i + 1] & 0xC0) == 0xC0)) {

  00027	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002a	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00030	83 f8 40	 cmp	 eax, 64			; 00000040H
  00033	75 12		 jne	 SHORT $LN3@sparc_code
  00035	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00038	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0003b	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0003f	81 e2 c0 00 00
	00		 and	 edx, 192		; 000000c0H
  00045	74 2c		 je	 SHORT $LN4@sparc_code
$LN3@sparc_code:
  00047	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004a	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00050	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00053	0f 85 e9 00 00
	00		 jne	 $LN5@sparc_code
  00059	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0005c	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0005f	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00063	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00068	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0006d	0f 85 cf 00 00
	00		 jne	 $LN5@sparc_code
$LN4@sparc_code:

; 28   : 
; 29   : 			uint32_t src = ((uint32_t)buffer[i + 0] << 24)
; 30   : 					| ((uint32_t)buffer[i + 1] << 16)
; 31   : 					| ((uint32_t)buffer[i + 2] << 8)
; 32   : 					| ((uint32_t)buffer[i + 3]);

  00073	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00076	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00079	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0007c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0007f	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00082	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00085	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00089	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0008c	0b d1		 or	 edx, ecx
  0008e	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00091	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00094	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00098	c1 e1 08	 shl	 ecx, 8
  0009b	0b d1		 or	 edx, ecx
  0009d	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  000a0	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000a3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000a7	0b d1		 or	 edx, ecx
  000a9	89 55 f8	 mov	 DWORD PTR _src$32369[ebp], edx

; 33   : 
; 34   : 			src <<= 2;

  000ac	8b 55 f8	 mov	 edx, DWORD PTR _src$32369[ebp]
  000af	c1 e2 02	 shl	 edx, 2
  000b2	89 55 f8	 mov	 DWORD PTR _src$32369[ebp], edx

; 35   : 
; 36   :           {
; 37   : 			uint32_t dest;
; 38   : 			if (is_encoder)

  000b5	0f b6 45 10	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	74 0e		 je	 SHORT $LN2@sparc_code

; 39   : 				dest = now_pos + (uint32_t)(i) + src;

  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _now_pos$[ebp]
  000c0	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000c3	03 4d f8	 add	 ecx, DWORD PTR _src$32369[ebp]
  000c6	89 4d f4	 mov	 DWORD PTR _dest$32374[ebp], ecx

; 40   : 			else

  000c9	eb 0e		 jmp	 SHORT $LN1@sparc_code
$LN2@sparc_code:

; 41   : 				dest = src - (now_pos + (uint32_t)(i));

  000cb	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  000ce	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _src$32369[ebp]
  000d4	2b c2		 sub	 eax, edx
  000d6	89 45 f4	 mov	 DWORD PTR _dest$32374[ebp], eax
$LN1@sparc_code:

; 42   : 
; 43   : 			dest >>= 2;

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _dest$32374[ebp]
  000dc	c1 e9 02	 shr	 ecx, 2
  000df	89 4d f4	 mov	 DWORD PTR _dest$32374[ebp], ecx

; 44   : 
; 45   : 			dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF)
; 46   : 					| (dest & 0x3FFFFF)
; 47   : 					| 0x40000000;

  000e2	8b 55 f4	 mov	 edx, DWORD PTR _dest$32374[ebp]
  000e5	c1 ea 16	 shr	 edx, 22			; 00000016H
  000e8	83 e2 01	 and	 edx, 1
  000eb	33 c0		 xor	 eax, eax
  000ed	2b c2		 sub	 eax, edx
  000ef	c1 e0 16	 shl	 eax, 22			; 00000016H
  000f2	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _dest$32374[ebp]
  000fa	81 e1 ff ff 3f
	00		 and	 ecx, 4194303		; 003fffffH
  00100	0b c1		 or	 eax, ecx
  00102	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00107	89 45 f4	 mov	 DWORD PTR _dest$32374[ebp], eax

; 48   : 
; 49   : 			buffer[i + 0] = (uint8_t)(dest >> 24);

  0010a	8b 55 f4	 mov	 edx, DWORD PTR _dest$32374[ebp]
  0010d	c1 ea 18	 shr	 edx, 24			; 00000018H
  00110	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00113	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00116	88 10		 mov	 BYTE PTR [eax], dl

; 50   : 			buffer[i + 1] = (uint8_t)(dest >> 16);

  00118	8b 4d f4	 mov	 ecx, DWORD PTR _dest$32374[ebp]
  0011b	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0011e	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00121	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00124	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 51   : 			buffer[i + 2] = (uint8_t)(dest >> 8);

  00127	8b 45 f4	 mov	 eax, DWORD PTR _dest$32374[ebp]
  0012a	c1 e8 08	 shr	 eax, 8
  0012d	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00130	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00133	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 52   : 			buffer[i + 3] = (uint8_t)(dest);

  00136	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00139	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0013c	8a 45 f4	 mov	 al, BYTE PTR _dest$32374[ebp]
  0013f	88 42 03	 mov	 BYTE PTR [edx+3], al
$LN5@sparc_code:

; 53   : 		  }
; 54   : 		}
; 55   : 	}

  00142	e9 c8 fe ff ff	 jmp	 $LN7@sparc_code
$LN6@sparc_code:

; 56   : 
; 57   : 	return i;

  00147	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 58   : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
_sparc_code ENDP
; Function compile flags: /Odtp
;	COMDAT _sparc_coder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_sparc_coder_init PROC					; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   : 	return lzma_simple_coder_init(next, allocator, filters,
; 66   : 			&sparc_code, 0, 4, 4, is_encoder);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00007	50		 push	 eax
  00008	6a 04		 push	 4
  0000a	6a 04		 push	 4
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _sparc_code
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 67   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_sparc_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_sparc_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_sparc_decoder_init PROC			; COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 84   : 	return sparc_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _sparc_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 85   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_sparc_decoder_init ENDP
END
