; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\stream_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

	ORG $+2
?convert@?7??stream_encode@@9@9 DD 00H			; `stream_encode'::`8'::convert
	DD	01H
	DD	03H
	DD	03H
	DD	03H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder.c
;	COMDAT _stream_encoder_end
_TEXT	SEGMENT
tv130 = -16						; size = 4
tv129 = -12						; size = 4
_i$32336 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_stream_encoder_end PROC				; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 227  : 	lzma_stream_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 228  : 
; 229  : 	lzma_next_end(&coder->block_encoder, allocator);

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00014	83 c2 08	 add	 edx, 8
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _lzma_next_end
  0001d	83 c4 08	 add	 esp, 8

; 230  : 	lzma_next_end(&coder->index_encoder, allocator);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00027	81 c1 48 01 00
	00		 add	 ecx, 328		; 00000148H
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _lzma_next_end
  00033	83 c4 08	 add	 esp, 8

; 231  : 	lzma_index_end(coder->index, allocator);

  00036	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0003d	8b 88 78 01 00
	00		 mov	 ecx, DWORD PTR [eax+376]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _lzma_index_end
  00049	83 c4 08	 add	 esp, 8

; 232  :   {
; 233  :   size_t i;
; 234  : 
; 235  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$32336[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN3@stream_enc
$LN2@stream_enc:
  00055	8b 55 f8	 mov	 edx, DWORD PTR _i$32336[ebp]
  00058	83 c2 01	 add	 edx, 1
  0005b	89 55 f8	 mov	 DWORD PTR _i$32336[ebp], edx
$LN3@stream_enc:
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _i$32336[ebp]
  00061	c1 e0 04	 shl	 eax, 4
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00067	89 4d f4	 mov	 DWORD PTR tv129[ebp], ecx
  0006a	89 45 f0	 mov	 DWORD PTR tv130[ebp], eax
  0006d	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00070	8b 45 f4	 mov	 eax, DWORD PTR tv129[ebp]
  00073	8b 4d f0	 mov	 ecx, DWORD PTR tv130[ebp]
  00076	8b 75 f4	 mov	 esi, DWORD PTR tv129[ebp]
  00079	8b 94 10 f8 00
	00 00		 mov	 edx, DWORD PTR [eax+edx+248]
  00080	23 94 0e fc 00
	00 00		 and	 edx, DWORD PTR [esi+ecx+252]
  00087	83 fa ff	 cmp	 edx, -1
  0008a	74 1f		 je	 SHORT $LN1@stream_enc

; 236  : 		lzma_free(coder->filters[i].options, allocator);

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _i$32336[ebp]
  00093	c1 e1 04	 shl	 ecx, 4
  00096	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00099	8b 84 0a 00 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx+256]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _lzma_free
  000a6	83 c4 08	 add	 esp, 8
  000a9	eb aa		 jmp	 SHORT $LN2@stream_enc
$LN1@stream_enc:

; 237  :   }
; 238  : 
; 239  : 	lzma_free(coder, allocator);

  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  000ae	51		 push	 ecx
  000af	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 _lzma_free
  000b8	83 c4 08	 add	 esp, 8

; 240  : 	return;
; 241  : }

  000bb	5e		 pop	 esi
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_stream_encoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _block_encoder_init
_TEXT	SEGMENT
_ret_$32258 = -4					; size = 4
_coder$ = 8						; size = 4
_allocator$ = 12					; size = 4
_block_encoder_init PROC				; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 64   : 	// Prepare the Block options. Even though Block encoder doesn't need
; 65   : 	// compressed_size, uncompressed_size, and header_size to be
; 66   : 	// initialized, it is a good idea to do it here, because this way
; 67   : 	// we catch if someone gave us Filter ID that cannot be used in
; 68   : 	// Blocks/Streams.
; 69   : 	coder->block_options.compressed_size = LZMA_VLI_UNKNOWN;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00007	c7 40 48 ff ff
	ff ff		 mov	 DWORD PTR [eax+72], -1
  0000e	c7 40 4c ff ff
	ff ff		 mov	 DWORD PTR [eax+76], -1

; 70   : 	coder->block_options.uncompressed_size = LZMA_VLI_UNKNOWN;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00018	c7 41 50 ff ff
	ff ff		 mov	 DWORD PTR [ecx+80], -1
  0001f	c7 41 54 ff ff
	ff ff		 mov	 DWORD PTR [ecx+84], -1
$LN4@block_enco@5:

; 71   : 
; 72   : 	return_if_error(lzma_block_header_size(&coder->block_options));

  00026	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00029	83 c2 38	 add	 edx, 56			; 00000038H
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _lzma_block_header_size
  00032	83 c4 04	 add	 esp, 4
  00035	89 45 fc	 mov	 DWORD PTR _ret_$32258[ebp], eax
  00038	83 7d fc 00	 cmp	 DWORD PTR _ret_$32258[ebp], 0
  0003c	74 05		 je	 SHORT $LN3@block_enco@5
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32258[ebp]
  00041	eb 1e		 jmp	 SHORT $LN5@block_enco@5
$LN3@block_enco@5:
  00043	33 c0		 xor	 eax, eax
  00045	75 df		 jne	 SHORT $LN4@block_enco@5

; 73   : 
; 74   : 	// Initialize the actual Block encoder.
; 75   : 	return lzma_block_encoder_init(&coder->block_encoder, allocator,
; 76   : 			&coder->block_options);

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0004a	83 c1 38	 add	 ecx, 56			; 00000038H
  0004d	51		 push	 ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00051	52		 push	 edx
  00052	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00055	83 c0 08	 add	 eax, 8
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _lzma_block_encoder_init
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@block_enco@5:

; 77   : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_block_encoder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_encoder_update
_TEXT	SEGMENT
tv160 = -24						; size = 4
tv159 = -20						; size = 4
_i$32363 = -16						; size = 4
_ret_$32360 = -12					; size = 4
_ret$32353 = -8						; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_reversed_filters$ = 20					; size = 4
_stream_encoder_update PROC				; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 249  : 	lzma_stream_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 250  : 
; 251  : 	if (coder->sequence <= SEQ_BLOCK_INIT) {

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00010	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00013	7f 49		 jg	 SHORT $LN12@stream_enc@3

; 252  : 		// There is no incomplete Block waiting to be finished,
; 253  : 		// thus we can change the whole filter chain. Start by
; 254  : 		// trying to initialize the Block encoder with the new
; 255  : 		// chain. This way we detect if the chain is valid.
; 256  : 		coder->block_encoder_is_initialized = false;

  00015	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00018	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 257  : 		coder->block_options.filters = (lzma_filter *)(filters);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00022	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 258  :     {
; 259  : 		const lzma_ret ret = block_encoder_init(coder, allocator);

  00025	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00028	52		 push	 edx
  00029	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _block_encoder_init
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 f8	 mov	 DWORD PTR _ret$32353[ebp], eax

; 260  : 		coder->block_options.filters = coder->filters;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003b	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  00041	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00044	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 261  : 		if (ret != LZMA_OK)

  00047	83 7d f8 00	 cmp	 DWORD PTR _ret$32353[ebp], 0
  0004b	74 08		 je	 SHORT $LN11@stream_enc@3

; 262  : 			return ret;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _ret$32353[ebp]
  00050	e9 c6 00 00 00	 jmp	 $LN13@stream_enc@3
$LN11@stream_enc@3:

; 263  :     }
; 264  : 
; 265  : 		coder->block_encoder_is_initialized = true;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00058	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  0005c	eb 44		 jmp	 SHORT $LN10@stream_enc@3
$LN12@stream_enc@3:

; 266  : 
; 267  : 	} else if (coder->sequence <= SEQ_BLOCK_ENCODE) {

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00061	83 39 03	 cmp	 DWORD PTR [ecx], 3
  00064	7f 35		 jg	 SHORT $LN9@stream_enc@3
$LN8@stream_enc@3:

; 268  : 		// We are in the middle of a Block. Try to update only
; 269  : 		// the filter-specific options.
; 270  : 		return_if_error(coder->block_encoder.update(
; 271  : 				coder->block_encoder.coder, allocator,
; 272  : 				filters, reversed_filters));

  00066	8b 55 14	 mov	 edx, DWORD PTR _reversed_filters$[ebp]
  00069	52		 push	 edx
  0006a	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00075	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0007c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0007f	ff d2		 call	 edx
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	89 45 f4	 mov	 DWORD PTR _ret_$32360[ebp], eax
  00087	83 7d f4 00	 cmp	 DWORD PTR _ret_$32360[ebp], 0
  0008b	74 08		 je	 SHORT $LN7@stream_enc@3
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32360[ebp]
  00090	e9 86 00 00 00	 jmp	 $LN13@stream_enc@3
$LN7@stream_enc@3:
  00095	33 c0		 xor	 eax, eax
  00097	75 cd		 jne	 SHORT $LN8@stream_enc@3

; 273  : 	} else {

  00099	eb 07		 jmp	 SHORT $LN10@stream_enc@3
$LN9@stream_enc@3:

; 274  : 		// Trying to update the filter chain when we are already
; 275  : 		// encoding Index or Stream Footer.
; 276  : 		return LZMA_PROG_ERROR;

  0009b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000a0	eb 79		 jmp	 SHORT $LN13@stream_enc@3
$LN10@stream_enc@3:

; 277  : 	}
; 278  : 
; 279  : 	// Free the copy of the old chain and make a copy of the new chain.
; 280  :   { size_t i;
; 281  : 
; 282  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  000a2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$32363[ebp], 0
  000a9	eb 09		 jmp	 SHORT $LN3@stream_enc@3
$LN2@stream_enc@3:
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR _i$32363[ebp]
  000ae	83 c1 01	 add	 ecx, 1
  000b1	89 4d f0	 mov	 DWORD PTR _i$32363[ebp], ecx
$LN3@stream_enc@3:
  000b4	8b 55 f0	 mov	 edx, DWORD PTR _i$32363[ebp]
  000b7	c1 e2 04	 shl	 edx, 4
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000bd	89 45 ec	 mov	 DWORD PTR tv159[ebp], eax
  000c0	89 55 e8	 mov	 DWORD PTR tv160[ebp], edx
  000c3	8b 4d e8	 mov	 ecx, DWORD PTR tv160[ebp]
  000c6	8b 55 ec	 mov	 edx, DWORD PTR tv159[ebp]
  000c9	8b 45 e8	 mov	 eax, DWORD PTR tv160[ebp]
  000cc	8b 75 ec	 mov	 esi, DWORD PTR tv159[ebp]
  000cf	8b 8c 0a f8 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+248]
  000d6	23 8c 06 fc 00
	00 00		 and	 ecx, DWORD PTR [esi+eax+252]
  000dd	83 f9 ff	 cmp	 ecx, -1
  000e0	74 1f		 je	 SHORT $LN1@stream_enc@3

; 283  : 		lzma_free(coder->filters[i].options, allocator);

  000e2	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000e5	52		 push	 edx
  000e6	8b 45 f0	 mov	 eax, DWORD PTR _i$32363[ebp]
  000e9	c1 e0 04	 shl	 eax, 4
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  000ef	8b 94 01 00 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+256]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _lzma_free
  000fc	83 c4 08	 add	 esp, 8
  000ff	eb aa		 jmp	 SHORT $LN2@stream_enc@3
$LN1@stream_enc@3:

; 284  :   }
; 285  : 
; 286  : 	return lzma_filters_copy(filters, coder->filters, allocator);

  00101	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00104	50		 push	 eax
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00108	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  0010e	51		 push	 ecx
  0010f	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 _lzma_filters_copy
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@stream_enc@3:

; 287  : }

  0011b	5e		 pop	 esi
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
_stream_encoder_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _stream_encode
_TEXT	SEGMENT
tv65 = -92						; size = 4
_stream_flags$32325 = -88				; size = 56
_ret$32321 = -32					; size = 4
_ret_$32318 = -28					; size = 4
_unpadded_size$32313 = -24				; size = 8
_ret$32310 = -16					; size = 4
_ret_$32303 = -12					; size = 4
_ret_$32297 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_stream_encode PROC					; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 86   : 	lzma_stream_coder *coder = coder_ptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax
$LN31@stream_enc@4:

; 87   : 
; 88   : 	// Main loop
; 89   : 	while (*out_pos < out_size)

  0000c	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	3b 55 24	 cmp	 edx, DWORD PTR _out_size$[ebp]
  00014	0f 83 e0 02 00
	00		 jae	 $LN30@stream_enc@4

; 90   : 	switch (coder->sequence) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d a4	 mov	 DWORD PTR tv65[ebp], ecx
  00022	83 7d a4 05	 cmp	 DWORD PTR tv65[ebp], 5
  00026	0f 87 c2 02 00
	00		 ja	 $LN1@stream_enc@4
  0002c	8b 55 a4	 mov	 edx, DWORD PTR tv65[ebp]
  0002f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN34@stream_enc@4[edx*4]
$LN27@stream_enc@4:

; 91   : 	case SEQ_STREAM_HEADER:
; 92   : 	case SEQ_BLOCK_HEADER:
; 93   : 	case SEQ_STREAM_FOOTER:
; 94   : 		lzma_bufcpy(coder->buffer, &coder->buffer_pos,
; 95   : 				coder->buffer_size, out, out_pos, out_size);

  00036	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  00041	52		 push	 edx
  00042	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00045	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  0004b	51		 push	 ecx
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0004f	81 c2 7c 01 00
	00		 add	 edx, 380		; 0000017cH
  00055	52		 push	 edx
  00056	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00059	05 84 01 00 00	 add	 eax, 388		; 00000184H
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _lzma_bufcpy
  00064	83 c4 18	 add	 esp, 24			; 00000018H

; 96   : 		if (coder->buffer_pos < coder->buffer_size)

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0006d	8b 81 7c 01 00
	00		 mov	 eax, DWORD PTR [ecx+380]
  00073	3b 82 80 01 00
	00		 cmp	 eax, DWORD PTR [edx+384]
  00079	73 07		 jae	 SHORT $LN26@stream_enc@4

; 97   : 			return LZMA_OK;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 7a 02 00 00	 jmp	 $LN32@stream_enc@4
$LN26@stream_enc@4:

; 98   : 
; 99   : 		if (coder->sequence == SEQ_STREAM_FOOTER)

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00085	83 39 05	 cmp	 DWORD PTR [ecx], 5
  00088	75 0a		 jne	 SHORT $LN25@stream_enc@4

; 100  : 			return LZMA_STREAM_END;

  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	e9 68 02 00 00	 jmp	 $LN32@stream_enc@4
$LN25@stream_enc@4:

; 101  : 
; 102  : 		coder->buffer_pos = 0;

  00094	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00097	c7 82 7c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+380], 0

; 103  : 		++coder->sequence;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	83 c1 01	 add	 ecx, 1
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000ac	89 0a		 mov	 DWORD PTR [edx], ecx

; 104  : 		break;

  000ae	e9 42 02 00 00	 jmp	 $LN28@stream_enc@4
$LN24@stream_enc@4:

; 105  : 
; 106  : 	case SEQ_BLOCK_INIT: {
; 107  : 		if (*in_pos == in_size) {

  000b3	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	3b 4d 18	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  000bb	75 57		 jne	 SHORT $LN23@stream_enc@4

; 108  : 			// If we are requested to flush or finish the current
; 109  : 			// Block, return LZMA_STREAM_END immediately since
; 110  : 			// there's nothing to do.
; 111  : 			if (action != LZMA_FINISH)

  000bd	83 7d 28 03	 cmp	 DWORD PTR _action$[ebp], 3
  000c1	74 0e		 je	 SHORT $LN21@stream_enc@4

; 112  : 				return action == LZMA_RUN
; 113  : 						? LZMA_OK : LZMA_STREAM_END;

  000c3	33 c0		 xor	 eax, eax
  000c5	83 7d 28 00	 cmp	 DWORD PTR _action$[ebp], 0
  000c9	0f 95 c0	 setne	 al
  000cc	e9 2b 02 00 00	 jmp	 $LN32@stream_enc@4
$LN21@stream_enc@4:

; 114  : 
; 115  : 			// The application had used LZMA_FULL_FLUSH to finish
; 116  : 			// the previous Block, but now wants to finish without
; 117  : 			// encoding new data, or it is simply creating an
; 118  : 			// empty Stream with no Blocks.
; 119  : 			//
; 120  : 			// Initialize the Index encoder, and continue to
; 121  : 			// actually encoding the Index.
; 122  : 			return_if_error(lzma_index_encoder_init(
; 123  : 					&coder->index_encoder, allocator,
; 124  : 					coder->index));

  000d1	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000d4	8b 82 78 01 00
	00		 mov	 eax, DWORD PTR [edx+376]
  000da	50		 push	 eax
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  000de	51		 push	 ecx
  000df	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000e2	81 c2 48 01 00
	00		 add	 edx, 328		; 00000148H
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _lzma_index_encoder_init
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f1	89 45 f8	 mov	 DWORD PTR _ret_$32297[ebp], eax
  000f4	83 7d f8 00	 cmp	 DWORD PTR _ret_$32297[ebp], 0
  000f8	74 08		 je	 SHORT $LN20@stream_enc@4
  000fa	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32297[ebp]
  000fd	e9 fa 01 00 00	 jmp	 $LN32@stream_enc@4
$LN20@stream_enc@4:
  00102	33 c0		 xor	 eax, eax
  00104	75 cb		 jne	 SHORT $LN21@stream_enc@4

; 125  : 			coder->sequence = SEQ_INDEX_ENCODE;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00109	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 126  : 			break;

  0010f	e9 e1 01 00 00	 jmp	 $LN28@stream_enc@4
$LN23@stream_enc@4:

; 127  : 		}
; 128  : 
; 129  : 		// Initialize the Block encoder unless it was already
; 130  : 		// initialized by stream_encoder_init() or
; 131  : 		// stream_encoder_update().
; 132  : 		if (!coder->block_encoder_is_initialized)

  00114	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00117	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0011b	85 c0		 test	 eax, eax
  0011d	75 25		 jne	 SHORT $LN17@stream_enc@4
$LN16@stream_enc@4:

; 133  : 			return_if_error(block_encoder_init(coder, allocator));

  0011f	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00122	51		 push	 ecx
  00123	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 _block_encoder_init
  0012c	83 c4 08	 add	 esp, 8
  0012f	89 45 f4	 mov	 DWORD PTR _ret_$32303[ebp], eax
  00132	83 7d f4 00	 cmp	 DWORD PTR _ret_$32303[ebp], 0
  00136	74 08		 je	 SHORT $LN15@stream_enc@4
  00138	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32303[ebp]
  0013b	e9 bc 01 00 00	 jmp	 $LN32@stream_enc@4
$LN15@stream_enc@4:
  00140	33 c0		 xor	 eax, eax
  00142	75 db		 jne	 SHORT $LN16@stream_enc@4
$LN17@stream_enc@4:

; 134  : 
; 135  : 		// Make it false so that we don't skip the initialization
; 136  : 		// with the next Block.
; 137  : 		coder->block_encoder_is_initialized = false;

  00144	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00147	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 138  : 
; 139  : 		// Encode the Block Header. This shouldn't fail since we have
; 140  : 		// already initialized the Block encoder.
; 141  : 		if (lzma_block_header_encode(&coder->block_options,
; 142  : 				coder->buffer) != LZMA_OK)

  0014b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0014e	81 c2 84 01 00
	00		 add	 edx, 388		; 00000184H
  00154	52		 push	 edx
  00155	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00158	83 c0 38	 add	 eax, 56			; 00000038H
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _lzma_block_header_encode
  00161	83 c4 08	 add	 esp, 8
  00164	85 c0		 test	 eax, eax
  00166	74 0a		 je	 SHORT $LN12@stream_enc@4

; 143  : 			return LZMA_PROG_ERROR;

  00168	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0016d	e9 8a 01 00 00	 jmp	 $LN32@stream_enc@4
$LN12@stream_enc@4:

; 144  : 
; 145  : 		coder->buffer_size = coder->block_options.header_size;

  00172	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00175	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00178	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0017b	89 81 80 01 00
	00		 mov	 DWORD PTR [ecx+384], eax

; 146  : 		coder->sequence = SEQ_BLOCK_HEADER;

  00181	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00184	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 147  : 		break;

  0018a	e9 66 01 00 00	 jmp	 $LN28@stream_enc@4
$LN11@stream_enc@4:

; 148  : 	}
; 149  : 
; 150  : 	case SEQ_BLOCK_ENCODE: {
; 151  : 		static const lzma_action convert[LZMA_ACTION_MAX + 1] = {
; 152  : 			LZMA_RUN,
; 153  : 			LZMA_SYNC_FLUSH,
; 154  : 			LZMA_FINISH,
; 155  : 			LZMA_FINISH,
; 156  : 			LZMA_FINISH,
; 157  : 		};
; 158  : 
; 159  : 		const lzma_ret ret = coder->block_encoder.code(
; 160  : 				coder->block_encoder.coder, allocator,
; 161  : 				in, in_pos, in_size,
; 162  : 				out, out_pos, out_size, convert[action]);

  0018f	8b 55 28	 mov	 edx, DWORD PTR _action$[ebp]
  00192	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?convert@?7??stream_encode@@9@9[edx*4]
  00199	50		 push	 eax
  0019a	8b 4d 24	 mov	 ecx, DWORD PTR _out_size$[ebp]
  0019d	51		 push	 ecx
  0019e	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  001a1	52		 push	 edx
  001a2	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  001a5	50		 push	 eax
  001a6	8b 4d 18	 mov	 ecx, DWORD PTR _in_size$[ebp]
  001a9	51		 push	 ecx
  001aa	8b 55 14	 mov	 edx, DWORD PTR _in_pos$[ebp]
  001ad	52		 push	 edx
  001ae	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  001b1	50		 push	 eax
  001b2	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  001b5	51		 push	 ecx
  001b6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  001b9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001bc	50		 push	 eax
  001bd	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001c0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  001c3	ff d2		 call	 edx
  001c5	83 c4 24	 add	 esp, 36			; 00000024H
  001c8	89 45 f0	 mov	 DWORD PTR _ret$32310[ebp], eax

; 163  : 		if (ret != LZMA_STREAM_END || action == LZMA_SYNC_FLUSH)

  001cb	83 7d f0 01	 cmp	 DWORD PTR _ret$32310[ebp], 1
  001cf	75 06		 jne	 SHORT $LN9@stream_enc@4
  001d1	83 7d 28 01	 cmp	 DWORD PTR _action$[ebp], 1
  001d5	75 08		 jne	 SHORT $LN10@stream_enc@4
$LN9@stream_enc@4:

; 164  : 			return ret;

  001d7	8b 45 f0	 mov	 eax, DWORD PTR _ret$32310[ebp]
  001da	e9 1d 01 00 00	 jmp	 $LN32@stream_enc@4
$LN10@stream_enc@4:

; 165  : 
; 166  : 		// Add a new Index Record.
; 167  : 	  {
; 168  : 		const lzma_vli unpadded_size = lzma_block_unpadded_size(
; 169  : 				&coder->block_options);

  001df	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001e2	83 c0 38	 add	 eax, 56			; 00000038H
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  001eb	83 c4 04	 add	 esp, 4
  001ee	89 45 e8	 mov	 DWORD PTR _unpadded_size$32313[ebp], eax
  001f1	89 55 ec	 mov	 DWORD PTR _unpadded_size$32313[ebp+4], edx
$LN8@stream_enc@4:

; 170  : 		assert(unpadded_size != 0);
; 171  : 		return_if_error(lzma_index_append(coder->index, allocator,
; 172  : 				unpadded_size,
; 173  : 				coder->block_options.uncompressed_size));

  001f4	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001f7	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  001fa	52		 push	 edx
  001fb	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  001fe	50		 push	 eax
  001ff	8b 4d ec	 mov	 ecx, DWORD PTR _unpadded_size$32313[ebp+4]
  00202	51		 push	 ecx
  00203	8b 55 e8	 mov	 edx, DWORD PTR _unpadded_size$32313[ebp]
  00206	52		 push	 edx
  00207	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0020a	50		 push	 eax
  0020b	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0020e	8b 91 78 01 00
	00		 mov	 edx, DWORD PTR [ecx+376]
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 _lzma_index_append
  0021a	83 c4 18	 add	 esp, 24			; 00000018H
  0021d	89 45 e4	 mov	 DWORD PTR _ret_$32318[ebp], eax
  00220	83 7d e4 00	 cmp	 DWORD PTR _ret_$32318[ebp], 0
  00224	74 08		 je	 SHORT $LN7@stream_enc@4
  00226	8b 45 e4	 mov	 eax, DWORD PTR _ret_$32318[ebp]
  00229	e9 ce 00 00 00	 jmp	 $LN32@stream_enc@4
$LN7@stream_enc@4:
  0022e	33 c0		 xor	 eax, eax
  00230	75 c2		 jne	 SHORT $LN8@stream_enc@4

; 174  : 	  }
; 175  : 
; 176  : 		coder->sequence = SEQ_BLOCK_INIT;

  00232	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00235	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 177  : 		break;

  0023b	e9 b5 00 00 00	 jmp	 $LN28@stream_enc@4
$LN4@stream_enc@4:

; 178  : 	}
; 179  : 
; 180  : 	case SEQ_INDEX_ENCODE: {
; 181  : 		// Call the Index encoder. It doesn't take any input, so
; 182  : 		// those pointers can be NULL.
; 183  : 		const lzma_ret ret = coder->index_encoder.code(
; 184  : 				coder->index_encoder.coder, allocator,
; 185  : 				NULL, NULL, 0,
; 186  : 				out, out_pos, out_size, LZMA_RUN);

  00240	6a 00		 push	 0
  00242	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  00245	52		 push	 edx
  00246	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00249	50		 push	 eax
  0024a	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  0024d	51		 push	 ecx
  0024e	6a 00		 push	 0
  00250	6a 00		 push	 0
  00252	6a 00		 push	 0
  00254	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00257	52		 push	 edx
  00258	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0025b	8b 88 48 01 00
	00		 mov	 ecx, DWORD PTR [eax+328]
  00261	51		 push	 ecx
  00262	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00265	8b 82 5c 01 00
	00		 mov	 eax, DWORD PTR [edx+348]
  0026b	ff d0		 call	 eax
  0026d	83 c4 24	 add	 esp, 36			; 00000024H
  00270	89 45 e0	 mov	 DWORD PTR _ret$32321[ebp], eax

; 187  : 		if (ret != LZMA_STREAM_END)

  00273	83 7d e0 01	 cmp	 DWORD PTR _ret$32321[ebp], 1
  00277	74 05		 je	 SHORT $LN3@stream_enc@4

; 188  : 			return ret;

  00279	8b 45 e0	 mov	 eax, DWORD PTR _ret$32321[ebp]
  0027c	eb 7e		 jmp	 SHORT $LN32@stream_enc@4
$LN3@stream_enc@4:

; 189  : 
; 190  : 		// Encode the Stream Footer into coder->buffer.
; 191  : 		{ //MiSt
; 192  : 		/*
; 193  : 		const lzma_stream_flags stream_flags = {
; 194  : 				.version = 0,
; 195  : 				.backward_size = lzma_index_size(coder->index),
; 196  : 				.check = coder->block_options.check,
; 197  : 		};
; 198  : 		*/
; 199  : 		lzma_stream_flags stream_flags;
; 200  : 		memset (&stream_flags, 0, sizeof(stream_flags));

  0027e	6a 38		 push	 56			; 00000038H
  00280	6a 00		 push	 0
  00282	8d 4d a8	 lea	 ecx, DWORD PTR _stream_flags$32325[ebp]
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 _memset
  0028b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : 		stream_flags.version       = 0;

  0028e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _stream_flags$32325[ebp], 0

; 202  : 		stream_flags.backward_size = lzma_index_size(coder->index);

  00295	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00298	8b 82 78 01 00
	00		 mov	 eax, DWORD PTR [edx+376]
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 _lzma_index_size
  002a4	83 c4 04	 add	 esp, 4
  002a7	89 45 b0	 mov	 DWORD PTR _stream_flags$32325[ebp+8], eax
  002aa	89 55 b4	 mov	 DWORD PTR _stream_flags$32325[ebp+12], edx

; 203  : 		stream_flags.check         = coder->block_options.check;

  002ad	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002b0	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  002b3	89 55 b8	 mov	 DWORD PTR _stream_flags$32325[ebp+16], edx

; 204  : 
; 205  : 		if (lzma_stream_footer_encode(&stream_flags, coder->buffer)
; 206  : 				!= LZMA_OK)

  002b6	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002b9	05 84 01 00 00	 add	 eax, 388		; 00000184H
  002be	50		 push	 eax
  002bf	8d 4d a8	 lea	 ecx, DWORD PTR _stream_flags$32325[ebp]
  002c2	51		 push	 ecx
  002c3	e8 00 00 00 00	 call	 _lzma_stream_footer_encode
  002c8	83 c4 08	 add	 esp, 8
  002cb	85 c0		 test	 eax, eax
  002cd	74 07		 je	 SHORT $LN2@stream_enc@4

; 207  : 			return LZMA_PROG_ERROR;

  002cf	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  002d4	eb 26		 jmp	 SHORT $LN32@stream_enc@4
$LN2@stream_enc@4:

; 208  : 
; 209  : 		coder->buffer_size = LZMA_STREAM_HEADER_SIZE;

  002d6	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  002d9	c7 82 80 01 00
	00 0c 00 00 00	 mov	 DWORD PTR [edx+384], 12	; 0000000cH

; 210  : 		coder->sequence = SEQ_STREAM_FOOTER;

  002e3	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  002e6	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5

; 211  : 		}
; 212  : 		break;

  002ec	eb 07		 jmp	 SHORT $LN28@stream_enc@4
$LN1@stream_enc@4:

; 213  : 	}
; 214  : 
; 215  : 	default:
; 216  : 		assert(0);
; 217  : 		return LZMA_PROG_ERROR;

  002ee	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  002f3	eb 07		 jmp	 SHORT $LN32@stream_enc@4
$LN28@stream_enc@4:

; 218  : 	}

  002f5	e9 12 fd ff ff	 jmp	 $LN31@stream_enc@4
$LN30@stream_enc@4:

; 219  : 
; 220  : 	return LZMA_OK;

  002fa	33 c0		 xor	 eax, eax
$LN32@stream_enc@4:

; 221  : }

  002fc	8b e5		 mov	 esp, ebp
  002fe	5d		 pop	 ebp
  002ff	c3		 ret	 0
$LN34@stream_enc@4:
  00300	00 00 00 00	 DD	 $LN27@stream_enc@4
  00304	00 00 00 00	 DD	 $LN24@stream_enc@4
  00308	00 00 00 00	 DD	 $LN27@stream_enc@4
  0030c	00 00 00 00	 DD	 $LN11@stream_enc@4
  00310	00 00 00 00	 DD	 $LN4@stream_enc@4
  00314	00 00 00 00	 DD	 $LN27@stream_enc@4
_stream_encode ENDP
; Function compile flags: /Odtp
;	COMDAT _stream_encoder_init
_TEXT	SEGMENT
_ret_$32398 = -68					; size = 4
_stream_flags$32394 = -64				; size = 56
_coder$32385 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_check$ = 20						; size = 4
_stream_encoder_init PROC				; COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN12@stream_enc@5:

; 294  : 	lzma_next_coder_init(&stream_encoder_init, next, allocator);

  00008	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0000b	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _stream_encoder_init
  00012	74 10		 je	 SHORT $LN9@stream_enc@5
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _lzma_next_end
  00021	83 c4 08	 add	 esp, 8
$LN9@stream_enc@5:
  00024	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _stream_encoder_init
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 d6		 jne	 SHORT $LN12@stream_enc@5

; 295  : 
; 296  : 	if (filters == NULL)

  00032	83 7d 10 00	 cmp	 DWORD PTR _filters$[ebp], 0
  00036	75 0a		 jne	 SHORT $LN8@stream_enc@5

; 297  : 		return LZMA_PROG_ERROR;

  00038	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0003d	e9 75 01 00 00	 jmp	 $LN13@stream_enc@5
$LN8@stream_enc@5:

; 298  : 
; 299  :   {
; 300  : 	lzma_stream_coder *coder = next->coder;

  00042	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 45 fc	 mov	 DWORD PTR _coder$32385[ebp], eax

; 301  : 
; 302  : 	if (coder == NULL) {

  0004a	83 7d fc 00	 cmp	 DWORD PTR _coder$32385[ebp], 0
  0004e	0f 85 95 00 00
	00		 jne	 $LN7@stream_enc@5

; 303  : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00057	51		 push	 ecx
  00058	68 88 05 00 00	 push	 1416			; 00000588H
  0005d	e8 00 00 00 00	 call	 _lzma_alloc
  00062	83 c4 08	 add	 esp, 8
  00065	89 45 fc	 mov	 DWORD PTR _coder$32385[ebp], eax

; 304  : 		if (coder == NULL)

  00068	83 7d fc 00	 cmp	 DWORD PTR _coder$32385[ebp], 0
  0006c	75 0a		 jne	 SHORT $LN6@stream_enc@5

; 305  : 			return LZMA_MEM_ERROR;

  0006e	b8 05 00 00 00	 mov	 eax, 5
  00073	e9 3f 01 00 00	 jmp	 $LN13@stream_enc@5
$LN6@stream_enc@5:

; 306  : 
; 307  : 		next->coder = coder;

  00078	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _coder$32385[ebp]
  0007e	89 02		 mov	 DWORD PTR [edx], eax

; 308  : 		next->code = &stream_encode;

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00083	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _stream_encode

; 309  : 		next->end = &stream_encoder_end;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  0008d	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _stream_encoder_end

; 310  : 		next->update = &stream_encoder_update;

  00094	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00097	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _stream_encoder_update

; 311  : 
; 312  : 		coder->filters[0].id = LZMA_VLI_UNKNOWN;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32385[ebp]
  000a1	c7 81 f8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+248], -1
  000ab	c7 81 fc 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+252], -1

; 313  : 		coder->block_encoder = LZMA_NEXT_CODER_INIT;

  000b5	8b 7d fc	 mov	 edi, DWORD PTR _coder$32385[ebp]
  000b8	83 c7 08	 add	 edi, 8
  000bb	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000c0	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000c5	f3 a5		 rep movsd

; 314  : 		coder->index_encoder = LZMA_NEXT_CODER_INIT;

  000c7	8b 7d fc	 mov	 edi, DWORD PTR _coder$32385[ebp]
  000ca	81 c7 48 01 00
	00		 add	 edi, 328		; 00000148H
  000d0	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000d5	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000da	f3 a5		 rep movsd

; 315  : 		coder->index = NULL;

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _coder$32385[ebp]
  000df	c7 82 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+376], 0
$LN7@stream_enc@5:

; 316  : 	}
; 317  : 
; 318  : 	// Basic initializations
; 319  : 	coder->sequence = SEQ_STREAM_HEADER;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _coder$32385[ebp]
  000ec	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 320  : 	coder->block_options.version = 0;

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32385[ebp]
  000f5	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 321  : 	coder->block_options.check = check;

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _coder$32385[ebp]
  000ff	8b 45 14	 mov	 eax, DWORD PTR _check$[ebp]
  00102	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 322  : 
; 323  : 	// Initialize the Index
; 324  : 	lzma_index_end(coder->index, allocator);

  00105	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 fc	 mov	 edx, DWORD PTR _coder$32385[ebp]
  0010c	8b 82 78 01 00
	00		 mov	 eax, DWORD PTR [edx+376]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _lzma_index_end
  00118	83 c4 08	 add	 esp, 8

; 325  : 	coder->index = lzma_index_init(allocator);

  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _lzma_index_init
  00124	83 c4 04	 add	 esp, 4
  00127	8b 55 fc	 mov	 edx, DWORD PTR _coder$32385[ebp]
  0012a	89 82 78 01 00
	00		 mov	 DWORD PTR [edx+376], eax

; 326  : 	if (coder->index == NULL)

  00130	8b 45 fc	 mov	 eax, DWORD PTR _coder$32385[ebp]
  00133	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  0013a	75 07		 jne	 SHORT $LN5@stream_enc@5

; 327  : 		return LZMA_MEM_ERROR;

  0013c	b8 05 00 00 00	 mov	 eax, 5
  00141	eb 74		 jmp	 SHORT $LN13@stream_enc@5
$LN5@stream_enc@5:

; 328  : 
; 329  : 	// Encode the Stream Header
; 330  : 	{
; 331  : 	/*
; 332  : 	lzma_stream_flags stream_flags = {
; 333  :     		.version = 0,
; 334  :     		.check = check,
; 335  : 	};
; 336  : 	*/
; 337  : 	lzma_stream_flags stream_flags;
; 338  : 	memset (&stream_flags, 0, sizeof(stream_flags));

  00143	6a 38		 push	 56			; 00000038H
  00145	6a 00		 push	 0
  00147	8d 4d c0	 lea	 ecx, DWORD PTR _stream_flags$32394[ebp]
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 _memset
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 	stream_flags.version = 0;

  00153	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _stream_flags$32394[ebp], 0

; 340  : 	stream_flags.check   = check;

  0015a	8b 55 14	 mov	 edx, DWORD PTR _check$[ebp]
  0015d	89 55 d0	 mov	 DWORD PTR _stream_flags$32394[ebp+16], edx
$LN4@stream_enc@5:

; 341  : 
; 342  : 	return_if_error(lzma_stream_header_encode(
; 343  : 			&stream_flags, coder->buffer));

  00160	8b 45 fc	 mov	 eax, DWORD PTR _coder$32385[ebp]
  00163	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00168	50		 push	 eax
  00169	8d 4d c0	 lea	 ecx, DWORD PTR _stream_flags$32394[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _lzma_stream_header_encode
  00172	83 c4 08	 add	 esp, 8
  00175	89 45 bc	 mov	 DWORD PTR _ret_$32398[ebp], eax
  00178	83 7d bc 00	 cmp	 DWORD PTR _ret_$32398[ebp], 0
  0017c	74 05		 je	 SHORT $LN3@stream_enc@5
  0017e	8b 45 bc	 mov	 eax, DWORD PTR _ret_$32398[ebp]
  00181	eb 34		 jmp	 SHORT $LN13@stream_enc@5
$LN3@stream_enc@5:
  00183	33 d2		 xor	 edx, edx
  00185	75 d9		 jne	 SHORT $LN4@stream_enc@5

; 344  : 
; 345  : 	coder->buffer_pos = 0;

  00187	8b 45 fc	 mov	 eax, DWORD PTR _coder$32385[ebp]
  0018a	c7 80 7c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+380], 0

; 346  : 	coder->buffer_size = LZMA_STREAM_HEADER_SIZE;

  00194	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32385[ebp]
  00197	c7 81 80 01 00
	00 0c 00 00 00	 mov	 DWORD PTR [ecx+384], 12	; 0000000cH

; 347  : 
; 348  : 	// Initialize the Block encoder. This way we detect unsupported
; 349  : 	// filter chains when initializing the Stream encoder instead of
; 350  : 	// giving an error after Stream Header has already written out.
; 351  : 	return stream_encoder_update(coder, allocator, filters, NULL);

  001a1	6a 00		 push	 0
  001a3	8b 55 10	 mov	 edx, DWORD PTR _filters$[ebp]
  001a6	52		 push	 edx
  001a7	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  001aa	50		 push	 eax
  001ab	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32385[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _stream_encoder_update
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@stream_enc@5:

; 352  :   }}
; 353  : }

  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
_stream_encoder_init ENDP
PUBLIC	_lzma_stream_encoder
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_encoder
_TEXT	SEGMENT
_ret_$32416 = -8					; size = 4
_ret_$32414 = -4					; size = 4
_strm$ = 8						; size = 4
_filters$ = 12						; size = 4
_check$ = 16						; size = 4
_lzma_stream_encoder PROC				; COMDAT

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_strea@9:

; 360  : 	lzma_next_strm_init(stream_encoder_init, strm, filters, check);

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lzma_strm_init
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _ret_$32414[ebp], eax
  00015	83 7d fc 00	 cmp	 DWORD PTR _ret_$32414[ebp], 0
  00019	74 05		 je	 SHORT $LN4@lzma_strea@9
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32414[ebp]
  0001e	eb 74		 jmp	 SHORT $LN9@lzma_strea@9
$LN4@lzma_strea@9:
  00020	33 c9		 xor	 ecx, ecx
  00022	75 e2		 jne	 SHORT $LN5@lzma_strea@9
  00024	8b 55 10	 mov	 edx, DWORD PTR _check$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR _filters$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00036	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _stream_encoder_init
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	89 45 f8	 mov	 DWORD PTR _ret_$32416[ebp], eax
  00045	83 7d f8 00	 cmp	 DWORD PTR _ret_$32416[ebp], 0
  00049	74 11		 je	 SHORT $LN7@lzma_strea@9
  0004b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _lzma_end
  00054	83 c4 04	 add	 esp, 4
  00057	8b 45 f8	 mov	 eax, DWORD PTR _ret_$32416[ebp]
  0005a	eb 38		 jmp	 SHORT $LN9@lzma_strea@9
$LN7@lzma_strea@9:
  0005c	33 c0		 xor	 eax, eax
  0005e	75 a6		 jne	 SHORT $LN5@lzma_strea@9

; 361  : 
; 362  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00063	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00066	c6 42 38 01	 mov	 BYTE PTR [edx+56], 1

; 363  : 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00070	c6 41 39 01	 mov	 BYTE PTR [ecx+57], 1

; 364  : 	strm->internal->supported_actions[LZMA_FULL_FLUSH] = true;

  00074	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00077	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0007a	c6 40 3a 01	 mov	 BYTE PTR [eax+58], 1

; 365  : 	strm->internal->supported_actions[LZMA_FULL_BARRIER] = true;

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00081	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00084	c6 42 3c 01	 mov	 BYTE PTR [edx+60], 1

; 366  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00088	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0008b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0008e	c6 41 3b 01	 mov	 BYTE PTR [ecx+59], 1

; 367  : 
; 368  : 	return LZMA_OK;

  00092	33 c0		 xor	 eax, eax
$LN9@lzma_strea@9:

; 369  : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_lzma_stream_encoder ENDP
END
