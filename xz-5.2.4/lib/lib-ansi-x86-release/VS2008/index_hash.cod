; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\index_hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_memcmp:PROC
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
;	COMDAT _index_size_unpadded
_TEXT	SEGMENT
_count$ = 8						; size = 8
_index_list_size$ = 16					; size = 8
_index_size_unpadded PROC				; COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 50   : 	// Index Indicator + Number of Records + List of Records + CRC32
; 51   : 	return 1 + lzma_vli_size(count) + index_list_size + 4;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp+4]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _count$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _lzma_vli_size
  00010	83 c4 08	 add	 esp, 8
  00013	83 c0 01	 add	 eax, 1
  00016	33 d2		 xor	 edx, edx
  00018	03 45 10	 add	 eax, DWORD PTR _index_list_size$[ebp]
  0001b	13 55 14	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  0001e	83 c0 04	 add	 eax, 4
  00021	83 d2 00	 adc	 edx, 0

; 52   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_index_size_unpadded ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _vli_ceil4
_TEXT	SEGMENT
_vli$ = 8						; size = 8
_vli_ceil4 PROC						; COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : 	assert(vli <= LZMA_VLI_MAX);
; 42   : 	return (vli + 3) & ~LZMA_VLI_C(3);

  00003	8b 45 08	 mov	 eax, DWORD PTR _vli$[ebp]
  00006	83 c0 03	 add	 eax, 3
  00009	8b 55 0c	 mov	 edx, DWORD PTR _vli$[ebp+4]
  0000c	83 d2 00	 adc	 edx, 0
  0000f	83 e0 fc	 and	 eax, -4			; fffffffcH

; 43   : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_vli_ceil4 ENDP
PUBLIC	_lzma_index_hash_end
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
;	COMDAT _lzma_index_hash_end
_TEXT	SEGMENT
_index_hash$ = 8					; size = 4
_allocator$ = 12					; size = 4
_lzma_index_hash_end PROC				; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 	lzma_free(index_hash, allocator);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _lzma_free
  00010	83 c4 08	 add	 esp, 8

; 109  : 	return;
; 110  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_lzma_index_hash_end ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_hash_init
; Function compile flags: /Odtp
;	COMDAT _lzma_index_hash_init
_TEXT	SEGMENT
_index_hash$ = 8					; size = 4
_allocator$ = 12					; size = 4
_lzma_index_hash_init PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 	if (index_hash == NULL) {

  00003	83 7d 08 00	 cmp	 DWORD PTR _index_hash$[ebp], 0
  00007	75 21		 jne	 SHORT $LN2@lzma_index

; 77   : 		index_hash = lzma_alloc(sizeof(lzma_index_hash), allocator);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0000c	50		 push	 eax
  0000d	68 38 01 00 00	 push	 312			; 00000138H
  00012	e8 00 00 00 00	 call	 _lzma_alloc
  00017	83 c4 08	 add	 esp, 8
  0001a	89 45 08	 mov	 DWORD PTR _index_hash$[ebp], eax

; 78   : 		if (index_hash == NULL)

  0001d	83 7d 08 00	 cmp	 DWORD PTR _index_hash$[ebp], 0
  00021	75 07		 jne	 SHORT $LN2@lzma_index

; 79   : 			return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	e9 18 01 00 00	 jmp	 $LN3@lzma_index
$LN2@lzma_index:

; 80   : 	}
; 81   : 
; 82   : 	index_hash->sequence = SEQ_BLOCK;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  0002d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 83   : 	index_hash->blocks.blocks_size = 0;

  00033	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00036	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  0003d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 84   : 	index_hash->blocks.uncompressed_size = 0;

  00044	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00047	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0004e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 85   : 	index_hash->blocks.count = 0;

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00058	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0005f	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 86   : 	index_hash->blocks.index_list_size = 0;

  00066	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00069	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00070	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 87   : 	index_hash->records.blocks_size = 0;

  00077	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0007a	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0
  00084	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0

; 88   : 	index_hash->records.uncompressed_size = 0;

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00091	c7 81 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+152], 0
  0009b	c7 81 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+156], 0

; 89   : 	index_hash->records.count = 0;

  000a5	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  000a8	c7 82 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+160], 0
  000b2	c7 82 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+164], 0

; 90   : 	index_hash->records.index_list_size = 0;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  000bf	c7 80 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+168], 0
  000c9	c7 80 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+172], 0

; 91   : 	index_hash->unpadded_size = 0;

  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  000d6	c7 81 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+288], 0
  000e0	c7 81 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+292], 0

; 92   : 	index_hash->uncompressed_size = 0;

  000ea	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  000ed	c7 82 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+296], 0
  000f7	c7 82 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+300], 0

; 93   : 	index_hash->pos = 0;

  00101	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00104	c7 80 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+304], 0

; 94   : 	index_hash->crc32 = 0;

  0010e	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00111	c7 81 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+308], 0

; 95   : 
; 96   : 	// These cannot fail because LZMA_CHECK_BEST is known to be supported.
; 97   : 	(void)lzma_check_init(&index_hash->blocks.check, LZMA_CHECK_BEST);

  0011b	6a 0a		 push	 10			; 0000000aH
  0011d	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00120	83 c2 28	 add	 edx, 40			; 00000028H
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _lzma_check_init
  00129	83 c4 08	 add	 esp, 8

; 98   : 	(void)lzma_check_init(&index_hash->records.check, LZMA_CHECK_BEST);

  0012c	6a 0a		 push	 10			; 0000000aH
  0012e	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00131	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _lzma_check_init
  0013c	83 c4 08	 add	 esp, 8

; 99   : 
; 100  : 	return index_hash;

  0013f	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
$LN3@lzma_index:

; 101  : }

  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
_lzma_index_hash_init ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
_TEXT	ENDS
;	COMDAT _index_size
_TEXT	SEGMENT
$T35913 = -8						; size = 8
_count$ = 8						; size = 8
_index_list_size$ = 16					; size = 8
_index_size PROC					; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 59   : 	return vli_ceil4(index_size_unpadded(count, index_list_size));

  00006	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp+4]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _count$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _lzma_vli_size
  00013	83 c4 08	 add	 esp, 8
  00016	83 c0 01	 add	 eax, 1
  00019	33 d2		 xor	 edx, edx
  0001b	03 45 10	 add	 eax, DWORD PTR _index_list_size$[ebp]
  0001e	13 55 14	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  00021	83 c0 04	 add	 eax, 4
  00024	83 d2 00	 adc	 edx, 0
  00027	89 45 f8	 mov	 DWORD PTR $T35913[ebp], eax
  0002a	89 55 fc	 mov	 DWORD PTR $T35913[ebp+4], edx
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T35913[ebp]
  00030	83 c0 03	 add	 eax, 3
  00033	8b 55 fc	 mov	 edx, DWORD PTR $T35913[ebp+4]
  00036	83 d2 00	 adc	 edx, 0
  00039	83 e0 fc	 and	 eax, -4			; fffffffcH

; 60   : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_index_size ENDP
PUBLIC	_lzma_index_hash_size
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
;	COMDAT _lzma_index_hash_size
_TEXT	SEGMENT
$T36058 = -24						; size = 8
$T36057 = -16						; size = 8
$T36047 = -8						; size = 8
_index_hash$ = 8					; size = 4
_lzma_index_hash_size PROC				; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 116  : 	// Get the size of the Index from ->blocks instead of ->records for
; 117  : 	// cases where application wants to know the Index Size before
; 118  : 	// decoding the Index.
; 119  : 	return index_size(index_hash->blocks.count,
; 120  : 			index_hash->blocks.index_list_size);

  00006	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00009	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000c	89 4d e8	 mov	 DWORD PTR $T36058[ebp], ecx
  0000f	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00012	89 55 ec	 mov	 DWORD PTR $T36058[ebp+4], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00018	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001b	89 4d f0	 mov	 DWORD PTR $T36057[ebp], ecx
  0001e	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00021	89 55 f4	 mov	 DWORD PTR $T36057[ebp+4], edx
  00024	8b 45 f4	 mov	 eax, DWORD PTR $T36057[ebp+4]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T36057[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _lzma_vli_size
  00031	83 c4 08	 add	 esp, 8
  00034	83 c0 01	 add	 eax, 1
  00037	33 d2		 xor	 edx, edx
  00039	03 45 e8	 add	 eax, DWORD PTR $T36058[ebp]
  0003c	13 55 ec	 adc	 edx, DWORD PTR $T36058[ebp+4]
  0003f	83 c0 04	 add	 eax, 4
  00042	83 d2 00	 adc	 edx, 0
  00045	89 45 f8	 mov	 DWORD PTR $T36047[ebp], eax
  00048	89 55 fc	 mov	 DWORD PTR $T36047[ebp+4], edx
  0004b	8b 45 f8	 mov	 eax, DWORD PTR $T36047[ebp]
  0004e	83 c0 03	 add	 eax, 3
  00051	8b 55 fc	 mov	 edx, DWORD PTR $T36047[ebp+4]
  00054	83 d2 00	 adc	 edx, 0
  00057	83 e0 fc	 and	 eax, -4			; fffffffcH

; 121  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_lzma_index_hash_size ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
_TEXT	ENDS
;	COMDAT _index_stream_size
_TEXT	SEGMENT
$T36064 = -8						; size = 8
_blocks_size$ = 8					; size = 8
_count$ = 16						; size = 8
_index_list_size$ = 24					; size = 8
_index_stream_size PROC					; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 68   : 	return LZMA_STREAM_HEADER_SIZE + blocks_size
; 69   : 			+ index_size(count, index_list_size)
; 70   : 			+ LZMA_STREAM_HEADER_SIZE;

  00007	8b 45 14	 mov	 eax, DWORD PTR _count$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _lzma_vli_size
  00014	83 c4 08	 add	 esp, 8
  00017	83 c0 01	 add	 eax, 1
  0001a	33 d2		 xor	 edx, edx
  0001c	03 45 18	 add	 eax, DWORD PTR _index_list_size$[ebp]
  0001f	13 55 1c	 adc	 edx, DWORD PTR _index_list_size$[ebp+4]
  00022	83 c0 04	 add	 eax, 4
  00025	83 d2 00	 adc	 edx, 0
  00028	89 45 f8	 mov	 DWORD PTR $T36064[ebp], eax
  0002b	89 55 fc	 mov	 DWORD PTR $T36064[ebp+4], edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _blocks_size$[ebp]
  00031	83 c0 0c	 add	 eax, 12			; 0000000cH
  00034	8b 55 0c	 mov	 edx, DWORD PTR _blocks_size$[ebp+4]
  00037	83 d2 00	 adc	 edx, 0
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR $T36064[ebp]
  0003d	83 c1 03	 add	 ecx, 3
  00040	8b 75 fc	 mov	 esi, DWORD PTR $T36064[ebp+4]
  00043	83 d6 00	 adc	 esi, 0
  00046	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00049	03 c1		 add	 eax, ecx
  0004b	13 d6		 adc	 edx, esi
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	83 d2 00	 adc	 edx, 0

; 71   : }

  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_index_stream_size ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
;	COMDAT _hash_append
_TEXT	SEGMENT
_sizes$32351 = -16					; size = 16
_info$ = 8						; size = 4
_unpadded_size$ = 12					; size = 8
_uncompressed_size$ = 20				; size = 8
_hash_append PROC					; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 129  : 	info->blocks_size += vli_ceil4(unpadded_size);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _unpadded_size$[ebp]
  0000a	83 c0 03	 add	 eax, 3
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _unpadded_size$[ebp+4]
  00010	83 d1 00	 adc	 ecx, 0
  00013	83 e0 fc	 and	 eax, -4			; fffffffcH
  00016	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00019	03 02		 add	 eax, DWORD PTR [edx]
  0001b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0001e	13 d1		 adc	 edx, ecx
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00023	89 01		 mov	 DWORD PTR [ecx], eax
  00025	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 130  : 	info->uncompressed_size += uncompressed_size;

  00028	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0002b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002e	03 45 14	 add	 eax, DWORD PTR _uncompressed_size$[ebp]
  00031	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00034	13 4d 18	 adc	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  00037	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0003a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0003d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 131  : 	info->index_list_size += lzma_vli_size(unpadded_size)
; 132  : 			+ lzma_vli_size(uncompressed_size);

  00040	8b 45 10	 mov	 eax, DWORD PTR _unpadded_size$[ebp+4]
  00043	50		 push	 eax
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _unpadded_size$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _lzma_vli_size
  0004d	83 c4 08	 add	 esp, 8
  00050	8b f0		 mov	 esi, eax
  00052	8b 55 18	 mov	 edx, DWORD PTR _uncompressed_size$[ebp+4]
  00055	52		 push	 edx
  00056	8b 45 14	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _lzma_vli_size
  0005f	83 c4 08	 add	 esp, 8
  00062	03 f0		 add	 esi, eax
  00064	33 c9		 xor	 ecx, ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00069	03 72 18	 add	 esi, DWORD PTR [edx+24]
  0006c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0006f	13 c1		 adc	 eax, ecx
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00074	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00077	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 133  : 	++info->count;

  0007a	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0007d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00080	83 c0 01	 add	 eax, 1
  00083	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00086	83 d1 00	 adc	 ecx, 0
  00089	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0008c	89 42 10	 mov	 DWORD PTR [edx+16], eax
  0008f	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 134  : 
; 135  :   {
; 136  : 	const lzma_vli sizes[2] = { unpadded_size, uncompressed_size };

  00092	8b 45 0c	 mov	 eax, DWORD PTR _unpadded_size$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR _sizes$32351[ebp], eax
  00098	8b 4d 10	 mov	 ecx, DWORD PTR _unpadded_size$[ebp+4]
  0009b	89 4d f4	 mov	 DWORD PTR _sizes$32351[ebp+4], ecx
  0009e	8b 55 14	 mov	 edx, DWORD PTR _uncompressed_size$[ebp]
  000a1	89 55 f8	 mov	 DWORD PTR _sizes$32351[ebp+8], edx
  000a4	8b 45 18	 mov	 eax, DWORD PTR _uncompressed_size$[ebp+4]
  000a7	89 45 fc	 mov	 DWORD PTR _sizes$32351[ebp+12], eax

; 137  : 	lzma_check_update(&info->check, LZMA_CHECK_BEST,
; 138  : 			(const uint8_t *)(sizes), sizeof(sizes));

  000aa	6a 10		 push	 16			; 00000010H
  000ac	8d 4d f0	 lea	 ecx, DWORD PTR _sizes$32351[ebp]
  000af	51		 push	 ecx
  000b0	6a 0a		 push	 10			; 0000000aH
  000b2	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000b5	83 c2 20	 add	 edx, 32			; 00000020H
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 _lzma_check_update
  000be	83 c4 10	 add	 esp, 16			; 00000010H

; 139  :   }
; 140  : 
; 141  : 	return LZMA_OK;

  000c1	33 c0		 xor	 eax, eax

; 142  : }

  000c3	5e		 pop	 esi
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_hash_append ENDP
PUBLIC	_lzma_index_hash_decode
; Function compile flags: /Odtp
;	COMDAT _lzma_index_hash_decode
_TEXT	SEGMENT
tv451 = -120						; size = 4
tv450 = -116						; size = 4
tv440 = -112						; size = 4
tv439 = -108						; size = 4
tv429 = -104						; size = 4
tv428 = -100						; size = 4
tv160 = -96						; size = 4
tv380 = -92						; size = 4
tv360 = -88						; size = 4
tv359 = -84						; size = 4
tv348 = -80						; size = 4
tv347 = -76						; size = 4
tv336 = -72						; size = 4
tv335 = -68						; size = 4
tv310 = -64						; size = 4
tv305 = -60						; size = 4
tv90 = -56						; size = 4
tv86 = -52						; size = 4
tv284 = -48						; size = 4
tv273 = -44						; size = 4
tv272 = -40						; size = 4
tv66 = -36						; size = 4
$T36198 = -32						; size = 8
$T36197 = -24						; size = 8
_ret_$32404 = -16					; size = 4
_size$32395 = -12					; size = 4
_in_start$32379 = -8					; size = 4
_ret$32380 = -4						; size = 4
_index_hash$ = 8					; size = 4
_in$ = 12						; size = 4
_in_pos$ = 16						; size = 4
_in_size$ = 20						; size = 4
_lzma_index_hash_decode PROC				; COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	56		 push	 esi

; 180  : 	// Catch zero input buffer here, because in contrast to Index encoder
; 181  : 	// and decoder functions, applications call this function directly
; 182  : 	// instead of via lzma_code(), which does the buffer checking.
; 183  : 	if (*in_pos >= in_size)

  00007	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	3b 4d 14	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  0000f	72 0a		 jb	 SHORT $LN36@lzma_index@2

; 184  : 		return LZMA_BUF_ERROR;

  00011	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00016	e9 bf 05 00 00	 jmp	 $LN37@lzma_index@2
$LN36@lzma_index@2:

; 185  : 
; 186  : 	// NOTE: This function has many similarities to index_encode() and
; 187  : 	// index_decode() functions found from index_encoder.c and
; 188  : 	// index_decoder.c. See the comments especially in index_encoder.c.
; 189  :   {
; 190  : 	const size_t in_start = *in_pos;

  0001b	8b 55 10	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	89 45 f8	 mov	 DWORD PTR _in_start$32379[ebp], eax

; 191  : 	lzma_ret ret = LZMA_OK;

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$32380[ebp], 0
$LN35@lzma_index@2:

; 192  : 
; 193  : 	while (*in_pos < in_size)

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	3b 55 14	 cmp	 edx, DWORD PTR _in_size$[ebp]
  00032	0f 83 74 05 00
	00		 jae	 $out$32392

; 194  : 	switch (index_hash->sequence) {

  00038	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	89 4d dc	 mov	 DWORD PTR tv66[ebp], ecx
  00040	83 7d dc 06	 cmp	 DWORD PTR tv66[ebp], 6
  00044	0f 87 56 05 00
	00		 ja	 $LN1@lzma_index@2
  0004a	8b 55 dc	 mov	 edx, DWORD PTR tv66[ebp]
  0004d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN54@lzma_index@2[edx*4]
$LN31@lzma_index@2:

; 195  : 	case SEQ_BLOCK:
; 196  : 		// Check the Index Indicator is present.
; 197  : 		if (in[(*in_pos)++] != 0x00)

  00054	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  0005c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00060	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	83 c2 01	 add	 edx, 1
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0006b	89 11		 mov	 DWORD PTR [ecx], edx
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN30@lzma_index@2

; 198  : 			return LZMA_DATA_ERROR;

  00071	b8 09 00 00 00	 mov	 eax, 9
  00076	e9 5f 05 00 00	 jmp	 $LN37@lzma_index@2
$LN30@lzma_index@2:

; 199  : 
; 200  : 		index_hash->sequence = SEQ_COUNT;

  0007b	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0007e	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 201  : 		break;

  00084	e9 1e 05 00 00	 jmp	 $LN32@lzma_index@2
$LN29@lzma_index@2:

; 202  : 
; 203  : 	case SEQ_COUNT: {
; 204  : 		ret = lzma_vli_decode(&index_hash->remaining,
; 205  : 				&index_hash->pos, in, in_pos, in_size);

  00089	8b 45 14	 mov	 eax, DWORD PTR _in_size$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00098	05 30 01 00 00	 add	 eax, 304		; 00000130H
  0009d	50		 push	 eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  000a1	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _lzma_vli_decode
  000ad	83 c4 14	 add	 esp, 20			; 00000014H
  000b0	89 45 fc	 mov	 DWORD PTR _ret$32380[ebp], eax

; 206  : 		if (ret != LZMA_STREAM_END)

  000b3	83 7d fc 01	 cmp	 DWORD PTR _ret$32380[ebp], 1
  000b7	74 05		 je	 SHORT $LN28@lzma_index@2

; 207  : 			goto out;

  000b9	e9 ee 04 00 00	 jmp	 $out$32392
$LN28@lzma_index@2:

; 208  : 
; 209  : 		// The count must match the count of the Blocks decoded.
; 210  : 		if (index_hash->remaining != index_hash->blocks.count)

  000be	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  000c1	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  000c4	89 55 d8	 mov	 DWORD PTR tv272[ebp], edx
  000c7	89 45 d4	 mov	 DWORD PTR tv273[ebp], eax
  000ca	8b 4d d8	 mov	 ecx, DWORD PTR tv272[ebp]
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv273[ebp]
  000d0	8b 81 18 01 00
	00		 mov	 eax, DWORD PTR [ecx+280]
  000d6	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  000d9	75 11		 jne	 SHORT $LN47@lzma_index@2
  000db	8b 4d d8	 mov	 ecx, DWORD PTR tv272[ebp]
  000de	8b 55 d4	 mov	 edx, DWORD PTR tv273[ebp]
  000e1	8b 81 1c 01 00
	00		 mov	 eax, DWORD PTR [ecx+284]
  000e7	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  000ea	74 0a		 je	 SHORT $LN27@lzma_index@2
$LN47@lzma_index@2:

; 211  : 			return LZMA_DATA_ERROR;

  000ec	b8 09 00 00 00	 mov	 eax, 9
  000f1	e9 e4 04 00 00	 jmp	 $LN37@lzma_index@2
$LN27@lzma_index@2:

; 212  : 
; 213  : 		ret = LZMA_OK;

  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$32380[ebp], 0

; 214  : 		index_hash->pos = 0;

  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00100	c7 81 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+304], 0

; 215  : 
; 216  : 		// Handle the special case when there are no Blocks.
; 217  : 		index_hash->sequence = index_hash->remaining == 0
; 218  : 				? SEQ_PADDING_INIT : SEQ_UNPADDED;

  0010a	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0010d	89 55 d0	 mov	 DWORD PTR tv284[ebp], edx
  00110	8b 45 d0	 mov	 eax, DWORD PTR tv284[ebp]
  00113	8b 4d d0	 mov	 ecx, DWORD PTR tv284[ebp]
  00116	8b 90 18 01 00
	00		 mov	 edx, DWORD PTR [eax+280]
  0011c	0b 91 1c 01 00
	00		 or	 edx, DWORD PTR [ecx+284]
  00122	75 09		 jne	 SHORT $LN39@lzma_index@2
  00124	c7 45 cc 04 00
	00 00		 mov	 DWORD PTR tv86[ebp], 4
  0012b	eb 07		 jmp	 SHORT $LN40@lzma_index@2
$LN39@lzma_index@2:
  0012d	c7 45 cc 02 00
	00 00		 mov	 DWORD PTR tv86[ebp], 2
$LN40@lzma_index@2:
  00134	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00137	8b 4d cc	 mov	 ecx, DWORD PTR tv86[ebp]
  0013a	89 08		 mov	 DWORD PTR [eax], ecx

; 219  : 		break;

  0013c	e9 66 04 00 00	 jmp	 $LN32@lzma_index@2
$LN26@lzma_index@2:

; 220  : 	}
; 221  : 
; 222  : 	case SEQ_UNPADDED:
; 223  : 	case SEQ_UNCOMPRESSED: {
; 224  : 		lzma_vli *size = index_hash->sequence == SEQ_UNPADDED
; 225  : 				? &index_hash->unpadded_size
; 226  : 				: &index_hash->uncompressed_size;

  00141	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00144	83 3a 02	 cmp	 DWORD PTR [edx], 2
  00147	75 0d		 jne	 SHORT $LN41@lzma_index@2
  00149	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0014c	05 20 01 00 00	 add	 eax, 288		; 00000120H
  00151	89 45 c8	 mov	 DWORD PTR tv90[ebp], eax
  00154	eb 0c		 jmp	 SHORT $LN42@lzma_index@2
$LN41@lzma_index@2:
  00156	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00159	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  0015f	89 4d c8	 mov	 DWORD PTR tv90[ebp], ecx
$LN42@lzma_index@2:
  00162	8b 55 c8	 mov	 edx, DWORD PTR tv90[ebp]
  00165	89 55 f4	 mov	 DWORD PTR _size$32395[ebp], edx

; 227  : 
; 228  : 		ret = lzma_vli_decode(size, &index_hash->pos,
; 229  : 				in, in_pos, in_size);

  00168	8b 45 14	 mov	 eax, DWORD PTR _in_size$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00173	52		 push	 edx
  00174	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00177	05 30 01 00 00	 add	 eax, 304		; 00000130H
  0017c	50		 push	 eax
  0017d	8b 4d f4	 mov	 ecx, DWORD PTR _size$32395[ebp]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 _lzma_vli_decode
  00186	83 c4 14	 add	 esp, 20			; 00000014H
  00189	89 45 fc	 mov	 DWORD PTR _ret$32380[ebp], eax

; 230  : 		if (ret != LZMA_STREAM_END)

  0018c	83 7d fc 01	 cmp	 DWORD PTR _ret$32380[ebp], 1
  00190	74 05		 je	 SHORT $LN25@lzma_index@2

; 231  : 			goto out;

  00192	e9 15 04 00 00	 jmp	 $out$32392
$LN25@lzma_index@2:

; 232  : 
; 233  : 		ret = LZMA_OK;

  00197	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$32380[ebp], 0

; 234  : 		index_hash->pos = 0;

  0019e	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  001a1	c7 82 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+304], 0

; 235  : 
; 236  : 		if (index_hash->sequence == SEQ_UNPADDED) {

  001ab	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  001ae	83 38 02	 cmp	 DWORD PTR [eax], 2
  001b1	75 59		 jne	 SHORT $LN20@lzma_index@2

; 237  : 			if (index_hash->unpadded_size < UNPADDED_SIZE_MIN
; 238  : 					|| index_hash->unpadded_size
; 239  : 						> UNPADDED_SIZE_MAX)

  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  001b6	89 4d c4	 mov	 DWORD PTR tv305[ebp], ecx
  001b9	8b 55 c4	 mov	 edx, DWORD PTR tv305[ebp]
  001bc	83 ba 24 01 00
	00 00		 cmp	 DWORD PTR [edx+292], 0
  001c3	77 0c		 ja	 SHORT $LN48@lzma_index@2
  001c5	8b 45 c4	 mov	 eax, DWORD PTR tv305[ebp]
  001c8	83 b8 20 01 00
	00 05		 cmp	 DWORD PTR [eax+288], 5
  001cf	72 23		 jb	 SHORT $LN22@lzma_index@2
$LN48@lzma_index@2:
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  001d4	89 4d c0	 mov	 DWORD PTR tv310[ebp], ecx
  001d7	8b 55 c0	 mov	 edx, DWORD PTR tv310[ebp]
  001da	81 ba 24 01 00
	00 ff ff ff 7f	 cmp	 DWORD PTR [edx+292], 2147483647 ; 7fffffffH
  001e4	72 18		 jb	 SHORT $LN23@lzma_index@2
  001e6	77 0c		 ja	 SHORT $LN22@lzma_index@2
  001e8	8b 45 c0	 mov	 eax, DWORD PTR tv310[ebp]
  001eb	83 b8 20 01 00
	00 fc		 cmp	 DWORD PTR [eax+288], -4	; fffffffcH
  001f2	76 0a		 jbe	 SHORT $LN23@lzma_index@2
$LN22@lzma_index@2:

; 240  : 				return LZMA_DATA_ERROR;

  001f4	b8 09 00 00 00	 mov	 eax, 9
  001f9	e9 dc 03 00 00	 jmp	 $LN37@lzma_index@2
$LN23@lzma_index@2:

; 241  : 
; 242  : 			index_hash->sequence = SEQ_UNCOMPRESSED;

  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00201	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 243  : 		} else {

  00207	e9 39 01 00 00	 jmp	 $LN21@lzma_index@2
$LN20@lzma_index@2:

; 244  : 			// Update the hash.
; 245  : 			return_if_error(hash_append(&index_hash->records,
; 246  : 					index_hash->unpadded_size,
; 247  : 					index_hash->uncompressed_size));

  0020c	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0020f	8b 82 2c 01 00
	00		 mov	 eax, DWORD PTR [edx+300]
  00215	50		 push	 eax
  00216	8b 8a 28 01 00
	00		 mov	 ecx, DWORD PTR [edx+296]
  0021c	51		 push	 ecx
  0021d	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00220	8b 82 24 01 00
	00		 mov	 eax, DWORD PTR [edx+292]
  00226	50		 push	 eax
  00227	8b 8a 20 01 00
	00		 mov	 ecx, DWORD PTR [edx+288]
  0022d	51		 push	 ecx
  0022e	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00231	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 _hash_append
  0023d	83 c4 14	 add	 esp, 20			; 00000014H
  00240	89 45 f0	 mov	 DWORD PTR _ret_$32404[ebp], eax
  00243	83 7d f0 00	 cmp	 DWORD PTR _ret_$32404[ebp], 0
  00247	74 08		 je	 SHORT $LN19@lzma_index@2
  00249	8b 45 f0	 mov	 eax, DWORD PTR _ret_$32404[ebp]
  0024c	e9 89 03 00 00	 jmp	 $LN37@lzma_index@2
$LN19@lzma_index@2:
  00251	33 c0		 xor	 eax, eax
  00253	75 b7		 jne	 SHORT $LN20@lzma_index@2

; 248  : 
; 249  : 			// Verify that we don't go over the known sizes. Note
; 250  : 			// that this validation is simpler than the one used
; 251  : 			// in lzma_index_hash_append(), because here we know
; 252  : 			// that values in index_hash->blocks are already
; 253  : 			// validated and we are fine as long as we don't
; 254  : 			// exceed them in index_hash->records.
; 255  : 			if (index_hash->blocks.blocks_size
; 256  : 					< index_hash->records.blocks_size
; 257  : 					|| index_hash->blocks.uncompressed_size
; 258  : 					< index_hash->records.uncompressed_size
; 259  : 					|| index_hash->blocks.index_list_size
; 260  : 					< index_hash->records.index_list_size)

  00255	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00258	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0025b	89 4d bc	 mov	 DWORD PTR tv335[ebp], ecx
  0025e	89 55 b8	 mov	 DWORD PTR tv336[ebp], edx
  00261	8b 45 bc	 mov	 eax, DWORD PTR tv335[ebp]
  00264	8b 4d b8	 mov	 ecx, DWORD PTR tv336[ebp]
  00267	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0026a	3b 91 94 00 00
	00		 cmp	 edx, DWORD PTR [ecx+148]
  00270	72 73		 jb	 SHORT $LN15@lzma_index@2
  00272	77 11		 ja	 SHORT $LN50@lzma_index@2
  00274	8b 45 bc	 mov	 eax, DWORD PTR tv335[ebp]
  00277	8b 4d b8	 mov	 ecx, DWORD PTR tv336[ebp]
  0027a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0027d	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  00283	72 60		 jb	 SHORT $LN15@lzma_index@2
$LN50@lzma_index@2:
  00285	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00288	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  0028b	89 45 b4	 mov	 DWORD PTR tv347[ebp], eax
  0028e	89 4d b0	 mov	 DWORD PTR tv348[ebp], ecx
  00291	8b 55 b4	 mov	 edx, DWORD PTR tv347[ebp]
  00294	8b 45 b0	 mov	 eax, DWORD PTR tv348[ebp]
  00297	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0029a	3b 88 9c 00 00
	00		 cmp	 ecx, DWORD PTR [eax+156]
  002a0	72 43		 jb	 SHORT $LN15@lzma_index@2
  002a2	77 11		 ja	 SHORT $LN51@lzma_index@2
  002a4	8b 55 b4	 mov	 edx, DWORD PTR tv347[ebp]
  002a7	8b 45 b0	 mov	 eax, DWORD PTR tv348[ebp]
  002aa	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  002ad	3b 88 98 00 00
	00		 cmp	 ecx, DWORD PTR [eax+152]
  002b3	72 30		 jb	 SHORT $LN15@lzma_index@2
$LN51@lzma_index@2:
  002b5	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  002b8	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  002bb	89 55 ac	 mov	 DWORD PTR tv359[ebp], edx
  002be	89 45 a8	 mov	 DWORD PTR tv360[ebp], eax
  002c1	8b 4d ac	 mov	 ecx, DWORD PTR tv359[ebp]
  002c4	8b 55 a8	 mov	 edx, DWORD PTR tv360[ebp]
  002c7	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  002ca	3b 82 ac 00 00
	00		 cmp	 eax, DWORD PTR [edx+172]
  002d0	77 1d		 ja	 SHORT $LN16@lzma_index@2
  002d2	72 11		 jb	 SHORT $LN15@lzma_index@2
  002d4	8b 4d ac	 mov	 ecx, DWORD PTR tv359[ebp]
  002d7	8b 55 a8	 mov	 edx, DWORD PTR tv360[ebp]
  002da	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002dd	3b 82 a8 00 00
	00		 cmp	 eax, DWORD PTR [edx+168]
  002e3	73 0a		 jae	 SHORT $LN16@lzma_index@2
$LN15@lzma_index@2:

; 261  : 				return LZMA_DATA_ERROR;

  002e5	b8 09 00 00 00	 mov	 eax, 9
  002ea	e9 eb 02 00 00	 jmp	 $LN37@lzma_index@2
$LN16@lzma_index@2:

; 262  : 
; 263  : 			// Check if this was the last Record.
; 264  : 			index_hash->sequence = --index_hash->remaining == 0
; 265  : 					? SEQ_PADDING_INIT : SEQ_UNPADDED;

  002ef	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  002f2	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR [ecx+280]
  002f8	83 ea 01	 sub	 edx, 1
  002fb	8b 81 1c 01 00
	00		 mov	 eax, DWORD PTR [ecx+284]
  00301	83 d8 00	 sbb	 eax, 0
  00304	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00307	89 91 18 01 00
	00		 mov	 DWORD PTR [ecx+280], edx
  0030d	89 81 1c 01 00
	00		 mov	 DWORD PTR [ecx+284], eax
  00313	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00316	89 55 a4	 mov	 DWORD PTR tv380[ebp], edx
  00319	8b 45 a4	 mov	 eax, DWORD PTR tv380[ebp]
  0031c	8b 4d a4	 mov	 ecx, DWORD PTR tv380[ebp]
  0031f	8b 90 18 01 00
	00		 mov	 edx, DWORD PTR [eax+280]
  00325	0b 91 1c 01 00
	00		 or	 edx, DWORD PTR [ecx+284]
  0032b	75 09		 jne	 SHORT $LN43@lzma_index@2
  0032d	c7 45 a0 04 00
	00 00		 mov	 DWORD PTR tv160[ebp], 4
  00334	eb 07		 jmp	 SHORT $LN44@lzma_index@2
$LN43@lzma_index@2:
  00336	c7 45 a0 02 00
	00 00		 mov	 DWORD PTR tv160[ebp], 2
$LN44@lzma_index@2:
  0033d	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00340	8b 4d a0	 mov	 ecx, DWORD PTR tv160[ebp]
  00343	89 08		 mov	 DWORD PTR [eax], ecx
$LN21@lzma_index@2:

; 266  : 		}
; 267  : 
; 268  : 		break;

  00345	e9 5d 02 00 00	 jmp	 $LN32@lzma_index@2
$LN14@lzma_index@2:

; 269  : 	}
; 270  : 
; 271  : 	case SEQ_PADDING_INIT:
; 272  : 		index_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(
; 273  : 				index_hash->records.count,
; 274  : 				index_hash->records.index_list_size)) & 3;

  0034a	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0034d	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00353	89 45 e0	 mov	 DWORD PTR $T36198[ebp], eax
  00356	8b 8a ac 00 00
	00		 mov	 ecx, DWORD PTR [edx+172]
  0035c	89 4d e4	 mov	 DWORD PTR $T36198[ebp+4], ecx
  0035f	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00362	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00368	89 45 e8	 mov	 DWORD PTR $T36197[ebp], eax
  0036b	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  00371	89 4d ec	 mov	 DWORD PTR $T36197[ebp+4], ecx
  00374	8b 55 ec	 mov	 edx, DWORD PTR $T36197[ebp+4]
  00377	52		 push	 edx
  00378	8b 45 e8	 mov	 eax, DWORD PTR $T36197[ebp]
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 _lzma_vli_size
  00381	83 c4 08	 add	 esp, 8
  00384	83 c0 01	 add	 eax, 1
  00387	33 c9		 xor	 ecx, ecx
  00389	03 45 e0	 add	 eax, DWORD PTR $T36198[ebp]
  0038c	13 4d e4	 adc	 ecx, DWORD PTR $T36198[ebp+4]
  0038f	83 c0 04	 add	 eax, 4
  00392	83 d1 00	 adc	 ecx, 0
  00395	ba 04 00 00 00	 mov	 edx, 4
  0039a	2b d0		 sub	 edx, eax
  0039c	b8 00 00 00 00	 mov	 eax, 0
  003a1	1b c1		 sbb	 eax, ecx
  003a3	83 e2 03	 and	 edx, 3
  003a6	83 e0 00	 and	 eax, 0
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  003ac	89 91 30 01 00
	00		 mov	 DWORD PTR [ecx+304], edx

; 275  : 		index_hash->sequence = SEQ_PADDING;

  003b2	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  003b5	c7 02 05 00 00
	00		 mov	 DWORD PTR [edx], 5
$LN13@lzma_index@2:

; 276  : 
; 277  : 	// Fall through
; 278  : 
; 279  : 	case SEQ_PADDING:
; 280  : 		if (index_hash->pos > 0) {

  003bb	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  003be	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [eax+304], 0
  003c5	76 41		 jbe	 SHORT $LN12@lzma_index@2

; 281  : 			--index_hash->pos;

  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  003ca	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR [ecx+304]
  003d0	83 ea 01	 sub	 edx, 1
  003d3	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  003d6	89 90 30 01 00
	00		 mov	 DWORD PTR [eax+304], edx

; 282  : 			if (in[(*in_pos)++] != 0x00)

  003dc	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  003df	8b 11		 mov	 edx, DWORD PTR [ecx]
  003e1	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  003e4	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003e8	8b 55 10	 mov	 edx, DWORD PTR _in_pos$[ebp]
  003eb	8b 02		 mov	 eax, DWORD PTR [edx]
  003ed	83 c0 01	 add	 eax, 1
  003f0	8b 55 10	 mov	 edx, DWORD PTR _in_pos$[ebp]
  003f3	89 02		 mov	 DWORD PTR [edx], eax
  003f5	85 c9		 test	 ecx, ecx
  003f7	74 0a		 je	 SHORT $LN11@lzma_index@2

; 283  : 				return LZMA_DATA_ERROR;

  003f9	b8 09 00 00 00	 mov	 eax, 9
  003fe	e9 d7 01 00 00	 jmp	 $LN37@lzma_index@2
$LN11@lzma_index@2:

; 284  : 
; 285  : 			break;

  00403	e9 9f 01 00 00	 jmp	 $LN32@lzma_index@2
$LN12@lzma_index@2:

; 286  : 		}
; 287  : 
; 288  : 		// Compare the sizes.
; 289  : 		if (index_hash->blocks.blocks_size
; 290  : 				!= index_hash->records.blocks_size
; 291  : 				|| index_hash->blocks.uncompressed_size
; 292  : 				!= index_hash->records.uncompressed_size
; 293  : 				|| index_hash->blocks.index_list_size
; 294  : 				!= index_hash->records.index_list_size)

  00408	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0040b	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  0040e	89 45 9c	 mov	 DWORD PTR tv428[ebp], eax
  00411	89 4d 98	 mov	 DWORD PTR tv429[ebp], ecx
  00414	8b 55 9c	 mov	 edx, DWORD PTR tv428[ebp]
  00417	8b 45 98	 mov	 eax, DWORD PTR tv429[ebp]
  0041a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0041d	3b 88 90 00 00
	00		 cmp	 ecx, DWORD PTR [eax+144]
  00423	75 6d		 jne	 SHORT $LN9@lzma_index@2
  00425	8b 55 9c	 mov	 edx, DWORD PTR tv428[ebp]
  00428	8b 45 98	 mov	 eax, DWORD PTR tv429[ebp]
  0042b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0042e	3b 88 94 00 00
	00		 cmp	 ecx, DWORD PTR [eax+148]
  00434	75 5c		 jne	 SHORT $LN9@lzma_index@2
  00436	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00439	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0043c	89 55 94	 mov	 DWORD PTR tv439[ebp], edx
  0043f	89 45 90	 mov	 DWORD PTR tv440[ebp], eax
  00442	8b 4d 94	 mov	 ecx, DWORD PTR tv439[ebp]
  00445	8b 55 90	 mov	 edx, DWORD PTR tv440[ebp]
  00448	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0044b	3b 82 98 00 00
	00		 cmp	 eax, DWORD PTR [edx+152]
  00451	75 3f		 jne	 SHORT $LN9@lzma_index@2
  00453	8b 4d 94	 mov	 ecx, DWORD PTR tv439[ebp]
  00456	8b 55 90	 mov	 edx, DWORD PTR tv440[ebp]
  00459	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0045c	3b 82 9c 00 00
	00		 cmp	 eax, DWORD PTR [edx+156]
  00462	75 2e		 jne	 SHORT $LN9@lzma_index@2
  00464	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00467	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0046a	89 4d 8c	 mov	 DWORD PTR tv450[ebp], ecx
  0046d	89 55 88	 mov	 DWORD PTR tv451[ebp], edx
  00470	8b 45 8c	 mov	 eax, DWORD PTR tv450[ebp]
  00473	8b 4d 88	 mov	 ecx, DWORD PTR tv451[ebp]
  00476	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00479	3b 91 a8 00 00
	00		 cmp	 edx, DWORD PTR [ecx+168]
  0047f	75 11		 jne	 SHORT $LN9@lzma_index@2
  00481	8b 45 8c	 mov	 eax, DWORD PTR tv450[ebp]
  00484	8b 4d 88	 mov	 ecx, DWORD PTR tv451[ebp]
  00487	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0048a	3b 91 ac 00 00
	00		 cmp	 edx, DWORD PTR [ecx+172]
  00490	74 0a		 je	 SHORT $LN10@lzma_index@2
$LN9@lzma_index@2:

; 295  : 			return LZMA_DATA_ERROR;

  00492	b8 09 00 00 00	 mov	 eax, 9
  00497	e9 3e 01 00 00	 jmp	 $LN37@lzma_index@2
$LN10@lzma_index@2:

; 296  : 
; 297  : 		// Finish the hashes and compare them.
; 298  : 		lzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);

  0049c	6a 0a		 push	 10			; 0000000aH
  0049e	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  004a1	83 c0 28	 add	 eax, 40			; 00000028H
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 _lzma_check_finish
  004aa	83 c4 08	 add	 esp, 8

; 299  : 		lzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);

  004ad	6a 0a		 push	 10			; 0000000aH
  004af	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  004b2	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  004b8	51		 push	 ecx
  004b9	e8 00 00 00 00	 call	 _lzma_check_finish
  004be	83 c4 08	 add	 esp, 8

; 300  : 		if (memcmp(index_hash->blocks.check.buffer.u8,
; 301  : 				index_hash->records.check.buffer.u8,
; 302  : 				lzma_check_size(LZMA_CHECK_BEST)) != 0)

  004c1	6a 0a		 push	 10			; 0000000aH
  004c3	e8 00 00 00 00	 call	 _lzma_check_size
  004c8	83 c4 04	 add	 esp, 4
  004cb	50		 push	 eax
  004cc	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  004cf	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  004d5	52		 push	 edx
  004d6	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  004d9	83 c0 28	 add	 eax, 40			; 00000028H
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 _memcmp
  004e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e5	85 c0		 test	 eax, eax
  004e7	74 0a		 je	 SHORT $LN8@lzma_index@2

; 303  : 			return LZMA_DATA_ERROR;

  004e9	b8 09 00 00 00	 mov	 eax, 9
  004ee	e9 e7 00 00 00	 jmp	 $LN37@lzma_index@2
$LN8@lzma_index@2:

; 304  : 
; 305  : 		// Finish the CRC32 calculation.
; 306  : 		index_hash->crc32 = lzma_crc32(in + in_start,
; 307  : 				*in_pos - in_start, index_hash->crc32);

  004f3	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  004f6	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR [ecx+308]
  004fc	52		 push	 edx
  004fd	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  00500	8b 08		 mov	 ecx, DWORD PTR [eax]
  00502	2b 4d f8	 sub	 ecx, DWORD PTR _in_start$32379[ebp]
  00505	51		 push	 ecx
  00506	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00509	03 55 f8	 add	 edx, DWORD PTR _in_start$32379[ebp]
  0050c	52		 push	 edx
  0050d	e8 00 00 00 00	 call	 _lzma_crc32
  00512	83 c4 0c	 add	 esp, 12			; 0000000cH
  00515	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00518	89 81 34 01 00
	00		 mov	 DWORD PTR [ecx+308], eax

; 308  : 
; 309  : 		index_hash->sequence = SEQ_CRC32;

  0051e	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00521	c7 02 06 00 00
	00		 mov	 DWORD PTR [edx], 6
$LN6@lzma_index@2:

; 310  : 
; 311  : 	// Fall through
; 312  : 
; 313  : 	case SEQ_CRC32:
; 314  : 		do {
; 315  : 			if (*in_pos == in_size)

  00527	8b 45 10	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0052a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0052c	3b 4d 14	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  0052f	75 07		 jne	 SHORT $LN3@lzma_index@2

; 316  : 				return LZMA_OK;

  00531	33 c0		 xor	 eax, eax
  00533	e9 a2 00 00 00	 jmp	 $LN37@lzma_index@2
$LN3@lzma_index@2:

; 317  : 
; 318  : 			if (((index_hash->crc32 >> (index_hash->pos * 8))
; 319  : 					& 0xFF) != in[(*in_pos)++])

  00538	8b 55 10	 mov	 edx, DWORD PTR _in_pos$[ebp]
  0053b	8b 02		 mov	 eax, DWORD PTR [edx]
  0053d	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  00540	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00544	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00547	8b 88 30 01 00
	00		 mov	 ecx, DWORD PTR [eax+304]
  0054d	c1 e1 03	 shl	 ecx, 3
  00550	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  00553	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [eax+308]
  00559	d3 e8		 shr	 eax, cl
  0055b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00560	8b 4d 10	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00563	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00565	83 c1 01	 add	 ecx, 1
  00568	8b 75 10	 mov	 esi, DWORD PTR _in_pos$[ebp]
  0056b	89 0e		 mov	 DWORD PTR [esi], ecx
  0056d	3b c2		 cmp	 eax, edx
  0056f	74 07		 je	 SHORT $LN5@lzma_index@2

; 320  : 				return LZMA_DATA_ERROR;

  00571	b8 09 00 00 00	 mov	 eax, 9
  00576	eb 62		 jmp	 SHORT $LN37@lzma_index@2
$LN5@lzma_index@2:

; 321  : 
; 322  : 		} while (++index_hash->pos < 4);

  00578	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0057b	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00581	83 c0 01	 add	 eax, 1
  00584	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00587	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax
  0058d	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  00590	83 ba 30 01 00
	00 04		 cmp	 DWORD PTR [edx+304], 4
  00597	72 8e		 jb	 SHORT $LN6@lzma_index@2

; 323  : 
; 324  : 		return LZMA_STREAM_END;

  00599	b8 01 00 00 00	 mov	 eax, 1
  0059e	eb 3a		 jmp	 SHORT $LN37@lzma_index@2
$LN1@lzma_index@2:

; 325  : 
; 326  : 	default:
; 327  : 		assert(0);
; 328  : 		return LZMA_PROG_ERROR;

  005a0	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  005a5	eb 33		 jmp	 SHORT $LN37@lzma_index@2
$LN32@lzma_index@2:

; 329  : 	}

  005a7	e9 7e fa ff ff	 jmp	 $LN35@lzma_index@2
$out$32392:

; 330  : 
; 331  : out:
; 332  : 	// Update the CRC32,
; 333  : 	index_hash->crc32 = lzma_crc32(in + in_start,
; 334  : 			*in_pos - in_start, index_hash->crc32);

  005ac	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  005af	8b 88 34 01 00
	00		 mov	 ecx, DWORD PTR [eax+308]
  005b5	51		 push	 ecx
  005b6	8b 55 10	 mov	 edx, DWORD PTR _in_pos$[ebp]
  005b9	8b 02		 mov	 eax, DWORD PTR [edx]
  005bb	2b 45 f8	 sub	 eax, DWORD PTR _in_start$32379[ebp]
  005be	50		 push	 eax
  005bf	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  005c2	03 4d f8	 add	 ecx, DWORD PTR _in_start$32379[ebp]
  005c5	51		 push	 ecx
  005c6	e8 00 00 00 00	 call	 _lzma_crc32
  005cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ce	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  005d1	89 82 34 01 00
	00		 mov	 DWORD PTR [edx+308], eax

; 335  : 
; 336  : 	return ret;

  005d7	8b 45 fc	 mov	 eax, DWORD PTR _ret$32380[ebp]
$LN37@lzma_index@2:

; 337  :   }
; 338  : }

  005da	5e		 pop	 esi
  005db	8b e5		 mov	 esp, ebp
  005dd	5d		 pop	 ebp
  005de	c3		 ret	 0
  005df	90		 npad	 1
$LN54@lzma_index@2:
  005e0	00 00 00 00	 DD	 $LN31@lzma_index@2
  005e4	00 00 00 00	 DD	 $LN29@lzma_index@2
  005e8	00 00 00 00	 DD	 $LN26@lzma_index@2
  005ec	00 00 00 00	 DD	 $LN26@lzma_index@2
  005f0	00 00 00 00	 DD	 $LN14@lzma_index@2
  005f4	00 00 00 00	 DD	 $LN13@lzma_index@2
  005f8	00 00 00 00	 DD	 $LN6@lzma_index@2
_lzma_index_hash_decode ENDP
_TEXT	ENDS
PUBLIC	_lzma_index_hash_append
; Function compile flags: /Odtp
;	COMDAT _lzma_index_hash_append
_TEXT	SEGMENT
tv251 = -84						; size = 8
tv203 = -76						; size = 8
tv170 = -68						; size = 4
tv164 = -64						; size = 4
$T36249 = -60						; size = 8
$T36248 = -52						; size = 8
$T36247 = -44						; size = 8
$T36229 = -36						; size = 8
$T36223 = -28						; size = 8
$T36222 = -20						; size = 8
$T36212 = -12						; size = 8
_ret_$32365 = -4					; size = 4
_index_hash$ = 8					; size = 4
_unpadded_size$ = 12					; size = 8
_uncompressed_size$ = 20				; size = 8
_lzma_index_hash_append PROC				; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	56		 push	 esi

; 149  : 	// Validate the arguments.
; 150  : 	if (index_hash->sequence != SEQ_BLOCK
; 151  : 			|| unpadded_size < UNPADDED_SIZE_MIN
; 152  : 			|| unpadded_size > UNPADDED_SIZE_MAX
; 153  : 			|| uncompressed_size > LZMA_VLI_MAX)

  00007	8b 45 08	 mov	 eax, DWORD PTR _index_hash$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	75 2e		 jne	 SHORT $LN7@lzma_index@3
  0000f	83 7d 10 00	 cmp	 DWORD PTR _unpadded_size$[ebp+4], 0
  00013	77 06		 ja	 SHORT $LN25@lzma_index@3
  00015	83 7d 0c 05	 cmp	 DWORD PTR _unpadded_size$[ebp], 5
  00019	72 22		 jb	 SHORT $LN7@lzma_index@3
$LN25@lzma_index@3:
  0001b	81 7d 10 ff ff
	ff 7f		 cmp	 DWORD PTR _unpadded_size$[ebp+4], 2147483647 ; 7fffffffH
  00022	77 19		 ja	 SHORT $LN7@lzma_index@3
  00024	72 06		 jb	 SHORT $LN26@lzma_index@3
  00026	83 7d 0c fc	 cmp	 DWORD PTR _unpadded_size$[ebp], -4 ; fffffffcH
  0002a	77 11		 ja	 SHORT $LN7@lzma_index@3
$LN26@lzma_index@3:
  0002c	81 7d 18 ff ff
	ff 7f		 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 2147483647 ; 7fffffffH
  00033	72 12		 jb	 SHORT $LN6@lzma_index@3
  00035	77 06		 ja	 SHORT $LN7@lzma_index@3
  00037	83 7d 14 ff	 cmp	 DWORD PTR _uncompressed_size$[ebp], -1
  0003b	76 0a		 jbe	 SHORT $LN6@lzma_index@3
$LN7@lzma_index@3:

; 154  : 		return LZMA_PROG_ERROR;

  0003d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00042	e9 87 01 00 00	 jmp	 $LN9@lzma_index@3
$LN6@lzma_index@3:

; 155  : 
; 156  : 	// Update the hash.
; 157  : 	return_if_error(hash_append(&index_hash->blocks,
; 158  : 			unpadded_size, uncompressed_size));

  00047	8b 4d 18	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  0004a	51		 push	 ecx
  0004b	8b 55 14	 mov	 edx, DWORD PTR _uncompressed_size$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 10	 mov	 eax, DWORD PTR _unpadded_size$[ebp+4]
  00052	50		 push	 eax
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _unpadded_size$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 08	 mov	 edx, DWORD PTR _index_hash$[ebp]
  0005a	83 c2 08	 add	 edx, 8
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _hash_append
  00063	83 c4 14	 add	 esp, 20			; 00000014H
  00066	89 45 fc	 mov	 DWORD PTR _ret_$32365[ebp], eax
  00069	83 7d fc 00	 cmp	 DWORD PTR _ret_$32365[ebp], 0
  0006d	74 08		 je	 SHORT $LN5@lzma_index@3
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32365[ebp]
  00072	e9 57 01 00 00	 jmp	 $LN9@lzma_index@3
$LN5@lzma_index@3:
  00077	33 c0		 xor	 eax, eax
  00079	75 cc		 jne	 SHORT $LN6@lzma_index@3

; 159  : 
; 160  : 	// Validate the properties of *info are still in allowed limits.
; 161  : 	if (index_hash->blocks.blocks_size > LZMA_VLI_MAX
; 162  : 			|| index_hash->blocks.uncompressed_size > LZMA_VLI_MAX
; 163  : 			|| index_size(index_hash->blocks.count,
; 164  : 					index_hash->blocks.index_list_size)
; 165  : 				> LZMA_BACKWARD_SIZE_MAX
; 166  : 			|| index_stream_size(index_hash->blocks.blocks_size,
; 167  : 					index_hash->blocks.count,
; 168  : 					index_hash->blocks.index_list_size)
; 169  : 				> LZMA_VLI_MAX)

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  0007e	89 4d c0	 mov	 DWORD PTR tv164[ebp], ecx
  00081	8b 55 c0	 mov	 edx, DWORD PTR tv164[ebp]
  00084	81 7a 0c ff ff
	ff 7f		 cmp	 DWORD PTR [edx+12], 2147483647 ; 7fffffffH
  0008b	0f 87 34 01 00
	00		 ja	 $LN1@lzma_index@3
  00091	72 0d		 jb	 SHORT $LN28@lzma_index@3
  00093	8b 45 c0	 mov	 eax, DWORD PTR tv164[ebp]
  00096	83 78 08 ff	 cmp	 DWORD PTR [eax+8], -1
  0009a	0f 87 25 01 00
	00		 ja	 $LN1@lzma_index@3
$LN28@lzma_index@3:
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  000a3	89 4d bc	 mov	 DWORD PTR tv170[ebp], ecx
  000a6	8b 55 bc	 mov	 edx, DWORD PTR tv170[ebp]
  000a9	81 7a 14 ff ff
	ff 7f		 cmp	 DWORD PTR [edx+20], 2147483647 ; 7fffffffH
  000b0	0f 87 0f 01 00
	00		 ja	 $LN1@lzma_index@3
  000b6	72 0d		 jb	 SHORT $LN29@lzma_index@3
  000b8	8b 45 bc	 mov	 eax, DWORD PTR tv170[ebp]
  000bb	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  000bf	0f 87 00 01 00
	00		 ja	 $LN1@lzma_index@3
$LN29@lzma_index@3:
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  000c8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000cb	89 55 e4	 mov	 DWORD PTR $T36223[ebp], edx
  000ce	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  000d1	89 45 e8	 mov	 DWORD PTR $T36223[ebp+4], eax
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  000d7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000da	89 55 ec	 mov	 DWORD PTR $T36222[ebp], edx
  000dd	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000e0	89 45 f0	 mov	 DWORD PTR $T36222[ebp+4], eax
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR $T36222[ebp+4]
  000e6	51		 push	 ecx
  000e7	8b 55 ec	 mov	 edx, DWORD PTR $T36222[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _lzma_vli_size
  000f0	83 c4 08	 add	 esp, 8
  000f3	83 c0 01	 add	 eax, 1
  000f6	33 c9		 xor	 ecx, ecx
  000f8	03 45 e4	 add	 eax, DWORD PTR $T36223[ebp]
  000fb	13 4d e8	 adc	 ecx, DWORD PTR $T36223[ebp+4]
  000fe	83 c0 04	 add	 eax, 4
  00101	83 d1 00	 adc	 ecx, 0
  00104	89 45 f4	 mov	 DWORD PTR $T36212[ebp], eax
  00107	89 4d f8	 mov	 DWORD PTR $T36212[ebp+4], ecx
  0010a	8b 55 f4	 mov	 edx, DWORD PTR $T36212[ebp]
  0010d	83 c2 03	 add	 edx, 3
  00110	8b 45 f8	 mov	 eax, DWORD PTR $T36212[ebp+4]
  00113	83 d0 00	 adc	 eax, 0
  00116	83 e2 fc	 and	 edx, -4			; fffffffcH
  00119	89 55 b4	 mov	 DWORD PTR tv203[ebp], edx
  0011c	89 45 b8	 mov	 DWORD PTR tv203[ebp+4], eax
  0011f	83 7d b8 04	 cmp	 DWORD PTR tv203[ebp+4], 4
  00123	0f 87 9c 00 00
	00		 ja	 $LN1@lzma_index@3
  00129	72 0a		 jb	 SHORT $LN30@lzma_index@3
  0012b	83 7d b4 00	 cmp	 DWORD PTR tv203[ebp], 0
  0012f	0f 87 90 00 00
	00		 ja	 $LN1@lzma_index@3
$LN30@lzma_index@3:
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00138	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0013b	89 55 c4	 mov	 DWORD PTR $T36249[ebp], edx
  0013e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00141	89 45 c8	 mov	 DWORD PTR $T36249[ebp+4], eax
  00144	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00147	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0014a	89 55 cc	 mov	 DWORD PTR $T36248[ebp], edx
  0014d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00150	89 45 d0	 mov	 DWORD PTR $T36248[ebp+4], eax
  00153	8b 4d 08	 mov	 ecx, DWORD PTR _index_hash$[ebp]
  00156	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00159	89 55 d4	 mov	 DWORD PTR $T36247[ebp], edx
  0015c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0015f	89 45 d8	 mov	 DWORD PTR $T36247[ebp+4], eax
  00162	8b 4d d0	 mov	 ecx, DWORD PTR $T36248[ebp+4]
  00165	51		 push	 ecx
  00166	8b 55 cc	 mov	 edx, DWORD PTR $T36248[ebp]
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 _lzma_vli_size
  0016f	83 c4 08	 add	 esp, 8
  00172	83 c0 01	 add	 eax, 1
  00175	33 c9		 xor	 ecx, ecx
  00177	03 45 c4	 add	 eax, DWORD PTR $T36249[ebp]
  0017a	13 4d c8	 adc	 ecx, DWORD PTR $T36249[ebp+4]
  0017d	83 c0 04	 add	 eax, 4
  00180	83 d1 00	 adc	 ecx, 0
  00183	89 45 dc	 mov	 DWORD PTR $T36229[ebp], eax
  00186	89 4d e0	 mov	 DWORD PTR $T36229[ebp+4], ecx
  00189	8b 55 dc	 mov	 edx, DWORD PTR $T36229[ebp]
  0018c	83 c2 03	 add	 edx, 3
  0018f	8b 45 e0	 mov	 eax, DWORD PTR $T36229[ebp+4]
  00192	83 d0 00	 adc	 eax, 0
  00195	83 e2 fc	 and	 edx, -4			; fffffffcH
  00198	8b 4d d4	 mov	 ecx, DWORD PTR $T36247[ebp]
  0019b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0019e	8b 75 d8	 mov	 esi, DWORD PTR $T36247[ebp+4]
  001a1	83 d6 00	 adc	 esi, 0
  001a4	03 ca		 add	 ecx, edx
  001a6	13 f0		 adc	 esi, eax
  001a8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001ab	83 d6 00	 adc	 esi, 0
  001ae	89 4d ac	 mov	 DWORD PTR tv251[ebp], ecx
  001b1	89 75 b0	 mov	 DWORD PTR tv251[ebp+4], esi
  001b4	81 7d b0 ff ff
	ff 7f		 cmp	 DWORD PTR tv251[ebp+4], 2147483647 ; 7fffffffH
  001bb	72 0f		 jb	 SHORT $LN2@lzma_index@3
  001bd	77 06		 ja	 SHORT $LN1@lzma_index@3
  001bf	83 7d ac ff	 cmp	 DWORD PTR tv251[ebp], -1
  001c3	76 07		 jbe	 SHORT $LN2@lzma_index@3
$LN1@lzma_index@3:

; 170  : 		return LZMA_DATA_ERROR;

  001c5	b8 09 00 00 00	 mov	 eax, 9
  001ca	eb 02		 jmp	 SHORT $LN9@lzma_index@3
$LN2@lzma_index@3:

; 171  : 
; 172  : 	return LZMA_OK;

  001cc	33 c0		 xor	 eax, eax
$LN9@lzma_index@3:

; 173  : }

  001ce	5e		 pop	 esi
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
_lzma_index_hash_append ENDP
END
