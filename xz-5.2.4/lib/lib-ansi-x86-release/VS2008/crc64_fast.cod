; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\check\crc64_fast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_crc64
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\check\crc64_fast.c
;	COMDAT _lzma_crc64
_TEXT	SEGMENT
_tmp$32284 = -8						; size = 4
_limit$32278 = -4					; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_crc$ = 16						; size = 8
_lzma_crc64 PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 35   : 	crc = ~crc;

  00008	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _crc$[ebp+4]
  00010	f7 d1		 not	 ecx
  00012	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax
  00015	89 4d 14	 mov	 DWORD PTR _crc$[ebp+4], ecx

; 36   : 
; 37   : #ifdef WORDS_BIGENDIAN
; 38   : 	crc = bswap64(crc);
; 39   : #endif
; 40   : 
; 41   : 	if (size > 4) {

  00018	83 7d 0c 04	 cmp	 DWORD PTR _size$[ebp], 4
  0001c	0f 86 16 01 00
	00		 jbe	 $LN2@lzma_crc64
$LN6@lzma_crc64:

; 42   : 		while ((uintptr_t)(buf) & 3) {

  00022	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00025	83 e2 03	 and	 edx, 3
  00028	74 5a		 je	 SHORT $LN5@lzma_crc64

; 43   : 			crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00030	99		 cdq
  00031	8b 4d 10	 mov	 ecx, DWORD PTR _crc$[ebp]
  00034	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003a	8b 75 14	 mov	 esi, DWORD PTR _crc$[ebp+4]
  0003d	83 e6 00	 and	 esi, 0
  00040	33 c1		 xor	 eax, ecx
  00042	33 d6		 xor	 edx, esi
  00044	6a 00		 push	 0
  00046	6a 08		 push	 8
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __allmul
  0004f	8b f0		 mov	 esi, eax
  00051	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00054	8b 55 14	 mov	 edx, DWORD PTR _crc$[ebp+4]
  00057	b1 08		 mov	 cl, 8
  00059	e8 00 00 00 00	 call	 __aullshr
  0005e	33 86 00 00 00
	00		 xor	 eax, DWORD PTR _lzma_crc64_table[esi]
  00064	33 96 04 00 00
	00		 xor	 edx, DWORD PTR _lzma_crc64_table[esi+4]
  0006a	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax
  0006d	89 55 14	 mov	 DWORD PTR _crc$[ebp+4], edx
  00070	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	83 c2 01	 add	 edx, 1
  00076	89 55 08	 mov	 DWORD PTR _buf$[ebp], edx

; 44   : 			--size;

  00079	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0007c	83 e8 01	 sub	 eax, 1
  0007f	89 45 0c	 mov	 DWORD PTR _size$[ebp], eax

; 45   : 		}

  00082	eb 9e		 jmp	 SHORT $LN6@lzma_crc64
$LN5@lzma_crc64:

; 46   : 
; 47   : 	  {
; 48   : 		const uint8_t *const limit = buf + (size & ~(size_t)(3));

  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00087	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0008a	03 4d 08	 add	 ecx, DWORD PTR _buf$[ebp]
  0008d	89 4d fc	 mov	 DWORD PTR _limit$32278[ebp], ecx

; 49   : 		size &= (size_t)(3);

  00090	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00093	83 e2 03	 and	 edx, 3
  00096	89 55 0c	 mov	 DWORD PTR _size$[ebp], edx
$LN4@lzma_crc64:

; 50   : 
; 51   : 		while (buf < limit) {

  00099	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0009c	3b 45 fc	 cmp	 eax, DWORD PTR _limit$32278[ebp]
  0009f	0f 83 93 00 00
	00		 jae	 $LN2@lzma_crc64

; 52   : #ifdef WORDS_BIGENDIAN
; 53   : 			const uint32_t tmp = (crc >> 32)
; 54   : 					^ *(const uint32_t *)(buf);
; 55   : #else
; 56   : 			const uint32_t tmp = (const uint32_t)(crc ^ *(const uint32_t *)(buf));

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	33 c0		 xor	 eax, eax
  000ac	33 55 10	 xor	 edx, DWORD PTR _crc$[ebp]
  000af	33 45 14	 xor	 eax, DWORD PTR _crc$[ebp+4]
  000b2	89 55 f8	 mov	 DWORD PTR _tmp$32284[ebp], edx

; 57   : #endif
; 58   : 			buf += 4;

  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000b8	83 c1 04	 add	 ecx, 4
  000bb	89 4d 08	 mov	 DWORD PTR _buf$[ebp], ecx

; 59   : 
; 60   : 			crc = lzma_crc64_table[3][A(tmp)]
; 61   : 			    ^ lzma_crc64_table[2][B(tmp)]
; 62   : 			    ^ S32(crc)
; 63   : 			    ^ lzma_crc64_table[1][C(tmp)]
; 64   : 			    ^ lzma_crc64_table[0][D(tmp)];

  000be	8b 55 f8	 mov	 edx, DWORD PTR _tmp$32284[ebp]
  000c1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _tmp$32284[ebp]
  000ca	c1 e8 08	 shr	 eax, 8
  000cd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d2	8b 34 d5 00 18
	00 00		 mov	 esi, DWORD PTR _lzma_crc64_table[edx*8+6144]
  000d9	33 34 c5 00 10
	00 00		 xor	 esi, DWORD PTR _lzma_crc64_table[eax*8+4096]
  000e0	8b 3c d5 04 18
	00 00		 mov	 edi, DWORD PTR _lzma_crc64_table[edx*8+6148]
  000e7	33 3c c5 04 10
	00 00		 xor	 edi, DWORD PTR _lzma_crc64_table[eax*8+4100]
  000ee	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  000f1	8b 55 14	 mov	 edx, DWORD PTR _crc$[ebp+4]
  000f4	b1 20		 mov	 cl, 32			; 00000020H
  000f6	e8 00 00 00 00	 call	 __aullshr
  000fb	33 f0		 xor	 esi, eax
  000fd	33 fa		 xor	 edi, edx
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$32284[ebp]
  00102	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00105	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0010b	33 34 cd 00 08
	00 00		 xor	 esi, DWORD PTR _lzma_crc64_table[ecx*8+2048]
  00112	33 3c cd 04 08
	00 00		 xor	 edi, DWORD PTR _lzma_crc64_table[ecx*8+2052]
  00119	8b 55 f8	 mov	 edx, DWORD PTR _tmp$32284[ebp]
  0011c	c1 ea 18	 shr	 edx, 24			; 00000018H
  0011f	33 34 d5 00 00
	00 00		 xor	 esi, DWORD PTR _lzma_crc64_table[edx*8]
  00126	33 3c d5 04 00
	00 00		 xor	 edi, DWORD PTR _lzma_crc64_table[edx*8+4]
  0012d	89 75 10	 mov	 DWORD PTR _crc$[ebp], esi
  00130	89 7d 14	 mov	 DWORD PTR _crc$[ebp+4], edi

; 65   : 		}

  00133	e9 61 ff ff ff	 jmp	 $LN4@lzma_crc64
$LN2@lzma_crc64:

; 66   :       }
; 67   : 	}
; 68   : 
; 69   : 	while (size-- != 0)

  00138	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0013b	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0013e	83 e9 01	 sub	 ecx, 1
  00141	89 4d 0c	 mov	 DWORD PTR _size$[ebp], ecx
  00144	85 c0		 test	 eax, eax
  00146	74 51		 je	 SHORT $LN1@lzma_crc64

; 70   : 		crc = lzma_crc64_table[0][*buf++ ^ A1(crc)] ^ S8(crc);

  00148	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0014b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0014e	99		 cdq
  0014f	8b 4d 10	 mov	 ecx, DWORD PTR _crc$[ebp]
  00152	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00158	8b 75 14	 mov	 esi, DWORD PTR _crc$[ebp+4]
  0015b	83 e6 00	 and	 esi, 0
  0015e	33 c1		 xor	 eax, ecx
  00160	33 d6		 xor	 edx, esi
  00162	6a 00		 push	 0
  00164	6a 08		 push	 8
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 __allmul
  0016d	8b f0		 mov	 esi, eax
  0016f	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00172	8b 55 14	 mov	 edx, DWORD PTR _crc$[ebp+4]
  00175	b1 08		 mov	 cl, 8
  00177	e8 00 00 00 00	 call	 __aullshr
  0017c	33 86 00 00 00
	00		 xor	 eax, DWORD PTR _lzma_crc64_table[esi]
  00182	33 96 04 00 00
	00		 xor	 edx, DWORD PTR _lzma_crc64_table[esi+4]
  00188	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax
  0018b	89 55 14	 mov	 DWORD PTR _crc$[ebp+4], edx
  0018e	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00191	83 c2 01	 add	 edx, 1
  00194	89 55 08	 mov	 DWORD PTR _buf$[ebp], edx
  00197	eb 9f		 jmp	 SHORT $LN2@lzma_crc64
$LN1@lzma_crc64:

; 71   : 
; 72   : #ifdef WORDS_BIGENDIAN
; 73   : 	crc = bswap64(crc);
; 74   : #endif
; 75   : 
; 76   : 	return ~crc;

  00199	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  0019c	f7 d0		 not	 eax
  0019e	8b 55 14	 mov	 edx, DWORD PTR _crc$[ebp+4]
  001a1	f7 d2		 not	 edx

; 77   : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c3		 ret	 0
_lzma_crc64 ENDP
END
