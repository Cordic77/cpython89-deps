; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_header_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT _write32ne
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_num$ = 12						; size = 4
_write32ne PROC						; COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	*(uint32_t *)buf = num;

  00003	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 	return;
; 269  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_write32ne ENDP
PUBLIC	_lzma_block_header_encode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_header_encoder.c
;	COMDAT _lzma_block_header_encode
_TEXT	SEGMENT
tv274 = -64						; size = 4
tv273 = -60						; size = 4
tv254 = -56						; size = 4
tv232 = -52						; size = 4
tv211 = -48						; size = 4
tv199 = -44						; size = 4
tv193 = -40						; size = 4
tv186 = -36						; size = 8
$T78790 = -28						; size = 4
_ret_$32326 = -24					; size = 4
_filter_count$32318 = -20				; size = 4
_ret_$32312 = -16					; size = 4
_ret_$32305 = -12					; size = 4
_out_pos$32300 = -8					; size = 4
_out_size$32298 = -4					; size = 4
_block$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_block_header_encode PROC				; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi

; 82   : 	// Validate everything but filters.
; 83   : 	if (lzma_block_unpadded_size(block) == 0
; 84   : 			|| !lzma_vli_is_valid(block->uncompressed_size))

  00007	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _lzma_block_unpadded_size
  00010	83 c4 04	 add	 esp, 4
  00013	89 45 dc	 mov	 DWORD PTR tv186[ebp], eax
  00016	89 55 e0	 mov	 DWORD PTR tv186[ebp+4], edx
  00019	8b 4d dc	 mov	 ecx, DWORD PTR tv186[ebp]
  0001c	0b 4d e0	 or	 ecx, DWORD PTR tv186[ebp+4]
  0001f	74 34		 je	 SHORT $LN21@lzma_block@4
  00021	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00024	89 55 d8	 mov	 DWORD PTR tv193[ebp], edx
  00027	8b 45 d8	 mov	 eax, DWORD PTR tv193[ebp]
  0002a	81 78 1c ff ff
	ff 7f		 cmp	 DWORD PTR [eax+28], 2147483647 ; 7fffffffH
  00031	72 2c		 jb	 SHORT $LN22@lzma_block@4
  00033	77 09		 ja	 SHORT $LN27@lzma_block@4
  00035	8b 4d d8	 mov	 ecx, DWORD PTR tv193[ebp]
  00038	83 79 18 ff	 cmp	 DWORD PTR [ecx+24], -1
  0003c	76 21		 jbe	 SHORT $LN22@lzma_block@4
$LN27@lzma_block@4:
  0003e	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00041	89 55 d4	 mov	 DWORD PTR tv199[ebp], edx
  00044	8b 45 d4	 mov	 eax, DWORD PTR tv199[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR tv199[ebp]
  0004a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0004d	23 51 1c	 and	 edx, DWORD PTR [ecx+28]
  00050	83 fa ff	 cmp	 edx, -1
  00053	74 0a		 je	 SHORT $LN22@lzma_block@4
$LN21@lzma_block@4:

; 85   : 		return LZMA_PROG_ERROR;

  00055	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0005a	e9 dd 01 00 00	 jmp	 $LN23@lzma_block@4
$LN22@lzma_block@4:

; 86   : 
; 87   : 	// Indicate the size of the buffer _excluding_ the CRC32 field.
; 88   :   {
; 89   : 	const size_t out_size = block->header_size - 4;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	83 e9 04	 sub	 ecx, 4
  00068	89 4d fc	 mov	 DWORD PTR _out_size$32298[ebp], ecx

; 90   : 
; 91   : 	// Store the Block Header Size.
; 92   : 	out[0] = (uint8_t)(out_size / 4);

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _out_size$32298[ebp]
  0006e	c1 ea 02	 shr	 edx, 2
  00071	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00074	88 10		 mov	 BYTE PTR [eax], dl

; 93   : 
; 94   : 	// We write Block Flags in pieces.
; 95   : 	out[1] = 0x00;

  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00079	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 96   :   {
; 97   : 	size_t out_pos = 2;

  0007d	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _out_pos$32300[ebp], 2

; 98   : 
; 99   : 	// Compressed Size
; 100  : 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {

  00084	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00087	89 55 d0	 mov	 DWORD PTR tv211[ebp], edx
  0008a	8b 45 d0	 mov	 eax, DWORD PTR tv211[ebp]
  0008d	8b 4d d0	 mov	 ecx, DWORD PTR tv211[ebp]
  00090	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00093	23 51 14	 and	 edx, DWORD PTR [ecx+20]
  00096	83 fa ff	 cmp	 edx, -1
  00099	74 46		 je	 SHORT $LN20@lzma_block@4
$LN19@lzma_block@4:

; 101  : 		return_if_error(lzma_vli_encode(block->compressed_size, NULL,
; 102  : 				out, &out_pos, out_size));

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _out_size$32298[ebp]
  0009e	50		 push	 eax
  0009f	8d 4d f8	 lea	 ecx, DWORD PTR _out_pos$32300[ebp]
  000a2	51		 push	 ecx
  000a3	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000af	51		 push	 ecx
  000b0	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 _lzma_vli_encode
  000b9	83 c4 18	 add	 esp, 24			; 00000018H
  000bc	89 45 f4	 mov	 DWORD PTR _ret_$32305[ebp], eax
  000bf	83 7d f4 00	 cmp	 DWORD PTR _ret_$32305[ebp], 0
  000c3	74 08		 je	 SHORT $LN18@lzma_block@4
  000c5	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32305[ebp]
  000c8	e9 6f 01 00 00	 jmp	 $LN23@lzma_block@4
$LN18@lzma_block@4:
  000cd	33 c0		 xor	 eax, eax
  000cf	75 ca		 jne	 SHORT $LN19@lzma_block@4

; 103  : 
; 104  : 		out[1] |= 0x40;

  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  000d4	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  000d8	83 ca 40	 or	 edx, 64			; 00000040H
  000db	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000de	88 50 01	 mov	 BYTE PTR [eax+1], dl
$LN20@lzma_block@4:

; 105  : 	}
; 106  : 
; 107  : 	// Uncompressed Size
; 108  : 	if (block->uncompressed_size != LZMA_VLI_UNKNOWN) {

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  000e4	89 4d cc	 mov	 DWORD PTR tv232[ebp], ecx
  000e7	8b 55 cc	 mov	 edx, DWORD PTR tv232[ebp]
  000ea	8b 45 cc	 mov	 eax, DWORD PTR tv232[ebp]
  000ed	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  000f0	23 48 1c	 and	 ecx, DWORD PTR [eax+28]
  000f3	83 f9 ff	 cmp	 ecx, -1
  000f6	74 49		 je	 SHORT $LN15@lzma_block@4
$LN14@lzma_block@4:

; 109  : 		return_if_error(lzma_vli_encode(block->uncompressed_size, NULL,
; 110  : 				out, &out_pos, out_size));

  000f8	8b 55 fc	 mov	 edx, DWORD PTR _out_size$32298[ebp]
  000fb	52		 push	 edx
  000fc	8d 45 f8	 lea	 eax, DWORD PTR _out_pos$32300[ebp]
  000ff	50		 push	 eax
  00100	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00103	51		 push	 ecx
  00104	6a 00		 push	 0
  00106	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00109	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0010c	50		 push	 eax
  0010d	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _lzma_vli_encode
  00116	83 c4 18	 add	 esp, 24			; 00000018H
  00119	89 45 f0	 mov	 DWORD PTR _ret_$32312[ebp], eax
  0011c	83 7d f0 00	 cmp	 DWORD PTR _ret_$32312[ebp], 0
  00120	74 08		 je	 SHORT $LN13@lzma_block@4
  00122	8b 45 f0	 mov	 eax, DWORD PTR _ret_$32312[ebp]
  00125	e9 12 01 00 00	 jmp	 $LN23@lzma_block@4
$LN13@lzma_block@4:
  0012a	33 d2		 xor	 edx, edx
  0012c	75 ca		 jne	 SHORT $LN14@lzma_block@4

; 111  : 
; 112  : 		out[1] |= 0x80;

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00131	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00135	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0013e	88 4a 01	 mov	 BYTE PTR [edx+1], cl
$LN15@lzma_block@4:

; 113  : 	}
; 114  : 
; 115  : 	// Filter Flags
; 116  : 	if (block->filters == NULL || block->filters[0].id == LZMA_VLI_UNKNOWN)

  00141	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00144	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00148	74 19		 je	 SHORT $LN9@lzma_block@4
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0014d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00150	89 55 c8	 mov	 DWORD PTR tv254[ebp], edx
  00153	8b 45 c8	 mov	 eax, DWORD PTR tv254[ebp]
  00156	8b 4d c8	 mov	 ecx, DWORD PTR tv254[ebp]
  00159	8b 10		 mov	 edx, DWORD PTR [eax]
  0015b	23 51 04	 and	 edx, DWORD PTR [ecx+4]
  0015e	83 fa ff	 cmp	 edx, -1
  00161	75 0a		 jne	 SHORT $LN10@lzma_block@4
$LN9@lzma_block@4:

; 117  : 		return LZMA_PROG_ERROR;

  00163	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00168	e9 cf 00 00 00	 jmp	 $LN23@lzma_block@4
$LN10@lzma_block@4:

; 118  : 
; 119  :   {
; 120  : 	size_t filter_count = 0;

  0016d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _filter_count$32318[ebp], 0
$LN8@lzma_block@4:

; 121  : 	do {
; 122  : 		// There can be a maximum of four filters.
; 123  : 		if (filter_count == LZMA_FILTERS_MAX)

  00174	83 7d ec 04	 cmp	 DWORD PTR _filter_count$32318[ebp], 4
  00178	75 0a		 jne	 SHORT $LN4@lzma_block@4

; 124  : 			return LZMA_PROG_ERROR;

  0017a	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0017f	e9 b8 00 00 00	 jmp	 $LN23@lzma_block@4
$LN4@lzma_block@4:

; 125  : 
; 126  : 		return_if_error(lzma_filter_flags_encode(
; 127  : 				block->filters + filter_count,
; 128  : 				out, &out_pos, out_size));

  00184	8b 45 fc	 mov	 eax, DWORD PTR _out_size$32298[ebp]
  00187	50		 push	 eax
  00188	8d 4d f8	 lea	 ecx, DWORD PTR _out_pos$32300[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 ec	 mov	 eax, DWORD PTR _filter_count$32318[ebp]
  00193	c1 e0 04	 shl	 eax, 4
  00196	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00199	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _lzma_filter_flags_encode
  001a2	83 c4 10	 add	 esp, 16			; 00000010H
  001a5	89 45 e8	 mov	 DWORD PTR _ret_$32326[ebp], eax
  001a8	83 7d e8 00	 cmp	 DWORD PTR _ret_$32326[ebp], 0
  001ac	74 08		 je	 SHORT $LN3@lzma_block@4
  001ae	8b 45 e8	 mov	 eax, DWORD PTR _ret_$32326[ebp]
  001b1	e9 86 00 00 00	 jmp	 $LN23@lzma_block@4
$LN3@lzma_block@4:
  001b6	33 d2		 xor	 edx, edx
  001b8	75 ca		 jne	 SHORT $LN4@lzma_block@4

; 129  : 
; 130  : 	} while (block->filters[++filter_count].id != LZMA_VLI_UNKNOWN);

  001ba	8b 45 ec	 mov	 eax, DWORD PTR _filter_count$32318[ebp]
  001bd	83 c0 01	 add	 eax, 1
  001c0	89 45 ec	 mov	 DWORD PTR _filter_count$32318[ebp], eax
  001c3	8b 4d ec	 mov	 ecx, DWORD PTR _filter_count$32318[ebp]
  001c6	c1 e1 04	 shl	 ecx, 4
  001c9	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  001cc	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001cf	89 4d c4	 mov	 DWORD PTR tv273[ebp], ecx
  001d2	89 45 c0	 mov	 DWORD PTR tv274[ebp], eax
  001d5	8b 4d c0	 mov	 ecx, DWORD PTR tv274[ebp]
  001d8	8b 55 c4	 mov	 edx, DWORD PTR tv273[ebp]
  001db	8b 45 c0	 mov	 eax, DWORD PTR tv274[ebp]
  001de	8b 75 c4	 mov	 esi, DWORD PTR tv273[ebp]
  001e1	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  001e4	23 4c 06 04	 and	 ecx, DWORD PTR [esi+eax+4]
  001e8	83 f9 ff	 cmp	 ecx, -1
  001eb	75 87		 jne	 SHORT $LN8@lzma_block@4

; 131  : 
; 132  : 	out[1] |= filter_count - 1;

  001ed	8b 55 ec	 mov	 edx, DWORD PTR _filter_count$32318[ebp]
  001f0	83 ea 01	 sub	 edx, 1
  001f3	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  001f6	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001fa	0b ca		 or	 ecx, edx
  001fc	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  001ff	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 133  : 
; 134  : 	// Padding
; 135  : 	memzero(out + out_pos, out_size - out_pos);

  00202	8b 45 fc	 mov	 eax, DWORD PTR _out_size$32298[ebp]
  00205	2b 45 f8	 sub	 eax, DWORD PTR _out_pos$32300[ebp]
  00208	50		 push	 eax
  00209	6a 00		 push	 0
  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0020e	03 4d f8	 add	 ecx, DWORD PTR _out_pos$32300[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 _memset
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH

; 136  : 
; 137  : 	// CRC32
; 138  : 	unaligned_write32le(out + out_size, lzma_crc32(out, out_size, 0));

  0021a	6a 00		 push	 0
  0021c	8b 55 fc	 mov	 edx, DWORD PTR _out_size$32298[ebp]
  0021f	52		 push	 edx
  00220	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _lzma_crc32
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022c	89 45 e4	 mov	 DWORD PTR $T78790[ebp], eax
  0022f	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00232	03 4d fc	 add	 ecx, DWORD PTR _out_size$32298[ebp]
  00235	8b 55 e4	 mov	 edx, DWORD PTR $T78790[ebp]
  00238	89 11		 mov	 DWORD PTR [ecx], edx

; 139  :   }}}
; 140  : 
; 141  : 	return LZMA_OK;

  0023a	33 c0		 xor	 eax, eax
$LN23@lzma_block@4:

; 142  : }

  0023c	5e		 pop	 esi
  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
_lzma_block_header_encode ENDP
_TEXT	ENDS
PUBLIC	_lzma_block_header_size
; Function compile flags: /Odtp
;	COMDAT _lzma_block_header_size
_TEXT	SEGMENT
tv192 = -48						; size = 4
tv191 = -44						; size = 4
tv181 = -40						; size = 4
tv164 = -36						; size = 4
tv155 = -32						; size = 4
tv141 = -28						; size = 4
_ret_$32289 = -24					; size = 4
_add$32285 = -20					; size = 4
_i$32280 = -16						; size = 4
_add$32275 = -12					; size = 4
_add$32271 = -8						; size = 4
_size$32269 = -4					; size = 4
_block$ = 8						; size = 4
_lzma_block_header_size PROC				; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi

; 20   : 	if (block->version > 1)

  00007	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0000a	83 38 01	 cmp	 DWORD PTR [eax], 1
  0000d	76 0a		 jbe	 SHORT $LN16@lzma_block@5

; 21   : 		return LZMA_OPTIONS_ERROR;

  0000f	b8 08 00 00 00	 mov	 eax, 8
  00014	e9 63 01 00 00	 jmp	 $LN17@lzma_block@5
$LN16@lzma_block@5:

; 22   : 
; 23   : 	// Block Header Size + Block Flags + CRC32.
; 24   :   {
; 25   :   uint32_t size = 1 + 1 + 4;

  00019	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR _size$32269[ebp], 6

; 26   : 
; 27   : 	// Compressed Size
; 28   : 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00023	89 4d e4	 mov	 DWORD PTR tv141[ebp], ecx
  00026	8b 55 e4	 mov	 edx, DWORD PTR tv141[ebp]
  00029	8b 45 e4	 mov	 eax, DWORD PTR tv141[ebp]
  0002c	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0002f	23 48 14	 and	 ecx, DWORD PTR [eax+20]
  00032	83 f9 ff	 cmp	 ecx, -1
  00035	74 43		 je	 SHORT $LN15@lzma_block@5

; 29   : 		const uint32_t add = lzma_vli_size(block->compressed_size);

  00037	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0003a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0003d	50		 push	 eax
  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _lzma_vli_size
  00047	83 c4 08	 add	 esp, 8
  0004a	89 45 f8	 mov	 DWORD PTR _add$32271[ebp], eax

; 30   : 		if (add == 0 || block->compressed_size == 0)

  0004d	83 7d f8 00	 cmp	 DWORD PTR _add$32271[ebp], 0
  00051	74 14		 je	 SHORT $LN13@lzma_block@5
  00053	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00056	89 55 e0	 mov	 DWORD PTR tv155[ebp], edx
  00059	8b 45 e0	 mov	 eax, DWORD PTR tv155[ebp]
  0005c	8b 4d e0	 mov	 ecx, DWORD PTR tv155[ebp]
  0005f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00062	0b 51 14	 or	 edx, DWORD PTR [ecx+20]
  00065	75 0a		 jne	 SHORT $LN14@lzma_block@5
$LN13@lzma_block@5:

; 31   : 			return LZMA_PROG_ERROR;

  00067	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0006c	e9 0b 01 00 00	 jmp	 $LN17@lzma_block@5
$LN14@lzma_block@5:

; 32   : 
; 33   : 		size += add;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _size$32269[ebp]
  00074	03 45 f8	 add	 eax, DWORD PTR _add$32271[ebp]
  00077	89 45 fc	 mov	 DWORD PTR _size$32269[ebp], eax
$LN15@lzma_block@5:

; 34   : 	}
; 35   : 
; 36   : 	// Uncompressed Size
; 37   : 	if (block->uncompressed_size != LZMA_VLI_UNKNOWN) {

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0007d	89 4d dc	 mov	 DWORD PTR tv164[ebp], ecx
  00080	8b 55 dc	 mov	 edx, DWORD PTR tv164[ebp]
  00083	8b 45 dc	 mov	 eax, DWORD PTR tv164[ebp]
  00086	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00089	23 48 1c	 and	 ecx, DWORD PTR [eax+28]
  0008c	83 f9 ff	 cmp	 ecx, -1
  0008f	74 2f		 je	 SHORT $LN12@lzma_block@5

; 38   : 		const uint32_t add = lzma_vli_size(block->uncompressed_size);

  00091	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00094	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00097	50		 push	 eax
  00098	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _lzma_vli_size
  000a1	83 c4 08	 add	 esp, 8
  000a4	89 45 f4	 mov	 DWORD PTR _add$32275[ebp], eax

; 39   : 		if (add == 0)

  000a7	83 7d f4 00	 cmp	 DWORD PTR _add$32275[ebp], 0
  000ab	75 0a		 jne	 SHORT $LN11@lzma_block@5

; 40   : 			return LZMA_PROG_ERROR;

  000ad	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000b2	e9 c5 00 00 00	 jmp	 $LN17@lzma_block@5
$LN11@lzma_block@5:

; 41   : 
; 42   : 		size += add;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _size$32269[ebp]
  000ba	03 55 f4	 add	 edx, DWORD PTR _add$32275[ebp]
  000bd	89 55 fc	 mov	 DWORD PTR _size$32269[ebp], edx
$LN12@lzma_block@5:

; 43   : 	}
; 44   : 
; 45   : 	// List of Filter Flags
; 46   : 	if (block->filters == NULL || block->filters[0].id == LZMA_VLI_UNKNOWN)

  000c0	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000c3	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000c7	74 19		 je	 SHORT $LN9@lzma_block@5
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  000cc	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000cf	89 55 d8	 mov	 DWORD PTR tv181[ebp], edx
  000d2	8b 45 d8	 mov	 eax, DWORD PTR tv181[ebp]
  000d5	8b 4d d8	 mov	 ecx, DWORD PTR tv181[ebp]
  000d8	8b 10		 mov	 edx, DWORD PTR [eax]
  000da	23 51 04	 and	 edx, DWORD PTR [ecx+4]
  000dd	83 fa ff	 cmp	 edx, -1
  000e0	75 0a		 jne	 SHORT $LN10@lzma_block@5
$LN9@lzma_block@5:

; 47   : 		return LZMA_PROG_ERROR;

  000e2	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000e7	e9 90 00 00 00	 jmp	 $LN17@lzma_block@5
$LN10@lzma_block@5:

; 48   : 
; 49   :   { size_t i;
; 50   : 
; 51   : 	for (i = 0; block->filters[i].id != LZMA_VLI_UNKNOWN; ++i) {

  000ec	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$32280[ebp], 0
  000f3	eb 09		 jmp	 SHORT $LN8@lzma_block@5
$LN7@lzma_block@5:
  000f5	8b 45 f0	 mov	 eax, DWORD PTR _i$32280[ebp]
  000f8	83 c0 01	 add	 eax, 1
  000fb	89 45 f0	 mov	 DWORD PTR _i$32280[ebp], eax
$LN8@lzma_block@5:
  000fe	8b 4d f0	 mov	 ecx, DWORD PTR _i$32280[ebp]
  00101	c1 e1 04	 shl	 ecx, 4
  00104	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00107	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0010a	89 4d d4	 mov	 DWORD PTR tv191[ebp], ecx
  0010d	89 45 d0	 mov	 DWORD PTR tv192[ebp], eax
  00110	8b 4d d0	 mov	 ecx, DWORD PTR tv192[ebp]
  00113	8b 55 d4	 mov	 edx, DWORD PTR tv191[ebp]
  00116	8b 45 d0	 mov	 eax, DWORD PTR tv192[ebp]
  00119	8b 75 d4	 mov	 esi, DWORD PTR tv191[ebp]
  0011c	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0011f	23 4c 06 04	 and	 ecx, DWORD PTR [esi+eax+4]
  00123	83 f9 ff	 cmp	 ecx, -1
  00126	74 43		 je	 SHORT $LN6@lzma_block@5

; 52   : 		// Don't allow too many filters.
; 53   : 		if (i == LZMA_FILTERS_MAX)

  00128	83 7d f0 04	 cmp	 DWORD PTR _i$32280[ebp], 4
  0012c	75 07		 jne	 SHORT $LN4@lzma_block@5

; 54   : 			return LZMA_PROG_ERROR;

  0012e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00133	eb 47		 jmp	 SHORT $LN17@lzma_block@5
$LN4@lzma_block@5:

; 55   : 
; 56   : 	  { uint32_t add;
; 57   : 		return_if_error(lzma_filter_flags_size(&add,
; 58   : 				block->filters + i));

  00135	8b 55 f0	 mov	 edx, DWORD PTR _i$32280[ebp]
  00138	c1 e2 04	 shl	 edx, 4
  0013b	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0013e	03 50 20	 add	 edx, DWORD PTR [eax+32]
  00141	52		 push	 edx
  00142	8d 4d ec	 lea	 ecx, DWORD PTR _add$32285[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _lzma_filter_flags_size
  0014b	83 c4 08	 add	 esp, 8
  0014e	89 45 e8	 mov	 DWORD PTR _ret_$32289[ebp], eax
  00151	83 7d e8 00	 cmp	 DWORD PTR _ret_$32289[ebp], 0
  00155	74 05		 je	 SHORT $LN3@lzma_block@5
  00157	8b 45 e8	 mov	 eax, DWORD PTR _ret_$32289[ebp]
  0015a	eb 20		 jmp	 SHORT $LN17@lzma_block@5
$LN3@lzma_block@5:
  0015c	33 d2		 xor	 edx, edx
  0015e	75 d5		 jne	 SHORT $LN4@lzma_block@5

; 59   : 
; 60   : 		size += add;

  00160	8b 45 fc	 mov	 eax, DWORD PTR _size$32269[ebp]
  00163	03 45 ec	 add	 eax, DWORD PTR _add$32285[ebp]
  00166	89 45 fc	 mov	 DWORD PTR _size$32269[ebp], eax

; 61   : 	  }
; 62   : 	}

  00169	eb 8a		 jmp	 SHORT $LN7@lzma_block@5
$LN6@lzma_block@5:

; 63   :   }
; 64   : 
; 65   : 	// Pad to a multiple of four bytes.
; 66   : 	block->header_size = (size + 3) & ~UINT32_C(3);

  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _size$32269[ebp]
  0016e	83 c1 03	 add	 ecx, 3
  00171	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00174	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00177	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 67   :   }
; 68   : 
; 69   : 	// NOTE: We don't verify that the encoded size of the Block stays
; 70   : 	// within limits. This is because it is possible that we are called
; 71   : 	// with exaggerated Compressed Size (e.g. LZMA_VLI_MAX) to reserve
; 72   : 	// space for Block Header, and later called again with lower,
; 73   : 	// real values.
; 74   : 
; 75   : 	return LZMA_OK;

  0017a	33 c0		 xor	 eax, eax
$LN17@lzma_block@5:

; 76   : }

  0017c	5e		 pop	 esi
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
_lzma_block_header_size ENDP
END
