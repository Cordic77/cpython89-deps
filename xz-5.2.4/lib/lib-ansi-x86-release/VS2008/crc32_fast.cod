; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\check\crc32_fast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_crc32
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\check\crc32_fast.c
;	COMDAT _lzma_crc32
_TEXT	SEGMENT
_tmp$32285 = -8						; size = 4
_limit$32278 = -4					; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_crc$ = 16						; size = 4
_lzma_crc32 PROC					; COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 32   : 	crc = ~crc;

  00006	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00009	f7 d0		 not	 eax
  0000b	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax

; 33   : 
; 34   : #ifdef WORDS_BIGENDIAN
; 35   : 	crc = bswap32(crc);
; 36   : #endif
; 37   : 
; 38   : 	if (size > 8) {

  0000e	83 7d 0c 08	 cmp	 DWORD PTR _size$[ebp], 8
  00012	0f 86 16 01 00
	00		 jbe	 $LN2@lzma_crc32
$LN6@lzma_crc32:

; 39   : 		// Fix the alignment, if needed. The if statement above
; 40   : 		// ensures that this won't read past the end of buf[].
; 41   : 		while ((uintptr_t)(buf) & 7) {

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0001b	83 e1 07	 and	 ecx, 7
  0001e	74 35		 je	 SHORT $LN5@lzma_crc32

; 42   : 			crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);

  00020	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00023	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00026	8b 4d 10	 mov	 ecx, DWORD PTR _crc$[ebp]
  00029	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002f	33 c1		 xor	 eax, ecx
  00031	8b 55 10	 mov	 edx, DWORD PTR _crc$[ebp]
  00034	c1 ea 08	 shr	 edx, 8
  00037	33 14 85 00 00
	00 00		 xor	 edx, DWORD PTR _lzma_crc32_table[eax*4]
  0003e	89 55 10	 mov	 DWORD PTR _crc$[ebp], edx
  00041	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax

; 43   : 			--size;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	89 4d 0c	 mov	 DWORD PTR _size$[ebp], ecx

; 44   : 		}

  00053	eb c3		 jmp	 SHORT $LN6@lzma_crc32
$LN5@lzma_crc32:

; 45   : 
; 46   : 		// Calculate the position where to stop.
; 47   : 	  {
; 48   : 		const uint8_t *const limit = buf + (size & ~(size_t)(7));

  00055	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00058	83 e2 f8	 and	 edx, -8			; fffffff8H
  0005b	03 55 08	 add	 edx, DWORD PTR _buf$[ebp]
  0005e	89 55 fc	 mov	 DWORD PTR _limit$32278[ebp], edx

; 49   : 
; 50   : 		// Calculate how many bytes must be calculated separately
; 51   : 		// before returning the result.
; 52   : 		size &= (size_t)(7);

  00061	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00064	83 e0 07	 and	 eax, 7
  00067	89 45 0c	 mov	 DWORD PTR _size$[ebp], eax
$LN4@lzma_crc32:

; 53   : 
; 54   : 		// Calculate the CRC32 using the slice-by-eight algorithm.
; 55   : 		while (buf < limit) {

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0006d	3b 4d fc	 cmp	 ecx, DWORD PTR _limit$32278[ebp]
  00070	0f 83 b8 00 00
	00		 jae	 $LN2@lzma_crc32

; 56   : 			crc ^= *(const uint32_t *)(buf);

  00076	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00079	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  0007c	33 02		 xor	 eax, DWORD PTR [edx]
  0007e	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax

; 57   : 			buf += 4;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00084	83 c1 04	 add	 ecx, 4
  00087	89 4d 08	 mov	 DWORD PTR _buf$[ebp], ecx

; 58   : 
; 59   : 			crc = lzma_crc32_table[7][A(crc)]
; 60   : 			    ^ lzma_crc32_table[6][B(crc)]
; 61   : 			    ^ lzma_crc32_table[5][C(crc)]
; 62   : 			    ^ lzma_crc32_table[4][D(crc)];

  0008a	8b 55 10	 mov	 edx, DWORD PTR _crc$[ebp]
  0008d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00093	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00096	c1 e8 08	 shr	 eax, 8
  00099	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009e	8b 0c 95 00 1c
	00 00		 mov	 ecx, DWORD PTR _lzma_crc32_table[edx*4+7168]
  000a5	33 0c 85 00 18
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[eax*4+6144]
  000ac	8b 55 10	 mov	 edx, DWORD PTR _crc$[ebp]
  000af	c1 ea 10	 shr	 edx, 16			; 00000010H
  000b2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b8	33 0c 95 00 14
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4+5120]
  000bf	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  000c2	c1 e8 18	 shr	 eax, 24			; 00000018H
  000c5	33 0c 85 00 10
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[eax*4+4096]
  000cc	89 4d 10	 mov	 DWORD PTR _crc$[ebp], ecx

; 63   : 
; 64   : 		  {
; 65   : 			const uint32_t tmp = *(const uint32_t *)(buf);

  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d4	89 55 f8	 mov	 DWORD PTR _tmp$32285[ebp], edx

; 66   : 			buf += 4;

  000d7	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000da	83 c0 04	 add	 eax, 4
  000dd	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax

; 67   : 
; 68   : 			// At least with some compilers, it is critical for
; 69   : 			// performance, that the crc variable is XORed
; 70   : 			// between the two table-lookup pairs.
; 71   : 			crc = lzma_crc32_table[3][A(tmp)]
; 72   : 			    ^ lzma_crc32_table[2][B(tmp)]
; 73   : 			    ^ crc
; 74   : 			    ^ lzma_crc32_table[1][C(tmp)]
; 75   : 			    ^ lzma_crc32_table[0][D(tmp)];

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$32285[ebp]
  000e3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e9	8b 55 f8	 mov	 edx, DWORD PTR _tmp$32285[ebp]
  000ec	c1 ea 08	 shr	 edx, 8
  000ef	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f5	8b 04 8d 00 0c
	00 00		 mov	 eax, DWORD PTR _lzma_crc32_table[ecx*4+3072]
  000fc	33 04 95 00 08
	00 00		 xor	 eax, DWORD PTR _lzma_crc32_table[edx*4+2048]
  00103	33 45 10	 xor	 eax, DWORD PTR _crc$[ebp]
  00106	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$32285[ebp]
  00109	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0010c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00112	33 04 8d 00 04
	00 00		 xor	 eax, DWORD PTR _lzma_crc32_table[ecx*4+1024]
  00119	8b 55 f8	 mov	 edx, DWORD PTR _tmp$32285[ebp]
  0011c	c1 ea 18	 shr	 edx, 24			; 00000018H
  0011f	33 04 95 00 00
	00 00		 xor	 eax, DWORD PTR _lzma_crc32_table[edx*4]
  00126	89 45 10	 mov	 DWORD PTR _crc$[ebp], eax

; 76   : 		  }
; 77   : 		}

  00129	e9 3c ff ff ff	 jmp	 $LN4@lzma_crc32
$LN2@lzma_crc32:

; 78   : 	  }
; 79   : 	}
; 80   : 
; 81   : 	while (size-- != 0)

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00131	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00134	83 e9 01	 sub	 ecx, 1
  00137	89 4d 0c	 mov	 DWORD PTR _size$[ebp], ecx
  0013a	85 c0		 test	 eax, eax
  0013c	74 2c		 je	 SHORT $LN1@lzma_crc32

; 82   : 		crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);

  0013e	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00141	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00144	8b 4d 10	 mov	 ecx, DWORD PTR _crc$[ebp]
  00147	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0014d	33 c1		 xor	 eax, ecx
  0014f	8b 55 10	 mov	 edx, DWORD PTR _crc$[ebp]
  00152	c1 ea 08	 shr	 edx, 8
  00155	33 14 85 00 00
	00 00		 xor	 edx, DWORD PTR _lzma_crc32_table[eax*4]
  0015c	89 55 10	 mov	 DWORD PTR _crc$[ebp], edx
  0015f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00162	83 c0 01	 add	 eax, 1
  00165	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax
  00168	eb c4		 jmp	 SHORT $LN2@lzma_crc32
$LN1@lzma_crc32:

; 83   : 
; 84   : #ifdef WORDS_BIGENDIAN
; 85   : 	crc = bswap32(crc);
; 86   : #endif
; 87   : 
; 88   : 	return ~crc;

  0016a	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  0016d	f7 d0		 not	 eax

; 89   : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
_lzma_crc32 ENDP
END
