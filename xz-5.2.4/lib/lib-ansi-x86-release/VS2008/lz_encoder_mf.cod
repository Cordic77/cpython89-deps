; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
;	COMDAT _move_pending
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_move_pending PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	++mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0000f	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 188  : 	assert(mf->read_pos <= mf->write_pos);
; 189  : 	++mf->pending;

  00012	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00015	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00018	83 c1 01	 add	 ecx, 1
  0001b	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0001e	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 190  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_move_pending ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _normalize
_TEXT	SEGMENT
_i$32498 = -8						; size = 4
_subvalue$32497 = -4					; size = 4
_mf$ = 8						; size = 4
_normalize PROC						; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 114  : 	assert(mf->read_pos + mf->offset == MUST_NORMALIZE_POS);
; 115  : 
; 116  : 	// In future we may not want to touch the lowest bits, because there
; 117  : 	// may be match finders that use larger resolution than one byte.
; 118  :   {
; 119  : 	const uint32_t subvalue
; 120  : 			= (MUST_NORMALIZE_POS - mf->cyclic_size);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	83 c9 ff	 or	 ecx, -1
  0000c	2b 48 3c	 sub	 ecx, DWORD PTR [eax+60]
  0000f	89 4d fc	 mov	 DWORD PTR _subvalue$32497[ebp], ecx

; 121  : 				// & (~(UINT32_C(1) << 10) - 1);
; 122  : 	uint32_t i;
; 123  : 
; 124  : 	for (i = 0; i < mf->hash_count; ++i) {

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$32498[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN10@normalize
$LN9@normalize:
  0001b	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  0001e	83 c2 01	 add	 edx, 1
  00021	89 55 f8	 mov	 DWORD PTR _i$32498[ebp], edx
$LN10@normalize:
  00024	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  0002a	3b 48 54	 cmp	 ecx, DWORD PTR [eax+84]
  0002d	73 40		 jae	 SHORT $LN8@normalize

; 125  : 		// If the distance is greater than the dictionary size,
; 126  : 		// we can simply mark the hash element as empty.
; 127  : 		if (mf->hash[i] <= subvalue)

  0002f	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00032	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  00038	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  0003b	3b 55 fc	 cmp	 edx, DWORD PTR _subvalue$32497[ebp]
  0003e	77 12		 ja	 SHORT $LN7@normalize

; 128  : 			mf->hash[i] = EMPTY_HASH_VALUE;

  00040	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00043	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00046	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  00049	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0

; 129  : 		else

  00050	eb 1b		 jmp	 SHORT $LN6@normalize
$LN7@normalize:

; 130  : 			mf->hash[i] -= subvalue;

  00052	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00055	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00058	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  0005b	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0005e	2b 45 fc	 sub	 eax, DWORD PTR _subvalue$32497[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00064	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  0006a	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN6@normalize:

; 131  : 	}

  0006d	eb ac		 jmp	 SHORT $LN9@normalize
$LN8@normalize:

; 132  : 
; 133  : 	for (i = 0; i < mf->sons_count; ++i) {

  0006f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$32498[ebp], 0
  00076	eb 09		 jmp	 SHORT $LN5@normalize
$LN4@normalize:
  00078	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  0007b	83 c2 01	 add	 edx, 1
  0007e	89 55 f8	 mov	 DWORD PTR _i$32498[ebp], edx
$LN5@normalize:
  00081	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  00087	3b 48 58	 cmp	 ecx, DWORD PTR [eax+88]
  0008a	73 40		 jae	 SHORT $LN3@normalize

; 134  : 		// Do the same for mf->son.
; 135  : 		//
; 136  : 		// NOTE: There may be uninitialized elements in mf->son.
; 137  : 		// Valgrind may complain that the "if" below depends on
; 138  : 		// an uninitialized value. In this case it is safe to ignore
; 139  : 		// the warning. See also the comments in lz_encoder_init()
; 140  : 		// in lz_encoder.c.
; 141  : 		if (mf->son[i] <= subvalue)

  0008c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0008f	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00092	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  00095	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00098	3b 55 fc	 cmp	 edx, DWORD PTR _subvalue$32497[ebp]
  0009b	77 12		 ja	 SHORT $LN2@normalize

; 142  : 			mf->son[i] = EMPTY_HASH_VALUE;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000a0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  000a6	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0

; 143  : 		else

  000ad	eb 1b		 jmp	 SHORT $LN1@normalize
$LN2@normalize:

; 144  : 			mf->son[i] -= subvalue;

  000af	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000b2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b5	8b 55 f8	 mov	 edx, DWORD PTR _i$32498[ebp]
  000b8	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000bb	2b 45 fc	 sub	 eax, DWORD PTR _subvalue$32497[ebp]
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000c1	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _i$32498[ebp]
  000c7	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN1@normalize:

; 145  : 	}

  000ca	eb ac		 jmp	 SHORT $LN4@normalize
$LN3@normalize:

; 146  : 
; 147  : 	// Update offset to match the new locations.
; 148  : 	mf->offset -= subvalue;

  000cc	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000cf	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d2	2b 45 fc	 sub	 eax, DWORD PTR _subvalue$32497[ebp]
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000d8	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 149  :   }
; 150  : 
; 151  : 	return;
; 152  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_normalize ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
_TEXT	ENDS
;	COMDAT _lzma_memcmplen
_TEXT	SEGMENT
tv77 = -8						; size = 4
_x$32471 = -4						; size = 4
_buf1$ = 8						; size = 4
_buf2$ = 12						; size = 4
_len$ = 16						; size = 4
_limit$ = 20						; size = 4
_lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_memcm:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {
; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);
; 66   : 		if (x != 0) {
; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);
; 70   : 			len += (uint32_t)tmp >> 3;
; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);
; 75   : 		}
; 76   : 
; 77   : 		len += 8;
; 78   : 	}
; 79   : 
; 80   : 	return limit;
; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0000c	73 6c		 jae	 SHORT $LN4@lzma_memcm

; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buf1$[ebp]
  00011	03 4d 10	 add	 ecx, DWORD PTR _len$[ebp]
  00014	8b 55 0c	 mov	 edx, DWORD PTR _buf2$[ebp]
  00017	03 55 10	 add	 edx, DWORD PTR _len$[ebp]
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	2b 02		 sub	 eax, DWORD PTR [edx]
  0001e	89 45 fc	 mov	 DWORD PTR _x$32471[ebp], eax

; 125  : 		if (x != 0) {

  00021	74 4c		 je	 SHORT $LN3@lzma_memcm

; 126  : 			if ((x & 0xFFFF) == 0) {

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _x$32471[ebp]
  00026	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0002c	75 12		 jne	 SHORT $LN2@lzma_memcm

; 127  : 				len += 2;

  0002e	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00031	83 c2 02	 add	 edx, 2
  00034	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 128  : 				x >>= 16;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _x$32471[ebp]
  0003a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003d	89 45 fc	 mov	 DWORD PTR _x$32471[ebp], eax
$LN2@lzma_memcm:

; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _x$32471[ebp]
  00043	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00049	75 09		 jne	 SHORT $LN1@lzma_memcm

; 132  : 				++len;

  0004b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
$LN1@lzma_memcm:

; 133  : 
; 134  : 			return my_min(len, limit);

  00054	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00057	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0005a	73 08		 jae	 SHORT $LN8@lzma_memcm
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
  00062	eb 06		 jmp	 SHORT $LN9@lzma_memcm
$LN8@lzma_memcm:
  00064	8b 55 14	 mov	 edx, DWORD PTR _limit$[ebp]
  00067	89 55 f8	 mov	 DWORD PTR tv77[ebp], edx
$LN9@lzma_memcm:
  0006a	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0006d	eb 0e		 jmp	 SHORT $LN6@lzma_memcm
$LN3@lzma_memcm:

; 135  : 		}
; 136  : 
; 137  : 		len += 4;

  0006f	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 138  : 	}

  00078	eb 8c		 jmp	 SHORT $LN5@lzma_memcm
$LN4@lzma_memcm:

; 139  : 
; 140  : 	return limit;

  0007a	8b 45 14	 mov	 eax, DWORD PTR _limit$[ebp]
$LN6@lzma_memcm:

; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_lzma_memcmplen ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT _mf_avail
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_avail PROC						; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  : 	return mf->write_pos - mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00009	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000c	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]

; 232  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_ptr
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_ptr	PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 	return mf->buffer + mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000b	03 41 14	 add	 eax, DWORD PTR [ecx+20]

; 224  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_mf_ptr	ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
;	COMDAT _bt_skip_func
_TEXT	SEGMENT
tv150 = -48						; size = 4
tv85 = -44						; size = 4
$T76838 = -40						; size = 4
_x$76834 = -36						; size = 4
_pb$32731 = -32						; size = 4
_len$32732 = -28					; size = 4
_pair$32730 = -24					; size = 4
_delta$32727 = -20					; size = 4
_ptr1$ = -16						; size = 4
_len1$ = -12						; size = 4
_ptr0$ = -8						; size = 4
_len0$ = -4						; size = 4
_len_limit$ = 8						; size = 4
_pos$ = 12						; size = 4
_cur$ = 16						; size = 4
_cur_match$ = 20					; size = 4
_depth$ = 24						; size = 4
_son$ = 28						; size = 4
_cyclic_pos$ = 32					; size = 4
_cyclic_size$ = 36					; size = 4
_bt_skip_func PROC					; COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 554  : 	uint32_t *ptr0 = son + (cyclic_pos << 1) + 1;

  00006	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00009	d1 e0		 shl	 eax, 1
  0000b	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  0000e	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  00012	89 55 f8	 mov	 DWORD PTR _ptr0$[ebp], edx

; 555  : 	uint32_t *ptr1 = son + (cyclic_pos << 1);

  00015	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00018	d1 e0		 shl	 eax, 1
  0001a	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  0001d	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00020	89 55 f0	 mov	 DWORD PTR _ptr1$[ebp], edx

; 556  : 
; 557  : 	uint32_t len0 = 0;

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len0$[ebp], 0

; 558  : 	uint32_t len1 = 0;

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _len1$[ebp], 0
$LN8@bt_skip_fu:

; 559  : 
; 560  : 	while (true) {

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	0f 84 90 01 00
	00		 je	 $LN9@bt_skip_fu

; 561  : 		const uint32_t delta = pos - cur_match;

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00041	2b 4d 14	 sub	 ecx, DWORD PTR _cur_match$[ebp]
  00044	89 4d ec	 mov	 DWORD PTR _delta$32727[ebp], ecx

; 562  : 		if (depth-- == 0 || delta >= cyclic_size) {

  00047	8b 55 18	 mov	 edx, DWORD PTR _depth$[ebp]
  0004a	8b 45 18	 mov	 eax, DWORD PTR _depth$[ebp]
  0004d	83 e8 01	 sub	 eax, 1
  00050	89 45 18	 mov	 DWORD PTR _depth$[ebp], eax
  00053	85 d2		 test	 edx, edx
  00055	74 08		 je	 SHORT $LN5@bt_skip_fu
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _delta$32727[ebp]
  0005a	3b 4d 24	 cmp	 ecx, DWORD PTR _cyclic_size$[ebp]
  0005d	72 17		 jb	 SHORT $LN6@bt_skip_fu
$LN5@bt_skip_fu:

; 563  : 			*ptr0 = EMPTY_HASH_VALUE;

  0005f	8b 55 f8	 mov	 edx, DWORD PTR _ptr0$[ebp]
  00062	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 564  : 			*ptr1 = EMPTY_HASH_VALUE;

  00068	8b 45 f0	 mov	 eax, DWORD PTR _ptr1$[ebp]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 565  : 			return;

  00071	e9 58 01 00 00	 jmp	 $LN9@bt_skip_fu
$LN6@bt_skip_fu:

; 566  : 		}
; 567  : 
; 568  : 	  {
; 569  : 		uint32_t *pair = son + ((cyclic_pos - delta
; 570  : 				+ (delta > cyclic_pos ? cyclic_size : 0))
; 571  : 				<< 1);

  00076	8b 4d 20	 mov	 ecx, DWORD PTR _cyclic_pos$[ebp]
  00079	2b 4d ec	 sub	 ecx, DWORD PTR _delta$32727[ebp]
  0007c	8b 55 ec	 mov	 edx, DWORD PTR _delta$32727[ebp]
  0007f	39 55 20	 cmp	 DWORD PTR _cyclic_pos$[ebp], edx
  00082	1b c0		 sbb	 eax, eax
  00084	23 45 24	 and	 eax, DWORD PTR _cyclic_size$[ebp]
  00087	03 c8		 add	 ecx, eax
  00089	d1 e1		 shl	 ecx, 1
  0008b	8b 55 1c	 mov	 edx, DWORD PTR _son$[ebp]
  0008e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00091	89 45 e8	 mov	 DWORD PTR _pair$32730[ebp], eax

; 572  : 		const uint8_t *pb = cur - delta;

  00094	8b 4d 10	 mov	 ecx, DWORD PTR _cur$[ebp]
  00097	2b 4d ec	 sub	 ecx, DWORD PTR _delta$32727[ebp]
  0009a	89 4d e0	 mov	 DWORD PTR _pb$32731[ebp], ecx

; 573  : 		uint32_t len = my_min(len0, len1);

  0009d	8b 55 fc	 mov	 edx, DWORD PTR _len0$[ebp]
  000a0	3b 55 f4	 cmp	 edx, DWORD PTR _len1$[ebp]
  000a3	73 08		 jae	 SHORT $LN11@bt_skip_fu
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _len0$[ebp]
  000a8	89 45 d4	 mov	 DWORD PTR tv85[ebp], eax
  000ab	eb 06		 jmp	 SHORT $LN12@bt_skip_fu
$LN11@bt_skip_fu:
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _len1$[ebp]
  000b0	89 4d d4	 mov	 DWORD PTR tv85[ebp], ecx
$LN12@bt_skip_fu:
  000b3	8b 55 d4	 mov	 edx, DWORD PTR tv85[ebp]
  000b6	89 55 e4	 mov	 DWORD PTR _len$32732[ebp], edx

; 574  : 
; 575  : 		if (pb[len] == cur[len]) {

  000b9	8b 45 e0	 mov	 eax, DWORD PTR _pb$32731[ebp]
  000bc	03 45 e4	 add	 eax, DWORD PTR _len$32732[ebp]
  000bf	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c2	8b 55 10	 mov	 edx, DWORD PTR _cur$[ebp]
  000c5	03 55 e4	 add	 edx, DWORD PTR _len$32732[ebp]
  000c8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	0f 85 a3 00 00
	00		 jne	 $LN4@bt_skip_fu

; 576  : 			len = lzma_memcmplen(pb, cur, len + 1, len_limit);

  000d3	8b 4d e4	 mov	 ecx, DWORD PTR _len$32732[ebp]
  000d6	83 c1 01	 add	 ecx, 1
  000d9	89 4d d8	 mov	 DWORD PTR $T76838[ebp], ecx
$LN17@bt_skip_fu:
  000dc	8b 55 d8	 mov	 edx, DWORD PTR $T76838[ebp]
  000df	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  000e2	73 6d		 jae	 SHORT $LN16@bt_skip_fu
  000e4	8b 45 e0	 mov	 eax, DWORD PTR _pb$32731[ebp]
  000e7	03 45 d8	 add	 eax, DWORD PTR $T76838[ebp]
  000ea	8b 4d 10	 mov	 ecx, DWORD PTR _cur$[ebp]
  000ed	03 4d d8	 add	 ecx, DWORD PTR $T76838[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f4	89 55 dc	 mov	 DWORD PTR _x$76834[ebp], edx
  000f7	74 4d		 je	 SHORT $LN15@bt_skip_fu
  000f9	8b 45 dc	 mov	 eax, DWORD PTR _x$76834[ebp]
  000fc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00101	75 12		 jne	 SHORT $LN14@bt_skip_fu
  00103	8b 4d d8	 mov	 ecx, DWORD PTR $T76838[ebp]
  00106	83 c1 02	 add	 ecx, 2
  00109	89 4d d8	 mov	 DWORD PTR $T76838[ebp], ecx
  0010c	8b 55 dc	 mov	 edx, DWORD PTR _x$76834[ebp]
  0010f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00112	89 55 dc	 mov	 DWORD PTR _x$76834[ebp], edx
$LN14@bt_skip_fu:
  00115	8b 45 dc	 mov	 eax, DWORD PTR _x$76834[ebp]
  00118	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0011d	75 09		 jne	 SHORT $LN13@bt_skip_fu
  0011f	8b 4d d8	 mov	 ecx, DWORD PTR $T76838[ebp]
  00122	83 c1 01	 add	 ecx, 1
  00125	89 4d d8	 mov	 DWORD PTR $T76838[ebp], ecx
$LN13@bt_skip_fu:
  00128	8b 55 d8	 mov	 edx, DWORD PTR $T76838[ebp]
  0012b	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  0012e	73 08		 jae	 SHORT $LN20@bt_skip_fu
  00130	8b 45 d8	 mov	 eax, DWORD PTR $T76838[ebp]
  00133	89 45 d0	 mov	 DWORD PTR tv150[ebp], eax
  00136	eb 06		 jmp	 SHORT $LN21@bt_skip_fu
$LN20@bt_skip_fu:
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  0013b	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
$LN21@bt_skip_fu:
  0013e	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  00141	89 55 e4	 mov	 DWORD PTR _len$32732[ebp], edx
  00144	eb 11		 jmp	 SHORT $LN18@bt_skip_fu
$LN15@bt_skip_fu:
  00146	8b 45 d8	 mov	 eax, DWORD PTR $T76838[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 d8	 mov	 DWORD PTR $T76838[ebp], eax
  0014f	eb 8b		 jmp	 SHORT $LN17@bt_skip_fu
$LN16@bt_skip_fu:
  00151	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  00154	89 4d e4	 mov	 DWORD PTR _len$32732[ebp], ecx
$LN18@bt_skip_fu:

; 577  : 
; 578  : 			if (len == len_limit) {

  00157	8b 55 e4	 mov	 edx, DWORD PTR _len$32732[ebp]
  0015a	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  0015d	75 17		 jne	 SHORT $LN4@bt_skip_fu

; 579  : 				*ptr1 = pair[0];

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _ptr1$[ebp]
  00162	8b 4d e8	 mov	 ecx, DWORD PTR _pair$32730[ebp]
  00165	8b 11		 mov	 edx, DWORD PTR [ecx]
  00167	89 10		 mov	 DWORD PTR [eax], edx

; 580  : 				*ptr0 = pair[1];

  00169	8b 45 f8	 mov	 eax, DWORD PTR _ptr0$[ebp]
  0016c	8b 4d e8	 mov	 ecx, DWORD PTR _pair$32730[ebp]
  0016f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00172	89 10		 mov	 DWORD PTR [eax], edx

; 581  : 				return;

  00174	eb 58		 jmp	 SHORT $LN9@bt_skip_fu
$LN4@bt_skip_fu:

; 582  : 			}
; 583  : 		}
; 584  : 
; 585  : 		if (pb[len] < cur[len]) {

  00176	8b 45 e0	 mov	 eax, DWORD PTR _pb$32731[ebp]
  00179	03 45 e4	 add	 eax, DWORD PTR _len$32732[ebp]
  0017c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0017f	8b 55 10	 mov	 edx, DWORD PTR _cur$[ebp]
  00182	03 55 e4	 add	 edx, DWORD PTR _len$32732[ebp]
  00185	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00188	3b c8		 cmp	 ecx, eax
  0018a	7d 21		 jge	 SHORT $LN2@bt_skip_fu

; 586  : 			*ptr1 = cur_match;

  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _ptr1$[ebp]
  0018f	8b 55 14	 mov	 edx, DWORD PTR _cur_match$[ebp]
  00192	89 11		 mov	 DWORD PTR [ecx], edx

; 587  : 			ptr1 = pair + 1;

  00194	8b 45 e8	 mov	 eax, DWORD PTR _pair$32730[ebp]
  00197	83 c0 04	 add	 eax, 4
  0019a	89 45 f0	 mov	 DWORD PTR _ptr1$[ebp], eax

; 588  : 			cur_match = *ptr1;

  0019d	8b 4d f0	 mov	 ecx, DWORD PTR _ptr1$[ebp]
  001a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a2	89 55 14	 mov	 DWORD PTR _cur_match$[ebp], edx

; 589  : 			len1 = len;

  001a5	8b 45 e4	 mov	 eax, DWORD PTR _len$32732[ebp]
  001a8	89 45 f4	 mov	 DWORD PTR _len1$[ebp], eax

; 590  : 		} else {

  001ab	eb 1c		 jmp	 SHORT $LN1@bt_skip_fu
$LN2@bt_skip_fu:

; 591  : 			*ptr0 = cur_match;

  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  001b0	8b 55 14	 mov	 edx, DWORD PTR _cur_match$[ebp]
  001b3	89 11		 mov	 DWORD PTR [ecx], edx

; 592  : 			ptr0 = pair;

  001b5	8b 45 e8	 mov	 eax, DWORD PTR _pair$32730[ebp]
  001b8	89 45 f8	 mov	 DWORD PTR _ptr0$[ebp], eax

; 593  : 			cur_match = *ptr0;

  001bb	8b 4d f8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  001be	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c0	89 55 14	 mov	 DWORD PTR _cur_match$[ebp], edx

; 594  : 			len0 = len;

  001c3	8b 45 e4	 mov	 eax, DWORD PTR _len$32732[ebp]
  001c6	89 45 fc	 mov	 DWORD PTR _len0$[ebp], eax
$LN1@bt_skip_fu:

; 595  : 		}
; 596  : 	  }
; 597  : 	}

  001c9	e9 63 fe ff ff	 jmp	 $LN8@bt_skip_fu
$LN9@bt_skip_fu:

; 598  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
_bt_skip_func ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _bt_find_func
_TEXT	SEGMENT
tv154 = -48						; size = 4
tv85 = -44						; size = 4
$T76855 = -40						; size = 4
_x$76851 = -36						; size = 4
_pb$32695 = -32						; size = 4
_len$32696 = -28					; size = 4
_pair$32694 = -24					; size = 4
_delta$32691 = -20					; size = 4
_ptr1$ = -16						; size = 4
_len1$ = -12						; size = 4
_ptr0$ = -8						; size = 4
_len0$ = -4						; size = 4
_len_limit$ = 8						; size = 4
_pos$ = 12						; size = 4
_cur$ = 16						; size = 4
_cur_match$ = 20					; size = 4
_depth$ = 24						; size = 4
_son$ = 28						; size = 4
_cyclic_pos$ = 32					; size = 4
_cyclic_size$ = 36					; size = 4
_matches$ = 40						; size = 4
_len_best$ = 44						; size = 4
_bt_find_func PROC					; COMDAT

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 488  : 	uint32_t *ptr0 = son + (cyclic_pos << 1) + 1;

  00006	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00009	d1 e0		 shl	 eax, 1
  0000b	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  0000e	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  00012	89 55 f8	 mov	 DWORD PTR _ptr0$[ebp], edx

; 489  : 	uint32_t *ptr1 = son + (cyclic_pos << 1);

  00015	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00018	d1 e0		 shl	 eax, 1
  0001a	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  0001d	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00020	89 55 f0	 mov	 DWORD PTR _ptr1$[ebp], edx

; 490  : 
; 491  : 	uint32_t len0 = 0;

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len0$[ebp], 0

; 492  : 	uint32_t len1 = 0;

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _len1$[ebp], 0
$LN9@bt_find_fu:

; 493  : 
; 494  : 	while (true) {

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	0f 84 c1 01 00
	00		 je	 $LN10@bt_find_fu

; 495  : 		const uint32_t delta = pos - cur_match;

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00041	2b 4d 14	 sub	 ecx, DWORD PTR _cur_match$[ebp]
  00044	89 4d ec	 mov	 DWORD PTR _delta$32691[ebp], ecx

; 496  : 		if (depth-- == 0 || delta >= cyclic_size) {

  00047	8b 55 18	 mov	 edx, DWORD PTR _depth$[ebp]
  0004a	8b 45 18	 mov	 eax, DWORD PTR _depth$[ebp]
  0004d	83 e8 01	 sub	 eax, 1
  00050	89 45 18	 mov	 DWORD PTR _depth$[ebp], eax
  00053	85 d2		 test	 edx, edx
  00055	74 08		 je	 SHORT $LN6@bt_find_fu
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _delta$32691[ebp]
  0005a	3b 4d 24	 cmp	 ecx, DWORD PTR _cyclic_size$[ebp]
  0005d	72 1a		 jb	 SHORT $LN7@bt_find_fu
$LN6@bt_find_fu:

; 497  : 			*ptr0 = EMPTY_HASH_VALUE;

  0005f	8b 55 f8	 mov	 edx, DWORD PTR _ptr0$[ebp]
  00062	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 498  : 			*ptr1 = EMPTY_HASH_VALUE;

  00068	8b 45 f0	 mov	 eax, DWORD PTR _ptr1$[ebp]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 499  : 			return matches;

  00071	8b 45 28	 mov	 eax, DWORD PTR _matches$[ebp]
  00074	e9 86 01 00 00	 jmp	 $LN10@bt_find_fu
$LN7@bt_find_fu:

; 500  : 		}
; 501  : 
; 502  : 	  {
; 503  : 		uint32_t *const pair = son + ((cyclic_pos - delta
; 504  : 				+ (delta > cyclic_pos ? cyclic_size : 0))
; 505  : 				<< 1);

  00079	8b 4d 20	 mov	 ecx, DWORD PTR _cyclic_pos$[ebp]
  0007c	2b 4d ec	 sub	 ecx, DWORD PTR _delta$32691[ebp]
  0007f	8b 55 ec	 mov	 edx, DWORD PTR _delta$32691[ebp]
  00082	39 55 20	 cmp	 DWORD PTR _cyclic_pos$[ebp], edx
  00085	1b c0		 sbb	 eax, eax
  00087	23 45 24	 and	 eax, DWORD PTR _cyclic_size$[ebp]
  0008a	03 c8		 add	 ecx, eax
  0008c	d1 e1		 shl	 ecx, 1
  0008e	8b 55 1c	 mov	 edx, DWORD PTR _son$[ebp]
  00091	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00094	89 45 e8	 mov	 DWORD PTR _pair$32694[ebp], eax

; 506  : 
; 507  : 		const uint8_t *const pb = cur - delta;

  00097	8b 4d 10	 mov	 ecx, DWORD PTR _cur$[ebp]
  0009a	2b 4d ec	 sub	 ecx, DWORD PTR _delta$32691[ebp]
  0009d	89 4d e0	 mov	 DWORD PTR _pb$32695[ebp], ecx

; 508  : 		uint32_t len = my_min(len0, len1);

  000a0	8b 55 fc	 mov	 edx, DWORD PTR _len0$[ebp]
  000a3	3b 55 f4	 cmp	 edx, DWORD PTR _len1$[ebp]
  000a6	73 08		 jae	 SHORT $LN12@bt_find_fu
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _len0$[ebp]
  000ab	89 45 d4	 mov	 DWORD PTR tv85[ebp], eax
  000ae	eb 06		 jmp	 SHORT $LN13@bt_find_fu
$LN12@bt_find_fu:
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _len1$[ebp]
  000b3	89 4d d4	 mov	 DWORD PTR tv85[ebp], ecx
$LN13@bt_find_fu:
  000b6	8b 55 d4	 mov	 edx, DWORD PTR tv85[ebp]
  000b9	89 55 e4	 mov	 DWORD PTR _len$32696[ebp], edx

; 509  : 
; 510  : 		if (pb[len] == cur[len]) {

  000bc	8b 45 e0	 mov	 eax, DWORD PTR _pb$32695[ebp]
  000bf	03 45 e4	 add	 eax, DWORD PTR _len$32696[ebp]
  000c2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c5	8b 55 10	 mov	 edx, DWORD PTR _cur$[ebp]
  000c8	03 55 e4	 add	 edx, DWORD PTR _len$32696[ebp]
  000cb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000ce	3b c8		 cmp	 ecx, eax
  000d0	0f 85 d1 00 00
	00		 jne	 $LN5@bt_find_fu

; 511  : 			len = lzma_memcmplen(pb, cur, len + 1, len_limit);

  000d6	8b 4d e4	 mov	 ecx, DWORD PTR _len$32696[ebp]
  000d9	83 c1 01	 add	 ecx, 1
  000dc	89 4d d8	 mov	 DWORD PTR $T76855[ebp], ecx
$LN18@bt_find_fu:
  000df	8b 55 d8	 mov	 edx, DWORD PTR $T76855[ebp]
  000e2	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  000e5	73 6d		 jae	 SHORT $LN17@bt_find_fu
  000e7	8b 45 e0	 mov	 eax, DWORD PTR _pb$32695[ebp]
  000ea	03 45 d8	 add	 eax, DWORD PTR $T76855[ebp]
  000ed	8b 4d 10	 mov	 ecx, DWORD PTR _cur$[ebp]
  000f0	03 4d d8	 add	 ecx, DWORD PTR $T76855[ebp]
  000f3	8b 10		 mov	 edx, DWORD PTR [eax]
  000f5	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f7	89 55 dc	 mov	 DWORD PTR _x$76851[ebp], edx
  000fa	74 4d		 je	 SHORT $LN16@bt_find_fu
  000fc	8b 45 dc	 mov	 eax, DWORD PTR _x$76851[ebp]
  000ff	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00104	75 12		 jne	 SHORT $LN15@bt_find_fu
  00106	8b 4d d8	 mov	 ecx, DWORD PTR $T76855[ebp]
  00109	83 c1 02	 add	 ecx, 2
  0010c	89 4d d8	 mov	 DWORD PTR $T76855[ebp], ecx
  0010f	8b 55 dc	 mov	 edx, DWORD PTR _x$76851[ebp]
  00112	c1 ea 10	 shr	 edx, 16			; 00000010H
  00115	89 55 dc	 mov	 DWORD PTR _x$76851[ebp], edx
$LN15@bt_find_fu:
  00118	8b 45 dc	 mov	 eax, DWORD PTR _x$76851[ebp]
  0011b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00120	75 09		 jne	 SHORT $LN14@bt_find_fu
  00122	8b 4d d8	 mov	 ecx, DWORD PTR $T76855[ebp]
  00125	83 c1 01	 add	 ecx, 1
  00128	89 4d d8	 mov	 DWORD PTR $T76855[ebp], ecx
$LN14@bt_find_fu:
  0012b	8b 55 d8	 mov	 edx, DWORD PTR $T76855[ebp]
  0012e	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  00131	73 08		 jae	 SHORT $LN21@bt_find_fu
  00133	8b 45 d8	 mov	 eax, DWORD PTR $T76855[ebp]
  00136	89 45 d0	 mov	 DWORD PTR tv154[ebp], eax
  00139	eb 06		 jmp	 SHORT $LN22@bt_find_fu
$LN21@bt_find_fu:
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  0013e	89 4d d0	 mov	 DWORD PTR tv154[ebp], ecx
$LN22@bt_find_fu:
  00141	8b 55 d0	 mov	 edx, DWORD PTR tv154[ebp]
  00144	89 55 e4	 mov	 DWORD PTR _len$32696[ebp], edx
  00147	eb 11		 jmp	 SHORT $LN19@bt_find_fu
$LN16@bt_find_fu:
  00149	8b 45 d8	 mov	 eax, DWORD PTR $T76855[ebp]
  0014c	83 c0 04	 add	 eax, 4
  0014f	89 45 d8	 mov	 DWORD PTR $T76855[ebp], eax
  00152	eb 8b		 jmp	 SHORT $LN18@bt_find_fu
$LN17@bt_find_fu:
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  00157	89 4d e4	 mov	 DWORD PTR _len$32696[ebp], ecx
$LN19@bt_find_fu:

; 512  : 
; 513  : 			if (len_best < len) {

  0015a	8b 55 2c	 mov	 edx, DWORD PTR _len_best$[ebp]
  0015d	3b 55 e4	 cmp	 edx, DWORD PTR _len$32696[ebp]
  00160	73 45		 jae	 SHORT $LN5@bt_find_fu

; 514  : 				len_best = len;

  00162	8b 45 e4	 mov	 eax, DWORD PTR _len$32696[ebp]
  00165	89 45 2c	 mov	 DWORD PTR _len_best$[ebp], eax

; 515  : 				matches->len = len;

  00168	8b 4d 28	 mov	 ecx, DWORD PTR _matches$[ebp]
  0016b	8b 55 e4	 mov	 edx, DWORD PTR _len$32696[ebp]
  0016e	89 11		 mov	 DWORD PTR [ecx], edx

; 516  : 				matches->dist = delta - 1;

  00170	8b 45 ec	 mov	 eax, DWORD PTR _delta$32691[ebp]
  00173	83 e8 01	 sub	 eax, 1
  00176	8b 4d 28	 mov	 ecx, DWORD PTR _matches$[ebp]
  00179	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 517  : 				++matches;

  0017c	8b 55 28	 mov	 edx, DWORD PTR _matches$[ebp]
  0017f	83 c2 08	 add	 edx, 8
  00182	89 55 28	 mov	 DWORD PTR _matches$[ebp], edx

; 518  : 
; 519  : 				if (len == len_limit) {

  00185	8b 45 e4	 mov	 eax, DWORD PTR _len$32696[ebp]
  00188	3b 45 08	 cmp	 eax, DWORD PTR _len_limit$[ebp]
  0018b	75 1a		 jne	 SHORT $LN5@bt_find_fu

; 520  : 					*ptr1 = pair[0];

  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _ptr1$[ebp]
  00190	8b 55 e8	 mov	 edx, DWORD PTR _pair$32694[ebp]
  00193	8b 02		 mov	 eax, DWORD PTR [edx]
  00195	89 01		 mov	 DWORD PTR [ecx], eax

; 521  : 					*ptr0 = pair[1];

  00197	8b 4d f8	 mov	 ecx, DWORD PTR _ptr0$[ebp]
  0019a	8b 55 e8	 mov	 edx, DWORD PTR _pair$32694[ebp]
  0019d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001a0	89 01		 mov	 DWORD PTR [ecx], eax

; 522  : 					return matches;

  001a2	8b 45 28	 mov	 eax, DWORD PTR _matches$[ebp]
  001a5	eb 58		 jmp	 SHORT $LN10@bt_find_fu
$LN5@bt_find_fu:

; 523  : 				}
; 524  : 			}
; 525  : 		}
; 526  : 
; 527  : 		if (pb[len] < cur[len]) {

  001a7	8b 4d e0	 mov	 ecx, DWORD PTR _pb$32695[ebp]
  001aa	03 4d e4	 add	 ecx, DWORD PTR _len$32696[ebp]
  001ad	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001b0	8b 45 10	 mov	 eax, DWORD PTR _cur$[ebp]
  001b3	03 45 e4	 add	 eax, DWORD PTR _len$32696[ebp]
  001b6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001b9	3b d1		 cmp	 edx, ecx
  001bb	7d 21		 jge	 SHORT $LN2@bt_find_fu

; 528  : 			*ptr1 = cur_match;

  001bd	8b 55 f0	 mov	 edx, DWORD PTR _ptr1$[ebp]
  001c0	8b 45 14	 mov	 eax, DWORD PTR _cur_match$[ebp]
  001c3	89 02		 mov	 DWORD PTR [edx], eax

; 529  : 			ptr1 = pair + 1;

  001c5	8b 4d e8	 mov	 ecx, DWORD PTR _pair$32694[ebp]
  001c8	83 c1 04	 add	 ecx, 4
  001cb	89 4d f0	 mov	 DWORD PTR _ptr1$[ebp], ecx

; 530  : 			cur_match = *ptr1;

  001ce	8b 55 f0	 mov	 edx, DWORD PTR _ptr1$[ebp]
  001d1	8b 02		 mov	 eax, DWORD PTR [edx]
  001d3	89 45 14	 mov	 DWORD PTR _cur_match$[ebp], eax

; 531  : 			len1 = len;

  001d6	8b 4d e4	 mov	 ecx, DWORD PTR _len$32696[ebp]
  001d9	89 4d f4	 mov	 DWORD PTR _len1$[ebp], ecx

; 532  : 		} else {

  001dc	eb 1c		 jmp	 SHORT $LN1@bt_find_fu
$LN2@bt_find_fu:

; 533  : 			*ptr0 = cur_match;

  001de	8b 55 f8	 mov	 edx, DWORD PTR _ptr0$[ebp]
  001e1	8b 45 14	 mov	 eax, DWORD PTR _cur_match$[ebp]
  001e4	89 02		 mov	 DWORD PTR [edx], eax

; 534  : 			ptr0 = pair;

  001e6	8b 4d e8	 mov	 ecx, DWORD PTR _pair$32694[ebp]
  001e9	89 4d f8	 mov	 DWORD PTR _ptr0$[ebp], ecx

; 535  : 			cur_match = *ptr0;

  001ec	8b 55 f8	 mov	 edx, DWORD PTR _ptr0$[ebp]
  001ef	8b 02		 mov	 eax, DWORD PTR [edx]
  001f1	89 45 14	 mov	 DWORD PTR _cur_match$[ebp], eax

; 536  : 			len0 = len;

  001f4	8b 4d e4	 mov	 ecx, DWORD PTR _len$32696[ebp]
  001f7	89 4d fc	 mov	 DWORD PTR _len0$[ebp], ecx
$LN1@bt_find_fu:

; 537  : 		}
; 538  : 	  }
; 539  : 	}

  001fa	e9 32 fe ff ff	 jmp	 $LN9@bt_find_fu
$LN10@bt_find_fu:

; 540  : }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
_bt_find_func ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _hc_find_func
_TEXT	SEGMENT
tv141 = -24						; size = 4
$T76870 = -20						; size = 4
_x$76866 = -16						; size = 4
_len$32551 = -12					; size = 4
_pb$32549 = -8						; size = 4
_delta$32546 = -4					; size = 4
_len_limit$ = 8						; size = 4
_pos$ = 12						; size = 4
_cur$ = 16						; size = 4
_cur_match$ = 20					; size = 4
_depth$ = 24						; size = 4
_son$ = 28						; size = 4
_cyclic_pos$ = 32					; size = 4
_cyclic_size$ = 36					; size = 4
_matches$ = 40						; size = 4
_len_best$ = 44						; size = 4
_hc_find_func PROC					; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 274  : 	son[cyclic_pos] = cur_match;

  00006	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00009	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  0000c	8b 55 14	 mov	 edx, DWORD PTR _cur_match$[ebp]
  0000f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN7@hc_find_fu:

; 275  : 
; 276  : 	while (true) {

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	0f 84 3b 01 00
	00		 je	 $LN8@hc_find_fu

; 277  : 		const uint32_t delta = pos - cur_match;

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00022	2b 4d 14	 sub	 ecx, DWORD PTR _cur_match$[ebp]
  00025	89 4d fc	 mov	 DWORD PTR _delta$32546[ebp], ecx

; 278  : 		if (depth-- == 0 || delta >= cyclic_size)

  00028	8b 55 18	 mov	 edx, DWORD PTR _depth$[ebp]
  0002b	8b 45 18	 mov	 eax, DWORD PTR _depth$[ebp]
  0002e	83 e8 01	 sub	 eax, 1
  00031	89 45 18	 mov	 DWORD PTR _depth$[ebp], eax
  00034	85 d2		 test	 edx, edx
  00036	74 08		 je	 SHORT $LN4@hc_find_fu
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _delta$32546[ebp]
  0003b	3b 4d 24	 cmp	 ecx, DWORD PTR _cyclic_size$[ebp]
  0003e	72 08		 jb	 SHORT $LN5@hc_find_fu
$LN4@hc_find_fu:

; 279  : 			return matches;

  00040	8b 45 28	 mov	 eax, DWORD PTR _matches$[ebp]
  00043	e9 12 01 00 00	 jmp	 $LN8@hc_find_fu
$LN5@hc_find_fu:

; 280  : 
; 281  : 	  {
; 282  : 		const uint8_t *const pb = cur - delta;

  00048	8b 55 10	 mov	 edx, DWORD PTR _cur$[ebp]
  0004b	2b 55 fc	 sub	 edx, DWORD PTR _delta$32546[ebp]
  0004e	89 55 f8	 mov	 DWORD PTR _pb$32549[ebp], edx

; 283  : 		cur_match = son[cyclic_pos - delta
; 284  : 				+ (delta > cyclic_pos ? cyclic_size : 0)];

  00051	8b 45 20	 mov	 eax, DWORD PTR _cyclic_pos$[ebp]
  00054	2b 45 fc	 sub	 eax, DWORD PTR _delta$32546[ebp]
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _delta$32546[ebp]
  0005a	39 4d 20	 cmp	 DWORD PTR _cyclic_pos$[ebp], ecx
  0005d	1b d2		 sbb	 edx, edx
  0005f	23 55 24	 and	 edx, DWORD PTR _cyclic_size$[ebp]
  00062	03 c2		 add	 eax, edx
  00064	8b 4d 1c	 mov	 ecx, DWORD PTR _son$[ebp]
  00067	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006a	89 55 14	 mov	 DWORD PTR _cur_match$[ebp], edx

; 285  : 
; 286  : 		if (pb[len_best] == cur[len_best] && pb[0] == cur[0]) {

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _pb$32549[ebp]
  00070	03 45 2c	 add	 eax, DWORD PTR _len_best$[ebp]
  00073	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00076	8b 55 10	 mov	 edx, DWORD PTR _cur$[ebp]
  00079	03 55 2c	 add	 edx, DWORD PTR _len_best$[ebp]
  0007c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0007f	3b c8		 cmp	 ecx, eax
  00081	0f 85 ce 00 00
	00		 jne	 $LN3@hc_find_fu
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _pb$32549[ebp]
  0008a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0008d	8b 45 10	 mov	 eax, DWORD PTR _cur$[ebp]
  00090	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00093	3b d1		 cmp	 edx, ecx
  00095	0f 85 ba 00 00
	00		 jne	 $LN3@hc_find_fu

; 287  : 			uint32_t len = lzma_memcmplen(pb, cur, 1, len_limit);

  0009b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T76870[ebp], 1
$LN14@hc_find_fu:
  000a2	8b 55 ec	 mov	 edx, DWORD PTR $T76870[ebp]
  000a5	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  000a8	73 6d		 jae	 SHORT $LN13@hc_find_fu
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _pb$32549[ebp]
  000ad	03 45 ec	 add	 eax, DWORD PTR $T76870[ebp]
  000b0	8b 4d 10	 mov	 ecx, DWORD PTR _cur$[ebp]
  000b3	03 4d ec	 add	 ecx, DWORD PTR $T76870[ebp]
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	2b 11		 sub	 edx, DWORD PTR [ecx]
  000ba	89 55 f0	 mov	 DWORD PTR _x$76866[ebp], edx
  000bd	74 4d		 je	 SHORT $LN12@hc_find_fu
  000bf	8b 45 f0	 mov	 eax, DWORD PTR _x$76866[ebp]
  000c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c7	75 12		 jne	 SHORT $LN11@hc_find_fu
  000c9	8b 4d ec	 mov	 ecx, DWORD PTR $T76870[ebp]
  000cc	83 c1 02	 add	 ecx, 2
  000cf	89 4d ec	 mov	 DWORD PTR $T76870[ebp], ecx
  000d2	8b 55 f0	 mov	 edx, DWORD PTR _x$76866[ebp]
  000d5	c1 ea 10	 shr	 edx, 16			; 00000010H
  000d8	89 55 f0	 mov	 DWORD PTR _x$76866[ebp], edx
$LN11@hc_find_fu:
  000db	8b 45 f0	 mov	 eax, DWORD PTR _x$76866[ebp]
  000de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000e3	75 09		 jne	 SHORT $LN10@hc_find_fu
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR $T76870[ebp]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	89 4d ec	 mov	 DWORD PTR $T76870[ebp], ecx
$LN10@hc_find_fu:
  000ee	8b 55 ec	 mov	 edx, DWORD PTR $T76870[ebp]
  000f1	3b 55 08	 cmp	 edx, DWORD PTR _len_limit$[ebp]
  000f4	73 08		 jae	 SHORT $LN17@hc_find_fu
  000f6	8b 45 ec	 mov	 eax, DWORD PTR $T76870[ebp]
  000f9	89 45 e8	 mov	 DWORD PTR tv141[ebp], eax
  000fc	eb 06		 jmp	 SHORT $LN18@hc_find_fu
$LN17@hc_find_fu:
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  00101	89 4d e8	 mov	 DWORD PTR tv141[ebp], ecx
$LN18@hc_find_fu:
  00104	8b 55 e8	 mov	 edx, DWORD PTR tv141[ebp]
  00107	89 55 f4	 mov	 DWORD PTR _len$32551[ebp], edx
  0010a	eb 11		 jmp	 SHORT $LN15@hc_find_fu
$LN12@hc_find_fu:
  0010c	8b 45 ec	 mov	 eax, DWORD PTR $T76870[ebp]
  0010f	83 c0 04	 add	 eax, 4
  00112	89 45 ec	 mov	 DWORD PTR $T76870[ebp], eax
  00115	eb 8b		 jmp	 SHORT $LN14@hc_find_fu
$LN13@hc_find_fu:
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _len_limit$[ebp]
  0011a	89 4d f4	 mov	 DWORD PTR _len$32551[ebp], ecx
$LN15@hc_find_fu:

; 288  : 
; 289  : 			if (len_best < len) {

  0011d	8b 55 2c	 mov	 edx, DWORD PTR _len_best$[ebp]
  00120	3b 55 f4	 cmp	 edx, DWORD PTR _len$32551[ebp]
  00123	73 30		 jae	 SHORT $LN3@hc_find_fu

; 290  : 				len_best = len;

  00125	8b 45 f4	 mov	 eax, DWORD PTR _len$32551[ebp]
  00128	89 45 2c	 mov	 DWORD PTR _len_best$[ebp], eax

; 291  : 				matches->len = len;

  0012b	8b 4d 28	 mov	 ecx, DWORD PTR _matches$[ebp]
  0012e	8b 55 f4	 mov	 edx, DWORD PTR _len$32551[ebp]
  00131	89 11		 mov	 DWORD PTR [ecx], edx

; 292  : 				matches->dist = delta - 1;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _delta$32546[ebp]
  00136	83 e8 01	 sub	 eax, 1
  00139	8b 4d 28	 mov	 ecx, DWORD PTR _matches$[ebp]
  0013c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 293  : 				++matches;

  0013f	8b 55 28	 mov	 edx, DWORD PTR _matches$[ebp]
  00142	83 c2 08	 add	 edx, 8
  00145	89 55 28	 mov	 DWORD PTR _matches$[ebp], edx

; 294  : 
; 295  : 				if (len == len_limit)

  00148	8b 45 f4	 mov	 eax, DWORD PTR _len$32551[ebp]
  0014b	3b 45 08	 cmp	 eax, DWORD PTR _len_limit$[ebp]
  0014e	75 05		 jne	 SHORT $LN3@hc_find_fu

; 296  : 					return matches;

  00150	8b 45 28	 mov	 eax, DWORD PTR _matches$[ebp]
  00153	eb 05		 jmp	 SHORT $LN8@hc_find_fu
$LN3@hc_find_fu:

; 297  : 			}
; 298  : 		}
; 299  : 	  }
; 300  : 	}

  00155	e9 b8 fe ff ff	 jmp	 $LN7@hc_find_fu
$LN8@hc_find_fu:

; 301  : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
_hc_find_func ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _move_pos
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_move_pos PROC						; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 	if (++mf->cyclic_pos == mf->cyclic_size)

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0000f	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
  00012	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00018	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0001b	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  0001e	75 0a		 jne	 SHORT $LN2@move_pos

; 160  : 		mf->cyclic_pos = 0;

  00020	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00023	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN2@move_pos:

; 161  : 
; 162  : 	++mf->read_pos;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0002d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00030	83 c2 01	 add	 edx, 1
  00033	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00036	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 163  : 	assert(mf->read_pos <= mf->write_pos);
; 164  : 
; 165  : 	if (unlikely(mf->read_pos + mf->offset == UINT32_MAX))

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0003c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00042	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00045	83 fa ff	 cmp	 edx, -1
  00048	75 0c		 jne	 SHORT $LN3@move_pos

; 166  : 		normalize(mf);

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _normalize
  00053	83 c4 04	 add	 esp, 4
$LN3@move_pos:

; 167  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_move_pos ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_find
_TEXT	SEGMENT
tv145 = -32						; size = 4
$T76892 = -28						; size = 4
_x$76888 = -24						; size = 4
_p1$32490 = -20						; size = 4
_p2$32491 = -16						; size = 4
_limit$32488 = -12					; size = 4
_len_best$ = -8						; size = 4
_count$ = -4						; size = 4
_mf$ = 8						; size = 4
_count_ptr$ = 12					; size = 4
_matches$ = 16						; size = 4
_lzma_mf_find PROC					; COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 25   : 	// Call the match finder. It returns the number of length-distance
; 26   : 	// pairs found.
; 27   : 	// FIXME: Minimum count is zero, what _exactly_ is the maximum?
; 28   : 	const uint32_t count = mf->find(mf, matches);

  00006	8b 45 10	 mov	 eax, DWORD PTR _matches$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00011	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 29   : 
; 30   : 	// Length of the longest match; assume that no matches were found
; 31   : 	// and thus the maximum length is zero.
; 32   : 	uint32_t len_best = 0;

  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len_best$[ebp], 0

; 33   : 
; 34   : 	if (count > 0) {

  00023	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  00027	0f 86 ea 00 00
	00		 jbe	 $LN3@lzma_mf_fi

; 35   : #ifndef NDEBUG
; 36   : 		// Validate the matches.
; 37   : 		uint32_t i;
; 38   : 
; 39   : 		for (i = 0; i < count; ++i) {
; 40   : 			assert(matches[i].len <= mf->nice_len);
; 41   : 			assert(matches[i].dist < mf->read_pos);
; 42   : 			assert(memcmp(mf_ptr(mf) - 1,
; 43   : 				mf_ptr(mf) - matches[i].dist - 2,
; 44   : 				matches[i].len) == 0);
; 45   : 		}
; 46   : #endif
; 47   : 
; 48   : 		// The last used element in the array contains
; 49   : 		// the longest match.
; 50   : 		len_best = matches[count - 1].len;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00030	8b 55 10	 mov	 edx, DWORD PTR _matches$[ebp]
  00033	8b 44 ca f8	 mov	 eax, DWORD PTR [edx+ecx*8-8]
  00037	89 45 f8	 mov	 DWORD PTR _len_best$[ebp], eax

; 51   : 
; 52   : 		// If a match of maximum search length was found, try to
; 53   : 		// extend the match to maximum possible length.
; 54   : 		if (len_best == mf->nice_len) {

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0003d	8b 55 f8	 mov	 edx, DWORD PTR _len_best$[ebp]
  00040	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00043	0f 85 ce 00 00
	00		 jne	 $LN3@lzma_mf_fi

; 55   : 			// The limit for the match length is either the
; 56   : 			// maximum match length supported by the LZ-based
; 57   : 			// encoder or the number of bytes left in the
; 58   : 			// dictionary, whichever is smaller.
; 59   : 			uint32_t limit = mf_avail(mf) + 1;

  00049	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0004f	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00052	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00055	83 c2 01	 add	 edx, 1
  00058	89 55 f4	 mov	 DWORD PTR _limit$32488[ebp], edx

; 60   : 			if (limit > mf->match_len_max)

  0005b	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _limit$32488[ebp]
  00061	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00064	76 09		 jbe	 SHORT $LN8@lzma_mf_fi

; 61   : 				limit = mf->match_len_max;

  00066	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00069	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0006c	89 45 f4	 mov	 DWORD PTR _limit$32488[ebp], eax

; 62   : 
; 63   : 			// Pointer to the byte we just ran through
; 64   : 			// the match finder.
; 65   : 		  {
; 66   : 			const uint8_t *p1 = mf_ptr(mf) - 1;

$LN8@lzma_mf_fi:
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00072	8b 11		 mov	 edx, DWORD PTR [ecx]
  00074	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00077	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007a	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  0007e	89 55 ec	 mov	 DWORD PTR _p1$32490[ebp], edx

; 67   : 
; 68   : 			// Pointer to the beginning of the match. We need -1
; 69   : 			// here because the match distances are zero based.
; 70   : 			const uint8_t *p2 = p1 - matches[count - 1].dist - 1;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00084	8b 4d 10	 mov	 ecx, DWORD PTR _matches$[ebp]
  00087	8b 55 ec	 mov	 edx, DWORD PTR _p1$32490[ebp]
  0008a	2b 54 c1 fc	 sub	 edx, DWORD PTR [ecx+eax*8-4]
  0008e	83 ea 01	 sub	 edx, 1
  00091	89 55 f0	 mov	 DWORD PTR _p2$32491[ebp], edx

; 71   : 
; 72   : 			len_best = lzma_memcmplen(p1, p2, len_best, limit);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _len_best$[ebp]
  00097	89 45 e4	 mov	 DWORD PTR $T76892[ebp], eax
$LN14@lzma_mf_fi:
  0009a	8b 4d e4	 mov	 ecx, DWORD PTR $T76892[ebp]
  0009d	3b 4d f4	 cmp	 ecx, DWORD PTR _limit$32488[ebp]
  000a0	73 6f		 jae	 SHORT $LN13@lzma_mf_fi
  000a2	8b 55 ec	 mov	 edx, DWORD PTR _p1$32490[ebp]
  000a5	03 55 e4	 add	 edx, DWORD PTR $T76892[ebp]
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _p2$32491[ebp]
  000ab	03 45 e4	 add	 eax, DWORD PTR $T76892[ebp]
  000ae	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000b0	2b 08		 sub	 ecx, DWORD PTR [eax]
  000b2	89 4d e8	 mov	 DWORD PTR _x$76888[ebp], ecx
  000b5	74 4f		 je	 SHORT $LN12@lzma_mf_fi
  000b7	8b 55 e8	 mov	 edx, DWORD PTR _x$76888[ebp]
  000ba	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000c0	75 12		 jne	 SHORT $LN11@lzma_mf_fi
  000c2	8b 45 e4	 mov	 eax, DWORD PTR $T76892[ebp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	89 45 e4	 mov	 DWORD PTR $T76892[ebp], eax
  000cb	8b 4d e8	 mov	 ecx, DWORD PTR _x$76888[ebp]
  000ce	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000d1	89 4d e8	 mov	 DWORD PTR _x$76888[ebp], ecx
$LN11@lzma_mf_fi:
  000d4	8b 55 e8	 mov	 edx, DWORD PTR _x$76888[ebp]
  000d7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000dd	75 09		 jne	 SHORT $LN10@lzma_mf_fi
  000df	8b 45 e4	 mov	 eax, DWORD PTR $T76892[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 e4	 mov	 DWORD PTR $T76892[ebp], eax
$LN10@lzma_mf_fi:
  000e8	8b 4d e4	 mov	 ecx, DWORD PTR $T76892[ebp]
  000eb	3b 4d f4	 cmp	 ecx, DWORD PTR _limit$32488[ebp]
  000ee	73 08		 jae	 SHORT $LN17@lzma_mf_fi
  000f0	8b 55 e4	 mov	 edx, DWORD PTR $T76892[ebp]
  000f3	89 55 e0	 mov	 DWORD PTR tv145[ebp], edx
  000f6	eb 06		 jmp	 SHORT $LN18@lzma_mf_fi
$LN17@lzma_mf_fi:
  000f8	8b 45 f4	 mov	 eax, DWORD PTR _limit$32488[ebp]
  000fb	89 45 e0	 mov	 DWORD PTR tv145[ebp], eax
$LN18@lzma_mf_fi:
  000fe	8b 4d e0	 mov	 ecx, DWORD PTR tv145[ebp]
  00101	89 4d f8	 mov	 DWORD PTR _len_best$[ebp], ecx
  00104	eb 11		 jmp	 SHORT $LN3@lzma_mf_fi
$LN12@lzma_mf_fi:
  00106	8b 55 e4	 mov	 edx, DWORD PTR $T76892[ebp]
  00109	83 c2 04	 add	 edx, 4
  0010c	89 55 e4	 mov	 DWORD PTR $T76892[ebp], edx
  0010f	eb 89		 jmp	 SHORT $LN14@lzma_mf_fi
$LN13@lzma_mf_fi:
  00111	8b 45 f4	 mov	 eax, DWORD PTR _limit$32488[ebp]
  00114	89 45 f8	 mov	 DWORD PTR _len_best$[ebp], eax
$LN3@lzma_mf_fi:

; 73   : 		  }
; 74   : 		}
; 75   : 	}
; 76   : 
; 77   : 	*count_ptr = count;

  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _count_ptr$[ebp]
  0011a	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  0011d	89 11		 mov	 DWORD PTR [ecx], edx

; 78   : 
; 79   : 	// Finally update the read position to indicate that match finder was
; 80   : 	// run for this dictionary offset.
; 81   : 	++mf->read_ahead;

  0011f	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00122	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00125	83 c1 01	 add	 ecx, 1
  00128	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0012b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 82   : 
; 83   : 	return len_best;

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _len_best$[ebp]

; 84   : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
_lzma_mf_find ENDP
PUBLIC	_lzma_mf_bt4_skip
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt4_skip
_TEXT	SEGMENT
_cur_match$32895 = -32					; size = 4
_hash_2_value$32890 = -28				; size = 4
_hash_value$32893 = -24					; size = 4
_hash_3_value$32891 = -20				; size = 4
_temp$32889 = -16					; size = 4
_pos$32888 = -12					; size = 4
_cur$32887 = -8						; size = 4
_len_limit$32881 = -4					; size = 4
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_lzma_mf_bt4_skip PROC					; COMDAT

; 779  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 780  : 	do {
; 781  : 		header_skip(true, 4);

$LN13@lzma_mf_bt:
  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32881[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32881[ebp]
  0001e	77 0b		 ja	 SHORT $LN7@lzma_mf_bt
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32881[ebp], eax
  00029	eb 29		 jmp	 SHORT $LN15@lzma_mf_bt
$LN7@lzma_mf_bt:
  0002b	83 7d fc 04	 cmp	 DWORD PTR _len_limit$32881[ebp], 4
  0002f	72 12		 jb	 SHORT $LN4@lzma_mf_bt
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1a		 je	 SHORT $LN15@lzma_mf_bt
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 11		 jne	 SHORT $LN15@lzma_mf_bt
$LN4@lzma_mf_bt:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	e9 0b 01 00 00	 jmp	 $LN9@lzma_mf_bt
$LN15@lzma_mf_bt:
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005c	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0005f	89 55 f8	 mov	 DWORD PTR _cur$32887[ebp], edx
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00065	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00068	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006b	03 50 10	 add	 edx, DWORD PTR [eax+16]
  0006e	89 55 f4	 mov	 DWORD PTR _pos$32888[ebp], edx

; 782  : 
; 783  : 	  {
; 784  : 		hash_4_calc();

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32887[ebp]
  00074	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00077	8b 45 f8	 mov	 eax, DWORD PTR _cur$32887[ebp]
  0007a	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0007e	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  00085	89 4d f0	 mov	 DWORD PTR _temp$32889[ebp], ecx
  00088	8b 55 f0	 mov	 edx, DWORD PTR _temp$32889[ebp]
  0008b	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00091	89 55 e4	 mov	 DWORD PTR _hash_2_value$32890[ebp], edx
  00094	8b 45 f8	 mov	 eax, DWORD PTR _cur$32887[ebp]
  00097	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0009b	c1 e1 08	 shl	 ecx, 8
  0009e	33 4d f0	 xor	 ecx, DWORD PTR _temp$32889[ebp]
  000a1	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a7	89 4d ec	 mov	 DWORD PTR _hash_3_value$32891[ebp], ecx
  000aa	8b 55 f8	 mov	 edx, DWORD PTR _cur$32887[ebp]
  000ad	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000b1	c1 e0 08	 shl	 eax, 8
  000b4	33 45 f0	 xor	 eax, DWORD PTR _temp$32889[ebp]
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32887[ebp]
  000ba	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000be	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  000c5	c1 e1 05	 shl	 ecx, 5
  000c8	33 c1		 xor	 eax, ecx
  000ca	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000cd	23 42 40	 and	 eax, DWORD PTR [edx+64]
  000d0	89 45 e8	 mov	 DWORD PTR _hash_value$32893[ebp], eax

; 785  : 
; 786  : 	  {
; 787  : 		const uint32_t cur_match
; 788  : 				= mf->hash[FIX_4_HASH_SIZE + hash_value];

  000d3	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000d6	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000d9	8b 55 e8	 mov	 edx, DWORD PTR _hash_value$32893[ebp]
  000dc	8b 84 91 00 10
	04 00		 mov	 eax, DWORD PTR [ecx+edx*4+266240]
  000e3	89 45 e0	 mov	 DWORD PTR _cur_match$32895[ebp], eax

; 789  : 
; 790  : 		mf->hash[hash_2_value] = pos;

  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000e9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000ec	8b 45 e4	 mov	 eax, DWORD PTR _hash_2_value$32890[ebp]
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32888[ebp]
  000f2	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 791  : 		mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  000f5	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000f8	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _hash_3_value$32891[ebp]
  000fe	8b 55 f4	 mov	 edx, DWORD PTR _pos$32888[ebp]
  00101	89 94 88 00 10
	00 00		 mov	 DWORD PTR [eax+ecx*4+4096], edx

; 792  : 		mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  00108	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0010b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0010e	8b 55 e8	 mov	 edx, DWORD PTR _hash_value$32893[ebp]
  00111	8b 45 f4	 mov	 eax, DWORD PTR _pos$32888[ebp]
  00114	89 84 91 00 10
	04 00		 mov	 DWORD PTR [ecx+edx*4+266240], eax
$LN3@lzma_mf_bt:

; 793  : 
; 794  : 		bt_skip();

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0011e	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00121	52		 push	 edx
  00122	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00125	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0012c	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0012f	50		 push	 eax
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00133	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00136	52		 push	 edx
  00137	8b 45 e0	 mov	 eax, DWORD PTR _cur_match$32895[ebp]
  0013a	50		 push	 eax
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32887[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 f4	 mov	 edx, DWORD PTR _pos$32888[ebp]
  00142	52		 push	 edx
  00143	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32881[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _bt_skip_func
  0014c	83 c4 20	 add	 esp, 32			; 00000020H
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _move_pos
  00158	83 c4 04	 add	 esp, 4
  0015b	33 d2		 xor	 edx, edx
  0015d	75 bc		 jne	 SHORT $LN3@lzma_mf_bt
$LN9@lzma_mf_bt:

; 795  : 	  }}
; 796  : 
; 797  :     }}  //MiSt: header_skip()
; 798  : 	} while (--amount != 0);

  0015f	8b 45 0c	 mov	 eax, DWORD PTR _amount$[ebp]
  00162	83 e8 01	 sub	 eax, 1
  00165	89 45 0c	 mov	 DWORD PTR _amount$[ebp], eax
  00168	0f 85 98 fe ff
	ff		 jne	 $LN13@lzma_mf_bt

; 799  : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
_lzma_mf_bt4_skip ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_bt4_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt4_find
_TEXT	SEGMENT
tv242 = -60						; size = 4
$T78515 = -56						; size = 4
_x$78511 = -52						; size = 4
_len_best$32859 = -48					; size = 4
_delta2$32856 = -44					; size = 4
_delta3$32857 = -40					; size = 4
_cur_match$32858 = -36					; size = 4
_hash_2_value$32851 = -32				; size = 4
_hash_value$32854 = -28					; size = 4
_hash_3_value$32852 = -24				; size = 4
_temp$32850 = -20					; size = 4
_matches_count$32849 = -16				; size = 4
_pos$32848 = -12					; size = 4
_cur$32847 = -8						; size = 4
_len_limit$32841 = -4					; size = 4
_mf$ = 8						; size = 4
_matches$ = 12						; size = 4
_lzma_mf_bt4_find PROC					; COMDAT

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 724  : 	header_find(true, 4);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32841[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32841[ebp]
  0001e	77 0b		 ja	 SHORT $LN15@lzma_mf_bt@2
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32841[ebp], eax
  00029	eb 2b		 jmp	 SHORT $LN20@lzma_mf_bt@2
$LN15@lzma_mf_bt@2:
  0002b	83 7d fc 04	 cmp	 DWORD PTR _len_limit$32841[ebp], 4
  0002f	72 12		 jb	 SHORT $LN12@lzma_mf_bt@2
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1c		 je	 SHORT $LN20@lzma_mf_bt@2
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 13		 jne	 SHORT $LN20@lzma_mf_bt@2
$LN12@lzma_mf_bt@2:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	33 c0		 xor	 eax, eax
  00051	e9 e6 02 00 00	 jmp	 $LN16@lzma_mf_bt@2
$LN20@lzma_mf_bt@2:
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005e	03 50 14	 add	 edx, DWORD PTR [eax+20]
  00061	89 55 f8	 mov	 DWORD PTR _cur$32847[ebp], edx
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00067	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006d	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00070	89 55 f4	 mov	 DWORD PTR _pos$32848[ebp], edx
  00073	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matches_count$32849[ebp], 0

; 725  : 
; 726  :   {
; 727  : 	hash_4_calc();

  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32847[ebp]
  0007d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00080	8b 45 f8	 mov	 eax, DWORD PTR _cur$32847[ebp]
  00083	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00087	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  0008e	89 4d ec	 mov	 DWORD PTR _temp$32850[ebp], ecx
  00091	8b 55 ec	 mov	 edx, DWORD PTR _temp$32850[ebp]
  00094	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0009a	89 55 e0	 mov	 DWORD PTR _hash_2_value$32851[ebp], edx
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _cur$32847[ebp]
  000a0	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000a4	c1 e1 08	 shl	 ecx, 8
  000a7	33 4d ec	 xor	 ecx, DWORD PTR _temp$32850[ebp]
  000aa	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000b0	89 4d e8	 mov	 DWORD PTR _hash_3_value$32852[ebp], ecx
  000b3	8b 55 f8	 mov	 edx, DWORD PTR _cur$32847[ebp]
  000b6	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000ba	c1 e0 08	 shl	 eax, 8
  000bd	33 45 ec	 xor	 eax, DWORD PTR _temp$32850[ebp]
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32847[ebp]
  000c3	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000c7	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  000ce	c1 e1 05	 shl	 ecx, 5
  000d1	33 c1		 xor	 eax, ecx
  000d3	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000d6	23 42 40	 and	 eax, DWORD PTR [edx+64]
  000d9	89 45 e4	 mov	 DWORD PTR _hash_value$32854[ebp], eax

; 728  : 
; 729  :   {
; 730  : 	uint32_t delta2 = pos - mf->hash[hash_2_value];

  000dc	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000df	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000e2	8b 55 e0	 mov	 edx, DWORD PTR _hash_2_value$32851[ebp]
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _pos$32848[ebp]
  000e8	2b 04 91	 sub	 eax, DWORD PTR [ecx+edx*4]
  000eb	89 45 d4	 mov	 DWORD PTR _delta2$32856[ebp], eax

; 731  : 	const uint32_t delta3
; 732  : 			= pos - mf->hash[FIX_3_HASH_SIZE + hash_3_value];

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000f4	8b 45 e8	 mov	 eax, DWORD PTR _hash_3_value$32852[ebp]
  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32848[ebp]
  000fa	2b 8c 82 00 10
	00 00		 sub	 ecx, DWORD PTR [edx+eax*4+4096]
  00101	89 4d d8	 mov	 DWORD PTR _delta3$32857[ebp], ecx

; 733  : 	const uint32_t cur_match = mf->hash[FIX_4_HASH_SIZE + hash_value];

  00104	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00107	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0010a	8b 4d e4	 mov	 ecx, DWORD PTR _hash_value$32854[ebp]
  0010d	8b 94 88 00 10
	04 00		 mov	 edx, DWORD PTR [eax+ecx*4+266240]
  00114	89 55 dc	 mov	 DWORD PTR _cur_match$32858[ebp], edx

; 734  : 
; 735  : 	mf->hash[hash_2_value] = pos;

  00117	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0011a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0011d	8b 55 e0	 mov	 edx, DWORD PTR _hash_2_value$32851[ebp]
  00120	8b 45 f4	 mov	 eax, DWORD PTR _pos$32848[ebp]
  00123	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 736  : 	mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  00126	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00129	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0012c	8b 45 e8	 mov	 eax, DWORD PTR _hash_3_value$32852[ebp]
  0012f	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32848[ebp]
  00132	89 8c 82 00 10
	00 00		 mov	 DWORD PTR [edx+eax*4+4096], ecx

; 737  : 	mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  00139	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0013c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0013f	8b 4d e4	 mov	 ecx, DWORD PTR _hash_value$32854[ebp]
  00142	8b 55 f4	 mov	 edx, DWORD PTR _pos$32848[ebp]
  00145	89 94 88 00 10
	04 00		 mov	 DWORD PTR [eax+ecx*4+266240], edx

; 738  : 
; 739  :   {
; 740  : 	uint32_t len_best = 1;

  0014c	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _len_best$32859[ebp], 1

; 741  : 
; 742  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00153	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00156	8b 4d d4	 mov	 ecx, DWORD PTR _delta2$32856[ebp]
  00159	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  0015c	73 36		 jae	 SHORT $LN11@lzma_mf_bt@2
  0015e	8b 55 f8	 mov	 edx, DWORD PTR _cur$32847[ebp]
  00161	2b 55 d4	 sub	 edx, DWORD PTR _delta2$32856[ebp]
  00164	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32847[ebp]
  0016a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0016d	3b c2		 cmp	 eax, edx
  0016f	75 23		 jne	 SHORT $LN11@lzma_mf_bt@2

; 743  : 		len_best = 2;

  00171	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _len_best$32859[ebp], 2

; 744  : 		matches[0].len = 2;

  00178	8b 45 0c	 mov	 eax, DWORD PTR _matches$[ebp]
  0017b	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 745  : 		matches[0].dist = delta2 - 1;

  00181	8b 4d d4	 mov	 ecx, DWORD PTR _delta2$32856[ebp]
  00184	83 e9 01	 sub	 ecx, 1
  00187	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  0018a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 746  : 		matches_count = 1;

  0018d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _matches_count$32849[ebp], 1
$LN11@lzma_mf_bt@2:

; 747  : 	}
; 748  : 
; 749  : 	if (delta2 != delta3 && delta3 < mf->cyclic_size
; 750  : 			&& *(cur - delta3) == *cur) {

  00194	8b 45 d4	 mov	 eax, DWORD PTR _delta2$32856[ebp]
  00197	3b 45 d8	 cmp	 eax, DWORD PTR _delta3$32857[ebp]
  0019a	74 44		 je	 SHORT $LN10@lzma_mf_bt@2
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0019f	8b 55 d8	 mov	 edx, DWORD PTR _delta3$32857[ebp]
  001a2	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  001a5	73 39		 jae	 SHORT $LN10@lzma_mf_bt@2
  001a7	8b 45 f8	 mov	 eax, DWORD PTR _cur$32847[ebp]
  001aa	2b 45 d8	 sub	 eax, DWORD PTR _delta3$32857[ebp]
  001ad	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001b0	8b 55 f8	 mov	 edx, DWORD PTR _cur$32847[ebp]
  001b3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001b6	3b c8		 cmp	 ecx, eax
  001b8	75 26		 jne	 SHORT $LN10@lzma_mf_bt@2

; 751  : 		len_best = 3;

  001ba	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _len_best$32859[ebp], 3

; 752  : 		matches[matches_count++].dist = delta3 - 1;

  001c1	8b 4d d8	 mov	 ecx, DWORD PTR _delta3$32857[ebp]
  001c4	83 e9 01	 sub	 ecx, 1
  001c7	8b 55 f0	 mov	 edx, DWORD PTR _matches_count$32849[ebp]
  001ca	8b 45 0c	 mov	 eax, DWORD PTR _matches$[ebp]
  001cd	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx
  001d1	8b 4d f0	 mov	 ecx, DWORD PTR _matches_count$32849[ebp]
  001d4	83 c1 01	 add	 ecx, 1
  001d7	89 4d f0	 mov	 DWORD PTR _matches_count$32849[ebp], ecx

; 753  : 		delta2 = delta3;

  001da	8b 55 d8	 mov	 edx, DWORD PTR _delta3$32857[ebp]
  001dd	89 55 d4	 mov	 DWORD PTR _delta2$32856[ebp], edx
$LN10@lzma_mf_bt@2:

; 754  : 	}
; 755  : 
; 756  : 	if (matches_count != 0) {

  001e0	83 7d f0 00	 cmp	 DWORD PTR _matches_count$32849[ebp], 0
  001e4	0f 84 e5 00 00
	00		 je	 $LN9@lzma_mf_bt@2

; 757  : 		len_best = lzma_memcmplen(
; 758  : 				cur, cur - delta2, len_best, len_limit);

  001ea	8b 45 d0	 mov	 eax, DWORD PTR _len_best$32859[ebp]
  001ed	89 45 c8	 mov	 DWORD PTR $T78515[ebp], eax
$LN26@lzma_mf_bt@2:
  001f0	8b 4d c8	 mov	 ecx, DWORD PTR $T78515[ebp]
  001f3	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32841[ebp]
  001f6	73 73		 jae	 SHORT $LN25@lzma_mf_bt@2
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _cur$32847[ebp]
  001fb	2b 55 d4	 sub	 edx, DWORD PTR _delta2$32856[ebp]
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _cur$32847[ebp]
  00201	03 45 c8	 add	 eax, DWORD PTR $T78515[ebp]
  00204	8b 4d c8	 mov	 ecx, DWORD PTR $T78515[ebp]
  00207	8b 00		 mov	 eax, DWORD PTR [eax]
  00209	2b 04 0a	 sub	 eax, DWORD PTR [edx+ecx]
  0020c	89 45 cc	 mov	 DWORD PTR _x$78511[ebp], eax
  0020f	74 4f		 je	 SHORT $LN24@lzma_mf_bt@2
  00211	8b 4d cc	 mov	 ecx, DWORD PTR _x$78511[ebp]
  00214	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0021a	75 12		 jne	 SHORT $LN23@lzma_mf_bt@2
  0021c	8b 55 c8	 mov	 edx, DWORD PTR $T78515[ebp]
  0021f	83 c2 02	 add	 edx, 2
  00222	89 55 c8	 mov	 DWORD PTR $T78515[ebp], edx
  00225	8b 45 cc	 mov	 eax, DWORD PTR _x$78511[ebp]
  00228	c1 e8 10	 shr	 eax, 16			; 00000010H
  0022b	89 45 cc	 mov	 DWORD PTR _x$78511[ebp], eax
$LN23@lzma_mf_bt@2:
  0022e	8b 4d cc	 mov	 ecx, DWORD PTR _x$78511[ebp]
  00231	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00237	75 09		 jne	 SHORT $LN22@lzma_mf_bt@2
  00239	8b 55 c8	 mov	 edx, DWORD PTR $T78515[ebp]
  0023c	83 c2 01	 add	 edx, 1
  0023f	89 55 c8	 mov	 DWORD PTR $T78515[ebp], edx
$LN22@lzma_mf_bt@2:
  00242	8b 45 c8	 mov	 eax, DWORD PTR $T78515[ebp]
  00245	3b 45 fc	 cmp	 eax, DWORD PTR _len_limit$32841[ebp]
  00248	73 08		 jae	 SHORT $LN29@lzma_mf_bt@2
  0024a	8b 4d c8	 mov	 ecx, DWORD PTR $T78515[ebp]
  0024d	89 4d c4	 mov	 DWORD PTR tv242[ebp], ecx
  00250	eb 06		 jmp	 SHORT $LN30@lzma_mf_bt@2
$LN29@lzma_mf_bt@2:
  00252	8b 55 fc	 mov	 edx, DWORD PTR _len_limit$32841[ebp]
  00255	89 55 c4	 mov	 DWORD PTR tv242[ebp], edx
$LN30@lzma_mf_bt@2:
  00258	8b 45 c4	 mov	 eax, DWORD PTR tv242[ebp]
  0025b	89 45 d0	 mov	 DWORD PTR _len_best$32859[ebp], eax
  0025e	eb 11		 jmp	 SHORT $LN27@lzma_mf_bt@2
$LN24@lzma_mf_bt@2:
  00260	8b 4d c8	 mov	 ecx, DWORD PTR $T78515[ebp]
  00263	83 c1 04	 add	 ecx, 4
  00266	89 4d c8	 mov	 DWORD PTR $T78515[ebp], ecx
  00269	eb 85		 jmp	 SHORT $LN26@lzma_mf_bt@2
$LN25@lzma_mf_bt@2:
  0026b	8b 55 fc	 mov	 edx, DWORD PTR _len_limit$32841[ebp]
  0026e	89 55 d0	 mov	 DWORD PTR _len_best$32859[ebp], edx
$LN27@lzma_mf_bt@2:

; 759  : 
; 760  : 		matches[matches_count - 1].len = len_best;

  00271	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32849[ebp]
  00274	8b 4d 0c	 mov	 ecx, DWORD PTR _matches$[ebp]
  00277	8b 55 d0	 mov	 edx, DWORD PTR _len_best$32859[ebp]
  0027a	89 54 c1 f8	 mov	 DWORD PTR [ecx+eax*8-8], edx

; 761  : 
; 762  : 		if (len_best == len_limit) {

  0027e	8b 45 d0	 mov	 eax, DWORD PTR _len_best$32859[ebp]
  00281	3b 45 fc	 cmp	 eax, DWORD PTR _len_limit$32841[ebp]
  00284	75 49		 jne	 SHORT $LN9@lzma_mf_bt@2
$LN7@lzma_mf_bt@2:

; 763  : 			bt_skip();

  00286	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00289	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0028c	52		 push	 edx
  0028d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00290	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00293	51		 push	 ecx
  00294	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00297	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0029a	50		 push	 eax
  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0029e	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  002a1	52		 push	 edx
  002a2	8b 45 dc	 mov	 eax, DWORD PTR _cur_match$32858[ebp]
  002a5	50		 push	 eax
  002a6	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32847[ebp]
  002a9	51		 push	 ecx
  002aa	8b 55 f4	 mov	 edx, DWORD PTR _pos$32848[ebp]
  002ad	52		 push	 edx
  002ae	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32841[ebp]
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 _bt_skip_func
  002b7	83 c4 20	 add	 esp, 32			; 00000020H
  002ba	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _move_pos
  002c3	83 c4 04	 add	 esp, 4
  002c6	33 d2		 xor	 edx, edx
  002c8	75 bc		 jne	 SHORT $LN7@lzma_mf_bt@2

; 764  : 			return matches_count;

  002ca	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32849[ebp]
  002cd	eb 6d		 jmp	 SHORT $LN16@lzma_mf_bt@2
$LN9@lzma_mf_bt@2:

; 765  : 		}
; 766  : 	}
; 767  : 
; 768  : 	if (len_best < 3)

  002cf	83 7d d0 03	 cmp	 DWORD PTR _len_best$32859[ebp], 3
  002d3	73 07		 jae	 SHORT $LN3@lzma_mf_bt@2

; 769  : 		len_best = 3;

  002d5	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _len_best$32859[ebp], 3
$LN3@lzma_mf_bt@2:

; 770  : 
; 771  : 	bt_find(len_best);

  002dc	8b 45 d0	 mov	 eax, DWORD PTR _len_best$32859[ebp]
  002df	50		 push	 eax
  002e0	8b 4d f0	 mov	 ecx, DWORD PTR _matches_count$32849[ebp]
  002e3	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  002e6	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  002e9	50		 push	 eax
  002ea	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  002ed	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  002f0	52		 push	 edx
  002f1	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002f4	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  002f7	51		 push	 ecx
  002f8	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002fb	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  002fe	50		 push	 eax
  002ff	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00302	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00305	52		 push	 edx
  00306	8b 45 dc	 mov	 eax, DWORD PTR _cur_match$32858[ebp]
  00309	50		 push	 eax
  0030a	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32847[ebp]
  0030d	51		 push	 ecx
  0030e	8b 55 f4	 mov	 edx, DWORD PTR _pos$32848[ebp]
  00311	52		 push	 edx
  00312	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32841[ebp]
  00315	50		 push	 eax
  00316	e8 00 00 00 00	 call	 _bt_find_func
  0031b	83 c4 28	 add	 esp, 40			; 00000028H
  0031e	2b 45 0c	 sub	 eax, DWORD PTR _matches$[ebp]
  00321	c1 f8 03	 sar	 eax, 3
  00324	89 45 f0	 mov	 DWORD PTR _matches_count$32849[ebp], eax
  00327	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0032a	51		 push	 ecx
  0032b	e8 00 00 00 00	 call	 _move_pos
  00330	83 c4 04	 add	 esp, 4
  00333	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32849[ebp]
  00336	eb 04		 jmp	 SHORT $LN16@lzma_mf_bt@2
  00338	33 d2		 xor	 edx, edx
  0033a	75 a0		 jne	 SHORT $LN3@lzma_mf_bt@2
$LN16@lzma_mf_bt@2:

; 772  :   }}}
; 773  :   }}}  //MiSt: header_find()
; 774  : }

  0033c	8b e5		 mov	 esp, ebp
  0033e	5d		 pop	 ebp
  0033f	c3		 ret	 0
_lzma_mf_bt4_find ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_bt3_skip
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt3_skip
_TEXT	SEGMENT
_cur_match$32832 = -28					; size = 4
_hash_2_value$32829 = -24				; size = 4
_hash_value$32830 = -20					; size = 4
_temp$32828 = -16					; size = 4
_pos$32827 = -12					; size = 4
_cur$32826 = -8						; size = 4
_len_limit$32820 = -4					; size = 4
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_lzma_mf_bt3_skip PROC					; COMDAT

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 698  : 	do {
; 699  : 		header_skip(true, 3);

$LN13@lzma_mf_bt@3:
  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32820[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32820[ebp]
  0001e	77 0b		 ja	 SHORT $LN7@lzma_mf_bt@3
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32820[ebp], eax
  00029	eb 29		 jmp	 SHORT $LN15@lzma_mf_bt@3
$LN7@lzma_mf_bt@3:
  0002b	83 7d fc 03	 cmp	 DWORD PTR _len_limit$32820[ebp], 3
  0002f	72 12		 jb	 SHORT $LN4@lzma_mf_bt@3
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1a		 je	 SHORT $LN15@lzma_mf_bt@3
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 11		 jne	 SHORT $LN15@lzma_mf_bt@3
$LN4@lzma_mf_bt@3:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	e9 cf 00 00 00	 jmp	 $LN9@lzma_mf_bt@3
$LN15@lzma_mf_bt@3:
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005c	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0005f	89 55 f8	 mov	 DWORD PTR _cur$32826[ebp], edx
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00065	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00068	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006b	03 50 10	 add	 edx, DWORD PTR [eax+16]
  0006e	89 55 f4	 mov	 DWORD PTR _pos$32827[ebp], edx

; 700  : 
; 701  : 	  {
; 702  : 		hash_3_calc();

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32826[ebp]
  00074	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00077	8b 45 f8	 mov	 eax, DWORD PTR _cur$32826[ebp]
  0007a	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0007e	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  00085	89 4d f0	 mov	 DWORD PTR _temp$32828[ebp], ecx
  00088	8b 55 f0	 mov	 edx, DWORD PTR _temp$32828[ebp]
  0008b	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00091	89 55 e8	 mov	 DWORD PTR _hash_2_value$32829[ebp], edx
  00094	8b 45 f8	 mov	 eax, DWORD PTR _cur$32826[ebp]
  00097	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0009b	c1 e1 08	 shl	 ecx, 8
  0009e	33 4d f0	 xor	 ecx, DWORD PTR _temp$32828[ebp]
  000a1	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000a4	23 4a 40	 and	 ecx, DWORD PTR [edx+64]
  000a7	89 4d ec	 mov	 DWORD PTR _hash_value$32830[ebp], ecx

; 703  : 
; 704  : 	  {
; 705  : 		const uint32_t cur_match
; 706  : 				= mf->hash[FIX_3_HASH_SIZE + hash_value];

  000aa	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000ad	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000b0	8b 55 ec	 mov	 edx, DWORD PTR _hash_value$32830[ebp]
  000b3	8b 84 91 00 10
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+4096]
  000ba	89 45 e4	 mov	 DWORD PTR _cur_match$32832[ebp], eax

; 707  : 
; 708  : 		mf->hash[hash_2_value] = pos;

  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000c0	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000c3	8b 45 e8	 mov	 eax, DWORD PTR _hash_2_value$32829[ebp]
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32827[ebp]
  000c9	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 709  : 		mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  000cc	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000cf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR _hash_value$32830[ebp]
  000d5	8b 55 f4	 mov	 edx, DWORD PTR _pos$32827[ebp]
  000d8	89 94 88 00 10
	00 00		 mov	 DWORD PTR [eax+ecx*4+4096], edx
$LN3@lzma_mf_bt@3:

; 710  : 
; 711  : 		bt_skip();

  000df	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000e2	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000e5	51		 push	 ecx
  000e6	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000e9	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000ec	50		 push	 eax
  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f3	52		 push	 edx
  000f4	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000f7	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000fa	51		 push	 ecx
  000fb	8b 55 e4	 mov	 edx, DWORD PTR _cur_match$32832[ebp]
  000fe	52		 push	 edx
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _cur$32826[ebp]
  00102	50		 push	 eax
  00103	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32827[ebp]
  00106	51		 push	 ecx
  00107	8b 55 fc	 mov	 edx, DWORD PTR _len_limit$32820[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 _bt_skip_func
  00110	83 c4 20	 add	 esp, 32			; 00000020H
  00113	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _move_pos
  0011c	83 c4 04	 add	 esp, 4
  0011f	33 c9		 xor	 ecx, ecx
  00121	75 bc		 jne	 SHORT $LN3@lzma_mf_bt@3
$LN9@lzma_mf_bt@3:

; 712  : 	  }}
; 713  : 
; 714  :     }}  //MiSt: header_skip()
; 715  : 	} while (--amount != 0);

  00123	8b 55 0c	 mov	 edx, DWORD PTR _amount$[ebp]
  00126	83 ea 01	 sub	 edx, 1
  00129	89 55 0c	 mov	 DWORD PTR _amount$[ebp], edx
  0012c	0f 85 d4 fe ff
	ff		 jne	 $LN13@lzma_mf_bt@3

; 716  : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
_lzma_mf_bt3_skip ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_bt3_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt3_find
_TEXT	SEGMENT
tv205 = -52						; size = 4
$T78543 = -48						; size = 4
_x$78539 = -44						; size = 4
_len_best$32801 = -40					; size = 4
_delta2$32799 = -36					; size = 4
_cur_match$32800 = -32					; size = 4
_hash_2_value$32796 = -28				; size = 4
_hash_value$32797 = -24					; size = 4
_temp$32795 = -20					; size = 4
_matches_count$32794 = -16				; size = 4
_pos$32793 = -12					; size = 4
_cur$32792 = -8						; size = 4
_len_limit$32786 = -4					; size = 4
_mf$ = 8						; size = 4
_matches$ = 12						; size = 4
_lzma_mf_bt3_find PROC					; COMDAT

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 660  : 	header_find(true, 3);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32786[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32786[ebp]
  0001e	77 0b		 ja	 SHORT $LN12@lzma_mf_bt@4
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32786[ebp], eax
  00029	eb 2b		 jmp	 SHORT $LN17@lzma_mf_bt@4
$LN12@lzma_mf_bt@4:
  0002b	83 7d fc 03	 cmp	 DWORD PTR _len_limit$32786[ebp], 3
  0002f	72 12		 jb	 SHORT $LN9@lzma_mf_bt@4
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1c		 je	 SHORT $LN17@lzma_mf_bt@4
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 13		 jne	 SHORT $LN17@lzma_mf_bt@4
$LN9@lzma_mf_bt@4:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	33 c0		 xor	 eax, eax
  00051	e9 26 02 00 00	 jmp	 $LN13@lzma_mf_bt@4
$LN17@lzma_mf_bt@4:
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005e	03 50 14	 add	 edx, DWORD PTR [eax+20]
  00061	89 55 f8	 mov	 DWORD PTR _cur$32792[ebp], edx
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00067	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006d	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00070	89 55 f4	 mov	 DWORD PTR _pos$32793[ebp], edx
  00073	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matches_count$32794[ebp], 0

; 661  : 
; 662  :   {
; 663  : 	hash_3_calc();

  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32792[ebp]
  0007d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00080	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  00083	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00087	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  0008e	89 4d ec	 mov	 DWORD PTR _temp$32795[ebp], ecx
  00091	8b 55 ec	 mov	 edx, DWORD PTR _temp$32795[ebp]
  00094	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0009a	89 55 e4	 mov	 DWORD PTR _hash_2_value$32796[ebp], edx
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  000a0	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000a4	c1 e1 08	 shl	 ecx, 8
  000a7	33 4d ec	 xor	 ecx, DWORD PTR _temp$32795[ebp]
  000aa	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000ad	23 4a 40	 and	 ecx, DWORD PTR [edx+64]
  000b0	89 4d e8	 mov	 DWORD PTR _hash_value$32797[ebp], ecx

; 664  : 
; 665  :   {
; 666  : 	const uint32_t delta2 = pos - mf->hash[hash_2_value];

  000b3	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000b6	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000b9	8b 55 e4	 mov	 edx, DWORD PTR _hash_2_value$32796[ebp]
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _pos$32793[ebp]
  000bf	2b 04 91	 sub	 eax, DWORD PTR [ecx+edx*4]
  000c2	89 45 dc	 mov	 DWORD PTR _delta2$32799[ebp], eax

; 667  : 	const uint32_t cur_match = mf->hash[FIX_3_HASH_SIZE + hash_value];

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000c8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000cb	8b 45 e8	 mov	 eax, DWORD PTR _hash_value$32797[ebp]
  000ce	8b 8c 82 00 10
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+4096]
  000d5	89 4d e0	 mov	 DWORD PTR _cur_match$32800[ebp], ecx

; 668  : 
; 669  : 	mf->hash[hash_2_value] = pos;

  000d8	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000db	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000de	8b 4d e4	 mov	 ecx, DWORD PTR _hash_2_value$32796[ebp]
  000e1	8b 55 f4	 mov	 edx, DWORD PTR _pos$32793[ebp]
  000e4	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 670  : 	mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000ea	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000ed	8b 55 e8	 mov	 edx, DWORD PTR _hash_value$32797[ebp]
  000f0	8b 45 f4	 mov	 eax, DWORD PTR _pos$32793[ebp]
  000f3	89 84 91 00 10
	00 00		 mov	 DWORD PTR [ecx+edx*4+4096], eax

; 671  : 
; 672  :   {
; 673  : 	uint32_t len_best = 2;

  000fa	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _len_best$32801[ebp], 2

; 674  : 
; 675  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00101	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00104	8b 55 dc	 mov	 edx, DWORD PTR _delta2$32799[ebp]
  00107	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  0010a	0f 83 0c 01 00
	00		 jae	 $LN3@lzma_mf_bt@4
  00110	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  00113	2b 45 dc	 sub	 eax, DWORD PTR _delta2$32799[ebp]
  00116	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00119	8b 55 f8	 mov	 edx, DWORD PTR _cur$32792[ebp]
  0011c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0011f	3b c8		 cmp	 ecx, eax
  00121	0f 85 f5 00 00
	00		 jne	 $LN3@lzma_mf_bt@4

; 676  : 		len_best = lzma_memcmplen(
; 677  : 				cur, cur - delta2, len_best, len_limit);

  00127	8b 4d d8	 mov	 ecx, DWORD PTR _len_best$32801[ebp]
  0012a	89 4d d0	 mov	 DWORD PTR $T78543[ebp], ecx
$LN23@lzma_mf_bt@4:
  0012d	8b 55 d0	 mov	 edx, DWORD PTR $T78543[ebp]
  00130	3b 55 fc	 cmp	 edx, DWORD PTR _len_limit$32786[ebp]
  00133	73 73		 jae	 SHORT $LN22@lzma_mf_bt@4
  00135	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  00138	2b 45 dc	 sub	 eax, DWORD PTR _delta2$32799[ebp]
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32792[ebp]
  0013e	03 4d d0	 add	 ecx, DWORD PTR $T78543[ebp]
  00141	8b 55 d0	 mov	 edx, DWORD PTR $T78543[ebp]
  00144	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00146	2b 0c 10	 sub	 ecx, DWORD PTR [eax+edx]
  00149	89 4d d4	 mov	 DWORD PTR _x$78539[ebp], ecx
  0014c	74 4f		 je	 SHORT $LN21@lzma_mf_bt@4
  0014e	8b 55 d4	 mov	 edx, DWORD PTR _x$78539[ebp]
  00151	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00157	75 12		 jne	 SHORT $LN20@lzma_mf_bt@4
  00159	8b 45 d0	 mov	 eax, DWORD PTR $T78543[ebp]
  0015c	83 c0 02	 add	 eax, 2
  0015f	89 45 d0	 mov	 DWORD PTR $T78543[ebp], eax
  00162	8b 4d d4	 mov	 ecx, DWORD PTR _x$78539[ebp]
  00165	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00168	89 4d d4	 mov	 DWORD PTR _x$78539[ebp], ecx
$LN20@lzma_mf_bt@4:
  0016b	8b 55 d4	 mov	 edx, DWORD PTR _x$78539[ebp]
  0016e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00174	75 09		 jne	 SHORT $LN19@lzma_mf_bt@4
  00176	8b 45 d0	 mov	 eax, DWORD PTR $T78543[ebp]
  00179	83 c0 01	 add	 eax, 1
  0017c	89 45 d0	 mov	 DWORD PTR $T78543[ebp], eax
$LN19@lzma_mf_bt@4:
  0017f	8b 4d d0	 mov	 ecx, DWORD PTR $T78543[ebp]
  00182	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32786[ebp]
  00185	73 08		 jae	 SHORT $LN26@lzma_mf_bt@4
  00187	8b 55 d0	 mov	 edx, DWORD PTR $T78543[ebp]
  0018a	89 55 cc	 mov	 DWORD PTR tv205[ebp], edx
  0018d	eb 06		 jmp	 SHORT $LN27@lzma_mf_bt@4
$LN26@lzma_mf_bt@4:
  0018f	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32786[ebp]
  00192	89 45 cc	 mov	 DWORD PTR tv205[ebp], eax
$LN27@lzma_mf_bt@4:
  00195	8b 4d cc	 mov	 ecx, DWORD PTR tv205[ebp]
  00198	89 4d d8	 mov	 DWORD PTR _len_best$32801[ebp], ecx
  0019b	eb 11		 jmp	 SHORT $LN24@lzma_mf_bt@4
$LN21@lzma_mf_bt@4:
  0019d	8b 55 d0	 mov	 edx, DWORD PTR $T78543[ebp]
  001a0	83 c2 04	 add	 edx, 4
  001a3	89 55 d0	 mov	 DWORD PTR $T78543[ebp], edx
  001a6	eb 85		 jmp	 SHORT $LN23@lzma_mf_bt@4
$LN22@lzma_mf_bt@4:
  001a8	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32786[ebp]
  001ab	89 45 d8	 mov	 DWORD PTR _len_best$32801[ebp], eax
$LN24@lzma_mf_bt@4:

; 678  : 
; 679  : 		matches[0].len = len_best;

  001ae	8b 4d 0c	 mov	 ecx, DWORD PTR _matches$[ebp]
  001b1	8b 55 d8	 mov	 edx, DWORD PTR _len_best$32801[ebp]
  001b4	89 11		 mov	 DWORD PTR [ecx], edx

; 680  : 		matches[0].dist = delta2 - 1;

  001b6	8b 45 dc	 mov	 eax, DWORD PTR _delta2$32799[ebp]
  001b9	83 e8 01	 sub	 eax, 1
  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _matches$[ebp]
  001bf	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 681  : 		matches_count = 1;

  001c2	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _matches_count$32794[ebp], 1

; 682  : 
; 683  : 		if (len_best == len_limit) {

  001c9	8b 55 d8	 mov	 edx, DWORD PTR _len_best$32801[ebp]
  001cc	3b 55 fc	 cmp	 edx, DWORD PTR _len_limit$32786[ebp]
  001cf	75 4b		 jne	 SHORT $LN3@lzma_mf_bt@4
$LN6@lzma_mf_bt@4:

; 684  : 			bt_skip();

  001d1	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001d4	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001d7	51		 push	 ecx
  001d8	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  001db	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001de	50		 push	 eax
  001df	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001e2	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001e5	52		 push	 edx
  001e6	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001e9	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001ec	51		 push	 ecx
  001ed	8b 55 e0	 mov	 edx, DWORD PTR _cur_match$32800[ebp]
  001f0	52		 push	 edx
  001f1	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  001f4	50		 push	 eax
  001f5	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32793[ebp]
  001f8	51		 push	 ecx
  001f9	8b 55 fc	 mov	 edx, DWORD PTR _len_limit$32786[ebp]
  001fc	52		 push	 edx
  001fd	e8 00 00 00 00	 call	 _bt_skip_func
  00202	83 c4 20	 add	 esp, 32			; 00000020H
  00205	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _move_pos
  0020e	83 c4 04	 add	 esp, 4
  00211	33 c9		 xor	 ecx, ecx
  00213	75 bc		 jne	 SHORT $LN6@lzma_mf_bt@4

; 685  : 			return 1; // matches_count

  00215	b8 01 00 00 00	 mov	 eax, 1
  0021a	eb 60		 jmp	 SHORT $LN13@lzma_mf_bt@4
$LN3@lzma_mf_bt@4:

; 686  : 		}
; 687  : 	}
; 688  : 
; 689  : 	bt_find(len_best);

  0021c	8b 55 d8	 mov	 edx, DWORD PTR _len_best$32801[ebp]
  0021f	52		 push	 edx
  00220	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32794[ebp]
  00223	8b 4d 0c	 mov	 ecx, DWORD PTR _matches$[ebp]
  00226	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00229	52		 push	 edx
  0022a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0022d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00230	51		 push	 ecx
  00231	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00234	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00237	50		 push	 eax
  00238	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0023b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0023e	52		 push	 edx
  0023f	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00242	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00245	51		 push	 ecx
  00246	8b 55 e0	 mov	 edx, DWORD PTR _cur_match$32800[ebp]
  00249	52		 push	 edx
  0024a	8b 45 f8	 mov	 eax, DWORD PTR _cur$32792[ebp]
  0024d	50		 push	 eax
  0024e	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32793[ebp]
  00251	51		 push	 ecx
  00252	8b 55 fc	 mov	 edx, DWORD PTR _len_limit$32786[ebp]
  00255	52		 push	 edx
  00256	e8 00 00 00 00	 call	 _bt_find_func
  0025b	83 c4 28	 add	 esp, 40			; 00000028H
  0025e	2b 45 0c	 sub	 eax, DWORD PTR _matches$[ebp]
  00261	c1 f8 03	 sar	 eax, 3
  00264	89 45 f0	 mov	 DWORD PTR _matches_count$32794[ebp], eax
  00267	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _move_pos
  00270	83 c4 04	 add	 esp, 4
  00273	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32794[ebp]
  00276	eb 04		 jmp	 SHORT $LN13@lzma_mf_bt@4
  00278	33 c9		 xor	 ecx, ecx
  0027a	75 a0		 jne	 SHORT $LN3@lzma_mf_bt@4
$LN13@lzma_mf_bt@4:

; 690  :   }}}
; 691  :   }}}  //MiSt: header_find()
; 692  : }

  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
_lzma_mf_bt3_find ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_bt2_skip
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt2_skip
_TEXT	SEGMENT
_cur_match$32777 = -20					; size = 4
_hash_value$32775 = -16					; size = 4
_pos$32774 = -12					; size = 4
_cur$32773 = -8						; size = 4
_len_limit$32767 = -4					; size = 4
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_lzma_mf_bt2_skip PROC					; COMDAT

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 637  : 	do {
; 638  : 		header_skip(true, 2);

$LN13@lzma_mf_bt@5:
  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32767[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32767[ebp]
  0001e	77 0b		 ja	 SHORT $LN7@lzma_mf_bt@5
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32767[ebp], eax
  00029	eb 29		 jmp	 SHORT $LN15@lzma_mf_bt@5
$LN7@lzma_mf_bt@5:
  0002b	83 7d fc 02	 cmp	 DWORD PTR _len_limit$32767[ebp], 2
  0002f	72 12		 jb	 SHORT $LN4@lzma_mf_bt@5
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1a		 je	 SHORT $LN15@lzma_mf_bt@5
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 11		 jne	 SHORT $LN15@lzma_mf_bt@5
$LN4@lzma_mf_bt@5:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	e9 88 00 00 00	 jmp	 $LN9@lzma_mf_bt@5
$LN15@lzma_mf_bt@5:
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005c	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0005f	89 55 f8	 mov	 DWORD PTR _cur$32773[ebp], edx
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00065	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00068	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006b	03 50 10	 add	 edx, DWORD PTR [eax+16]
  0006e	89 55 f4	 mov	 DWORD PTR _pos$32774[ebp], edx

; 639  : 
; 640  : 	  {
; 641  : 		hash_2_calc();

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32773[ebp]
  00074	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00077	89 55 f0	 mov	 DWORD PTR _hash_value$32775[ebp], edx

; 642  : 
; 643  : 	  {
; 644  : 		const uint32_t cur_match = mf->hash[hash_value];

  0007a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0007d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00080	8b 55 f0	 mov	 edx, DWORD PTR _hash_value$32775[ebp]
  00083	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00086	89 45 ec	 mov	 DWORD PTR _cur_match$32777[ebp], eax

; 645  : 		mf->hash[hash_value] = pos;

  00089	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0008c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0008f	8b 45 f0	 mov	 eax, DWORD PTR _hash_value$32775[ebp]
  00092	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32774[ebp]
  00095	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$LN3@lzma_mf_bt@5:

; 646  : 
; 647  : 		bt_skip();

  00098	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0009b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0009e	50		 push	 eax
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000a2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000a5	52		 push	 edx
  000a6	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000a9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ac	51		 push	 ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000b0	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000b3	50		 push	 eax
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _cur_match$32777[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _cur$32773[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _pos$32774[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _len_limit$32767[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _bt_skip_func
  000c9	83 c4 20	 add	 esp, 32			; 00000020H
  000cc	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _move_pos
  000d5	83 c4 04	 add	 esp, 4
  000d8	33 c0		 xor	 eax, eax
  000da	75 bc		 jne	 SHORT $LN3@lzma_mf_bt@5
$LN9@lzma_mf_bt@5:

; 648  : 	  }}
; 649  : 
; 650  :     }}  //MiSt: header_skip()
; 651  : 	} while (--amount != 0);

  000dc	8b 4d 0c	 mov	 ecx, DWORD PTR _amount$[ebp]
  000df	83 e9 01	 sub	 ecx, 1
  000e2	89 4d 0c	 mov	 DWORD PTR _amount$[ebp], ecx
  000e5	0f 85 1b ff ff
	ff		 jne	 $LN13@lzma_mf_bt@5

; 652  : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_lzma_mf_bt2_skip ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_bt2_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_bt2_find
_TEXT	SEGMENT
_cur_match$32753 = -24					; size = 4
_hash_value$32751 = -20					; size = 4
_matches_count$32750 = -16				; size = 4
_pos$32749 = -12					; size = 4
_cur$32748 = -8						; size = 4
_len_limit$32742 = -4					; size = 4
_mf$ = 8						; size = 4
_matches$ = 12						; size = 4
_lzma_mf_bt2_find PROC					; COMDAT

; 618  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 619  : 	header_find(true, 2);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32742[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32742[ebp]
  0001e	77 0b		 ja	 SHORT $LN7@lzma_mf_bt@6
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32742[ebp], eax
  00029	eb 2b		 jmp	 SHORT $LN12@lzma_mf_bt@6
$LN7@lzma_mf_bt@6:
  0002b	83 7d fc 02	 cmp	 DWORD PTR _len_limit$32742[ebp], 2
  0002f	72 12		 jb	 SHORT $LN4@lzma_mf_bt@6
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 1c		 je	 SHORT $LN12@lzma_mf_bt@6
  0003a	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0003d	83 7a 50 01	 cmp	 DWORD PTR [edx+80], 1
  00041	75 13		 jne	 SHORT $LN12@lzma_mf_bt@6
$LN4@lzma_mf_bt@6:
  00043	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _move_pending
  0004c	83 c4 04	 add	 esp, 4
  0004f	33 c0		 xor	 eax, eax
  00051	e9 a9 00 00 00	 jmp	 $LN8@lzma_mf_bt@6
$LN12@lzma_mf_bt@6:
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0005e	03 50 14	 add	 edx, DWORD PTR [eax+20]
  00061	89 55 f8	 mov	 DWORD PTR _cur$32748[ebp], edx
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00067	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006a	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0006d	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00070	89 55 f4	 mov	 DWORD PTR _pos$32749[ebp], edx
  00073	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matches_count$32750[ebp], 0

; 620  : 
; 621  :   {
; 622  : 	hash_2_calc();

  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32748[ebp]
  0007d	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00080	89 55 ec	 mov	 DWORD PTR _hash_value$32751[ebp], edx

; 623  : 
; 624  :   {
; 625  : 	const uint32_t cur_match = mf->hash[hash_value];

  00083	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00086	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00089	8b 55 ec	 mov	 edx, DWORD PTR _hash_value$32751[ebp]
  0008c	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0008f	89 45 e8	 mov	 DWORD PTR _cur_match$32753[ebp], eax

; 626  : 	mf->hash[hash_value] = pos;

  00092	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00095	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00098	8b 45 ec	 mov	 eax, DWORD PTR _hash_value$32751[ebp]
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32749[ebp]
  0009e	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$LN3@lzma_mf_bt@6:

; 627  : 
; 628  : 	bt_find(1);

  000a1	6a 01		 push	 1
  000a3	8b 55 f0	 mov	 edx, DWORD PTR _matches_count$32750[ebp]
  000a6	8b 45 0c	 mov	 eax, DWORD PTR _matches$[ebp]
  000a9	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  000ac	51		 push	 ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000b0	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000b3	50		 push	 eax
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000b7	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000ba	52		 push	 edx
  000bb	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000be	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c1	51		 push	 ecx
  000c2	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000c5	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000c8	50		 push	 eax
  000c9	8b 4d e8	 mov	 ecx, DWORD PTR _cur_match$32753[ebp]
  000cc	51		 push	 ecx
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _cur$32748[ebp]
  000d0	52		 push	 edx
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _pos$32749[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _len_limit$32742[ebp]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _bt_find_func
  000de	83 c4 28	 add	 esp, 40			; 00000028H
  000e1	2b 45 0c	 sub	 eax, DWORD PTR _matches$[ebp]
  000e4	c1 f8 03	 sar	 eax, 3
  000e7	89 45 f0	 mov	 DWORD PTR _matches_count$32750[ebp], eax
  000ea	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _move_pos
  000f3	83 c4 04	 add	 esp, 4
  000f6	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32750[ebp]
  000f9	eb 04		 jmp	 SHORT $LN8@lzma_mf_bt@6
  000fb	33 c0		 xor	 eax, eax
  000fd	75 a2		 jne	 SHORT $LN3@lzma_mf_bt@6
$LN8@lzma_mf_bt@6:

; 629  :   }}
; 630  :   }}}  //MiSt: header_find()
; 631  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_lzma_mf_bt2_find ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_hc4_skip
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_hc4_skip
_TEXT	SEGMENT
_pos$32651 = -28					; size = 4
_hash_2_value$32653 = -24				; size = 4
_hash_value$32656 = -20					; size = 4
_hash_3_value$32654 = -16				; size = 4
_temp$32652 = -12					; size = 4
_cur$32650 = -8						; size = 4
_cur_match$32658 = -4					; size = 4
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_lzma_mf_hc4_skip PROC					; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 443  : 	do {
; 444  : 		if (mf_avail(mf) < 4) {

$LN10@lzma_mf_hc:
  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	83 fa 04	 cmp	 edx, 4
  00015	73 11		 jae	 SHORT $LN12@lzma_mf_hc

; 445  : 			move_pending(mf);

  00017	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _move_pending
  00020	83 c4 04	 add	 esp, 4

; 446  : 			continue;

  00023	e9 e9 00 00 00	 jmp	 $LN6@lzma_mf_hc

; 447  : 		}
; 448  : 
; 449  : 	  {
; 450  : 		const uint8_t *cur = mf_ptr(mf);

$LN12@lzma_mf_hc:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00030	03 50 14	 add	 edx, DWORD PTR [eax+20]
  00033	89 55 f8	 mov	 DWORD PTR _cur$32650[ebp], edx

; 451  : 		const uint32_t pos = mf->read_pos + mf->offset;

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0003f	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00042	89 55 e4	 mov	 DWORD PTR _pos$32651[ebp], edx

; 452  : 
; 453  : 		hash_4_calc();

  00045	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32650[ebp]
  00048	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _cur$32650[ebp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00052	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  00059	89 4d f4	 mov	 DWORD PTR _temp$32652[ebp], ecx
  0005c	8b 55 f4	 mov	 edx, DWORD PTR _temp$32652[ebp]
  0005f	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00065	89 55 e8	 mov	 DWORD PTR _hash_2_value$32653[ebp], edx
  00068	8b 45 f8	 mov	 eax, DWORD PTR _cur$32650[ebp]
  0006b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0006f	c1 e1 08	 shl	 ecx, 8
  00072	33 4d f4	 xor	 ecx, DWORD PTR _temp$32652[ebp]
  00075	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0007b	89 4d f0	 mov	 DWORD PTR _hash_3_value$32654[ebp], ecx
  0007e	8b 55 f8	 mov	 edx, DWORD PTR _cur$32650[ebp]
  00081	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00085	c1 e0 08	 shl	 eax, 8
  00088	33 45 f4	 xor	 eax, DWORD PTR _temp$32652[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32650[ebp]
  0008e	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00092	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  00099	c1 e1 05	 shl	 ecx, 5
  0009c	33 c1		 xor	 eax, ecx
  0009e	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000a1	23 42 40	 and	 eax, DWORD PTR [edx+64]
  000a4	89 45 ec	 mov	 DWORD PTR _hash_value$32656[ebp], eax

; 454  : 
; 455  : 		const uint32_t cur_match
; 456  : 				= mf->hash[FIX_4_HASH_SIZE + hash_value];

  000a7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000aa	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000ad	8b 55 ec	 mov	 edx, DWORD PTR _hash_value$32656[ebp]
  000b0	8b 84 91 00 10
	04 00		 mov	 eax, DWORD PTR [ecx+edx*4+266240]
  000b7	89 45 fc	 mov	 DWORD PTR _cur_match$32658[ebp], eax

; 457  : 
; 458  : 		mf->hash[hash_2_value] = pos;

  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000bd	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000c0	8b 45 e8	 mov	 eax, DWORD PTR _hash_2_value$32653[ebp]
  000c3	8b 4d e4	 mov	 ecx, DWORD PTR _pos$32651[ebp]
  000c6	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 459  : 		mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  000c9	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000cc	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _hash_3_value$32654[ebp]
  000d2	8b 55 e4	 mov	 edx, DWORD PTR _pos$32651[ebp]
  000d5	89 94 88 00 10
	00 00		 mov	 DWORD PTR [eax+ecx*4+4096], edx

; 460  : 		mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000df	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000e2	8b 55 ec	 mov	 edx, DWORD PTR _hash_value$32656[ebp]
  000e5	8b 45 e4	 mov	 eax, DWORD PTR _pos$32651[ebp]
  000e8	89 84 91 00 10
	04 00		 mov	 DWORD PTR [ecx+edx*4+266240], eax
$LN3@lzma_mf_hc:

; 461  : 
; 462  : 		hc_skip();

  000ef	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000f5	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000f8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _cur_match$32658[ebp]
  000fe	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 _move_pos
  0010a	83 c4 04	 add	 esp, 4
  0010d	33 d2		 xor	 edx, edx
  0010f	75 de		 jne	 SHORT $LN3@lzma_mf_hc
$LN6@lzma_mf_hc:

; 463  : 	  }
; 464  : 
; 465  : 	} while (--amount != 0);

  00111	8b 45 0c	 mov	 eax, DWORD PTR _amount$[ebp]
  00114	83 e8 01	 sub	 eax, 1
  00117	89 45 0c	 mov	 DWORD PTR _amount$[ebp], eax
  0011a	0f 85 e6 fe ff
	ff		 jne	 $LN10@lzma_mf_hc

; 466  : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
_lzma_mf_hc4_skip ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_hc4_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_hc4_find
_TEXT	SEGMENT
tv232 = -60						; size = 4
$T78585 = -56						; size = 4
_x$78578 = -52						; size = 4
_len_best$32627 = -48					; size = 4
_delta2$32624 = -44					; size = 4
_hash_2_value$32619 = -40				; size = 4
_hash_value$32622 = -36					; size = 4
_hash_3_value$32620 = -32				; size = 4
_temp$32618 = -28					; size = 4
_delta3$32625 = -24					; size = 4
_cur_match$32626 = -20					; size = 4
_matches_count$32617 = -16				; size = 4
_pos$32616 = -12					; size = 4
_cur$32615 = -8						; size = 4
_len_limit$32609 = -4					; size = 4
_mf$ = 8						; size = 4
_matches$ = 12						; size = 4
_lzma_mf_hc4_find PROC					; COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 388  : 	header_find(false, 4);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32609[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32609[ebp]
  0001e	77 0b		 ja	 SHORT $LN15@lzma_mf_hc@2
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32609[ebp], eax
  00029	eb 1d		 jmp	 SHORT $LN20@lzma_mf_hc@2
$LN15@lzma_mf_hc@2:
  0002b	83 7d fc 04	 cmp	 DWORD PTR _len_limit$32609[ebp], 4
  0002f	72 04		 jb	 SHORT $LN12@lzma_mf_hc@2
  00031	33 c9		 xor	 ecx, ecx
  00033	74 13		 je	 SHORT $LN20@lzma_mf_hc@2
$LN12@lzma_mf_hc@2:
  00035	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _move_pending
  0003e	83 c4 04	 add	 esp, 4
  00041	33 c0		 xor	 eax, eax
  00043	e9 c3 02 00 00	 jmp	 $LN16@lzma_mf_hc@2
$LN20@lzma_mf_hc@2:
  00048	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00050	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  00053	89 4d f8	 mov	 DWORD PTR _cur$32615[ebp], ecx
  00056	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0005f	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00062	89 4d f4	 mov	 DWORD PTR _pos$32616[ebp], ecx
  00065	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matches_count$32617[ebp], 0

; 389  : 
; 390  :   {
; 391  : 	hash_4_calc();

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _cur$32615[ebp]
  0006f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR _cur$32615[ebp]
  00075	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00079	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR _lzma_crc32_table[ecx*4]
  00080	89 45 e4	 mov	 DWORD PTR _temp$32618[ebp], eax
  00083	8b 4d e4	 mov	 ecx, DWORD PTR _temp$32618[ebp]
  00086	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0008c	89 4d d8	 mov	 DWORD PTR _hash_2_value$32619[ebp], ecx
  0008f	8b 55 f8	 mov	 edx, DWORD PTR _cur$32615[ebp]
  00092	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00096	c1 e0 08	 shl	 eax, 8
  00099	33 45 e4	 xor	 eax, DWORD PTR _temp$32618[ebp]
  0009c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a1	89 45 e0	 mov	 DWORD PTR _hash_3_value$32620[ebp], eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32615[ebp]
  000a7	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  000ab	c1 e2 08	 shl	 edx, 8
  000ae	33 55 e4	 xor	 edx, DWORD PTR _temp$32618[ebp]
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _cur$32615[ebp]
  000b4	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000b8	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _lzma_crc32_table[ecx*4]
  000bf	c1 e0 05	 shl	 eax, 5
  000c2	33 d0		 xor	 edx, eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000c7	23 51 40	 and	 edx, DWORD PTR [ecx+64]
  000ca	89 55 dc	 mov	 DWORD PTR _hash_value$32622[ebp], edx

; 392  : 
; 393  : 	uint32_t delta2 = pos - mf->hash[hash_2_value];

  000cd	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000d0	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000d3	8b 4d d8	 mov	 ecx, DWORD PTR _hash_2_value$32619[ebp]
  000d6	8b 55 f4	 mov	 edx, DWORD PTR _pos$32616[ebp]
  000d9	2b 14 88	 sub	 edx, DWORD PTR [eax+ecx*4]
  000dc	89 55 d4	 mov	 DWORD PTR _delta2$32624[ebp], edx

; 394  : 	const uint32_t delta3
; 395  : 			= pos - mf->hash[FIX_3_HASH_SIZE + hash_3_value];

  000df	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000e2	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000e5	8b 55 e0	 mov	 edx, DWORD PTR _hash_3_value$32620[ebp]
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _pos$32616[ebp]
  000eb	2b 84 91 00 10
	00 00		 sub	 eax, DWORD PTR [ecx+edx*4+4096]
  000f2	89 45 e8	 mov	 DWORD PTR _delta3$32625[ebp], eax

; 396  : 	const uint32_t cur_match = mf->hash[FIX_4_HASH_SIZE + hash_value];

  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000f8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000fb	8b 45 dc	 mov	 eax, DWORD PTR _hash_value$32622[ebp]
  000fe	8b 8c 82 00 10
	04 00		 mov	 ecx, DWORD PTR [edx+eax*4+266240]
  00105	89 4d ec	 mov	 DWORD PTR _cur_match$32626[ebp], ecx

; 397  : 
; 398  : 	mf->hash[hash_2_value ] = pos;

  00108	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0010b	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0010e	8b 4d d8	 mov	 ecx, DWORD PTR _hash_2_value$32619[ebp]
  00111	8b 55 f4	 mov	 edx, DWORD PTR _pos$32616[ebp]
  00114	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 399  : 	mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  00117	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0011a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0011d	8b 55 e0	 mov	 edx, DWORD PTR _hash_3_value$32620[ebp]
  00120	8b 45 f4	 mov	 eax, DWORD PTR _pos$32616[ebp]
  00123	89 84 91 00 10
	00 00		 mov	 DWORD PTR [ecx+edx*4+4096], eax

; 400  : 	mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0012d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00130	8b 45 dc	 mov	 eax, DWORD PTR _hash_value$32622[ebp]
  00133	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32616[ebp]
  00136	89 8c 82 00 10
	04 00		 mov	 DWORD PTR [edx+eax*4+266240], ecx

; 401  : 
; 402  :   {
; 403  : 	uint32_t len_best = 1;

  0013d	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _len_best$32627[ebp], 1

; 404  : 
; 405  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00144	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00147	8b 45 d4	 mov	 eax, DWORD PTR _delta2$32624[ebp]
  0014a	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  0014d	73 36		 jae	 SHORT $LN11@lzma_mf_hc@2
  0014f	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32615[ebp]
  00152	2b 4d d4	 sub	 ecx, DWORD PTR _delta2$32624[ebp]
  00155	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00158	8b 45 f8	 mov	 eax, DWORD PTR _cur$32615[ebp]
  0015b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0015e	3b d1		 cmp	 edx, ecx
  00160	75 23		 jne	 SHORT $LN11@lzma_mf_hc@2

; 406  : 		len_best = 2;

  00162	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _len_best$32627[ebp], 2

; 407  : 		matches[0].len = 2;

  00169	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  0016c	c7 02 02 00 00
	00		 mov	 DWORD PTR [edx], 2

; 408  : 		matches[0].dist = delta2 - 1;

  00172	8b 45 d4	 mov	 eax, DWORD PTR _delta2$32624[ebp]
  00175	83 e8 01	 sub	 eax, 1
  00178	8b 4d 0c	 mov	 ecx, DWORD PTR _matches$[ebp]
  0017b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 409  : 		matches_count = 1;

  0017e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _matches_count$32617[ebp], 1
$LN11@lzma_mf_hc@2:

; 410  : 	}
; 411  : 
; 412  : 	if (delta2 != delta3 && delta3 < mf->cyclic_size
; 413  : 			&& *(cur - delta3) == *cur) {

  00185	8b 55 d4	 mov	 edx, DWORD PTR _delta2$32624[ebp]
  00188	3b 55 e8	 cmp	 edx, DWORD PTR _delta3$32625[ebp]
  0018b	74 44		 je	 SHORT $LN10@lzma_mf_hc@2
  0018d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00190	8b 4d e8	 mov	 ecx, DWORD PTR _delta3$32625[ebp]
  00193	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00196	73 39		 jae	 SHORT $LN10@lzma_mf_hc@2
  00198	8b 55 f8	 mov	 edx, DWORD PTR _cur$32615[ebp]
  0019b	2b 55 e8	 sub	 edx, DWORD PTR _delta3$32625[ebp]
  0019e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32615[ebp]
  001a4	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001a7	3b c2		 cmp	 eax, edx
  001a9	75 26		 jne	 SHORT $LN10@lzma_mf_hc@2

; 414  : 		len_best = 3;

  001ab	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _len_best$32627[ebp], 3

; 415  : 		matches[matches_count++].dist = delta3 - 1;

  001b2	8b 45 e8	 mov	 eax, DWORD PTR _delta3$32625[ebp]
  001b5	83 e8 01	 sub	 eax, 1
  001b8	8b 4d f0	 mov	 ecx, DWORD PTR _matches_count$32617[ebp]
  001bb	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  001be	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax
  001c2	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32617[ebp]
  001c5	83 c0 01	 add	 eax, 1
  001c8	89 45 f0	 mov	 DWORD PTR _matches_count$32617[ebp], eax

; 416  : 		delta2 = delta3;

  001cb	8b 4d e8	 mov	 ecx, DWORD PTR _delta3$32625[ebp]
  001ce	89 4d d4	 mov	 DWORD PTR _delta2$32624[ebp], ecx
$LN10@lzma_mf_hc@2:

; 417  : 	}
; 418  : 
; 419  : 	if (matches_count != 0) {

  001d1	83 7d f0 00	 cmp	 DWORD PTR _matches_count$32617[ebp], 0
  001d5	0f 84 c3 00 00
	00		 je	 $LN9@lzma_mf_hc@2

; 420  : 		len_best = lzma_memcmplen(cur - delta2, cur,
; 421  : 				len_best, len_limit);

  001db	8b 55 d0	 mov	 edx, DWORD PTR _len_best$32627[ebp]
  001de	89 55 c8	 mov	 DWORD PTR $T78585[ebp], edx
$LN26@lzma_mf_hc@2:
  001e1	8b 45 c8	 mov	 eax, DWORD PTR $T78585[ebp]
  001e4	3b 45 fc	 cmp	 eax, DWORD PTR _len_limit$32609[ebp]
  001e7	73 73		 jae	 SHORT $LN25@lzma_mf_hc@2
  001e9	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32615[ebp]
  001ec	2b 4d d4	 sub	 ecx, DWORD PTR _delta2$32624[ebp]
  001ef	8b 55 f8	 mov	 edx, DWORD PTR _cur$32615[ebp]
  001f2	03 55 c8	 add	 edx, DWORD PTR $T78585[ebp]
  001f5	8b 45 c8	 mov	 eax, DWORD PTR $T78585[ebp]
  001f8	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  001fb	2b 0a		 sub	 ecx, DWORD PTR [edx]
  001fd	89 4d cc	 mov	 DWORD PTR _x$78578[ebp], ecx
  00200	74 4f		 je	 SHORT $LN24@lzma_mf_hc@2
  00202	8b 55 cc	 mov	 edx, DWORD PTR _x$78578[ebp]
  00205	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0020b	75 12		 jne	 SHORT $LN23@lzma_mf_hc@2
  0020d	8b 45 c8	 mov	 eax, DWORD PTR $T78585[ebp]
  00210	83 c0 02	 add	 eax, 2
  00213	89 45 c8	 mov	 DWORD PTR $T78585[ebp], eax
  00216	8b 4d cc	 mov	 ecx, DWORD PTR _x$78578[ebp]
  00219	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0021c	89 4d cc	 mov	 DWORD PTR _x$78578[ebp], ecx
$LN23@lzma_mf_hc@2:
  0021f	8b 55 cc	 mov	 edx, DWORD PTR _x$78578[ebp]
  00222	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00228	75 09		 jne	 SHORT $LN22@lzma_mf_hc@2
  0022a	8b 45 c8	 mov	 eax, DWORD PTR $T78585[ebp]
  0022d	83 c0 01	 add	 eax, 1
  00230	89 45 c8	 mov	 DWORD PTR $T78585[ebp], eax
$LN22@lzma_mf_hc@2:
  00233	8b 4d c8	 mov	 ecx, DWORD PTR $T78585[ebp]
  00236	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32609[ebp]
  00239	73 08		 jae	 SHORT $LN29@lzma_mf_hc@2
  0023b	8b 55 c8	 mov	 edx, DWORD PTR $T78585[ebp]
  0023e	89 55 c4	 mov	 DWORD PTR tv232[ebp], edx
  00241	eb 06		 jmp	 SHORT $LN30@lzma_mf_hc@2
$LN29@lzma_mf_hc@2:
  00243	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32609[ebp]
  00246	89 45 c4	 mov	 DWORD PTR tv232[ebp], eax
$LN30@lzma_mf_hc@2:
  00249	8b 4d c4	 mov	 ecx, DWORD PTR tv232[ebp]
  0024c	89 4d d0	 mov	 DWORD PTR _len_best$32627[ebp], ecx
  0024f	eb 11		 jmp	 SHORT $LN27@lzma_mf_hc@2
$LN24@lzma_mf_hc@2:
  00251	8b 55 c8	 mov	 edx, DWORD PTR $T78585[ebp]
  00254	83 c2 04	 add	 edx, 4
  00257	89 55 c8	 mov	 DWORD PTR $T78585[ebp], edx
  0025a	eb 85		 jmp	 SHORT $LN26@lzma_mf_hc@2
$LN25@lzma_mf_hc@2:
  0025c	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32609[ebp]
  0025f	89 45 d0	 mov	 DWORD PTR _len_best$32627[ebp], eax
$LN27@lzma_mf_hc@2:

; 422  : 
; 423  : 		matches[matches_count - 1].len = len_best;

  00262	8b 4d f0	 mov	 ecx, DWORD PTR _matches_count$32617[ebp]
  00265	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  00268	8b 45 d0	 mov	 eax, DWORD PTR _len_best$32627[ebp]
  0026b	89 44 ca f8	 mov	 DWORD PTR [edx+ecx*8-8], eax

; 424  : 
; 425  : 		if (len_best == len_limit) {

  0026f	8b 4d d0	 mov	 ecx, DWORD PTR _len_best$32627[ebp]
  00272	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32609[ebp]
  00275	75 27		 jne	 SHORT $LN9@lzma_mf_hc@2
$LN7@lzma_mf_hc@2:

; 426  : 			hc_skip();

  00277	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0027a	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00280	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00283	8b 4d ec	 mov	 ecx, DWORD PTR _cur_match$32626[ebp]
  00286	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00289	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0028c	52		 push	 edx
  0028d	e8 00 00 00 00	 call	 _move_pos
  00292	83 c4 04	 add	 esp, 4
  00295	33 c0		 xor	 eax, eax
  00297	75 de		 jne	 SHORT $LN7@lzma_mf_hc@2

; 427  : 			return matches_count;

  00299	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32617[ebp]
  0029c	eb 6d		 jmp	 SHORT $LN16@lzma_mf_hc@2
$LN9@lzma_mf_hc@2:

; 428  : 		}
; 429  : 	}
; 430  : 
; 431  : 	if (len_best < 3)

  0029e	83 7d d0 03	 cmp	 DWORD PTR _len_best$32627[ebp], 3
  002a2	73 07		 jae	 SHORT $LN3@lzma_mf_hc@2

; 432  : 		len_best = 3;

  002a4	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _len_best$32627[ebp], 3
$LN3@lzma_mf_hc@2:

; 433  : 
; 434  : 	hc_find(len_best);

  002ab	8b 4d d0	 mov	 ecx, DWORD PTR _len_best$32627[ebp]
  002ae	51		 push	 ecx
  002af	8b 55 f0	 mov	 edx, DWORD PTR _matches_count$32617[ebp]
  002b2	8b 45 0c	 mov	 eax, DWORD PTR _matches$[ebp]
  002b5	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  002b8	51		 push	 ecx
  002b9	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002bc	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  002bf	50		 push	 eax
  002c0	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  002c3	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  002c6	52		 push	 edx
  002c7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  002ca	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002cd	51		 push	 ecx
  002ce	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002d1	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  002d4	50		 push	 eax
  002d5	8b 4d ec	 mov	 ecx, DWORD PTR _cur_match$32626[ebp]
  002d8	51		 push	 ecx
  002d9	8b 55 f8	 mov	 edx, DWORD PTR _cur$32615[ebp]
  002dc	52		 push	 edx
  002dd	8b 45 f4	 mov	 eax, DWORD PTR _pos$32616[ebp]
  002e0	50		 push	 eax
  002e1	8b 4d fc	 mov	 ecx, DWORD PTR _len_limit$32609[ebp]
  002e4	51		 push	 ecx
  002e5	e8 00 00 00 00	 call	 _hc_find_func
  002ea	83 c4 28	 add	 esp, 40			; 00000028H
  002ed	2b 45 0c	 sub	 eax, DWORD PTR _matches$[ebp]
  002f0	c1 f8 03	 sar	 eax, 3
  002f3	89 45 f0	 mov	 DWORD PTR _matches_count$32617[ebp], eax
  002f6	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  002f9	52		 push	 edx
  002fa	e8 00 00 00 00	 call	 _move_pos
  002ff	83 c4 04	 add	 esp, 4
  00302	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32617[ebp]
  00305	eb 04		 jmp	 SHORT $LN16@lzma_mf_hc@2
  00307	33 c0		 xor	 eax, eax
  00309	75 a0		 jne	 SHORT $LN3@lzma_mf_hc@2
$LN16@lzma_mf_hc@2:

; 435  :   }}
; 436  :   }}}  //MiSt: header_find()
; 437  : }

  0030b	8b e5		 mov	 esp, ebp
  0030d	5d		 pop	 ebp
  0030e	c3		 ret	 0
_lzma_mf_hc4_find ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_hc3_skip
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_hc3_skip
_TEXT	SEGMENT
_pos$32595 = -24					; size = 4
_hash_2_value$32597 = -20				; size = 4
_hash_value$32598 = -16					; size = 4
_temp$32596 = -12					; size = 4
_cur$32594 = -8						; size = 4
_cur_match$32600 = -4					; size = 4
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_lzma_mf_hc3_skip PROC					; COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 358  : 	do {
; 359  : 		if (mf_avail(mf) < 3) {

$LN10@lzma_mf_hc@3:
  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	83 fa 03	 cmp	 edx, 3
  00015	73 11		 jae	 SHORT $LN12@lzma_mf_hc@3

; 360  : 			move_pending(mf);

  00017	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _move_pending
  00020	83 c4 04	 add	 esp, 4

; 361  : 			continue;

  00023	e9 ad 00 00 00	 jmp	 $LN6@lzma_mf_hc@3

; 362  : 		}
; 363  : 
; 364  : 	  {
; 365  : 		const uint8_t *cur = mf_ptr(mf);

$LN12@lzma_mf_hc@3:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00030	03 50 14	 add	 edx, DWORD PTR [eax+20]
  00033	89 55 f8	 mov	 DWORD PTR _cur$32594[ebp], edx

; 366  : 		const uint32_t pos = mf->read_pos + mf->offset;

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0003f	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00042	89 55 e8	 mov	 DWORD PTR _pos$32595[ebp], edx

; 367  : 
; 368  : 		hash_3_calc();

  00045	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32594[ebp]
  00048	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _cur$32594[ebp]
  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00052	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _lzma_crc32_table[edx*4]
  00059	89 4d f4	 mov	 DWORD PTR _temp$32596[ebp], ecx
  0005c	8b 55 f4	 mov	 edx, DWORD PTR _temp$32596[ebp]
  0005f	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00065	89 55 ec	 mov	 DWORD PTR _hash_2_value$32597[ebp], edx
  00068	8b 45 f8	 mov	 eax, DWORD PTR _cur$32594[ebp]
  0006b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0006f	c1 e1 08	 shl	 ecx, 8
  00072	33 4d f4	 xor	 ecx, DWORD PTR _temp$32596[ebp]
  00075	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00078	23 4a 40	 and	 ecx, DWORD PTR [edx+64]
  0007b	89 4d f0	 mov	 DWORD PTR _hash_value$32598[ebp], ecx

; 369  : 
; 370  : 		const uint32_t cur_match
; 371  : 				= mf->hash[FIX_3_HASH_SIZE + hash_value];

  0007e	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00081	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00084	8b 55 f0	 mov	 edx, DWORD PTR _hash_value$32598[ebp]
  00087	8b 84 91 00 10
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+4096]
  0008e	89 45 fc	 mov	 DWORD PTR _cur_match$32600[ebp], eax

; 372  : 
; 373  : 		mf->hash[hash_2_value] = pos;

  00091	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00094	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00097	8b 45 ec	 mov	 eax, DWORD PTR _hash_2_value$32597[ebp]
  0009a	8b 4d e8	 mov	 ecx, DWORD PTR _pos$32595[ebp]
  0009d	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 374  : 		mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  000a0	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000a3	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _hash_value$32598[ebp]
  000a9	8b 55 e8	 mov	 edx, DWORD PTR _pos$32595[ebp]
  000ac	89 94 88 00 10
	00 00		 mov	 DWORD PTR [eax+ecx*4+4096], edx
$LN3@lzma_mf_hc@3:

; 375  : 
; 376  : 		hc_skip();

  000b3	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000b6	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b9	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000bc	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _cur_match$32600[ebp]
  000c2	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  000c5	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _move_pos
  000ce	83 c4 04	 add	 esp, 4
  000d1	33 c9		 xor	 ecx, ecx
  000d3	75 de		 jne	 SHORT $LN3@lzma_mf_hc@3
$LN6@lzma_mf_hc@3:

; 377  : 	  }
; 378  : 
; 379  : 	} while (--amount != 0);

  000d5	8b 55 0c	 mov	 edx, DWORD PTR _amount$[ebp]
  000d8	83 ea 01	 sub	 edx, 1
  000db	89 55 0c	 mov	 DWORD PTR _amount$[ebp], edx
  000de	0f 85 22 ff ff
	ff		 jne	 $LN10@lzma_mf_hc@3

; 380  : }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_lzma_mf_hc3_skip ENDP
_TEXT	ENDS
PUBLIC	_lzma_mf_hc3_find
; Function compile flags: /Odtp
;	COMDAT _lzma_mf_hc3_find
_TEXT	SEGMENT
tv195 = -52						; size = 4
$T78613 = -48						; size = 4
_x$78606 = -44						; size = 4
_len_best$32574 = -40					; size = 4
_delta2$32572 = -36					; size = 4
_hash_2_value$32569 = -32				; size = 4
_hash_value$32570 = -28					; size = 4
_temp$32568 = -24					; size = 4
_cur_match$32573 = -20					; size = 4
_matches_count$32567 = -16				; size = 4
_pos$32566 = -12					; size = 4
_cur$32565 = -8						; size = 4
_len_limit$32559 = -4					; size = 4
_mf$ = 8						; size = 4
_matches$ = 12						; size = 4
_lzma_mf_hc3_find PROC					; COMDAT

; 320  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 321  : 	header_find(false, 3);

  00006	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0000f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00012	89 55 fc	 mov	 DWORD PTR _len_limit$32559[ebp], edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00018	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001b	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32559[ebp]
  0001e	77 0b		 ja	 SHORT $LN12@lzma_mf_hc@4
  00020	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00023	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00026	89 45 fc	 mov	 DWORD PTR _len_limit$32559[ebp], eax
  00029	eb 1d		 jmp	 SHORT $LN17@lzma_mf_hc@4
$LN12@lzma_mf_hc@4:
  0002b	83 7d fc 03	 cmp	 DWORD PTR _len_limit$32559[ebp], 3
  0002f	72 04		 jb	 SHORT $LN9@lzma_mf_hc@4
  00031	33 c9		 xor	 ecx, ecx
  00033	74 13		 je	 SHORT $LN17@lzma_mf_hc@4
$LN9@lzma_mf_hc@4:
  00035	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _move_pending
  0003e	83 c4 04	 add	 esp, 4
  00041	33 c0		 xor	 eax, eax
  00043	e9 02 02 00 00	 jmp	 $LN13@lzma_mf_hc@4
$LN17@lzma_mf_hc@4:
  00048	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00050	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  00053	89 4d f8	 mov	 DWORD PTR _cur$32565[ebp], ecx
  00056	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005c	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  0005f	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00062	89 4d f4	 mov	 DWORD PTR _pos$32566[ebp], ecx
  00065	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matches_count$32567[ebp], 0

; 322  : 
; 323  :   {
; 324  : 	hash_3_calc();

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _cur$32565[ebp]
  0006f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR _cur$32565[ebp]
  00075	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00079	33 04 8d 00 00
	00 00		 xor	 eax, DWORD PTR _lzma_crc32_table[ecx*4]
  00080	89 45 e8	 mov	 DWORD PTR _temp$32568[ebp], eax
  00083	8b 4d e8	 mov	 ecx, DWORD PTR _temp$32568[ebp]
  00086	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0008c	89 4d e0	 mov	 DWORD PTR _hash_2_value$32569[ebp], ecx
  0008f	8b 55 f8	 mov	 edx, DWORD PTR _cur$32565[ebp]
  00092	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00096	c1 e0 08	 shl	 eax, 8
  00099	33 45 e8	 xor	 eax, DWORD PTR _temp$32568[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0009f	23 41 40	 and	 eax, DWORD PTR [ecx+64]
  000a2	89 45 e4	 mov	 DWORD PTR _hash_value$32570[ebp], eax

; 325  : 
; 326  : 	const uint32_t delta2 = pos - mf->hash[hash_2_value];

  000a5	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000a8	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000ab	8b 4d e0	 mov	 ecx, DWORD PTR _hash_2_value$32569[ebp]
  000ae	8b 55 f4	 mov	 edx, DWORD PTR _pos$32566[ebp]
  000b1	2b 14 88	 sub	 edx, DWORD PTR [eax+ecx*4]
  000b4	89 55 dc	 mov	 DWORD PTR _delta2$32572[ebp], edx

; 327  : 	const uint32_t cur_match = mf->hash[FIX_3_HASH_SIZE + hash_value];

  000b7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000ba	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000bd	8b 55 e4	 mov	 edx, DWORD PTR _hash_value$32570[ebp]
  000c0	8b 84 91 00 10
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+4096]
  000c7	89 45 ec	 mov	 DWORD PTR _cur_match$32573[ebp], eax

; 328  : 
; 329  : 	mf->hash[hash_2_value] = pos;

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  000cd	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000d0	8b 45 e0	 mov	 eax, DWORD PTR _hash_2_value$32569[ebp]
  000d3	8b 4d f4	 mov	 ecx, DWORD PTR _pos$32566[ebp]
  000d6	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 330  : 	mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  000d9	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  000dc	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000df	8b 4d e4	 mov	 ecx, DWORD PTR _hash_value$32570[ebp]
  000e2	8b 55 f4	 mov	 edx, DWORD PTR _pos$32566[ebp]
  000e5	89 94 88 00 10
	00 00		 mov	 DWORD PTR [eax+ecx*4+4096], edx

; 331  : 
; 332  :   {
; 333  : 	uint32_t len_best = 2;

  000ec	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _len_best$32574[ebp], 2

; 334  : 
; 335  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  000f3	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  000f6	8b 4d dc	 mov	 ecx, DWORD PTR _delta2$32572[ebp]
  000f9	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  000fc	0f 83 e8 00 00
	00		 jae	 $LN3@lzma_mf_hc@4
  00102	8b 55 f8	 mov	 edx, DWORD PTR _cur$32565[ebp]
  00105	2b 55 dc	 sub	 edx, DWORD PTR _delta2$32572[ebp]
  00108	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32565[ebp]
  0010e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00111	3b c2		 cmp	 eax, edx
  00113	0f 85 d1 00 00
	00		 jne	 $LN3@lzma_mf_hc@4

; 336  : 		len_best = lzma_memcmplen(cur - delta2, cur,
; 337  : 				len_best, len_limit);

  00119	8b 45 d8	 mov	 eax, DWORD PTR _len_best$32574[ebp]
  0011c	89 45 d0	 mov	 DWORD PTR $T78613[ebp], eax
$LN23@lzma_mf_hc@4:
  0011f	8b 4d d0	 mov	 ecx, DWORD PTR $T78613[ebp]
  00122	3b 4d fc	 cmp	 ecx, DWORD PTR _len_limit$32559[ebp]
  00125	73 71		 jae	 SHORT $LN22@lzma_mf_hc@4
  00127	8b 55 f8	 mov	 edx, DWORD PTR _cur$32565[ebp]
  0012a	2b 55 dc	 sub	 edx, DWORD PTR _delta2$32572[ebp]
  0012d	8b 45 f8	 mov	 eax, DWORD PTR _cur$32565[ebp]
  00130	03 45 d0	 add	 eax, DWORD PTR $T78613[ebp]
  00133	8b 4d d0	 mov	 ecx, DWORD PTR $T78613[ebp]
  00136	8b 14 0a	 mov	 edx, DWORD PTR [edx+ecx]
  00139	2b 10		 sub	 edx, DWORD PTR [eax]
  0013b	89 55 d4	 mov	 DWORD PTR _x$78606[ebp], edx
  0013e	74 4d		 je	 SHORT $LN21@lzma_mf_hc@4
  00140	8b 45 d4	 mov	 eax, DWORD PTR _x$78606[ebp]
  00143	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00148	75 12		 jne	 SHORT $LN20@lzma_mf_hc@4
  0014a	8b 4d d0	 mov	 ecx, DWORD PTR $T78613[ebp]
  0014d	83 c1 02	 add	 ecx, 2
  00150	89 4d d0	 mov	 DWORD PTR $T78613[ebp], ecx
  00153	8b 55 d4	 mov	 edx, DWORD PTR _x$78606[ebp]
  00156	c1 ea 10	 shr	 edx, 16			; 00000010H
  00159	89 55 d4	 mov	 DWORD PTR _x$78606[ebp], edx
$LN20@lzma_mf_hc@4:
  0015c	8b 45 d4	 mov	 eax, DWORD PTR _x$78606[ebp]
  0015f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00164	75 09		 jne	 SHORT $LN19@lzma_mf_hc@4
  00166	8b 4d d0	 mov	 ecx, DWORD PTR $T78613[ebp]
  00169	83 c1 01	 add	 ecx, 1
  0016c	89 4d d0	 mov	 DWORD PTR $T78613[ebp], ecx
$LN19@lzma_mf_hc@4:
  0016f	8b 55 d0	 mov	 edx, DWORD PTR $T78613[ebp]
  00172	3b 55 fc	 cmp	 edx, DWORD PTR _len_limit$32559[ebp]
  00175	73 08		 jae	 SHORT $LN26@lzma_mf_hc@4
  00177	8b 45 d0	 mov	 eax, DWORD PTR $T78613[ebp]
  0017a	89 45 cc	 mov	 DWORD PTR tv195[ebp], eax
  0017d	eb 06		 jmp	 SHORT $LN27@lzma_mf_hc@4
$LN26@lzma_mf_hc@4:
  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _len_limit$32559[ebp]
  00182	89 4d cc	 mov	 DWORD PTR tv195[ebp], ecx
$LN27@lzma_mf_hc@4:
  00185	8b 55 cc	 mov	 edx, DWORD PTR tv195[ebp]
  00188	89 55 d8	 mov	 DWORD PTR _len_best$32574[ebp], edx
  0018b	eb 11		 jmp	 SHORT $LN24@lzma_mf_hc@4
$LN21@lzma_mf_hc@4:
  0018d	8b 45 d0	 mov	 eax, DWORD PTR $T78613[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 d0	 mov	 DWORD PTR $T78613[ebp], eax
  00196	eb 87		 jmp	 SHORT $LN23@lzma_mf_hc@4
$LN22@lzma_mf_hc@4:
  00198	8b 4d fc	 mov	 ecx, DWORD PTR _len_limit$32559[ebp]
  0019b	89 4d d8	 mov	 DWORD PTR _len_best$32574[ebp], ecx
$LN24@lzma_mf_hc@4:

; 338  : 
; 339  : 		matches[0].len = len_best;

  0019e	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  001a1	8b 45 d8	 mov	 eax, DWORD PTR _len_best$32574[ebp]
  001a4	89 02		 mov	 DWORD PTR [edx], eax

; 340  : 		matches[0].dist = delta2 - 1;

  001a6	8b 4d dc	 mov	 ecx, DWORD PTR _delta2$32572[ebp]
  001a9	83 e9 01	 sub	 ecx, 1
  001ac	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  001af	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 341  : 		matches_count = 1;

  001b2	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _matches_count$32567[ebp], 1

; 342  : 
; 343  : 		if (len_best == len_limit) {

  001b9	8b 45 d8	 mov	 eax, DWORD PTR _len_best$32574[ebp]
  001bc	3b 45 fc	 cmp	 eax, DWORD PTR _len_limit$32559[ebp]
  001bf	75 29		 jne	 SHORT $LN3@lzma_mf_hc@4
$LN6@lzma_mf_hc@4:

; 344  : 			hc_skip();

  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001c4	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001c7	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  001ca	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001cd	8b 45 ec	 mov	 eax, DWORD PTR _cur_match$32573[ebp]
  001d0	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001d6	51		 push	 ecx
  001d7	e8 00 00 00 00	 call	 _move_pos
  001dc	83 c4 04	 add	 esp, 4
  001df	33 d2		 xor	 edx, edx
  001e1	75 de		 jne	 SHORT $LN6@lzma_mf_hc@4

; 345  : 			return 1; // matches_count

  001e3	b8 01 00 00 00	 mov	 eax, 1
  001e8	eb 60		 jmp	 SHORT $LN13@lzma_mf_hc@4
$LN3@lzma_mf_hc@4:

; 346  : 		}
; 347  : 	}
; 348  : 
; 349  : 	hc_find(len_best);

  001ea	8b 45 d8	 mov	 eax, DWORD PTR _len_best$32574[ebp]
  001ed	50		 push	 eax
  001ee	8b 4d f0	 mov	 ecx, DWORD PTR _matches_count$32567[ebp]
  001f1	8b 55 0c	 mov	 edx, DWORD PTR _matches$[ebp]
  001f4	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  001f7	50		 push	 eax
  001f8	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  001fb	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001fe	52		 push	 edx
  001ff	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00202	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00205	51		 push	 ecx
  00206	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00209	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0020c	50		 push	 eax
  0020d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00210	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00213	52		 push	 edx
  00214	8b 45 ec	 mov	 eax, DWORD PTR _cur_match$32573[ebp]
  00217	50		 push	 eax
  00218	8b 4d f8	 mov	 ecx, DWORD PTR _cur$32565[ebp]
  0021b	51		 push	 ecx
  0021c	8b 55 f4	 mov	 edx, DWORD PTR _pos$32566[ebp]
  0021f	52		 push	 edx
  00220	8b 45 fc	 mov	 eax, DWORD PTR _len_limit$32559[ebp]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _hc_find_func
  00229	83 c4 28	 add	 esp, 40			; 00000028H
  0022c	2b 45 0c	 sub	 eax, DWORD PTR _matches$[ebp]
  0022f	c1 f8 03	 sar	 eax, 3
  00232	89 45 f0	 mov	 DWORD PTR _matches_count$32567[ebp], eax
  00235	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 _move_pos
  0023e	83 c4 04	 add	 esp, 4
  00241	8b 45 f0	 mov	 eax, DWORD PTR _matches_count$32567[ebp]
  00244	eb 04		 jmp	 SHORT $LN13@lzma_mf_hc@4
  00246	33 d2		 xor	 edx, edx
  00248	75 a0		 jne	 SHORT $LN3@lzma_mf_hc@4
$LN13@lzma_mf_hc@4:

; 350  :   }}
; 351  :   }}}  //MiSt: header_find()
; 352  : }

  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
_lzma_mf_hc3_find ENDP
END
