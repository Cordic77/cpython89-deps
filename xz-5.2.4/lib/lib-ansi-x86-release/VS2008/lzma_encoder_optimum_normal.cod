; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
;	COMDAT _make_short_rep
_TEXT	SEGMENT
_optimal$ = 8						; size = 4
_make_short_rep PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  : 	optimal->back_prev = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _optimal$[ebp]
  00006	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 229  : 	optimal->prev_1_is_literal = false;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _optimal$[ebp]
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 230  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_make_short_rep ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _make_literal
_TEXT	SEGMENT
_optimal$ = 8						; size = 4
_make_literal PROC					; COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  : 	optimal->back_prev = UINT32_MAX;

  00003	8b 45 08	 mov	 eax, DWORD PTR _optimal$[ebp]
  00006	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1

; 221  : 	optimal->prev_1_is_literal = false;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _optimal$[ebp]
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 222  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_make_literal ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_len_price
_TEXT	SEGMENT
_lencoder$ = 8						; size = 4
_len$ = 12						; size = 4
_pos_state$ = 16					; size = 4
_get_len_price PROC					; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	// NOTE: Unlike the other price tables, length prices are updated
; 64   : 	// in lzma_encoder.c
; 65   : 	return lencoder->prices[pos_state][len - MATCH_LEN_MIN];

  00003	8b 45 10	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00006	69 c0 40 04 00
	00		 imul	 eax, 1088		; 00000440H
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lencoder$[ebp]
  0000f	8d 94 01 04 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1028]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00019	8b 44 82 f8	 mov	 eax, DWORD PTR [edx+eax*4-8]

; 66   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_get_len_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
_TEXT	ENDS
;	COMDAT _lzma_memcmplen
_TEXT	SEGMENT
tv77 = -8						; size = 4
_x$32781 = -4						; size = 4
_buf1$ = 8						; size = 4
_buf2$ = 12						; size = 4
_len$ = 16						; size = 4
_limit$ = 20						; size = 4
_lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN5@lzma_memcm@3:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {
; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);
; 66   : 		if (x != 0) {
; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);
; 70   : 			len += (uint32_t)tmp >> 3;
; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);
; 75   : 		}
; 76   : 
; 77   : 		len += 8;
; 78   : 	}
; 79   : 
; 80   : 	return limit;
; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0000c	73 6c		 jae	 SHORT $LN4@lzma_memcm@3

; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _buf1$[ebp]
  00011	03 4d 10	 add	 ecx, DWORD PTR _len$[ebp]
  00014	8b 55 0c	 mov	 edx, DWORD PTR _buf2$[ebp]
  00017	03 55 10	 add	 edx, DWORD PTR _len$[ebp]
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	2b 02		 sub	 eax, DWORD PTR [edx]
  0001e	89 45 fc	 mov	 DWORD PTR _x$32781[ebp], eax

; 125  : 		if (x != 0) {

  00021	74 4c		 je	 SHORT $LN3@lzma_memcm@3

; 126  : 			if ((x & 0xFFFF) == 0) {

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _x$32781[ebp]
  00026	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0002c	75 12		 jne	 SHORT $LN2@lzma_memcm@3

; 127  : 				len += 2;

  0002e	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00031	83 c2 02	 add	 edx, 2
  00034	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 128  : 				x >>= 16;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _x$32781[ebp]
  0003a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003d	89 45 fc	 mov	 DWORD PTR _x$32781[ebp], eax
$LN2@lzma_memcm@3:

; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _x$32781[ebp]
  00043	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00049	75 09		 jne	 SHORT $LN1@lzma_memcm@3

; 132  : 				++len;

  0004b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
$LN1@lzma_memcm@3:

; 133  : 
; 134  : 			return my_min(len, limit);

  00054	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00057	3b 45 14	 cmp	 eax, DWORD PTR _limit$[ebp]
  0005a	73 08		 jae	 SHORT $LN8@lzma_memcm@3
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
  00062	eb 06		 jmp	 SHORT $LN9@lzma_memcm@3
$LN8@lzma_memcm@3:
  00064	8b 55 14	 mov	 edx, DWORD PTR _limit$[ebp]
  00067	89 55 f8	 mov	 DWORD PTR tv77[ebp], edx
$LN9@lzma_memcm@3:
  0006a	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0006d	eb 0e		 jmp	 SHORT $LN6@lzma_memcm@3
$LN3@lzma_memcm@3:

; 135  : 		}
; 136  : 
; 137  : 		len += 4;

  0006f	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00072	83 c0 04	 add	 eax, 4
  00075	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 138  : 	}

  00078	eb 8c		 jmp	 SHORT $LN5@lzma_memcm@3
$LN4@lzma_memcm@3:

; 139  : 
; 140  : 	return limit;

  0007a	8b 45 14	 mov	 eax, DWORD PTR _limit$[ebp]
$LN6@lzma_memcm@3:

; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_lzma_memcmplen ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT _get_dist_slot_2
_TEXT	SEGMENT
_dist$ = 8						; size = 4
_get_dist_slot_2 PROC					; COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  : 	assert(dist >= FULL_DISTANCES);
; 128  : 
; 129  : 	if (dist < fastpos_limit(FULL_DISTANCES_BITS - 1, 0))

  00003	81 7d 08 00 00
	08 00		 cmp	 DWORD PTR _dist$[ebp], 524288 ; 00080000H
  0000a	73 12		 jae	 SHORT $LN2@get_dist_s

; 130  : 		return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 0);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _dist$[ebp]
  0000f	c1 e8 06	 shr	 eax, 6
  00012	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[eax]
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	eb 2b		 jmp	 SHORT $LN3@get_dist_s
$LN2@get_dist_s:

; 131  : 
; 132  : 	if (dist < fastpos_limit(FULL_DISTANCES_BITS - 1, 1))

  0001e	81 7d 08 00 00
	00 80		 cmp	 DWORD PTR _dist$[ebp], -2147483648 ; 80000000H
  00025	73 12		 jae	 SHORT $LN1@get_dist_s

; 133  : 		return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 1);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _dist$[ebp]
  0002a	c1 e9 12	 shr	 ecx, 18			; 00000012H
  0002d	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[ecx]
  00034	83 c0 24	 add	 eax, 36			; 00000024H
  00037	eb 10		 jmp	 SHORT $LN3@get_dist_s
$LN1@get_dist_s:

; 134  : 
; 135  : 	return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 2);

  00039	8b 55 08	 mov	 edx, DWORD PTR _dist$[ebp]
  0003c	c1 ea 1e	 shr	 edx, 30			; 0000001eH
  0003f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  00046	83 c0 3c	 add	 eax, 60			; 0000003cH
$LN3@get_dist_s:

; 136  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_get_dist_slot_2 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_dist_slot
_TEXT	SEGMENT
_dist$ = 8						; size = 4
_get_dist_slot PROC					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00003	81 7d 08 00 20
	00 00		 cmp	 DWORD PTR _dist$[ebp], 8192 ; 00002000H
  0000a	73 0c		 jae	 SHORT $LN2@get_dist_s@2

; 114  : 		return lzma_fastpos[dist];

  0000c	8b 45 08	 mov	 eax, DWORD PTR _dist$[ebp]
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[eax]
  00016	eb 2b		 jmp	 SHORT $LN3@get_dist_s@2
$LN2@get_dist_s@2:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  00018	81 7d 08 00 00
	00 02		 cmp	 DWORD PTR _dist$[ebp], 33554432 ; 02000000H
  0001f	73 12		 jae	 SHORT $LN1@get_dist_s@2

; 117  : 		return fastpos_result(dist, 0, 1);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _dist$[ebp]
  00024	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  00027	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[ecx]
  0002e	83 c0 18	 add	 eax, 24			; 00000018H
  00031	eb 10		 jmp	 SHORT $LN3@get_dist_s@2
$LN1@get_dist_s@2:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00033	8b 55 08	 mov	 edx, DWORD PTR _dist$[ebp]
  00036	c1 ea 18	 shr	 edx, 24			; 00000018H
  00039	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  00040	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@2:

; 120  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_get_dist_slot ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT _rc_direct_price
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_rc_direct_price PROC					; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   : 	 return bits << RC_BIT_PRICE_SHIFT_BITS;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  00006	c1 e0 04	 shl	 eax, 4

; 90   : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_rc_direct_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit_1_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_rc_bit_1_price PROC					; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 	return lzma_rc_prices[(prob ^ (RC_BIT_MODEL_TOTAL - 1))
; 47   : 			>> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0000c	c1 e8 04	 shr	 eax, 4
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 48   : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_rc_bit_1_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit_0_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_rc_bit_0_price PROC					; COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	return lzma_rc_prices[prob >> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	c1 f8 04	 sar	 eax, 4
  0000a	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 40   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_rc_bit_0_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bit_price
_TEXT	SEGMENT
_prob$ = 8						; size = 2
_bit$ = 12						; size = 4
_rc_bit_price PROC					; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	return lzma_rc_prices[(prob ^ ((UINT32_C(0) - bit)
; 32   : 			& (RC_BIT_MODEL_TOTAL - 1))) >> RC_MOVE_REDUCING_BITS];

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _prob$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	2b 4d 0c	 sub	 ecx, DWORD PTR _bit$[ebp]
  0000c	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00012	33 c1		 xor	 eax, ecx
  00014	c1 e8 04	 shr	 eax, 4
  00017	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[eax]

; 33   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_rc_bit_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT _mf_skip
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_amount$ = 12						; size = 4
_mf_skip PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	if (amount != 0) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR _amount$[ebp], 0
  00007	74 22		 je	 SHORT $LN2@mf_skip@2

; 270  : 		mf->skip(mf, amount);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _amount$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _mf$[ebp]
  00014	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8

; 271  : 		mf->read_ahead += amount;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0001f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00022	03 55 0c	 add	 edx, DWORD PTR _amount$[ebp]
  00025	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00028	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN2@mf_skip@2:

; 272  : 	}
; 273  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_mf_skip ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_avail
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_avail PROC						; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  : 	return mf->write_pos - mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  00009	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000c	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]

; 232  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _mf_ptr
_TEXT	SEGMENT
_mf$ = 8						; size = 4
_mf_ptr	PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 	return mf->buffer + mf->read_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mf$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _mf$[ebp]
  0000b	03 41 14	 add	 eax, DWORD PTR [ecx+20]

; 224  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_mf_ptr	ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
;	COMDAT _backward
_TEXT	SEGMENT
$T76947 = -20						; size = 4
_back_cur$32936 = -16					; size = 4
_pos_prev$32935 = -12					; size = 4
_pos_mem$32928 = -8					; size = 4
_back_mem$32929 = -4					; size = 4
_coder$ = 8						; size = 4
_len_res$ = 12						; size = 4
_back_res$ = 16						; size = 4
_cur$ = 20						; size = 4
_backward PROC						; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 241  : 	coder->opts_end_index = cur;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0000a	8b 4d 14	 mov	 ecx, DWORD PTR _cur$[ebp]
  0000d	89 88 ec 0d 01
	00		 mov	 DWORD PTR [eax+69100], ecx

; 242  : 
; 243  :   {
; 244  : 	uint32_t pos_mem = coder->opts[cur].pos_prev;

  00013	8b 55 14	 mov	 edx, DWORD PTR _cur$[ebp]
  00016	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00019	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001c	8b 8c 10 08 0e
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69128]
  00023	89 4d f8	 mov	 DWORD PTR _pos_mem$32928[ebp], ecx

; 245  : 	uint32_t back_mem = coder->opts[cur].back_prev;

  00026	8b 55 14	 mov	 edx, DWORD PTR _cur$[ebp]
  00029	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0002c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002f	8b 8c 10 0c 0e
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69132]
  00036	89 4d fc	 mov	 DWORD PTR _back_mem$32929[ebp], ecx
$LN5@backward:

; 246  : 
; 247  : 	do {
; 248  : 		if (coder->opts[cur].prev_1_is_literal) {

  00039	8b 55 14	 mov	 edx, DWORD PTR _cur$[ebp]
  0003c	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0003f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00042	0f b6 8c 10 f8
	0d 01 00	 movzx	 ecx, BYTE PTR [eax+edx+69112]
  0004a	85 c9		 test	 ecx, ecx
  0004c	0f 84 a9 00 00
	00		 je	 $LN2@backward

; 249  : 			make_literal(&coder->opts[pos_mem]);

  00052	8b 55 f8	 mov	 edx, DWORD PTR _pos_mem$32928[ebp]
  00055	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00058	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0005b	8d 8c 10 f4 0d
	01 00		 lea	 ecx, DWORD PTR [eax+edx+69108]
  00062	89 4d ec	 mov	 DWORD PTR $T76947[ebp], ecx
  00065	8b 55 ec	 mov	 edx, DWORD PTR $T76947[ebp]
  00068	c7 42 18 ff ff
	ff ff		 mov	 DWORD PTR [edx+24], -1
  0006f	8b 45 ec	 mov	 eax, DWORD PTR $T76947[ebp]
  00072	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 250  : 			coder->opts[pos_mem].pos_prev = pos_mem - 1;

  00076	8b 4d f8	 mov	 ecx, DWORD PTR _pos_mem$32928[ebp]
  00079	83 e9 01	 sub	 ecx, 1
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _pos_mem$32928[ebp]
  0007f	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00082	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00085	89 8c 10 08 0e
	01 00		 mov	 DWORD PTR [eax+edx+69128], ecx

; 251  : 
; 252  : 			if (coder->opts[cur].prev_2) {

  0008c	8b 4d 14	 mov	 ecx, DWORD PTR _cur$[ebp]
  0008f	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00092	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00095	0f b6 84 0a f9
	0d 01 00	 movzx	 eax, BYTE PTR [edx+ecx+69113]
  0009d	85 c0		 test	 eax, eax
  0009f	74 5a		 je	 SHORT $LN2@backward

; 253  : 				coder->opts[pos_mem - 1].prev_1_is_literal
; 254  : 						= false;

  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _pos_mem$32928[ebp]
  000a4	83 e9 01	 sub	 ecx, 1
  000a7	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  000aa	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ad	c6 84 0a f8 0d
	01 00 00	 mov	 BYTE PTR [edx+ecx+69112], 0

; 255  : 				coder->opts[pos_mem - 1].pos_prev
; 256  : 						= coder->opts[cur].pos_prev_2;

  000b5	8b 45 14	 mov	 eax, DWORD PTR _cur$[ebp]
  000b8	6b c0 2c	 imul	 eax, 44			; 0000002cH
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _pos_mem$32928[ebp]
  000be	83 e9 01	 sub	 ecx, 1
  000c1	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  000c4	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000c7	8b 75 08	 mov	 esi, DWORD PTR _coder$[ebp]
  000ca	8b 84 06 fc 0d
	01 00		 mov	 eax, DWORD PTR [esi+eax+69116]
  000d1	89 84 0a 08 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69128], eax

; 257  : 				coder->opts[pos_mem - 1].back_prev
; 258  : 						= coder->opts[cur].back_prev_2;

  000d8	8b 4d 14	 mov	 ecx, DWORD PTR _cur$[ebp]
  000db	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  000de	8b 55 f8	 mov	 edx, DWORD PTR _pos_mem$32928[ebp]
  000e1	83 ea 01	 sub	 edx, 1
  000e4	6b d2 2c	 imul	 edx, 44			; 0000002cH
  000e7	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000ea	8b 75 08	 mov	 esi, DWORD PTR _coder$[ebp]
  000ed	8b 8c 0e 00 0e
	01 00		 mov	 ecx, DWORD PTR [esi+ecx+69120]
  000f4	89 8c 10 0c 0e
	01 00		 mov	 DWORD PTR [eax+edx+69132], ecx
$LN2@backward:

; 259  : 			}
; 260  : 		}
; 261  : 
; 262  :       {
; 263  : 		const uint32_t pos_prev = pos_mem;

  000fb	8b 55 f8	 mov	 edx, DWORD PTR _pos_mem$32928[ebp]
  000fe	89 55 f4	 mov	 DWORD PTR _pos_prev$32935[ebp], edx

; 264  : 		const uint32_t back_cur = back_mem;

  00101	8b 45 fc	 mov	 eax, DWORD PTR _back_mem$32929[ebp]
  00104	89 45 f0	 mov	 DWORD PTR _back_cur$32936[ebp], eax

; 265  : 
; 266  : 		back_mem = coder->opts[pos_prev].back_prev;

  00107	8b 4d f4	 mov	 ecx, DWORD PTR _pos_prev$32935[ebp]
  0010a	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0010d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00110	8b 84 0a 0c 0e
	01 00		 mov	 eax, DWORD PTR [edx+ecx+69132]
  00117	89 45 fc	 mov	 DWORD PTR _back_mem$32929[ebp], eax

; 267  : 		pos_mem = coder->opts[pos_prev].pos_prev;

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _pos_prev$32935[ebp]
  0011d	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00120	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00123	8b 84 0a 08 0e
	01 00		 mov	 eax, DWORD PTR [edx+ecx+69128]
  0012a	89 45 f8	 mov	 DWORD PTR _pos_mem$32928[ebp], eax

; 268  : 
; 269  : 		coder->opts[pos_prev].back_prev = back_cur;

  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _pos_prev$32935[ebp]
  00130	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00133	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00136	8b 45 f0	 mov	 eax, DWORD PTR _back_cur$32936[ebp]
  00139	89 84 0a 0c 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69132], eax

; 270  : 		coder->opts[pos_prev].pos_prev = cur;

  00140	8b 4d f4	 mov	 ecx, DWORD PTR _pos_prev$32935[ebp]
  00143	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00146	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00149	8b 45 14	 mov	 eax, DWORD PTR _cur$[ebp]
  0014c	89 84 0a 08 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69128], eax

; 271  : 		cur = pos_prev;

  00153	8b 4d f4	 mov	 ecx, DWORD PTR _pos_prev$32935[ebp]
  00156	89 4d 14	 mov	 DWORD PTR _cur$[ebp], ecx

; 272  :       }
; 273  : 
; 274  : 	} while (cur != 0);

  00159	83 7d 14 00	 cmp	 DWORD PTR _cur$[ebp], 0
  0015d	0f 85 d6 fe ff
	ff		 jne	 $LN5@backward

; 275  :   }
; 276  : 
; 277  : 	coder->opts_current_index = coder->opts[0].pos_prev;

  00163	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00166	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00169	8b 88 08 0e 01
	00		 mov	 ecx, DWORD PTR [eax+69128]
  0016f	89 8a f0 0d 01
	00		 mov	 DWORD PTR [edx+69104], ecx

; 278  : 	*len_res = coder->opts[0].pos_prev;

  00175	8b 55 0c	 mov	 edx, DWORD PTR _len_res$[ebp]
  00178	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0017b	8b 88 08 0e 01
	00		 mov	 ecx, DWORD PTR [eax+69128]
  00181	89 0a		 mov	 DWORD PTR [edx], ecx

; 279  : 	*back_res = coder->opts[0].back_prev;

  00183	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  00186	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00189	8b 88 0c 0e 01
	00		 mov	 ecx, DWORD PTR [eax+69132]
  0018f	89 0a		 mov	 DWORD PTR [edx], ecx

; 280  : 
; 281  : 	return;
; 282  : }

  00191	5e		 pop	 esi
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
_backward ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_dist_len_price
_TEXT	SEGMENT
tv66 = -20						; size = 4
$T76955 = -16						; size = 4
_dist_slot$32869 = -12					; size = 4
_price$ = -8						; size = 4
_dist_state$ = -4					; size = 4
_coder$ = 8						; size = 4
_dist$ = 12						; size = 4
_len$ = 16						; size = 4
_pos_state$ = 20					; size = 4
_get_dist_len_price PROC				; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 117  : 	const uint32_t dist_state = get_dist_state(len);

  00006	83 7d 10 06	 cmp	 DWORD PTR _len$[ebp], 6
  0000a	73 0b		 jae	 SHORT $LN5@get_dist_l
  0000c	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0000f	83 e8 02	 sub	 eax, 2
  00012	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  00015	eb 07		 jmp	 SHORT $LN6@get_dist_l
$LN5@get_dist_l:
  00017	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR tv66[ebp], 3
$LN6@get_dist_l:
  0001e	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00021	89 4d fc	 mov	 DWORD PTR _dist_state$[ebp], ecx

; 118  : 	uint32_t price;
; 119  : 
; 120  : 	if (dist < FULL_DISTANCES) {

  00024	81 7d 0c 80 00
	00 00		 cmp	 DWORD PTR _dist$[ebp], 128 ; 00000080H
  0002b	73 1b		 jae	 SHORT $LN2@get_dist_l

; 121  : 		price = coder->dist_prices[dist_state][dist];

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _dist_state$[ebp]
  00030	c1 e2 09	 shl	 edx, 9
  00033	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00036	8d 8c 10 a0 05
	01 00		 lea	 ecx, DWORD PTR [eax+edx+66976]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _dist$[ebp]
  00040	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00043	89 45 f8	 mov	 DWORD PTR _price$[ebp], eax

; 122  : 	} else {

  00046	eb 38		 jmp	 SHORT $LN1@get_dist_l
$LN2@get_dist_l:

; 123  : 		const uint32_t dist_slot = get_dist_slot_2(dist);

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _dist$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _get_dist_slot_2
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f4	 mov	 DWORD PTR _dist_slot$32869[ebp], eax

; 124  : 		price = coder->dist_slot_prices[dist_state][dist_slot]
; 125  : 				+ coder->align_prices[dist & ALIGN_MASK];

  00057	8b 55 fc	 mov	 edx, DWORD PTR _dist_state$[ebp]
  0005a	c1 e2 08	 shl	 edx, 8
  0005d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00060	8d 8c 10 a0 01
	01 00		 lea	 ecx, DWORD PTR [eax+edx+65952]
  00067	8b 55 0c	 mov	 edx, DWORD PTR _dist$[ebp]
  0006a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0006d	8b 45 f4	 mov	 eax, DWORD PTR _dist_slot$32869[ebp]
  00070	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00073	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00076	03 8c 90 a8 0d
	01 00		 add	 ecx, DWORD PTR [eax+edx*4+69032]
  0007d	89 4d f8	 mov	 DWORD PTR _price$[ebp], ecx
$LN1@get_dist_l:

; 126  : 	}
; 127  : 
; 128  : 	price += get_len_price(&coder->match_len_encoder, len, pos_state);

  00080	8b 4d 14	 mov	 ecx, DWORD PTR _pos_state$[ebp]
  00083	69 c9 40 04 00
	00		 imul	 ecx, 1088		; 00000440H
  00089	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0008c	8d 84 0a 14 75
	00 00		 lea	 eax, DWORD PTR [edx+ecx+29972]
  00093	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00096	8b 54 88 f8	 mov	 edx, DWORD PTR [eax+ecx*4-8]
  0009a	89 55 f0	 mov	 DWORD PTR $T76955[ebp], edx
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _price$[ebp]
  000a0	03 45 f0	 add	 eax, DWORD PTR $T76955[ebp]
  000a3	89 45 f8	 mov	 DWORD PTR _price$[ebp], eax

; 129  : 
; 130  : 	return price;

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _price$[ebp]

; 131  : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
_get_dist_len_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_pure_rep_price
_TEXT	SEGMENT
_price$ = -4						; size = 4
_coder$ = 8						; size = 4
_rep_index$ = 12					; size = 4
_state$ = 16						; size = 4
_pos_state$ = 20					; size = 4
_get_pure_rep_price PROC				; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 82   : 	uint32_t price;
; 83   : 
; 84   : 	if (rep_index == 0) {

  00004	83 7d 0c 00	 cmp	 DWORD PTR _rep_index$[ebp], 0
  00008	75 4d		 jne	 SHORT $LN11@get_pure_r

; 85   : 		price = rc_bit_0_price(coder->is_rep0[state]);

  0000a	8b 45 10	 mov	 eax, DWORD PTR _state$[ebp]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00010	0f b7 94 41 44
	6c 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+27716]
  00018	c1 fa 04	 sar	 edx, 4
  0001b	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  00022	89 45 fc	 mov	 DWORD PTR _price$[ebp], eax

; 86   : 		price += rc_bit_1_price(coder->is_rep0_long[state][pos_state]);

  00025	8b 4d 10	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	c1 e1 05	 shl	 ecx, 5
  0002b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002e	8d 84 0a 8c 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27788]
  00035	8b 4d 14	 mov	 ecx, DWORD PTR _pos_state$[ebp]
  00038	0f b7 14 48	 movzx	 edx, WORD PTR [eax+ecx*2]
  0003c	81 f2 ff 07 00
	00		 xor	 edx, 2047		; 000007ffH
  00042	c1 ea 04	 shr	 edx, 4
  00045	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  0004c	03 45 fc	 add	 eax, DWORD PTR _price$[ebp]
  0004f	89 45 fc	 mov	 DWORD PTR _price$[ebp], eax

; 87   : 	} else {

  00052	e9 9a 00 00 00	 jmp	 $LN3@get_pure_r

; 88   : 		price = rc_bit_1_price(coder->is_rep0[state]);

$LN11@get_pure_r:
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _state$[ebp]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0005d	0f b7 84 4a 44
	6c 00 00	 movzx	 eax, WORD PTR [edx+ecx*2+27716]
  00065	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0006a	c1 e8 04	 shr	 eax, 4
  0006d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00074	89 4d fc	 mov	 DWORD PTR _price$[ebp], ecx

; 89   : 
; 90   : 		if (rep_index == 1) {

  00077	83 7d 0c 01	 cmp	 DWORD PTR _rep_index$[ebp], 1
  0007b	75 20		 jne	 SHORT $LN15@get_pure_r

; 91   : 			price += rc_bit_0_price(coder->is_rep1[state]);

  0007d	8b 55 10	 mov	 edx, DWORD PTR _state$[ebp]
  00080	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00083	0f b7 8c 50 5c
	6c 00 00	 movzx	 ecx, WORD PTR [eax+edx*2+27740]
  0008b	c1 f9 04	 sar	 ecx, 4
  0008e	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  00095	03 55 fc	 add	 edx, DWORD PTR _price$[ebp]
  00098	89 55 fc	 mov	 DWORD PTR _price$[ebp], edx

; 92   : 		} else {

  0009b	eb 54		 jmp	 SHORT $LN3@get_pure_r

; 93   : 			price += rc_bit_1_price(coder->is_rep1[state]);

$LN15@get_pure_r:
  0009d	8b 45 10	 mov	 eax, DWORD PTR _state$[ebp]
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a3	0f b7 94 41 5c
	6c 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+27740]
  000ab	81 f2 ff 07 00
	00		 xor	 edx, 2047		; 000007ffH
  000b1	c1 ea 04	 shr	 edx, 4
  000b4	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  000bb	03 45 fc	 add	 eax, DWORD PTR _price$[ebp]
  000be	89 45 fc	 mov	 DWORD PTR _price$[ebp], eax

; 94   : 			price += rc_bit_price(coder->is_rep2[state],
; 95   : 					rep_index - 2);

  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _rep_index$[ebp]
  000c4	83 e9 02	 sub	 ecx, 2
  000c7	33 d2		 xor	 edx, edx
  000c9	2b d1		 sub	 edx, ecx
  000cb	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  000d1	8b 45 10	 mov	 eax, DWORD PTR _state$[ebp]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000d7	0f b7 84 41 74
	6c 00 00	 movzx	 eax, WORD PTR [ecx+eax*2+27764]
  000df	33 c2		 xor	 eax, edx
  000e1	c1 e8 04	 shr	 eax, 4
  000e4	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  000eb	03 4d fc	 add	 ecx, DWORD PTR _price$[ebp]
  000ee	89 4d fc	 mov	 DWORD PTR _price$[ebp], ecx
$LN3@get_pure_r:

; 96   : 		}
; 97   : 	}
; 98   : 
; 99   : 	return price;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR _price$[ebp]

; 100  : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_get_pure_rep_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_short_rep_price
_TEXT	SEGMENT
$T76979 = -4						; size = 4
_coder$ = 8						; size = 4
_state$ = 12						; size = 4
_pos_state$ = 16					; size = 4
_get_short_rep_price PROC				; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   : 	return rc_bit_0_price(coder->is_rep0[state])
; 74   : 		+ rc_bit_0_price(coder->is_rep0_long[state][pos_state]);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000a	0f b7 94 41 44
	6c 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+27716]
  00012	c1 fa 04	 sar	 edx, 4
  00015	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  0001c	89 45 fc	 mov	 DWORD PTR $T76979[ebp], eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00022	c1 e1 05	 shl	 ecx, 5
  00025	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00028	8d 84 0a 8c 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27788]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _pos_state$[ebp]
  00032	0f b7 14 48	 movzx	 edx, WORD PTR [eax+ecx*2]
  00036	c1 fa 04	 sar	 edx, 4
  00039	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  00040	03 45 fc	 add	 eax, DWORD PTR $T76979[ebp]

; 75   : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_get_short_rep_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT _rc_bittree_reverse_price
_TEXT	SEGMENT
_bit$32449 = -12					; size = 4
_model_index$ = -8					; size = 4
_price$ = -4						; size = 4
_probs$ = 8						; size = 4
_bit_levels$ = 12					; size = 4
_symbol$ = 16						; size = 4
_rc_bittree_reverse_price PROC				; COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 72   : 	uint32_t price = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _price$[ebp], 0

; 73   : 	uint32_t model_index = 1;

  0000d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _model_index$[ebp], 1
$LN3@rc_bittree:

; 74   : 
; 75   : 	do {
; 76   : 		const uint32_t bit = symbol & 1;

  00014	8b 45 10	 mov	 eax, DWORD PTR _symbol$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	89 45 f4	 mov	 DWORD PTR _bit$32449[ebp], eax

; 77   : 		symbol >>= 1;

  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _symbol$[ebp]
  00020	d1 e9		 shr	 ecx, 1
  00022	89 4d 10	 mov	 DWORD PTR _symbol$[ebp], ecx

; 78   : 		price += rc_bit_price(probs[model_index], bit);

  00025	33 d2		 xor	 edx, edx
  00027	2b 55 f4	 sub	 edx, DWORD PTR _bit$32449[ebp]
  0002a	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00030	8b 45 f8	 mov	 eax, DWORD PTR _model_index$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _probs$[ebp]
  00036	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0003a	33 c2		 xor	 eax, edx
  0003c	c1 e8 04	 shr	 eax, 4
  0003f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00046	03 4d fc	 add	 ecx, DWORD PTR _price$[ebp]
  00049	89 4d fc	 mov	 DWORD PTR _price$[ebp], ecx

; 79   : 		model_index = (model_index << 1) + bit;

  0004c	8b 55 f8	 mov	 edx, DWORD PTR _model_index$[ebp]
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _bit$32449[ebp]
  00052	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00055	89 4d f8	 mov	 DWORD PTR _model_index$[ebp], ecx

; 80   : 	} while (--bit_levels != 0);

  00058	8b 55 0c	 mov	 edx, DWORD PTR _bit_levels$[ebp]
  0005b	83 ea 01	 sub	 edx, 1
  0005e	89 55 0c	 mov	 DWORD PTR _bit_levels$[ebp], edx
  00061	75 b1		 jne	 SHORT $LN3@rc_bittree

; 81   : 
; 82   : 	return price;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _price$[ebp]

; 83   : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_rc_bittree_reverse_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _rc_bittree_price
_TEXT	SEGMENT
_bit$32435 = -8						; size = 4
_price$ = -4						; size = 4
_probs$ = 8						; size = 4
_bit_levels$ = 12					; size = 4
_symbol$ = 16						; size = 4
_rc_bittree_price PROC					; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 55   : 	uint32_t price = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _price$[ebp], 0

; 56   : 	symbol += UINT32_C(1) << bit_levels;

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _bit_levels$[ebp]
  00015	d3 e0		 shl	 eax, cl
  00017	03 45 10	 add	 eax, DWORD PTR _symbol$[ebp]
  0001a	89 45 10	 mov	 DWORD PTR _symbol$[ebp], eax
$LN3@rc_bittree@2:

; 57   : 
; 58   : 	do {
; 59   : 		const uint32_t bit = symbol & 1;

  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _symbol$[ebp]
  00020	83 e1 01	 and	 ecx, 1
  00023	89 4d f8	 mov	 DWORD PTR _bit$32435[ebp], ecx

; 60   : 		symbol >>= 1;

  00026	8b 55 10	 mov	 edx, DWORD PTR _symbol$[ebp]
  00029	d1 ea		 shr	 edx, 1
  0002b	89 55 10	 mov	 DWORD PTR _symbol$[ebp], edx

; 61   : 		price += rc_bit_price(probs[symbol], bit);

  0002e	33 c0		 xor	 eax, eax
  00030	2b 45 f8	 sub	 eax, DWORD PTR _bit$32435[ebp]
  00033	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _symbol$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR _probs$[ebp]
  0003e	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  00042	33 c8		 xor	 ecx, eax
  00044	c1 e9 04	 shr	 ecx, 4
  00047	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  0004e	03 55 fc	 add	 edx, DWORD PTR _price$[ebp]
  00051	89 55 fc	 mov	 DWORD PTR _price$[ebp], edx

; 62   : 	} while (symbol != 1);

  00054	83 7d 10 01	 cmp	 DWORD PTR _symbol$[ebp], 1
  00058	75 c3		 jne	 SHORT $LN3@rc_bittree@2

; 63   : 
; 64   : 	return price;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _price$[ebp]

; 65   : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_rc_bittree_price ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
;	COMDAT _fill_align_prices
_TEXT	SEGMENT
_i$ = -4						; size = 4
_coder$ = 8						; size = 4
_fill_align_prices PROC					; COMDAT

; 202  : {	uint32_t i;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 203  : 
; 204  : 	for (i = 0; i < ALIGN_SIZE; ++i)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@fill_align
$LN2@fill_align:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@fill_align:
  00018	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0001c	73 27		 jae	 SHORT $LN1@fill_align

; 205  : 		coder->align_prices[i] = rc_bittree_reverse_price(
; 206  : 				coder->dist_align, ALIGN_BITS, i);

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	51		 push	 ecx
  00022	6a 04		 push	 4
  00024	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00027	81 c2 f0 70 00
	00		 add	 edx, 28912		; 000070f0H
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _rc_bittree_reverse_price
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003c	89 84 8a a8 0d
	01 00		 mov	 DWORD PTR [edx+ecx*4+69032], eax
  00043	eb ca		 jmp	 SHORT $LN2@fill_align
$LN1@fill_align:

; 207  : 
; 208  : 	coder->align_price_count = 0;

  00045	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00048	c7 80 e8 0d 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+69096], 0

; 209  : 	return;
; 210  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_fill_align_prices ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fill_dist_prices
_TEXT	SEGMENT
_price$32898 = -40					; size = 4
_dist_slot$32895 = -36					; size = 4
_base$32897 = -32					; size = 4
_footer_bits$32896 = -28				; size = 4
_dist_state$32891 = -24					; size = 4
_i$32890 = -20						; size = 4
_i$32886 = -16						; size = 4
_dist_slot$32879 = -12					; size = 4
_dist_slot_prices$32878 = -8				; size = 4
_dist_state$ = -4					; size = 4
_coder$ = 8						; size = 4
_fill_dist_prices PROC					; COMDAT

; 136  : {	uint32_t dist_state;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi

; 137  : 
; 138  : 	for (dist_state = 0; dist_state < DIST_STATES; ++dist_state) {

  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dist_state$[ebp], 0
  0000e	eb 09		 jmp	 SHORT $LN18@fill_dist_
$LN17@fill_dist_:
  00010	8b 45 fc	 mov	 eax, DWORD PTR _dist_state$[ebp]
  00013	83 c0 01	 add	 eax, 1
  00016	89 45 fc	 mov	 DWORD PTR _dist_state$[ebp], eax
$LN18@fill_dist_:
  00019	83 7d fc 04	 cmp	 DWORD PTR _dist_state$[ebp], 4
  0001d	0f 83 da 00 00
	00		 jae	 $LN16@fill_dist_

; 139  : 
; 140  : 		uint32_t *const dist_slot_prices
; 141  : 				= coder->dist_slot_prices[dist_state];

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _dist_state$[ebp]
  00026	c1 e1 08	 shl	 ecx, 8
  00029	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002c	8d 84 0a a0 01
	01 00		 lea	 eax, DWORD PTR [edx+ecx+65952]
  00033	89 45 f8	 mov	 DWORD PTR _dist_slot_prices$32878[ebp], eax

; 142  : 
; 143  : 		// Price to encode the dist_slot.
; 144  : 	  { uint32_t dist_slot;
; 145  : 
; 146  : 		for (dist_slot = 0;
; 147  : 				dist_slot < coder->dist_table_size; ++dist_slot)

  00036	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dist_slot$32879[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN15@fill_dist_
$LN14@fill_dist_:
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _dist_slot$32879[ebp]
  00042	83 c1 01	 add	 ecx, 1
  00045	89 4d f4	 mov	 DWORD PTR _dist_slot$32879[ebp], ecx
$LN15@fill_dist_:
  00048	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0004b	8b 45 f4	 mov	 eax, DWORD PTR _dist_slot$32879[ebp]
  0004e	3b 82 a0 0d 01
	00		 cmp	 eax, DWORD PTR [edx+69024]
  00054	73 2a		 jae	 SHORT $LN13@fill_dist_

; 148  : 			dist_slot_prices[dist_slot] = rc_bittree_price(
; 149  : 					coder->dist_slot[dist_state],
; 150  : 					DIST_SLOT_BITS, dist_slot);

  00056	8b 4d f4	 mov	 ecx, DWORD PTR _dist_slot$32879[ebp]
  00059	51		 push	 ecx
  0005a	6a 06		 push	 6
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _dist_state$[ebp]
  0005f	c1 e2 07	 shl	 edx, 7
  00062	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00065	8d 8c 10 0c 6e
	00 00		 lea	 ecx, DWORD PTR [eax+edx+28172]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _rc_bittree_price
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	8b 55 f4	 mov	 edx, DWORD PTR _dist_slot$32879[ebp]
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _dist_slot_prices$32878[ebp]
  0007b	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  0007e	eb bf		 jmp	 SHORT $LN14@fill_dist_
$LN13@fill_dist_:

; 151  : 
; 152  : 		// For matches with distance >= FULL_DISTANCES, add the price
; 153  : 		// of the direct bits part of the match distance. (Align bits
; 154  : 		// are handled by fill_align_prices()).
; 155  : 		for (dist_slot = DIST_MODEL_END;
; 156  : 				dist_slot < coder->dist_table_size;
; 157  : 				++dist_slot)

  00080	c7 45 f4 0e 00
	00 00		 mov	 DWORD PTR _dist_slot$32879[ebp], 14 ; 0000000eH
  00087	eb 09		 jmp	 SHORT $LN12@fill_dist_
$LN11@fill_dist_:
  00089	8b 55 f4	 mov	 edx, DWORD PTR _dist_slot$32879[ebp]
  0008c	83 c2 01	 add	 edx, 1
  0008f	89 55 f4	 mov	 DWORD PTR _dist_slot$32879[ebp], edx
$LN12@fill_dist_:
  00092	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _dist_slot$32879[ebp]
  00098	3b 88 a0 0d 01
	00		 cmp	 ecx, DWORD PTR [eax+69024]
  0009e	73 1f		 jae	 SHORT $LN10@fill_dist_

; 158  : 			dist_slot_prices[dist_slot] += rc_direct_price(
; 159  : 					((dist_slot >> 1) - 1) - ALIGN_BITS);

  000a0	8b 55 f4	 mov	 edx, DWORD PTR _dist_slot$32879[ebp]
  000a3	d1 ea		 shr	 edx, 1
  000a5	83 ea 05	 sub	 edx, 5
  000a8	c1 e2 04	 shl	 edx, 4
  000ab	8b 45 f4	 mov	 eax, DWORD PTR _dist_slot$32879[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _dist_slot_prices$32878[ebp]
  000b1	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000b4	8b 45 f4	 mov	 eax, DWORD PTR _dist_slot$32879[ebp]
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _dist_slot_prices$32878[ebp]
  000ba	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  000bd	eb ca		 jmp	 SHORT $LN11@fill_dist_
$LN10@fill_dist_:

; 160  : 
; 161  : 		// Distances in the range [0, 3] are fully encoded with
; 162  : 		// dist_slot, so they are used for coder->dist_prices
; 163  : 		// as is.
; 164  : 	  { uint32_t i;
; 165  : 
; 166  : 		for (i = 0; i < DIST_MODEL_START; ++i)

  000bf	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$32886[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN9@fill_dist_
$LN8@fill_dist_:
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _i$32886[ebp]
  000cb	83 c2 01	 add	 edx, 1
  000ce	89 55 f0	 mov	 DWORD PTR _i$32886[ebp], edx
$LN9@fill_dist_:
  000d1	83 7d f0 04	 cmp	 DWORD PTR _i$32886[ebp], 4
  000d5	73 21		 jae	 SHORT $LN7@fill_dist_

; 167  : 			coder->dist_prices[dist_state][i]
; 168  : 					= dist_slot_prices[i];

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _dist_state$[ebp]
  000da	c1 e0 09	 shl	 eax, 9
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000e0	8d 94 01 a0 05
	01 00		 lea	 edx, DWORD PTR [ecx+eax+66976]
  000e7	8b 45 f0	 mov	 eax, DWORD PTR _i$32886[ebp]
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _i$32886[ebp]
  000ed	8b 75 f8	 mov	 esi, DWORD PTR _dist_slot_prices$32878[ebp]
  000f0	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  000f3	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  000f6	eb d0		 jmp	 SHORT $LN8@fill_dist_
$LN7@fill_dist_:

; 169  : 	  }}
; 170  : 	}

  000f8	e9 13 ff ff ff	 jmp	 $LN17@fill_dist_
$LN16@fill_dist_:

; 171  : 
; 172  : 	// Distances in the range [4, 127] depend on dist_slot and
; 173  : 	// dist_special. We do this in a loop separate from the above
; 174  : 	// loop to avoid redundant calls to get_dist_slot().
; 175  :   {
; 176  : 	uint32_t i;
; 177  : 	uint32_t dist_state;
; 178  : 
; 179  : 	for (i = DIST_MODEL_START; i < FULL_DISTANCES; ++i) {

  000fd	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _i$32890[ebp], 4
  00104	eb 09		 jmp	 SHORT $LN6@fill_dist_
$LN5@fill_dist_:
  00106	8b 55 ec	 mov	 edx, DWORD PTR _i$32890[ebp]
  00109	83 c2 01	 add	 edx, 1
  0010c	89 55 ec	 mov	 DWORD PTR _i$32890[ebp], edx
$LN6@fill_dist_:
  0010f	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _i$32890[ebp], 128 ; 00000080H
  00116	0f 83 e1 00 00
	00		 jae	 $LN4@fill_dist_

; 180  : 		const uint32_t dist_slot = get_dist_slot(i);

  0011c	81 7d ec 00 20
	00 00		 cmp	 DWORD PTR _i$32890[ebp], 8192 ; 00002000H
  00123	73 0f		 jae	 SHORT $LN31@fill_dist_
  00125	8b 45 ec	 mov	 eax, DWORD PTR _i$32890[ebp]
  00128	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_fastpos[eax]
  0012f	89 4d dc	 mov	 DWORD PTR _dist_slot$32895[ebp], ecx
  00132	eb 31		 jmp	 SHORT $LN32@fill_dist_
$LN31@fill_dist_:
  00134	81 7d ec 00 00
	00 02		 cmp	 DWORD PTR _i$32890[ebp], 33554432 ; 02000000H
  0013b	73 15		 jae	 SHORT $LN30@fill_dist_
  0013d	8b 55 ec	 mov	 edx, DWORD PTR _i$32890[ebp]
  00140	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  00143	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_fastpos[edx]
  0014a	83 c0 18	 add	 eax, 24			; 00000018H
  0014d	89 45 dc	 mov	 DWORD PTR _dist_slot$32895[ebp], eax
  00150	eb 13		 jmp	 SHORT $LN32@fill_dist_
$LN30@fill_dist_:
  00152	8b 4d ec	 mov	 ecx, DWORD PTR _i$32890[ebp]
  00155	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00158	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_fastpos[ecx]
  0015f	83 c2 30	 add	 edx, 48			; 00000030H
  00162	89 55 dc	 mov	 DWORD PTR _dist_slot$32895[ebp], edx
$LN32@fill_dist_:

; 181  : 		const uint32_t footer_bits = ((dist_slot >> 1) - 1);

  00165	8b 45 dc	 mov	 eax, DWORD PTR _dist_slot$32895[ebp]
  00168	d1 e8		 shr	 eax, 1
  0016a	83 e8 01	 sub	 eax, 1
  0016d	89 45 e4	 mov	 DWORD PTR _footer_bits$32896[ebp], eax

; 182  : 		const uint32_t base = (2 | (dist_slot & 1)) << footer_bits;

  00170	8b 55 dc	 mov	 edx, DWORD PTR _dist_slot$32895[ebp]
  00173	83 e2 01	 and	 edx, 1
  00176	83 ca 02	 or	 edx, 2
  00179	8b 4d e4	 mov	 ecx, DWORD PTR _footer_bits$32896[ebp]
  0017c	d3 e2		 shl	 edx, cl
  0017e	89 55 e0	 mov	 DWORD PTR _base$32897[ebp], edx

; 183  : 		const uint32_t price = rc_bittree_reverse_price(
; 184  : 				coder->dist_special + base - dist_slot - 1,
; 185  : 				footer_bits, i - base);

  00181	8b 45 ec	 mov	 eax, DWORD PTR _i$32890[ebp]
  00184	2b 45 e0	 sub	 eax, DWORD PTR _base$32897[ebp]
  00187	50		 push	 eax
  00188	8b 4d e4	 mov	 ecx, DWORD PTR _footer_bits$32896[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 e0	 mov	 edx, DWORD PTR _base$32897[ebp]
  0018f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00192	8d 8c 50 0c 70
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+28684]
  00199	8b 55 dc	 mov	 edx, DWORD PTR _dist_slot$32895[ebp]
  0019c	d1 e2		 shl	 edx, 1
  0019e	2b ca		 sub	 ecx, edx
  001a0	83 e9 02	 sub	 ecx, 2
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 _rc_bittree_reverse_price
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	89 45 d8	 mov	 DWORD PTR _price$32898[ebp], eax

; 186  : 
; 187  : 		for (dist_state = 0; dist_state < DIST_STATES;
; 188  : 				++dist_state)

  001af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dist_state$32891[ebp], 0
  001b6	eb 09		 jmp	 SHORT $LN3@fill_dist_
$LN2@fill_dist_:
  001b8	8b 45 e8	 mov	 eax, DWORD PTR _dist_state$32891[ebp]
  001bb	83 c0 01	 add	 eax, 1
  001be	89 45 e8	 mov	 DWORD PTR _dist_state$32891[ebp], eax
$LN3@fill_dist_:
  001c1	83 7d e8 04	 cmp	 DWORD PTR _dist_state$32891[ebp], 4
  001c5	73 31		 jae	 SHORT $LN1@fill_dist_

; 189  : 			coder->dist_prices[dist_state][i]
; 190  : 					= price + coder->dist_slot_prices[
; 191  : 						dist_state][dist_slot];

  001c7	8b 4d e8	 mov	 ecx, DWORD PTR _dist_state$32891[ebp]
  001ca	c1 e1 08	 shl	 ecx, 8
  001cd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  001d0	8d 84 0a a0 01
	01 00		 lea	 eax, DWORD PTR [edx+ecx+65952]
  001d7	8b 4d dc	 mov	 ecx, DWORD PTR _dist_slot$32895[ebp]
  001da	8b 55 d8	 mov	 edx, DWORD PTR _price$32898[ebp]
  001dd	03 14 88	 add	 edx, DWORD PTR [eax+ecx*4]
  001e0	8b 45 e8	 mov	 eax, DWORD PTR _dist_state$32891[ebp]
  001e3	c1 e0 09	 shl	 eax, 9
  001e6	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001e9	8d 84 01 a0 05
	01 00		 lea	 eax, DWORD PTR [ecx+eax+66976]
  001f0	8b 4d ec	 mov	 ecx, DWORD PTR _i$32890[ebp]
  001f3	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  001f6	eb c0		 jmp	 SHORT $LN2@fill_dist_
$LN1@fill_dist_:

; 192  : 	}

  001f8	e9 09 ff ff ff	 jmp	 $LN5@fill_dist_
$LN4@fill_dist_:

; 193  :   }
; 194  : 
; 195  : 	coder->match_price_count = 0;

  001fd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00200	c7 82 a4 0d 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+69028], 0

; 196  : 	return;
; 197  : }

  0020a	5e		 pop	 esi
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
_fill_dist_prices ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_rep_price
_TEXT	SEGMENT
$T78642 = -4						; size = 4
_coder$ = 8						; size = 4
_rep_index$ = 12					; size = 4
_len$ = 16						; size = 4
_state$ = 20						; size = 4
_pos_state$ = 24					; size = 4
_get_rep_price PROC					; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 108  : 	return get_len_price(&coder->rep_len_encoder, len, pos_state)
; 109  : 		+ get_pure_rep_price(coder, rep_index, state, pos_state);

  00006	8b 45 18	 mov	 eax, DWORD PTR _pos_state$[ebp]
  00009	69 c0 40 04 00
	00		 imul	 eax, 1088		; 00000440H
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00012	8d 94 01 5c bd
	00 00		 lea	 edx, DWORD PTR [ecx+eax+48476]
  00019	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0001c	8b 4c 82 f8	 mov	 ecx, DWORD PTR [edx+eax*4-8]
  00020	89 4d fc	 mov	 DWORD PTR $T78642[ebp], ecx
  00023	8b 55 18	 mov	 edx, DWORD PTR _pos_state$[ebp]
  00026	52		 push	 edx
  00027	8b 45 14	 mov	 eax, DWORD PTR _state$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _rep_index$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _get_pure_rep_price
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	03 45 fc	 add	 eax, DWORD PTR $T78642[ebp]

; 110  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_get_rep_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_literal_price
_TEXT	SEGMENT
_bit$32811 = -24					; size = 4
_match_bit$32809 = -20					; size = 4
_subcoder_index$32810 = -16				; size = 4
_offset$32805 = -12					; size = 4
_price$ = -8						; size = 4
_subcoder$ = -4						; size = 4
_coder$ = 8						; size = 4
_pos$ = 12						; size = 4
_prev_byte$ = 16					; size = 4
_match_mode$ = 20					; size = 1
_match_byte$ = 24					; size = 4
_symbol$ = 28						; size = 4
_get_literal_price PROC					; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 26   : 	const probability *const subcoder = literal_subcoder(coder->literal,
; 27   : 			coder->literal_context_bits, coder->literal_pos_mask,
; 28   : 			pos, prev_byte);

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0000a	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  0000d	23 90 a8 0a 00
	00		 and	 edx, DWORD PTR [eax+2728]
  00013	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00016	8b 88 a4 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2724]
  0001c	d3 e2		 shl	 edx, cl
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	b8 08 00 00 00	 mov	 eax, 8
  00026	2b 81 a4 0a 00
	00		 sub	 eax, DWORD PTR [ecx+2724]
  0002c	8b 75 10	 mov	 esi, DWORD PTR _prev_byte$[ebp]
  0002f	8b c8		 mov	 ecx, eax
  00031	d3 ee		 shr	 esi, cl
  00033	03 d6		 add	 edx, esi
  00035	69 d2 00 06 00
	00		 imul	 edx, 1536		; 00000600H
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0003e	8d 94 11 ac 0a
	00 00		 lea	 edx, DWORD PTR [ecx+edx+2732]
  00045	89 55 fc	 mov	 DWORD PTR _subcoder$[ebp], edx

; 29   : 
; 30   : 	uint32_t price = 0;

  00048	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _price$[ebp], 0

; 31   : 
; 32   : 	if (!match_mode) {

  0004f	0f b6 45 14	 movzx	 eax, BYTE PTR _match_mode$[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 1a		 jne	 SHORT $LN5@get_litera

; 33   : 		price = rc_bittree_price(subcoder, 8, symbol);

  00057	8b 4d 1c	 mov	 ecx, DWORD PTR _symbol$[ebp]
  0005a	51		 push	 ecx
  0005b	6a 08		 push	 8
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _subcoder$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _rc_bittree_price
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	89 45 f8	 mov	 DWORD PTR _price$[ebp], eax

; 34   : 	} else {

  0006c	e9 85 00 00 00	 jmp	 $LN4@get_litera
$LN5@get_litera:

; 35   : 		uint32_t offset = 0x100;

  00071	c7 45 f4 00 01
	00 00		 mov	 DWORD PTR _offset$32805[ebp], 256 ; 00000100H

; 36   : 		symbol += UINT32_C(1) << 8;

  00078	8b 45 1c	 mov	 eax, DWORD PTR _symbol$[ebp]
  0007b	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00080	89 45 1c	 mov	 DWORD PTR _symbol$[ebp], eax
$LN3@get_litera:

; 37   : 
; 38   : 		do {
; 39   : 			match_byte <<= 1;

  00083	8b 4d 18	 mov	 ecx, DWORD PTR _match_byte$[ebp]
  00086	d1 e1		 shl	 ecx, 1
  00088	89 4d 18	 mov	 DWORD PTR _match_byte$[ebp], ecx

; 40   : 
; 41   :           {
; 42   : 			const uint32_t match_bit = match_byte & offset;

  0008b	8b 55 18	 mov	 edx, DWORD PTR _match_byte$[ebp]
  0008e	23 55 f4	 and	 edx, DWORD PTR _offset$32805[ebp]
  00091	89 55 ec	 mov	 DWORD PTR _match_bit$32809[ebp], edx

; 43   : 			const uint32_t subcoder_index
; 44   : 					= offset + match_bit + (symbol >> 8);

  00094	8b 45 f4	 mov	 eax, DWORD PTR _offset$32805[ebp]
  00097	03 45 ec	 add	 eax, DWORD PTR _match_bit$32809[ebp]
  0009a	8b 4d 1c	 mov	 ecx, DWORD PTR _symbol$[ebp]
  0009d	c1 e9 08	 shr	 ecx, 8
  000a0	03 c1		 add	 eax, ecx
  000a2	89 45 f0	 mov	 DWORD PTR _subcoder_index$32810[ebp], eax

; 45   : 			const uint32_t bit = (symbol >> 7) & 1;

  000a5	8b 55 1c	 mov	 edx, DWORD PTR _symbol$[ebp]
  000a8	c1 ea 07	 shr	 edx, 7
  000ab	83 e2 01	 and	 edx, 1
  000ae	89 55 e8	 mov	 DWORD PTR _bit$32811[ebp], edx

; 46   : 			price += rc_bit_price(subcoder[subcoder_index], bit);

  000b1	33 c0		 xor	 eax, eax
  000b3	2b 45 e8	 sub	 eax, DWORD PTR _bit$32811[ebp]
  000b6	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR _subcoder_index$32810[ebp]
  000be	8b 55 fc	 mov	 edx, DWORD PTR _subcoder$[ebp]
  000c1	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  000c5	33 c8		 xor	 ecx, eax
  000c7	c1 e9 04	 shr	 ecx, 4
  000ca	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  000d1	03 55 f8	 add	 edx, DWORD PTR _price$[ebp]
  000d4	89 55 f8	 mov	 DWORD PTR _price$[ebp], edx

; 47   : 
; 48   : 			symbol <<= 1;

  000d7	8b 45 1c	 mov	 eax, DWORD PTR _symbol$[ebp]
  000da	d1 e0		 shl	 eax, 1
  000dc	89 45 1c	 mov	 DWORD PTR _symbol$[ebp], eax

; 49   : 			offset &= ~(match_byte ^ symbol);

  000df	8b 4d 18	 mov	 ecx, DWORD PTR _match_byte$[ebp]
  000e2	33 4d 1c	 xor	 ecx, DWORD PTR _symbol$[ebp]
  000e5	f7 d1		 not	 ecx
  000e7	23 4d f4	 and	 ecx, DWORD PTR _offset$32805[ebp]
  000ea	89 4d f4	 mov	 DWORD PTR _offset$32805[ebp], ecx

; 50   :           }
; 51   : 
; 52   : 		} while (symbol < (UINT32_C(1) << 16));

  000ed	81 7d 1c 00 00
	01 00		 cmp	 DWORD PTR _symbol$[ebp], 65536 ; 00010000H
  000f4	72 8d		 jb	 SHORT $LN3@get_litera
$LN4@get_litera:

; 53   : 	}
; 54   : 
; 55   : 	return price;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _price$[ebp]

; 56   : }

  000f9	5e		 pop	 esi
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
_get_literal_price ENDP
; Function compile flags: /Odtp
;	COMDAT _helper2
_TEXT	SEGMENT
tv775 = -384						; size = 4
tv776 = -380						; size = 4
tv731 = -376						; size = 4
tv583 = -372						; size = 4
tv584 = -368						; size = 4
tv533 = -364						; size = 4
tv978 = -360						; size = 4
tv374 = -356						; size = 4
tv375 = -352						; size = 4
tv922 = -348						; size = 4
tv362 = -344						; size = 4
tv351 = -340						; size = 4
tv156 = -336						; size = 4
tv157 = -332						; size = 4
tv138 = -328						; size = 4
tv139 = -324						; size = 4
$T79220 = -316						; size = 4
$T79212 = -312						; size = 4
$T79208 = -308						; size = 4
$T79170 = -284						; size = 4
$T79162 = -280						; size = 4
$T79158 = -276						; size = 4
$T79154 = -272						; size = 4
$T79150 = -268						; size = 4
$T79127 = -260						; size = 4
_x$79120 = -256						; size = 4
$T79090 = -248						; size = 4
$T79082 = -244						; size = 4
$T79078 = -240						; size = 4
$T79077 = -236						; size = 4
_x$79070 = -232						; size = 4
$T79063 = -228						; size = 4
$T79050 = -224						; size = 4
$T79039 = -220						; size = 4
$T79035 = -216						; size = 4
_next_rep_match_price$33165 = -212			; size = 4
_offset$33166 = -208					; size = 4
_pos_state_next$33163 = -204				; size = 4
_cur_and_len_literal_price$33164 = -200			; size = 4
_state_2$33162 = -196					; size = 4
_limit$33157 = -192					; size = 4
_buf_back$33155 = -188					; size = 4
_len_test_2$33156 = -184				; size = 4
_cur_back$33151 = -180					; size = 4
_cur_and_len_price$33152 = -176				; size = 4
_len_test$33147 = -172					; size = 4
_i$33143 = -168						; size = 4
_normal_match_price$33139 = -164			; size = 4
_cur_and_len_price$33132 = -160				; size = 4
_next_rep_match_price$33127 = -156			; size = 4
_offset$33128 = -152					; size = 4
_pos_state_next$33125 = -148				; size = 4
_cur_and_len_literal_price$33126 = -144			; size = 4
_state_2$33124 = -140					; size = 4
_limit$33119 = -136					; size = 4
_len_test_2$33118 = -132				; size = 4
_cur_and_len_price$33115 = -128				; size = 4
_price$33111 = -124					; size = 4
_len_test_temp$33110 = -120				; size = 4
_len_test$33106 = -116					; size = 4
_buf_back$33102 = -112					; size = 4
_start_len$33097 = -108					; size = 4
_rep_index$33098 = -104					; size = 4
_cur_and_len_price$33095 = -100				; size = 4
_next_rep_match_price$33090 = -96			; size = 4
_offset$33091 = -92					; size = 4
_pos_state_next$33089 = -88				; size = 4
_state_2$33088 = -84					; size = 4
_len_test$33086 = -80					; size = 4
_limit$33085 = -76					; size = 4
_buf_back$33084 = -72					; size = 4
_buf_avail$33082 = -68					; size = 4
_short_rep_price$33079 = -64				; size = 4
_rep_match_price$33076 = -60				; size = 4
_match_price$33075 = -56				; size = 4
_next_is_literal$33073 = -49				; size = 1
_cur_and_1_price$33072 = -48				; size = 4
_cur_price$33068 = -44					; size = 4
_match_byte$33070 = -37					; size = 1
_pos_state$33071 = -36					; size = 4
_current_byte$33069 = -29				; size = 1
_i$33064 = -28						; size = 4
_i$33052 = -24						; size = 4
_pos$33047 = -20					; size = 4
_state$ = -16						; size = 4
_new_len$ = -12						; size = 4
_pos_prev$ = -8						; size = 4
_matches_count$ = -4					; size = 4
_coder$ = 8						; size = 4
_reps$ = 12						; size = 4
_buf$ = 16						; size = 4
_len_end$ = 20						; size = 4
_position$ = 24						; size = 4
_cur$ = 28						; size = 4
_nice_len$ = 32						; size = 4
_buf_avail_full$ = 36					; size = 4
_helper2 PROC						; COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  00009	56		 push	 esi

; 480  : 	uint32_t matches_count = coder->matches_count;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0000d	8b 88 94 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2708]
  00013	89 4d fc	 mov	 DWORD PTR _matches_count$[ebp], ecx

; 481  : 	uint32_t new_len = coder->longest_match_length;

  00016	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00019	8b 82 98 0a 00
	00		 mov	 eax, DWORD PTR [edx+2712]
  0001f	89 45 f4	 mov	 DWORD PTR _new_len$[ebp], eax

; 482  : 	uint32_t pos_prev = coder->opts[cur].pos_prev;

  00022	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00025	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00028	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0002b	8b 84 0a 08 0e
	01 00		 mov	 eax, DWORD PTR [edx+ecx+69128]
  00032	89 45 f8	 mov	 DWORD PTR _pos_prev$[ebp], eax

; 483  : 	lzma_lzma_state state;
; 484  : 
; 485  : 	if (coder->opts[cur].prev_1_is_literal) {

  00035	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00038	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0003b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0003e	0f b6 84 0a f8
	0d 01 00	 movzx	 eax, BYTE PTR [edx+ecx+69112]
  00046	85 c0		 test	 eax, eax
  00048	0f 84 db 00 00
	00		 je	 $LN77@helper2

; 486  : 		--pos_prev;

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _pos_prev$[ebp]
  00051	83 e9 01	 sub	 ecx, 1
  00054	89 4d f8	 mov	 DWORD PTR _pos_prev$[ebp], ecx

; 487  : 
; 488  : 		if (coder->opts[cur].prev_2) {

  00057	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  0005a	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0005d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00060	0f b6 8c 10 f9
	0d 01 00	 movzx	 ecx, BYTE PTR [eax+edx+69113]
  00068	85 c9		 test	 ecx, ecx
  0006a	74 61		 je	 SHORT $LN76@helper2

; 489  : 			state = coder->opts[coder->opts[cur].pos_prev_2].state;

  0006c	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  0006f	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00072	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00075	8b 8c 10 fc 0d
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69116]
  0007c	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0007f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00082	8b 84 0a f4 0d
	01 00		 mov	 eax, DWORD PTR [edx+ecx+69108]
  00089	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 490  : 
; 491  : 			if (coder->opts[cur].back_prev_2 < REPS)

  0008c	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0008f	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00092	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00095	83 bc 0a 00 0e
	01 00 04	 cmp	 DWORD PTR [edx+ecx+69120], 4
  0009d	73 17		 jae	 SHORT $LN75@helper2

; 492  : 				update_long_rep(state);

  0009f	33 c0		 xor	 eax, eax
  000a1	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  000a5	0f 9d c0	 setge	 al
  000a8	83 e8 01	 sub	 eax, 1
  000ab	83 e0 fd	 and	 eax, -3			; fffffffdH
  000ae	83 c0 0b	 add	 eax, 11			; 0000000bH
  000b1	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 493  : 			else

  000b4	eb 15		 jmp	 SHORT $LN74@helper2
$LN75@helper2:

; 494  : 				update_match(state);

  000b6	33 c9		 xor	 ecx, ecx
  000b8	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  000bc	0f 9d c1	 setge	 cl
  000bf	83 e9 01	 sub	 ecx, 1
  000c2	83 e1 fd	 and	 ecx, -3			; fffffffdH
  000c5	83 c1 0a	 add	 ecx, 10			; 0000000aH
  000c8	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx
$LN74@helper2:

; 495  : 
; 496  : 		} else {

  000cb	eb 13		 jmp	 SHORT $LN73@helper2
$LN76@helper2:

; 497  : 			state = coder->opts[pos_prev].state;

  000cd	8b 55 f8	 mov	 edx, DWORD PTR _pos_prev$[ebp]
  000d0	6b d2 2c	 imul	 edx, 44			; 0000002cH
  000d3	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  000d6	8b 8c 10 f4 0d
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69108]
  000dd	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx
$LN73@helper2:

; 498  : 		}
; 499  : 
; 500  : 		update_literal(state);

  000e0	83 7d f0 03	 cmp	 DWORD PTR _state$[ebp], 3
  000e4	7f 0c		 jg	 SHORT $LN82@helper2
  000e6	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
  000f0	eb 2c		 jmp	 SHORT $LN83@helper2
$LN82@helper2:
  000f2	83 7d f0 09	 cmp	 DWORD PTR _state$[ebp], 9
  000f6	7f 0e		 jg	 SHORT $LN80@helper2
  000f8	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fb	83 ea 03	 sub	 edx, 3
  000fe	89 95 b8 fe ff
	ff		 mov	 DWORD PTR tv138[ebp], edx
  00104	eb 0c		 jmp	 SHORT $LN81@helper2
$LN80@helper2:
  00106	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00109	83 e8 06	 sub	 eax, 6
  0010c	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
$LN81@helper2:
  00112	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv138[ebp]
  00118	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv139[ebp], ecx
$LN83@helper2:
  0011e	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR tv139[ebp]
  00124	89 55 f0	 mov	 DWORD PTR _state$[ebp], edx

; 501  : 
; 502  : 	} else {

  00127	eb 13		 jmp	 SHORT $LN72@helper2
$LN77@helper2:

; 503  : 		state = coder->opts[pos_prev].state;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _pos_prev$[ebp]
  0012c	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00132	8b 94 01 f4 0d
	01 00		 mov	 edx, DWORD PTR [ecx+eax+69108]
  00139	89 55 f0	 mov	 DWORD PTR _state$[ebp], edx
$LN72@helper2:

; 504  : 	}
; 505  : 
; 506  : 	if (pos_prev == cur - 1) {

  0013c	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  0013f	83 e8 01	 sub	 eax, 1
  00142	39 45 f8	 cmp	 DWORD PTR _pos_prev$[ebp], eax
  00145	75 71		 jne	 SHORT $LN71@helper2

; 507  : 		if (is_short_rep(coder->opts[cur]))

  00147	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0014a	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0014d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00150	83 bc 0a 0c 0e
	01 00 00	 cmp	 DWORD PTR [edx+ecx+69132], 0
  00158	75 12		 jne	 SHORT $LN70@helper2

; 508  : 			update_short_rep(state);

  0015a	33 c0		 xor	 eax, eax
  0015c	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  00160	0f 9d c0	 setge	 al
  00163	8d 44 00 09	 lea	 eax, DWORD PTR [eax+eax+9]
  00167	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 509  : 		else

  0016a	eb 47		 jmp	 SHORT $LN69@helper2
$LN70@helper2:

; 510  : 			update_literal(state);

  0016c	83 7d f0 03	 cmp	 DWORD PTR _state$[ebp], 3
  00170	7f 0c		 jg	 SHORT $LN86@helper2
  00172	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv157[ebp], 0
  0017c	eb 2c		 jmp	 SHORT $LN87@helper2
$LN86@helper2:
  0017e	83 7d f0 09	 cmp	 DWORD PTR _state$[ebp], 9
  00182	7f 0e		 jg	 SHORT $LN84@helper2
  00184	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00187	83 e9 03	 sub	 ecx, 3
  0018a	89 8d b0 fe ff
	ff		 mov	 DWORD PTR tv156[ebp], ecx
  00190	eb 0c		 jmp	 SHORT $LN85@helper2
$LN84@helper2:
  00192	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00195	83 ea 06	 sub	 edx, 6
  00198	89 95 b0 fe ff
	ff		 mov	 DWORD PTR tv156[ebp], edx
$LN85@helper2:
  0019e	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv156[ebp]
  001a4	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv157[ebp], eax
$LN87@helper2:
  001aa	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  001b0	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx
$LN69@helper2:

; 511  : 	} else {

  001b3	e9 88 01 00 00	 jmp	 $LN68@helper2
$LN71@helper2:

; 512  : 		uint32_t pos;
; 513  : 		if (coder->opts[cur].prev_1_is_literal
; 514  : 				&& coder->opts[cur].prev_2) {

  001b8	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  001bb	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001be	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001c1	0f b6 8c 10 f8
	0d 01 00	 movzx	 ecx, BYTE PTR [eax+edx+69112]
  001c9	85 c9		 test	 ecx, ecx
  001cb	74 52		 je	 SHORT $LN67@helper2
  001cd	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  001d0	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001d3	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001d6	0f b6 8c 10 f9
	0d 01 00	 movzx	 ecx, BYTE PTR [eax+edx+69113]
  001de	85 c9		 test	 ecx, ecx
  001e0	74 3d		 je	 SHORT $LN67@helper2

; 515  : 			pos_prev = coder->opts[cur].pos_prev_2;

  001e2	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  001e5	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001e8	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001eb	8b 8c 10 fc 0d
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69116]
  001f2	89 4d f8	 mov	 DWORD PTR _pos_prev$[ebp], ecx

; 516  : 			pos = coder->opts[cur].back_prev_2;

  001f5	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  001f8	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001fb	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001fe	8b 8c 10 00 0e
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69120]
  00205	89 4d ec	 mov	 DWORD PTR _pos$33047[ebp], ecx

; 517  : 			update_long_rep(state);

  00208	33 d2		 xor	 edx, edx
  0020a	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  0020e	0f 9d c2	 setge	 dl
  00211	83 ea 01	 sub	 edx, 1
  00214	83 e2 fd	 and	 edx, -3			; fffffffdH
  00217	83 c2 0b	 add	 edx, 11			; 0000000bH
  0021a	89 55 f0	 mov	 DWORD PTR _state$[ebp], edx

; 518  : 		} else {

  0021d	eb 45		 jmp	 SHORT $LN66@helper2
$LN67@helper2:

; 519  : 			pos = coder->opts[cur].back_prev;

  0021f	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  00222	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00225	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00228	8b 94 01 0c 0e
	01 00		 mov	 edx, DWORD PTR [ecx+eax+69132]
  0022f	89 55 ec	 mov	 DWORD PTR _pos$33047[ebp], edx

; 520  : 			if (pos < REPS)

  00232	83 7d ec 04	 cmp	 DWORD PTR _pos$33047[ebp], 4
  00236	73 17		 jae	 SHORT $LN65@helper2

; 521  : 				update_long_rep(state);

  00238	33 c0		 xor	 eax, eax
  0023a	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  0023e	0f 9d c0	 setge	 al
  00241	83 e8 01	 sub	 eax, 1
  00244	83 e0 fd	 and	 eax, -3			; fffffffdH
  00247	83 c0 0b	 add	 eax, 11			; 0000000bH
  0024a	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 522  : 			else

  0024d	eb 15		 jmp	 SHORT $LN66@helper2
$LN65@helper2:

; 523  : 				update_match(state);

  0024f	33 c9		 xor	 ecx, ecx
  00251	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  00255	0f 9d c1	 setge	 cl
  00258	83 e9 01	 sub	 ecx, 1
  0025b	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0025e	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00261	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx
$LN66@helper2:

; 524  : 		}
; 525  : 
; 526  :       { uint32_t i;
; 527  : 
; 528  : 		if (pos < REPS) {

  00264	83 7d ec 04	 cmp	 DWORD PTR _pos$33047[ebp], 4
  00268	0f 83 8d 00 00
	00		 jae	 $LN63@helper2

; 529  : 			reps[0] = coder->opts[pos_prev].backs[pos];

  0026e	8b 55 f8	 mov	 edx, DWORD PTR _pos_prev$[ebp]
  00271	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00274	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00277	8d 8c 10 f4 0d
	01 00		 lea	 ecx, DWORD PTR [eax+edx+69108]
  0027e	8b 55 0c	 mov	 edx, DWORD PTR _reps$[ebp]
  00281	8b 45 ec	 mov	 eax, DWORD PTR _pos$33047[ebp]
  00284	8b 4c 81 1c	 mov	 ecx, DWORD PTR [ecx+eax*4+28]
  00288	89 0a		 mov	 DWORD PTR [edx], ecx

; 530  : 
; 531  : 			for (i = 1; i <= pos; ++i)

  0028a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i$33052[ebp], 1
  00291	eb 09		 jmp	 SHORT $LN62@helper2
$LN61@helper2:
  00293	8b 55 e8	 mov	 edx, DWORD PTR _i$33052[ebp]
  00296	83 c2 01	 add	 edx, 1
  00299	89 55 e8	 mov	 DWORD PTR _i$33052[ebp], edx
$LN62@helper2:
  0029c	8b 45 e8	 mov	 eax, DWORD PTR _i$33052[ebp]
  0029f	3b 45 ec	 cmp	 eax, DWORD PTR _pos$33047[ebp]
  002a2	77 22		 ja	 SHORT $LN60@helper2

; 532  : 				reps[i] = coder->opts[pos_prev].backs[i - 1];

  002a4	8b 4d f8	 mov	 ecx, DWORD PTR _pos_prev$[ebp]
  002a7	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  002aa	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002ad	8d 84 0a f4 0d
	01 00		 lea	 eax, DWORD PTR [edx+ecx+69108]
  002b4	8b 4d e8	 mov	 ecx, DWORD PTR _i$33052[ebp]
  002b7	8b 55 0c	 mov	 edx, DWORD PTR _reps$[ebp]
  002ba	8b 75 e8	 mov	 esi, DWORD PTR _i$33052[ebp]
  002bd	8b 44 b0 18	 mov	 eax, DWORD PTR [eax+esi*4+24]
  002c1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  002c4	eb cd		 jmp	 SHORT $LN61@helper2
$LN60@helper2:

; 533  : 
; 534  : 			for (; i < REPS; ++i)

  002c6	eb 09		 jmp	 SHORT $LN59@helper2
$LN58@helper2:
  002c8	8b 4d e8	 mov	 ecx, DWORD PTR _i$33052[ebp]
  002cb	83 c1 01	 add	 ecx, 1
  002ce	89 4d e8	 mov	 DWORD PTR _i$33052[ebp], ecx
$LN59@helper2:
  002d1	83 7d e8 04	 cmp	 DWORD PTR _i$33052[ebp], 4
  002d5	73 22		 jae	 SHORT $LN57@helper2

; 535  : 				reps[i] = coder->opts[pos_prev].backs[i];

  002d7	8b 55 f8	 mov	 edx, DWORD PTR _pos_prev$[ebp]
  002da	6b d2 2c	 imul	 edx, 44			; 0000002cH
  002dd	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  002e0	8d 8c 10 f4 0d
	01 00		 lea	 ecx, DWORD PTR [eax+edx+69108]
  002e7	8b 55 e8	 mov	 edx, DWORD PTR _i$33052[ebp]
  002ea	8b 45 0c	 mov	 eax, DWORD PTR _reps$[ebp]
  002ed	8b 75 e8	 mov	 esi, DWORD PTR _i$33052[ebp]
  002f0	8b 4c b1 1c	 mov	 ecx, DWORD PTR [ecx+esi*4+28]
  002f4	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  002f7	eb cf		 jmp	 SHORT $LN58@helper2
$LN57@helper2:

; 536  : 
; 537  : 		} else {

  002f9	eb 45		 jmp	 SHORT $LN68@helper2
$LN63@helper2:

; 538  : 			reps[0] = pos - REPS;

  002fb	8b 55 ec	 mov	 edx, DWORD PTR _pos$33047[ebp]
  002fe	83 ea 04	 sub	 edx, 4
  00301	8b 45 0c	 mov	 eax, DWORD PTR _reps$[ebp]
  00304	89 10		 mov	 DWORD PTR [eax], edx

; 539  : 
; 540  : 			for (i = 1; i < REPS; ++i)

  00306	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i$33052[ebp], 1
  0030d	eb 09		 jmp	 SHORT $LN55@helper2
$LN54@helper2:
  0030f	8b 4d e8	 mov	 ecx, DWORD PTR _i$33052[ebp]
  00312	83 c1 01	 add	 ecx, 1
  00315	89 4d e8	 mov	 DWORD PTR _i$33052[ebp], ecx
$LN55@helper2:
  00318	83 7d e8 04	 cmp	 DWORD PTR _i$33052[ebp], 4
  0031c	73 22		 jae	 SHORT $LN68@helper2

; 541  : 				reps[i] = coder->opts[pos_prev].backs[i - 1];

  0031e	8b 55 f8	 mov	 edx, DWORD PTR _pos_prev$[ebp]
  00321	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00324	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00327	8d 8c 10 f4 0d
	01 00		 lea	 ecx, DWORD PTR [eax+edx+69108]
  0032e	8b 55 e8	 mov	 edx, DWORD PTR _i$33052[ebp]
  00331	8b 45 0c	 mov	 eax, DWORD PTR _reps$[ebp]
  00334	8b 75 e8	 mov	 esi, DWORD PTR _i$33052[ebp]
  00337	8b 4c b1 18	 mov	 ecx, DWORD PTR [ecx+esi*4+24]
  0033b	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  0033e	eb cf		 jmp	 SHORT $LN54@helper2
$LN68@helper2:

; 542  : 		}
; 543  : 	  }
; 544  : 	}
; 545  : 
; 546  : 	coder->opts[cur].state = state;

  00340	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00343	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00346	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00349	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0034c	89 8c 10 f4 0d
	01 00		 mov	 DWORD PTR [eax+edx+69108], ecx

; 547  : 
; 548  :   { uint32_t i;
; 549  : 	for (i = 0; i < REPS; ++i)

  00353	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$33064[ebp], 0
  0035a	eb 09		 jmp	 SHORT $LN52@helper2
$LN51@helper2:
  0035c	8b 55 e4	 mov	 edx, DWORD PTR _i$33064[ebp]
  0035f	83 c2 01	 add	 edx, 1
  00362	89 55 e4	 mov	 DWORD PTR _i$33064[ebp], edx
$LN52@helper2:
  00365	83 7d e4 04	 cmp	 DWORD PTR _i$33064[ebp], 4
  00369	73 22		 jae	 SHORT $LN50@helper2

; 550  : 		coder->opts[cur].backs[i] = reps[i];

  0036b	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  0036e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00371	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00374	8d 94 01 f4 0d
	01 00		 lea	 edx, DWORD PTR [ecx+eax+69108]
  0037b	8b 45 e4	 mov	 eax, DWORD PTR _i$33064[ebp]
  0037e	8b 4d e4	 mov	 ecx, DWORD PTR _i$33064[ebp]
  00381	8b 75 0c	 mov	 esi, DWORD PTR _reps$[ebp]
  00384	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00387	89 4c 82 1c	 mov	 DWORD PTR [edx+eax*4+28], ecx
  0038b	eb cf		 jmp	 SHORT $LN51@helper2
$LN50@helper2:

; 551  :   }
; 552  :   
; 553  :   {
; 554  : 	const uint32_t cur_price = coder->opts[cur].price;

  0038d	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00390	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00393	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00396	8b 8c 10 04 0e
	01 00		 mov	 ecx, DWORD PTR [eax+edx+69124]
  0039d	89 4d d4	 mov	 DWORD PTR _cur_price$33068[ebp], ecx

; 555  : 
; 556  : 	const uint8_t current_byte = *buf;

  003a0	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  003a3	8a 02		 mov	 al, BYTE PTR [edx]
  003a5	88 45 e3	 mov	 BYTE PTR _current_byte$33069[ebp], al

; 557  : 	const uint8_t match_byte = *(buf - reps[0] - 1);

  003a8	8b 4d 0c	 mov	 ecx, DWORD PTR _reps$[ebp]
  003ab	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  003ae	2b 11		 sub	 edx, DWORD PTR [ecx]
  003b0	8a 42 ff	 mov	 al, BYTE PTR [edx-1]
  003b3	88 45 db	 mov	 BYTE PTR _match_byte$33070[ebp], al

; 558  : 
; 559  : 	const uint32_t pos_state = position & coder->pos_mask;

  003b6	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  003b9	8b 55 18	 mov	 edx, DWORD PTR _position$[ebp]
  003bc	23 91 a0 0a 00
	00		 and	 edx, DWORD PTR [ecx+2720]
  003c2	89 55 dc	 mov	 DWORD PTR _pos_state$33071[ebp], edx

; 560  : 
; 561  : 	const uint32_t cur_and_1_price = cur_price
; 562  : 			+ rc_bit_0_price(coder->is_match[state][pos_state])
; 563  : 			+ get_literal_price(coder, position, buf[-1],
; 564  : 			!is_literal_state(state), match_byte, current_byte);

  003c5	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  003c8	c1 e0 05	 shl	 eax, 5
  003cb	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  003ce	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  003d5	8b 45 dc	 mov	 eax, DWORD PTR _pos_state$33071[ebp]
  003d8	0f b7 0c 42	 movzx	 ecx, WORD PTR [edx+eax*2]
  003dc	c1 f9 04	 sar	 ecx, 4
  003df	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  003e6	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T79035[ebp], edx
  003ec	8b 75 d4	 mov	 esi, DWORD PTR _cur_price$33068[ebp]
  003ef	03 b5 28 ff ff
	ff		 add	 esi, DWORD PTR $T79035[ebp]
  003f5	0f b6 45 e3	 movzx	 eax, BYTE PTR _current_byte$33069[ebp]
  003f9	50		 push	 eax
  003fa	0f b6 4d db	 movzx	 ecx, BYTE PTR _match_byte$33070[ebp]
  003fe	51		 push	 ecx
  003ff	33 d2		 xor	 edx, edx
  00401	83 7d f0 07	 cmp	 DWORD PTR _state$[ebp], 7
  00405	0f 9d c2	 setge	 dl
  00408	0f b6 c2	 movzx	 eax, dl
  0040b	50		 push	 eax
  0040c	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  0040f	0f b6 51 ff	 movzx	 edx, BYTE PTR [ecx-1]
  00413	52		 push	 edx
  00414	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  00417	50		 push	 eax
  00418	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0041b	51		 push	 ecx
  0041c	e8 00 00 00 00	 call	 _get_literal_price
  00421	83 c4 18	 add	 esp, 24			; 00000018H
  00424	03 f0		 add	 esi, eax
  00426	89 75 d0	 mov	 DWORD PTR _cur_and_1_price$33072[ebp], esi

; 565  : 
; 566  : 	bool next_is_literal = false;

  00429	c6 45 cf 00	 mov	 BYTE PTR _next_is_literal$33073[ebp], 0

; 567  : 
; 568  : 	if (cur_and_1_price < coder->opts[cur + 1].price) {

  0042d	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00430	83 c2 01	 add	 edx, 1
  00433	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00436	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00439	8b 4d d0	 mov	 ecx, DWORD PTR _cur_and_1_price$33072[ebp]
  0043c	3b 8c 10 04 0e
	01 00		 cmp	 ecx, DWORD PTR [eax+edx+69124]
  00443	73 60		 jae	 SHORT $LN112@helper2

; 569  : 		coder->opts[cur + 1].price = cur_and_1_price;

  00445	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00448	83 c2 01	 add	 edx, 1
  0044b	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0044e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00451	8b 4d d0	 mov	 ecx, DWORD PTR _cur_and_1_price$33072[ebp]
  00454	89 8c 10 04 0e
	01 00		 mov	 DWORD PTR [eax+edx+69124], ecx

; 570  : 		coder->opts[cur + 1].pos_prev = cur;

  0045b	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  0045e	83 c2 01	 add	 edx, 1
  00461	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00464	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00467	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0046a	89 8c 10 08 0e
	01 00		 mov	 DWORD PTR [eax+edx+69128], ecx

; 571  : 		make_literal(&coder->opts[cur + 1]);

  00471	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00474	83 c2 01	 add	 edx, 1
  00477	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0047a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0047d	8d 8c 10 f4 0d
	01 00		 lea	 ecx, DWORD PTR [eax+edx+69108]
  00484	89 8d 24 ff ff
	ff		 mov	 DWORD PTR $T79039[ebp], ecx
  0048a	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR $T79039[ebp]
  00490	c7 42 18 ff ff
	ff ff		 mov	 DWORD PTR [edx+24], -1
  00497	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T79039[ebp]
  0049d	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 572  : 		next_is_literal = true;

  004a1	c6 45 cf 01	 mov	 BYTE PTR _next_is_literal$33073[ebp], 1

; 573  : 	}
; 574  : 
; 575  :   {
; 576  : 	const uint32_t match_price = cur_price
; 577  : 			+ rc_bit_1_price(coder->is_match[state][pos_state]);

$LN112@helper2:
  004a5	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  004a8	c1 e1 05	 shl	 ecx, 5
  004ab	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  004ae	8d 84 0a ac 6a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27308]
  004b5	8b 4d dc	 mov	 ecx, DWORD PTR _pos_state$33071[ebp]
  004b8	0f b7 14 48	 movzx	 edx, WORD PTR [eax+ecx*2]
  004bc	81 f2 ff 07 00
	00		 xor	 edx, 2047		; 000007ffH
  004c2	c1 ea 04	 shr	 edx, 4
  004c5	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  004cc	03 45 d4	 add	 eax, DWORD PTR _cur_price$33068[ebp]
  004cf	89 45 c8	 mov	 DWORD PTR _match_price$33075[ebp], eax

; 578  : 	const uint32_t rep_match_price = match_price
; 579  : 			+ rc_bit_1_price(coder->is_rep[state]);

  004d2	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  004d5	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  004d8	0f b7 84 4a 2c
	6c 00 00	 movzx	 eax, WORD PTR [edx+ecx*2+27692]
  004e0	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  004e5	c1 e8 04	 shr	 eax, 4
  004e8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  004ef	03 4d c8	 add	 ecx, DWORD PTR _match_price$33075[ebp]
  004f2	89 4d c4	 mov	 DWORD PTR _rep_match_price$33076[ebp], ecx

; 580  : 
; 581  : 	if (match_byte == current_byte
; 582  : 			&& !(coder->opts[cur + 1].pos_prev < cur
; 583  : 				&& coder->opts[cur + 1].back_prev == 0)) {

  004f5	0f b6 55 db	 movzx	 edx, BYTE PTR _match_byte$33070[ebp]
  004f9	0f b6 45 e3	 movzx	 eax, BYTE PTR _current_byte$33069[ebp]
  004fd	3b d0		 cmp	 edx, eax
  004ff	0f 85 f5 00 00
	00		 jne	 $LN48@helper2
  00505	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00508	83 c1 01	 add	 ecx, 1
  0050b	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0050e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00511	8b 84 0a 08 0e
	01 00		 mov	 eax, DWORD PTR [edx+ecx+69128]
  00518	3b 45 1c	 cmp	 eax, DWORD PTR _cur$[ebp]
  0051b	73 1a		 jae	 SHORT $LN47@helper2
  0051d	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00520	83 c1 01	 add	 ecx, 1
  00523	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00526	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00529	83 bc 0a 0c 0e
	01 00 00	 cmp	 DWORD PTR [edx+ecx+69132], 0
  00531	0f 84 c3 00 00
	00		 je	 $LN48@helper2
$LN47@helper2:

; 584  : 
; 585  : 		const uint32_t short_rep_price = rep_match_price
; 586  : 				+ get_short_rep_price(coder, state, pos_state);

  00537	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0053a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0053d	0f b7 94 41 44
	6c 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+27716]
  00545	c1 fa 04	 sar	 edx, 4
  00548	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  0054f	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T79050[ebp], eax
  00555	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00558	c1 e1 05	 shl	 ecx, 5
  0055b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0055e	8d 84 0a 8c 6c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27788]
  00565	8b 4d dc	 mov	 ecx, DWORD PTR _pos_state$33071[ebp]
  00568	0f b7 14 48	 movzx	 edx, WORD PTR [eax+ecx*2]
  0056c	c1 fa 04	 sar	 edx, 4
  0056f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  00576	03 85 20 ff ff
	ff		 add	 eax, DWORD PTR $T79050[ebp]
  0057c	03 45 c4	 add	 eax, DWORD PTR _rep_match_price$33076[ebp]
  0057f	89 45 c0	 mov	 DWORD PTR _short_rep_price$33079[ebp], eax

; 587  : 
; 588  : 		if (short_rep_price <= coder->opts[cur + 1].price) {

  00582	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00585	83 c1 01	 add	 ecx, 1
  00588	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0058b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0058e	8b 45 c0	 mov	 eax, DWORD PTR _short_rep_price$33079[ebp]
  00591	3b 84 0a 04 0e
	01 00		 cmp	 eax, DWORD PTR [edx+ecx+69124]
  00598	77 60		 ja	 SHORT $LN48@helper2

; 589  : 			coder->opts[cur + 1].price = short_rep_price;

  0059a	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0059d	83 c1 01	 add	 ecx, 1
  005a0	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  005a3	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  005a6	8b 45 c0	 mov	 eax, DWORD PTR _short_rep_price$33079[ebp]
  005a9	89 84 0a 04 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69124], eax

; 590  : 			coder->opts[cur + 1].pos_prev = cur;

  005b0	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  005b3	83 c1 01	 add	 ecx, 1
  005b6	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  005b9	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  005bc	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  005bf	89 84 0a 08 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69128], eax

; 591  : 			make_short_rep(&coder->opts[cur + 1]);

  005c6	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  005c9	83 c1 01	 add	 ecx, 1
  005cc	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  005cf	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  005d2	8d 84 0a f4 0d
	01 00		 lea	 eax, DWORD PTR [edx+ecx+69108]
  005d9	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T79063[ebp], eax
  005df	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR $T79063[ebp]
  005e5	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  005ec	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR $T79063[ebp]
  005f2	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 592  : 			next_is_literal = true;

  005f6	c6 45 cf 01	 mov	 BYTE PTR _next_is_literal$33073[ebp], 1
$LN48@helper2:

; 593  : 		}
; 594  : 	}
; 595  : 
; 596  : 	if (buf_avail_full < 2)

  005fa	83 7d 24 02	 cmp	 DWORD PTR _buf_avail_full$[ebp], 2
  005fe	73 08		 jae	 SHORT $LN45@helper2

; 597  : 		return len_end;

  00600	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  00603	e9 5c 0e 00 00	 jmp	 $LN78@helper2
$LN45@helper2:

; 598  : 
; 599  :   {
; 600  : 	const uint32_t buf_avail = my_min(buf_avail_full, nice_len);

  00608	8b 45 24	 mov	 eax, DWORD PTR _buf_avail_full$[ebp]
  0060b	3b 45 20	 cmp	 eax, DWORD PTR _nice_len$[ebp]
  0060e	73 0b		 jae	 SHORT $LN88@helper2
  00610	8b 4d 24	 mov	 ecx, DWORD PTR _buf_avail_full$[ebp]
  00613	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv351[ebp], ecx
  00619	eb 09		 jmp	 SHORT $LN89@helper2
$LN88@helper2:
  0061b	8b 55 20	 mov	 edx, DWORD PTR _nice_len$[ebp]
  0061e	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv351[ebp], edx
$LN89@helper2:
  00624	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv351[ebp]
  0062a	89 45 bc	 mov	 DWORD PTR _buf_avail$33082[ebp], eax

; 601  : 
; 602  : 	if (!next_is_literal && match_byte != current_byte) { // speed optimization

  0062d	0f b6 4d cf	 movzx	 ecx, BYTE PTR _next_is_literal$33073[ebp]
  00631	85 c9		 test	 ecx, ecx
  00633	0f 85 ce 02 00
	00		 jne	 $LN44@helper2
  00639	0f b6 55 db	 movzx	 edx, BYTE PTR _match_byte$33070[ebp]
  0063d	0f b6 45 e3	 movzx	 eax, BYTE PTR _current_byte$33069[ebp]
  00641	3b d0		 cmp	 edx, eax
  00643	0f 84 be 02 00
	00		 je	 $LN44@helper2

; 603  : 		// try literal + rep0
; 604  : 		const uint8_t *const buf_back = buf - reps[0] - 1;

  00649	8b 4d 0c	 mov	 ecx, DWORD PTR _reps$[ebp]
  0064c	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  0064f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00651	83 ea 01	 sub	 edx, 1
  00654	89 55 b8	 mov	 DWORD PTR _buf_back$33084[ebp], edx

; 605  : 		const uint32_t limit = my_min(buf_avail_full, nice_len + 1);

  00657	8b 45 20	 mov	 eax, DWORD PTR _nice_len$[ebp]
  0065a	83 c0 01	 add	 eax, 1
  0065d	39 45 24	 cmp	 DWORD PTR _buf_avail_full$[ebp], eax
  00660	73 0b		 jae	 SHORT $LN90@helper2
  00662	8b 4d 24	 mov	 ecx, DWORD PTR _buf_avail_full$[ebp]
  00665	89 8d a8 fe ff
	ff		 mov	 DWORD PTR tv362[ebp], ecx
  0066b	eb 0c		 jmp	 SHORT $LN91@helper2
$LN90@helper2:
  0066d	8b 55 20	 mov	 edx, DWORD PTR _nice_len$[ebp]
  00670	83 c2 01	 add	 edx, 1
  00673	89 95 a8 fe ff
	ff		 mov	 DWORD PTR tv362[ebp], edx
$LN91@helper2:
  00679	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv362[ebp]
  0067f	89 45 b4	 mov	 DWORD PTR _limit$33085[ebp], eax

; 606  : 
; 607  : 		const uint32_t len_test = lzma_memcmplen(buf, buf_back, 1, limit) - 1;

  00682	c7 85 14 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T79077[ebp], 1
$LN128@helper2:
  0068c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T79077[ebp]
  00692	3b 4d b4	 cmp	 ecx, DWORD PTR _limit$33085[ebp]
  00695	0f 83 ab 00 00
	00		 jae	 $LN127@helper2
  0069b	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  0069e	03 95 14 ff ff
	ff		 add	 edx, DWORD PTR $T79077[ebp]
  006a4	8b 45 b8	 mov	 eax, DWORD PTR _buf_back$33084[ebp]
  006a7	03 85 14 ff ff
	ff		 add	 eax, DWORD PTR $T79077[ebp]
  006ad	8b 0a		 mov	 ecx, DWORD PTR [edx]
  006af	2b 08		 sub	 ecx, DWORD PTR [eax]
  006b1	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _x$79070[ebp], ecx
  006b7	74 79		 je	 SHORT $LN126@helper2
  006b9	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _x$79070[ebp]
  006bf	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  006c5	75 1e		 jne	 SHORT $LN125@helper2
  006c7	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T79077[ebp]
  006cd	83 c0 02	 add	 eax, 2
  006d0	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T79077[ebp], eax
  006d6	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _x$79070[ebp]
  006dc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  006df	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _x$79070[ebp], ecx
$LN125@helper2:
  006e5	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _x$79070[ebp]
  006eb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  006f1	75 0f		 jne	 SHORT $LN124@helper2
  006f3	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T79077[ebp]
  006f9	83 c0 01	 add	 eax, 1
  006fc	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T79077[ebp], eax
$LN124@helper2:
  00702	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T79077[ebp]
  00708	3b 4d b4	 cmp	 ecx, DWORD PTR _limit$33085[ebp]
  0070b	73 0e		 jae	 SHORT $LN131@helper2
  0070d	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T79077[ebp]
  00713	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv922[ebp], edx
  00719	eb 09		 jmp	 SHORT $LN132@helper2
$LN131@helper2:
  0071b	8b 45 b4	 mov	 eax, DWORD PTR _limit$33085[ebp]
  0071e	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv922[ebp], eax
$LN132@helper2:
  00724	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv922[ebp]
  0072a	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T79078[ebp], ecx
  00730	eb 1d		 jmp	 SHORT $LN129@helper2
$LN126@helper2:
  00732	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T79077[ebp]
  00738	83 c2 04	 add	 edx, 4
  0073b	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T79077[ebp], edx
  00741	e9 46 ff ff ff	 jmp	 $LN128@helper2
$LN127@helper2:
  00746	8b 45 b4	 mov	 eax, DWORD PTR _limit$33085[ebp]
  00749	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T79078[ebp], eax
$LN129@helper2:
  0074f	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR $T79078[ebp]
  00755	83 e9 01	 sub	 ecx, 1
  00758	89 4d b0	 mov	 DWORD PTR _len_test$33086[ebp], ecx

; 608  : 
; 609  : 		if (len_test >= 2) {

  0075b	83 7d b0 02	 cmp	 DWORD PTR _len_test$33086[ebp], 2
  0075f	0f 82 a2 01 00
	00		 jb	 $LN44@helper2

; 610  : 			lzma_lzma_state state_2 = state;

  00765	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00768	89 55 ac	 mov	 DWORD PTR _state_2$33088[ebp], edx

; 611  : 			update_literal(state_2);

  0076b	83 7d ac 03	 cmp	 DWORD PTR _state_2$33088[ebp], 3
  0076f	7f 0c		 jg	 SHORT $LN94@helper2
  00771	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv375[ebp], 0
  0077b	eb 2c		 jmp	 SHORT $LN95@helper2
$LN94@helper2:
  0077d	83 7d ac 09	 cmp	 DWORD PTR _state_2$33088[ebp], 9
  00781	7f 0e		 jg	 SHORT $LN92@helper2
  00783	8b 45 ac	 mov	 eax, DWORD PTR _state_2$33088[ebp]
  00786	83 e8 03	 sub	 eax, 3
  00789	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv374[ebp], eax
  0078f	eb 0c		 jmp	 SHORT $LN93@helper2
$LN92@helper2:
  00791	8b 4d ac	 mov	 ecx, DWORD PTR _state_2$33088[ebp]
  00794	83 e9 06	 sub	 ecx, 6
  00797	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv374[ebp], ecx
$LN93@helper2:
  0079d	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv374[ebp]
  007a3	89 95 a0 fe ff
	ff		 mov	 DWORD PTR tv375[ebp], edx
$LN95@helper2:
  007a9	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  007af	89 45 ac	 mov	 DWORD PTR _state_2$33088[ebp], eax

; 612  : 
; 613  :           {
; 614  : 			const uint32_t pos_state_next = (position + 1) & coder->pos_mask;

  007b2	8b 4d 18	 mov	 ecx, DWORD PTR _position$[ebp]
  007b5	83 c1 01	 add	 ecx, 1
  007b8	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  007bb	23 8a a0 0a 00
	00		 and	 ecx, DWORD PTR [edx+2720]
  007c1	89 4d a8	 mov	 DWORD PTR _pos_state_next$33089[ebp], ecx

; 615  : 			const uint32_t next_rep_match_price = cur_and_1_price
; 616  : 					+ rc_bit_1_price(coder->is_match[state_2][pos_state_next])
; 617  : 					+ rc_bit_1_price(coder->is_rep[state_2]);

  007c4	8b 45 ac	 mov	 eax, DWORD PTR _state_2$33088[ebp]
  007c7	c1 e0 05	 shl	 eax, 5
  007ca	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  007cd	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  007d4	8b 45 a8	 mov	 eax, DWORD PTR _pos_state_next$33089[ebp]
  007d7	0f b7 0c 42	 movzx	 ecx, WORD PTR [edx+eax*2]
  007db	81 f1 ff 07 00
	00		 xor	 ecx, 2047		; 000007ffH
  007e1	c1 e9 04	 shr	 ecx, 4
  007e4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  007eb	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T79082[ebp], edx
  007f1	8b 45 d0	 mov	 eax, DWORD PTR _cur_and_1_price$33072[ebp]
  007f4	03 85 0c ff ff
	ff		 add	 eax, DWORD PTR $T79082[ebp]
  007fa	8b 4d ac	 mov	 ecx, DWORD PTR _state_2$33088[ebp]
  007fd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00800	0f b7 8c 4a 2c
	6c 00 00	 movzx	 ecx, WORD PTR [edx+ecx*2+27692]
  00808	81 f1 ff 07 00
	00		 xor	 ecx, 2047		; 000007ffH
  0080e	c1 e9 04	 shr	 ecx, 4
  00811	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  00818	03 c2		 add	 eax, edx
  0081a	89 45 a0	 mov	 DWORD PTR _next_rep_match_price$33090[ebp], eax

; 618  : 
; 619  : 			//for (; len_test >= 2; --len_test) {
; 620  : 			const uint32_t offset = cur + 1 + len_test;

  0081d	8b 45 b0	 mov	 eax, DWORD PTR _len_test$33086[ebp]
  00820	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00823	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00827	89 55 a4	 mov	 DWORD PTR _offset$33091[ebp], edx
$LN42@helper2:

; 621  : 
; 622  : 			while (len_end < offset)

  0082a	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  0082d	3b 45 a4	 cmp	 eax, DWORD PTR _offset$33091[ebp]
  00830	73 1f		 jae	 SHORT $LN41@helper2

; 623  : 				coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00832	8b 4d 14	 mov	 ecx, DWORD PTR _len_end$[ebp]
  00835	83 c1 01	 add	 ecx, 1
  00838	89 4d 14	 mov	 DWORD PTR _len_end$[ebp], ecx
  0083b	8b 55 14	 mov	 edx, DWORD PTR _len_end$[ebp]
  0083e	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00841	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00844	c7 84 10 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [eax+edx+69124], 1073741824 ; 40000000H
  0084f	eb d9		 jmp	 SHORT $LN42@helper2
$LN41@helper2:

; 624  : 
; 625  :           {
; 626  : 			const uint32_t cur_and_len_price = next_rep_match_price
; 627  : 					+ get_rep_price(coder, 0, len_test,
; 628  : 						state_2, pos_state_next);

  00851	8b 4d a8	 mov	 ecx, DWORD PTR _pos_state_next$33089[ebp]
  00854	69 c9 40 04 00
	00		 imul	 ecx, 1088		; 00000440H
  0085a	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0085d	8d 84 0a 5c bd
	00 00		 lea	 eax, DWORD PTR [edx+ecx+48476]
  00864	8b 4d b0	 mov	 ecx, DWORD PTR _len_test$33086[ebp]
  00867	8b 54 88 f8	 mov	 edx, DWORD PTR [eax+ecx*4-8]
  0086b	89 95 08 ff ff
	ff		 mov	 DWORD PTR $T79090[ebp], edx
  00871	8b 45 a8	 mov	 eax, DWORD PTR _pos_state_next$33089[ebp]
  00874	50		 push	 eax
  00875	8b 4d ac	 mov	 ecx, DWORD PTR _state_2$33088[ebp]
  00878	51		 push	 ecx
  00879	6a 00		 push	 0
  0087b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0087e	52		 push	 edx
  0087f	e8 00 00 00 00	 call	 _get_pure_rep_price
  00884	83 c4 10	 add	 esp, 16			; 00000010H
  00887	03 85 08 ff ff
	ff		 add	 eax, DWORD PTR $T79090[ebp]
  0088d	03 45 a0	 add	 eax, DWORD PTR _next_rep_match_price$33090[ebp]
  00890	89 45 9c	 mov	 DWORD PTR _cur_and_len_price$33095[ebp], eax

; 629  : 
; 630  : 			if (cur_and_len_price < coder->opts[offset].price) {

  00893	8b 45 a4	 mov	 eax, DWORD PTR _offset$33091[ebp]
  00896	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00899	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0089c	8b 55 9c	 mov	 edx, DWORD PTR _cur_and_len_price$33095[ebp]
  0089f	3b 94 01 04 0e
	01 00		 cmp	 edx, DWORD PTR [ecx+eax+69124]
  008a6	73 5f		 jae	 SHORT $LN44@helper2

; 631  : 				coder->opts[offset].price = cur_and_len_price;

  008a8	8b 45 a4	 mov	 eax, DWORD PTR _offset$33091[ebp]
  008ab	6b c0 2c	 imul	 eax, 44			; 0000002cH
  008ae	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  008b1	8b 55 9c	 mov	 edx, DWORD PTR _cur_and_len_price$33095[ebp]
  008b4	89 94 01 04 0e
	01 00		 mov	 DWORD PTR [ecx+eax+69124], edx

; 632  : 				coder->opts[offset].pos_prev = cur + 1;

  008bb	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  008be	83 c0 01	 add	 eax, 1
  008c1	8b 4d a4	 mov	 ecx, DWORD PTR _offset$33091[ebp]
  008c4	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  008c7	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  008ca	89 84 0a 08 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69128], eax

; 633  : 				coder->opts[offset].back_prev = 0;

  008d1	8b 45 a4	 mov	 eax, DWORD PTR _offset$33091[ebp]
  008d4	6b c0 2c	 imul	 eax, 44			; 0000002cH
  008d7	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  008da	c7 84 01 0c 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+69132], 0

; 634  : 				coder->opts[offset].prev_1_is_literal = true;

  008e5	8b 55 a4	 mov	 edx, DWORD PTR _offset$33091[ebp]
  008e8	6b d2 2c	 imul	 edx, 44			; 0000002cH
  008eb	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  008ee	c6 84 10 f8 0d
	01 00 01	 mov	 BYTE PTR [eax+edx+69112], 1

; 635  : 				coder->opts[offset].prev_2 = false;

  008f6	8b 4d a4	 mov	 ecx, DWORD PTR _offset$33091[ebp]
  008f9	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  008fc	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  008ff	c6 84 0a f9 0d
	01 00 00	 mov	 BYTE PTR [edx+ecx+69113], 0
$LN44@helper2:

; 636  : 			}
; 637  : 			//}
; 638  : 		  }}
; 639  : 		}
; 640  : 	}
; 641  : 
; 642  : 
; 643  :    {
; 644  : 	uint32_t start_len = 2; // speed optimization

  00907	c7 45 94 02 00
	00 00		 mov	 DWORD PTR _start_len$33097[ebp], 2

; 645  : 	uint32_t rep_index;
; 646  : 
; 647  : 	for (rep_index = 0; rep_index < REPS; ++rep_index) {

  0090e	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _rep_index$33098[ebp], 0
  00915	eb 09		 jmp	 SHORT $LN39@helper2
$LN38@helper2:
  00917	8b 45 98	 mov	 eax, DWORD PTR _rep_index$33098[ebp]
  0091a	83 c0 01	 add	 eax, 1
  0091d	89 45 98	 mov	 DWORD PTR _rep_index$33098[ebp], eax
$LN39@helper2:
  00920	83 7d 98 04	 cmp	 DWORD PTR _rep_index$33098[ebp], 4
  00924	0f 83 98 05 00
	00		 jae	 $LN37@helper2

; 648  : 		const uint8_t *const buf_back = buf - reps[rep_index] - 1;

  0092a	8b 4d 98	 mov	 ecx, DWORD PTR _rep_index$33098[ebp]
  0092d	8b 55 0c	 mov	 edx, DWORD PTR _reps$[ebp]
  00930	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  00933	2b 04 8a	 sub	 eax, DWORD PTR [edx+ecx*4]
  00936	83 e8 01	 sub	 eax, 1
  00939	89 45 90	 mov	 DWORD PTR _buf_back$33102[ebp], eax

; 649  : 		if (not_equal_16(buf, buf_back))

  0093c	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  0093f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00942	8b 45 90	 mov	 eax, DWORD PTR _buf_back$33102[ebp]
  00945	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00948	3b d1		 cmp	 edx, ecx
  0094a	74 02		 je	 SHORT $LN36@helper2

; 650  : 			continue;

  0094c	eb c9		 jmp	 SHORT $LN38@helper2
$LN36@helper2:

; 651  : 
; 652  : 	  { uint32_t len_test = lzma_memcmplen(buf, buf_back, 2, buf_avail);

  0094e	c7 85 fc fe ff
	ff 02 00 00 00	 mov	 DWORD PTR $T79127[ebp], 2
$LN163@helper2:
  00958	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR $T79127[ebp]
  0095e	3b 55 bc	 cmp	 edx, DWORD PTR _buf_avail$33082[ebp]
  00961	0f 83 a6 00 00
	00		 jae	 $LN162@helper2
  00967	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  0096a	03 85 fc fe ff
	ff		 add	 eax, DWORD PTR $T79127[ebp]
  00970	8b 4d 90	 mov	 ecx, DWORD PTR _buf_back$33102[ebp]
  00973	03 8d fc fe ff
	ff		 add	 ecx, DWORD PTR $T79127[ebp]
  00979	8b 10		 mov	 edx, DWORD PTR [eax]
  0097b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0097d	89 95 00 ff ff
	ff		 mov	 DWORD PTR _x$79120[ebp], edx
  00983	74 74		 je	 SHORT $LN161@helper2
  00985	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _x$79120[ebp]
  0098b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00990	75 1e		 jne	 SHORT $LN160@helper2
  00992	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T79127[ebp]
  00998	83 c1 02	 add	 ecx, 2
  0099b	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T79127[ebp], ecx
  009a1	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR _x$79120[ebp]
  009a7	c1 ea 10	 shr	 edx, 16			; 00000010H
  009aa	89 95 00 ff ff
	ff		 mov	 DWORD PTR _x$79120[ebp], edx
$LN160@helper2:
  009b0	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _x$79120[ebp]
  009b6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009bb	75 0f		 jne	 SHORT $LN159@helper2
  009bd	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T79127[ebp]
  009c3	83 c1 01	 add	 ecx, 1
  009c6	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T79127[ebp], ecx
$LN159@helper2:
  009cc	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR $T79127[ebp]
  009d2	3b 55 bc	 cmp	 edx, DWORD PTR _buf_avail$33082[ebp]
  009d5	73 0e		 jae	 SHORT $LN166@helper2
  009d7	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T79127[ebp]
  009dd	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv978[ebp], eax
  009e3	eb 09		 jmp	 SHORT $LN167@helper2
$LN166@helper2:
  009e5	8b 4d bc	 mov	 ecx, DWORD PTR _buf_avail$33082[ebp]
  009e8	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv978[ebp], ecx
$LN167@helper2:
  009ee	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR tv978[ebp]
  009f4	89 55 8c	 mov	 DWORD PTR _len_test$33106[ebp], edx
  009f7	eb 1a		 jmp	 SHORT $LN35@helper2
$LN161@helper2:
  009f9	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T79127[ebp]
  009ff	83 c0 04	 add	 eax, 4
  00a02	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T79127[ebp], eax
  00a08	e9 4b ff ff ff	 jmp	 $LN163@helper2
$LN162@helper2:
  00a0d	8b 4d bc	 mov	 ecx, DWORD PTR _buf_avail$33082[ebp]
  00a10	89 4d 8c	 mov	 DWORD PTR _len_test$33106[ebp], ecx
$LN35@helper2:

; 653  : 
; 654  : 		while (len_end < cur + len_test)

  00a13	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00a16	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00a19	39 55 14	 cmp	 DWORD PTR _len_end$[ebp], edx
  00a1c	73 1f		 jae	 SHORT $LN34@helper2

; 655  : 			coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00a1e	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  00a21	83 c0 01	 add	 eax, 1
  00a24	89 45 14	 mov	 DWORD PTR _len_end$[ebp], eax
  00a27	8b 4d 14	 mov	 ecx, DWORD PTR _len_end$[ebp]
  00a2a	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00a2d	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00a30	c7 84 0a 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [edx+ecx+69124], 1073741824 ; 40000000H
  00a3b	eb d6		 jmp	 SHORT $LN35@helper2
$LN34@helper2:

; 656  : 
; 657  :       {
; 658  : 		const uint32_t len_test_temp = len_test;

  00a3d	8b 45 8c	 mov	 eax, DWORD PTR _len_test$33106[ebp]
  00a40	89 45 88	 mov	 DWORD PTR _len_test_temp$33110[ebp], eax

; 659  : 		const uint32_t price = rep_match_price + get_pure_rep_price(
; 660  : 				coder, rep_index, state, pos_state);

  00a43	8b 4d dc	 mov	 ecx, DWORD PTR _pos_state$33071[ebp]
  00a46	51		 push	 ecx
  00a47	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00a4a	52		 push	 edx
  00a4b	8b 45 98	 mov	 eax, DWORD PTR _rep_index$33098[ebp]
  00a4e	50		 push	 eax
  00a4f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00a52	51		 push	 ecx
  00a53	e8 00 00 00 00	 call	 _get_pure_rep_price
  00a58	83 c4 10	 add	 esp, 16			; 00000010H
  00a5b	03 45 c4	 add	 eax, DWORD PTR _rep_match_price$33076[ebp]
  00a5e	89 45 84	 mov	 DWORD PTR _price$33111[ebp], eax
$LN33@helper2:

; 661  : 
; 662  : 		do {
; 663  : 			const uint32_t cur_and_len_price = price
; 664  : 					+ get_len_price(&coder->rep_len_encoder,
; 665  : 							len_test, pos_state);

  00a61	8b 55 dc	 mov	 edx, DWORD PTR _pos_state$33071[ebp]
  00a64	69 d2 40 04 00
	00		 imul	 edx, 1088		; 00000440H
  00a6a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00a6d	8d 8c 10 5c bd
	00 00		 lea	 ecx, DWORD PTR [eax+edx+48476]
  00a74	8b 55 8c	 mov	 edx, DWORD PTR _len_test$33106[ebp]
  00a77	8b 44 91 f8	 mov	 eax, DWORD PTR [ecx+edx*4-8]
  00a7b	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T79150[ebp], eax
  00a81	8b 4d 84	 mov	 ecx, DWORD PTR _price$33111[ebp]
  00a84	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR $T79150[ebp]
  00a8a	89 4d 80	 mov	 DWORD PTR _cur_and_len_price$33115[ebp], ecx

; 666  : 
; 667  : 			if (cur_and_len_price < coder->opts[cur + len_test].price) {

  00a8d	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00a90	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00a93	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00a96	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00a99	8b 4d 80	 mov	 ecx, DWORD PTR _cur_and_len_price$33115[ebp]
  00a9c	3b 8c 10 04 0e
	01 00		 cmp	 ecx, DWORD PTR [eax+edx+69124]
  00aa3	73 56		 jae	 SHORT $LN32@helper2

; 668  : 				coder->opts[cur + len_test].price = cur_and_len_price;

  00aa5	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00aa8	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00aab	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00aae	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00ab1	8b 4d 80	 mov	 ecx, DWORD PTR _cur_and_len_price$33115[ebp]
  00ab4	89 8c 10 04 0e
	01 00		 mov	 DWORD PTR [eax+edx+69124], ecx

; 669  : 				coder->opts[cur + len_test].pos_prev = cur;

  00abb	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00abe	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00ac1	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00ac4	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00ac7	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00aca	89 8c 10 08 0e
	01 00		 mov	 DWORD PTR [eax+edx+69128], ecx

; 670  : 				coder->opts[cur + len_test].back_prev = rep_index;

  00ad1	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00ad4	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00ad7	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00ada	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00add	8b 4d 98	 mov	 ecx, DWORD PTR _rep_index$33098[ebp]
  00ae0	89 8c 10 0c 0e
	01 00		 mov	 DWORD PTR [eax+edx+69132], ecx

; 671  : 				coder->opts[cur + len_test].prev_1_is_literal = false;

  00ae7	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00aea	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00aed	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00af0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00af3	c6 84 10 f8 0d
	01 00 00	 mov	 BYTE PTR [eax+edx+69112], 0
$LN32@helper2:

; 672  : 			}
; 673  : 		} while (--len_test >= 2);

  00afb	8b 4d 8c	 mov	 ecx, DWORD PTR _len_test$33106[ebp]
  00afe	83 e9 01	 sub	 ecx, 1
  00b01	89 4d 8c	 mov	 DWORD PTR _len_test$33106[ebp], ecx
  00b04	83 7d 8c 02	 cmp	 DWORD PTR _len_test$33106[ebp], 2
  00b08	0f 83 53 ff ff
	ff		 jae	 $LN33@helper2

; 674  : 
; 675  : 		len_test = len_test_temp;

  00b0e	8b 55 88	 mov	 edx, DWORD PTR _len_test_temp$33110[ebp]
  00b11	89 55 8c	 mov	 DWORD PTR _len_test$33106[ebp], edx

; 676  : 
; 677  : 		if (rep_index == 0)

  00b14	83 7d 98 00	 cmp	 DWORD PTR _rep_index$33098[ebp], 0
  00b18	75 09		 jne	 SHORT $LN29@helper2

; 678  : 			start_len = len_test + 1;

  00b1a	8b 45 8c	 mov	 eax, DWORD PTR _len_test$33106[ebp]
  00b1d	83 c0 01	 add	 eax, 1
  00b20	89 45 94	 mov	 DWORD PTR _start_len$33097[ebp], eax
$LN29@helper2:

; 679  : 
; 680  :       {
; 681  : 		uint32_t len_test_2 = len_test + 1;

  00b23	8b 4d 8c	 mov	 ecx, DWORD PTR _len_test$33106[ebp]
  00b26	83 c1 01	 add	 ecx, 1
  00b29	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _len_test_2$33118[ebp], ecx

; 682  : 		const uint32_t limit = my_min(buf_avail_full,
; 683  : 				len_test_2 + nice_len);

  00b2f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _len_test_2$33118[ebp]
  00b35	03 55 20	 add	 edx, DWORD PTR _nice_len$[ebp]
  00b38	39 55 24	 cmp	 DWORD PTR _buf_avail_full$[ebp], edx
  00b3b	73 0b		 jae	 SHORT $LN96@helper2
  00b3d	8b 45 24	 mov	 eax, DWORD PTR _buf_avail_full$[ebp]
  00b40	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv533[ebp], eax
  00b46	eb 0f		 jmp	 SHORT $LN97@helper2
$LN96@helper2:
  00b48	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00b4e	03 4d 20	 add	 ecx, DWORD PTR _nice_len$[ebp]
  00b51	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv533[ebp], ecx
$LN97@helper2:
  00b57	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv533[ebp]
  00b5d	89 95 78 ff ff
	ff		 mov	 DWORD PTR _limit$33119[ebp], edx
  00b63	eb 0f		 jmp	 SHORT $LN28@helper2
$LN27@helper2:

; 684  : 		for (; len_test_2 < limit
; 685  : 				&& buf[len_test_2] == buf_back[len_test_2];
; 686  : 				++len_test_2) ;

  00b65	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _len_test_2$33118[ebp]
  00b6b	83 c0 01	 add	 eax, 1
  00b6e	89 85 7c ff ff
	ff		 mov	 DWORD PTR _len_test_2$33118[ebp], eax
$LN28@helper2:
  00b74	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00b7a	3b 8d 78 ff ff
	ff		 cmp	 ecx, DWORD PTR _limit$33119[ebp]
  00b80	73 1e		 jae	 SHORT $LN26@helper2
  00b82	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  00b85	03 95 7c ff ff
	ff		 add	 edx, DWORD PTR _len_test_2$33118[ebp]
  00b8b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b8e	8b 4d 90	 mov	 ecx, DWORD PTR _buf_back$33102[ebp]
  00b91	03 8d 7c ff ff
	ff		 add	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00b97	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00b9a	3b c2		 cmp	 eax, edx
  00b9c	75 02		 jne	 SHORT $LN26@helper2
  00b9e	eb c5		 jmp	 SHORT $LN27@helper2
$LN26@helper2:

; 687  : 
; 688  : 		len_test_2 -= len_test + 1;

  00ba0	8b 45 8c	 mov	 eax, DWORD PTR _len_test$33106[ebp]
  00ba3	83 c0 01	 add	 eax, 1
  00ba6	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00bac	2b c8		 sub	 ecx, eax
  00bae	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _len_test_2$33118[ebp], ecx

; 689  : 
; 690  : 		if (len_test_2 >= 2) {

  00bb4	83 bd 7c ff ff
	ff 02		 cmp	 DWORD PTR _len_test_2$33118[ebp], 2
  00bbb	0f 82 fc 02 00
	00		 jb	 $LN25@helper2

; 691  : 			lzma_lzma_state state_2 = state;

  00bc1	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00bc4	89 95 74 ff ff
	ff		 mov	 DWORD PTR _state_2$33124[ebp], edx

; 692  : 			update_long_rep(state_2);

  00bca	33 c0		 xor	 eax, eax
  00bcc	83 bd 74 ff ff
	ff 07		 cmp	 DWORD PTR _state_2$33124[ebp], 7
  00bd3	0f 9d c0	 setge	 al
  00bd6	83 e8 01	 sub	 eax, 1
  00bd9	83 e0 fd	 and	 eax, -3			; fffffffdH
  00bdc	83 c0 0b	 add	 eax, 11			; 0000000bH
  00bdf	89 85 74 ff ff
	ff		 mov	 DWORD PTR _state_2$33124[ebp], eax

; 693  : 
; 694  :           {
; 695  : 			uint32_t pos_state_next = (position + len_test) & coder->pos_mask;

  00be5	8b 4d 18	 mov	 ecx, DWORD PTR _position$[ebp]
  00be8	03 4d 8c	 add	 ecx, DWORD PTR _len_test$33106[ebp]
  00beb	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00bee	23 8a a0 0a 00
	00		 and	 ecx, DWORD PTR [edx+2720]
  00bf4	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pos_state_next$33125[ebp], ecx

; 696  : 
; 697  : 			const uint32_t cur_and_len_literal_price = price
; 698  : 					+ get_len_price(&coder->rep_len_encoder,
; 699  : 						len_test, pos_state)
; 700  : 					+ rc_bit_0_price(coder->is_match[state_2][pos_state_next])
; 701  : 					+ get_literal_price(coder, position + len_test,
; 702  : 						buf[len_test - 1], true,
; 703  : 						buf_back[len_test], buf[len_test]);

  00bfa	8b 45 dc	 mov	 eax, DWORD PTR _pos_state$33071[ebp]
  00bfd	69 c0 40 04 00
	00		 imul	 eax, 1088		; 00000440H
  00c03	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00c06	8d 94 01 5c bd
	00 00		 lea	 edx, DWORD PTR [ecx+eax+48476]
  00c0d	8b 45 8c	 mov	 eax, DWORD PTR _len_test$33106[ebp]
  00c10	8b 4c 82 f8	 mov	 ecx, DWORD PTR [edx+eax*4-8]
  00c14	89 8d f0 fe ff
	ff		 mov	 DWORD PTR $T79154[ebp], ecx
  00c1a	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _state_2$33124[ebp]
  00c20	c1 e2 05	 shl	 edx, 5
  00c23	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00c26	8d 8c 10 ac 6a
	00 00		 lea	 ecx, DWORD PTR [eax+edx+27308]
  00c2d	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _pos_state_next$33125[ebp]
  00c33	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00c37	c1 f8 04	 sar	 eax, 4
  00c3a	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00c41	89 8d ec fe ff
	ff		 mov	 DWORD PTR $T79158[ebp], ecx
  00c47	8b 75 84	 mov	 esi, DWORD PTR _price$33111[ebp]
  00c4a	03 b5 f0 fe ff
	ff		 add	 esi, DWORD PTR $T79154[ebp]
  00c50	03 b5 ec fe ff
	ff		 add	 esi, DWORD PTR $T79158[ebp]
  00c56	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  00c59	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00c5c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00c5f	50		 push	 eax
  00c60	8b 4d 90	 mov	 ecx, DWORD PTR _buf_back$33102[ebp]
  00c63	03 4d 8c	 add	 ecx, DWORD PTR _len_test$33106[ebp]
  00c66	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00c69	52		 push	 edx
  00c6a	6a 01		 push	 1
  00c6c	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  00c6f	03 45 8c	 add	 eax, DWORD PTR _len_test$33106[ebp]
  00c72	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  00c76	51		 push	 ecx
  00c77	8b 55 18	 mov	 edx, DWORD PTR _position$[ebp]
  00c7a	03 55 8c	 add	 edx, DWORD PTR _len_test$33106[ebp]
  00c7d	52		 push	 edx
  00c7e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00c81	50		 push	 eax
  00c82	e8 00 00 00 00	 call	 _get_literal_price
  00c87	83 c4 18	 add	 esp, 24			; 00000018H
  00c8a	03 f0		 add	 esi, eax
  00c8c	89 b5 70 ff ff
	ff		 mov	 DWORD PTR _cur_and_len_literal_price$33126[ebp], esi

; 704  : 
; 705  : 			update_literal(state_2);

  00c92	83 bd 74 ff ff
	ff 03		 cmp	 DWORD PTR _state_2$33124[ebp], 3
  00c99	7f 0c		 jg	 SHORT $LN100@helper2
  00c9b	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv584[ebp], 0
  00ca5	eb 35		 jmp	 SHORT $LN101@helper2
$LN100@helper2:
  00ca7	83 bd 74 ff ff
	ff 09		 cmp	 DWORD PTR _state_2$33124[ebp], 9
  00cae	7f 11		 jg	 SHORT $LN98@helper2
  00cb0	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _state_2$33124[ebp]
  00cb6	83 e9 03	 sub	 ecx, 3
  00cb9	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv583[ebp], ecx
  00cbf	eb 0f		 jmp	 SHORT $LN99@helper2
$LN98@helper2:
  00cc1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _state_2$33124[ebp]
  00cc7	83 ea 06	 sub	 edx, 6
  00cca	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv583[ebp], edx
$LN99@helper2:
  00cd0	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv583[ebp]
  00cd6	89 85 90 fe ff
	ff		 mov	 DWORD PTR tv584[ebp], eax
$LN101@helper2:
  00cdc	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR tv584[ebp]
  00ce2	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _state_2$33124[ebp], ecx

; 706  : 
; 707  : 			pos_state_next = (position + len_test + 1) & coder->pos_mask;

  00ce8	8b 55 8c	 mov	 edx, DWORD PTR _len_test$33106[ebp]
  00ceb	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  00cee	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00cf2	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00cf5	23 8a a0 0a 00
	00		 and	 ecx, DWORD PTR [edx+2720]
  00cfb	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _pos_state_next$33125[ebp], ecx

; 708  : 
; 709  :           {
; 710  : 			const uint32_t next_rep_match_price = cur_and_len_literal_price
; 711  : 					+ rc_bit_1_price(coder->is_match[state_2][pos_state_next])
; 712  : 					+ rc_bit_1_price(coder->is_rep[state_2]);

  00d01	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _state_2$33124[ebp]
  00d07	c1 e0 05	 shl	 eax, 5
  00d0a	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00d0d	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  00d14	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pos_state_next$33125[ebp]
  00d1a	0f b7 0c 42	 movzx	 ecx, WORD PTR [edx+eax*2]
  00d1e	81 f1 ff 07 00
	00		 xor	 ecx, 2047		; 000007ffH
  00d24	c1 e9 04	 shr	 ecx, 4
  00d27	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  00d2e	89 95 e8 fe ff
	ff		 mov	 DWORD PTR $T79162[ebp], edx
  00d34	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _cur_and_len_literal_price$33126[ebp]
  00d3a	03 85 e8 fe ff
	ff		 add	 eax, DWORD PTR $T79162[ebp]
  00d40	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _state_2$33124[ebp]
  00d46	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00d49	0f b7 8c 4a 2c
	6c 00 00	 movzx	 ecx, WORD PTR [edx+ecx*2+27692]
  00d51	81 f1 ff 07 00
	00		 xor	 ecx, 2047		; 000007ffH
  00d57	c1 e9 04	 shr	 ecx, 4
  00d5a	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  00d61	03 c2		 add	 eax, edx
  00d63	89 85 64 ff ff
	ff		 mov	 DWORD PTR _next_rep_match_price$33127[ebp], eax

; 713  : 
; 714  : 			//for(; len_test_2 >= 2; len_test_2--) {
; 715  : 			const uint32_t offset = cur + len_test + 1 + len_test_2;

  00d69	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  00d6c	03 45 8c	 add	 eax, DWORD PTR _len_test$33106[ebp]
  00d6f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00d75	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00d79	89 95 68 ff ff
	ff		 mov	 DWORD PTR _offset$33128[ebp], edx
$LN24@helper2:

; 716  : 
; 717  : 			while (len_end < offset)

  00d7f	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  00d82	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _offset$33128[ebp]
  00d88	73 1f		 jae	 SHORT $LN23@helper2

; 718  : 				coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00d8a	8b 4d 14	 mov	 ecx, DWORD PTR _len_end$[ebp]
  00d8d	83 c1 01	 add	 ecx, 1
  00d90	89 4d 14	 mov	 DWORD PTR _len_end$[ebp], ecx
  00d93	8b 55 14	 mov	 edx, DWORD PTR _len_end$[ebp]
  00d96	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00d99	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00d9c	c7 84 10 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [eax+edx+69124], 1073741824 ; 40000000H
  00da7	eb d6		 jmp	 SHORT $LN24@helper2
$LN23@helper2:

; 719  : 
; 720  :           {
; 721  : 			const uint32_t cur_and_len_price = next_rep_match_price
; 722  : 					+ get_rep_price(coder, 0, len_test_2,
; 723  : 						state_2, pos_state_next);

  00da9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _pos_state_next$33125[ebp]
  00daf	69 c9 40 04 00
	00		 imul	 ecx, 1088		; 00000440H
  00db5	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00db8	8d 84 0a 5c bd
	00 00		 lea	 eax, DWORD PTR [edx+ecx+48476]
  00dbf	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33118[ebp]
  00dc5	8b 54 88 f8	 mov	 edx, DWORD PTR [eax+ecx*4-8]
  00dc9	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T79170[ebp], edx
  00dcf	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pos_state_next$33125[ebp]
  00dd5	50		 push	 eax
  00dd6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _state_2$33124[ebp]
  00ddc	51		 push	 ecx
  00ddd	6a 00		 push	 0
  00ddf	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00de2	52		 push	 edx
  00de3	e8 00 00 00 00	 call	 _get_pure_rep_price
  00de8	83 c4 10	 add	 esp, 16			; 00000010H
  00deb	03 85 e4 fe ff
	ff		 add	 eax, DWORD PTR $T79170[ebp]
  00df1	03 85 64 ff ff
	ff		 add	 eax, DWORD PTR _next_rep_match_price$33127[ebp]
  00df7	89 85 60 ff ff
	ff		 mov	 DWORD PTR _cur_and_len_price$33132[ebp], eax

; 724  : 
; 725  : 			if (cur_and_len_price < coder->opts[offset].price) {

  00dfd	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _offset$33128[ebp]
  00e03	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e06	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00e09	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cur_and_len_price$33132[ebp]
  00e0f	3b 94 01 04 0e
	01 00		 cmp	 edx, DWORD PTR [ecx+eax+69124]
  00e16	0f 83 a1 00 00
	00		 jae	 $LN25@helper2

; 726  : 				coder->opts[offset].price = cur_and_len_price;

  00e1c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _offset$33128[ebp]
  00e22	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e25	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00e28	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _cur_and_len_price$33132[ebp]
  00e2e	89 94 01 04 0e
	01 00		 mov	 DWORD PTR [ecx+eax+69124], edx

; 727  : 				coder->opts[offset].pos_prev = cur + len_test + 1;

  00e35	8b 45 8c	 mov	 eax, DWORD PTR _len_test$33106[ebp]
  00e38	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00e3b	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00e3f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _offset$33128[ebp]
  00e45	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e48	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00e4b	89 94 01 08 0e
	01 00		 mov	 DWORD PTR [ecx+eax+69128], edx

; 728  : 				coder->opts[offset].back_prev = 0;

  00e52	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33128[ebp]
  00e58	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00e5b	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00e5e	c7 84 10 0c 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+69132], 0

; 729  : 				coder->opts[offset].prev_1_is_literal = true;

  00e69	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _offset$33128[ebp]
  00e6f	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00e72	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00e75	c6 84 0a f8 0d
	01 00 01	 mov	 BYTE PTR [edx+ecx+69112], 1

; 730  : 				coder->opts[offset].prev_2 = true;

  00e7d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _offset$33128[ebp]
  00e83	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e86	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00e89	c6 84 01 f9 0d
	01 00 01	 mov	 BYTE PTR [ecx+eax+69113], 1

; 731  : 				coder->opts[offset].pos_prev_2 = cur;

  00e91	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33128[ebp]
  00e97	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00e9a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00e9d	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00ea0	89 8c 10 fc 0d
	01 00		 mov	 DWORD PTR [eax+edx+69116], ecx

; 732  : 				coder->opts[offset].back_prev_2 = rep_index;

  00ea7	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33128[ebp]
  00ead	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00eb0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00eb3	8b 4d 98	 mov	 ecx, DWORD PTR _rep_index$33098[ebp]
  00eb6	89 8c 10 00 0e
	01 00		 mov	 DWORD PTR [eax+edx+69120], ecx
$LN25@helper2:

; 733  : 			}
; 734  : 			//}
; 735  : 		  }}}
; 736  : 		} //if
; 737  : 	  }}}
; 738  : 	}//for

  00ebd	e9 55 fa ff ff	 jmp	 $LN38@helper2
$LN37@helper2:

; 739  : 
; 740  : 
; 741  : 	//for (uint32_t len_test = 2; len_test <= new_len; ++len_test)
; 742  : 	if (new_len > buf_avail) {

  00ec2	8b 55 f4	 mov	 edx, DWORD PTR _new_len$[ebp]
  00ec5	3b 55 bc	 cmp	 edx, DWORD PTR _buf_avail$33082[ebp]
  00ec8	76 43		 jbe	 SHORT $LN21@helper2

; 743  : 		new_len = buf_avail;

  00eca	8b 45 bc	 mov	 eax, DWORD PTR _buf_avail$33082[ebp]
  00ecd	89 45 f4	 mov	 DWORD PTR _new_len$[ebp], eax

; 744  : 
; 745  : 		matches_count = 0;

  00ed0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _matches_count$[ebp], 0
$LN20@helper2:

; 746  : 		while (new_len > coder->matches[matches_count].len)

  00ed7	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  00eda	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00edd	8b 45 f4	 mov	 eax, DWORD PTR _new_len$[ebp]
  00ee0	3b 84 ca 04 02
	00 00		 cmp	 eax, DWORD PTR [edx+ecx*8+516]
  00ee7	76 0b		 jbe	 SHORT $LN19@helper2

; 747  : 			++matches_count;

  00ee9	8b 4d fc	 mov	 ecx, DWORD PTR _matches_count$[ebp]
  00eec	83 c1 01	 add	 ecx, 1
  00eef	89 4d fc	 mov	 DWORD PTR _matches_count$[ebp], ecx
  00ef2	eb e3		 jmp	 SHORT $LN20@helper2
$LN19@helper2:

; 748  : 
; 749  : 		coder->matches[matches_count++].len = new_len;

  00ef4	8b 55 fc	 mov	 edx, DWORD PTR _matches_count$[ebp]
  00ef7	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00efa	8b 4d f4	 mov	 ecx, DWORD PTR _new_len$[ebp]
  00efd	89 8c d0 04 02
	00 00		 mov	 DWORD PTR [eax+edx*8+516], ecx
  00f04	8b 55 fc	 mov	 edx, DWORD PTR _matches_count$[ebp]
  00f07	83 c2 01	 add	 edx, 1
  00f0a	89 55 fc	 mov	 DWORD PTR _matches_count$[ebp], edx
$LN21@helper2:

; 750  : 	}
; 751  : 
; 752  : 
; 753  : 	if (new_len >= start_len) {

  00f0d	8b 45 f4	 mov	 eax, DWORD PTR _new_len$[ebp]
  00f10	3b 45 94	 cmp	 eax, DWORD PTR _start_len$33097[ebp]
  00f13	0f 82 48 05 00
	00		 jb	 $LN18@helper2

; 754  : 		const uint32_t normal_match_price = match_price
; 755  : 				+ rc_bit_0_price(coder->is_rep[state]);

  00f19	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f1c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00f1f	0f b7 84 4a 2c
	6c 00 00	 movzx	 eax, WORD PTR [edx+ecx*2+27692]
  00f27	c1 f8 04	 sar	 eax, 4
  00f2a	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00f31	03 4d c8	 add	 ecx, DWORD PTR _match_price$33075[ebp]
  00f34	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _normal_match_price$33139[ebp], ecx
$LN17@helper2:

; 756  : 
; 757  : 		while (len_end < cur + new_len)

  00f3a	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  00f3d	03 55 f4	 add	 edx, DWORD PTR _new_len$[ebp]
  00f40	39 55 14	 cmp	 DWORD PTR _len_end$[ebp], edx
  00f43	73 1f		 jae	 SHORT $LN16@helper2

; 758  : 			coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00f45	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  00f48	83 c0 01	 add	 eax, 1
  00f4b	89 45 14	 mov	 DWORD PTR _len_end$[ebp], eax
  00f4e	8b 4d 14	 mov	 ecx, DWORD PTR _len_end$[ebp]
  00f51	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00f54	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00f57	c7 84 0a 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [edx+ecx+69124], 1073741824 ; 40000000H
  00f62	eb d6		 jmp	 SHORT $LN17@helper2
$LN16@helper2:

; 759  : 
; 760  : 	  { uint32_t i = 0;

  00f64	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$33143[ebp], 0
$LN15@helper2:

; 761  : 		while (start_len > coder->matches[i].len)

  00f6e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _i$33143[ebp]
  00f74	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00f77	8b 55 94	 mov	 edx, DWORD PTR _start_len$33097[ebp]
  00f7a	3b 94 c1 04 02
	00 00		 cmp	 edx, DWORD PTR [ecx+eax*8+516]
  00f81	76 11		 jbe	 SHORT $LN14@helper2

; 762  : 			++i;

  00f83	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _i$33143[ebp]
  00f89	83 c0 01	 add	 eax, 1
  00f8c	89 85 58 ff ff
	ff		 mov	 DWORD PTR _i$33143[ebp], eax
  00f92	eb da		 jmp	 SHORT $LN15@helper2
$LN14@helper2:

; 763  : 
; 764  :       { uint32_t len_test;
; 765  : 		for (len_test = start_len; ; ++len_test) {

  00f94	8b 4d 94	 mov	 ecx, DWORD PTR _start_len$33097[ebp]
  00f97	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _len_test$33147[ebp], ecx
  00f9d	eb 0f		 jmp	 SHORT $LN13@helper2
$LN12@helper2:
  00f9f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _len_test$33147[ebp]
  00fa5	83 c2 01	 add	 edx, 1
  00fa8	89 95 54 ff ff
	ff		 mov	 DWORD PTR _len_test$33147[ebp], edx
$LN13@helper2:

; 766  : 			const uint32_t cur_back = coder->matches[i].dist;

  00fae	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _i$33143[ebp]
  00fb4	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00fb7	8b 94 c1 08 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+520]
  00fbe	89 95 4c ff ff
	ff		 mov	 DWORD PTR _cur_back$33151[ebp], edx

; 767  : 			uint32_t cur_and_len_price = normal_match_price
; 768  : 					+ get_dist_len_price(coder,
; 769  : 						cur_back, len_test, pos_state);

  00fc4	8b 45 dc	 mov	 eax, DWORD PTR _pos_state$33071[ebp]
  00fc7	50		 push	 eax
  00fc8	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _len_test$33147[ebp]
  00fce	51		 push	 ecx
  00fcf	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _cur_back$33151[ebp]
  00fd5	52		 push	 edx
  00fd6	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00fd9	50		 push	 eax
  00fda	e8 00 00 00 00	 call	 _get_dist_len_price
  00fdf	83 c4 10	 add	 esp, 16			; 00000010H
  00fe2	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _normal_match_price$33139[ebp]
  00fe8	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cur_and_len_price$33152[ebp], eax

; 770  : 
; 771  : 			if (cur_and_len_price < coder->opts[cur + len_test].price) {

  00fee	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  00ff1	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  00ff7	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00ffa	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00ffd	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cur_and_len_price$33152[ebp]
  01003	3b 84 0a 04 0e
	01 00		 cmp	 eax, DWORD PTR [edx+ecx+69124]
  0100a	73 6b		 jae	 SHORT $LN10@helper2

; 772  : 				coder->opts[cur + len_test].price = cur_and_len_price;

  0100c	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0100f	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  01015	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  01018	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0101b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cur_and_len_price$33152[ebp]
  01021	89 84 0a 04 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69124], eax

; 773  : 				coder->opts[cur + len_test].pos_prev = cur;

  01028	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  0102b	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  01031	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  01034	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  01037	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  0103a	89 84 0a 08 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69128], eax

; 774  : 				coder->opts[cur + len_test].back_prev
; 775  : 						= cur_back + REPS;

  01041	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _cur_back$33151[ebp]
  01047	83 c1 04	 add	 ecx, 4
  0104a	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  0104d	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _len_test$33147[ebp]
  01053	6b d2 2c	 imul	 edx, 44			; 0000002cH
  01056	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  01059	89 8c 10 0c 0e
	01 00		 mov	 DWORD PTR [eax+edx+69132], ecx

; 776  : 				coder->opts[cur + len_test].prev_1_is_literal = false;

  01060	8b 4d 1c	 mov	 ecx, DWORD PTR _cur$[ebp]
  01063	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  01069	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0106c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0106f	c6 84 0a f8 0d
	01 00 00	 mov	 BYTE PTR [edx+ecx+69112], 0
$LN10@helper2:

; 777  : 			}
; 778  : 
; 779  : 			if (len_test == coder->matches[i].len) {

  01077	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _i$33143[ebp]
  0107d	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  01080	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _len_test$33147[ebp]
  01086	3b 94 c1 04 02
	00 00		 cmp	 edx, DWORD PTR [ecx+eax*8+516]
  0108d	0f 85 c9 03 00
	00		 jne	 $LN9@helper2

; 780  : 				// Try Match + Literal + Rep0
; 781  : 				const uint8_t *const buf_back = buf - cur_back - 1;

  01093	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  01096	2b 85 4c ff ff
	ff		 sub	 eax, DWORD PTR _cur_back$33151[ebp]
  0109c	83 e8 01	 sub	 eax, 1
  0109f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _buf_back$33155[ebp], eax

; 782  : 				uint32_t len_test_2 = len_test + 1;

  010a5	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _len_test$33147[ebp]
  010ab	83 c1 01	 add	 ecx, 1
  010ae	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _len_test_2$33156[ebp], ecx

; 783  : 				const uint32_t limit = my_min(buf_avail_full,
; 784  : 						len_test_2 + nice_len);

  010b4	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _len_test_2$33156[ebp]
  010ba	03 55 20	 add	 edx, DWORD PTR _nice_len$[ebp]
  010bd	39 55 24	 cmp	 DWORD PTR _buf_avail_full$[ebp], edx
  010c0	73 0b		 jae	 SHORT $LN102@helper2
  010c2	8b 45 24	 mov	 eax, DWORD PTR _buf_avail_full$[ebp]
  010c5	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv731[ebp], eax
  010cb	eb 0f		 jmp	 SHORT $LN103@helper2
$LN102@helper2:
  010cd	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33156[ebp]
  010d3	03 4d 20	 add	 ecx, DWORD PTR _nice_len$[ebp]
  010d6	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv731[ebp], ecx
$LN103@helper2:
  010dc	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv731[ebp]
  010e2	89 95 40 ff ff
	ff		 mov	 DWORD PTR _limit$33157[ebp], edx
  010e8	eb 0f		 jmp	 SHORT $LN8@helper2
$LN7@helper2:

; 785  : 
; 786  : 				for (; len_test_2 < limit &&
; 787  : 						buf[len_test_2] == buf_back[len_test_2];
; 788  : 						++len_test_2) ;

  010ea	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _len_test_2$33156[ebp]
  010f0	83 c0 01	 add	 eax, 1
  010f3	89 85 48 ff ff
	ff		 mov	 DWORD PTR _len_test_2$33156[ebp], eax
$LN8@helper2:
  010f9	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33156[ebp]
  010ff	3b 8d 40 ff ff
	ff		 cmp	 ecx, DWORD PTR _limit$33157[ebp]
  01105	73 21		 jae	 SHORT $LN6@helper2
  01107	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  0110a	03 95 48 ff ff
	ff		 add	 edx, DWORD PTR _len_test_2$33156[ebp]
  01110	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01113	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _buf_back$33155[ebp]
  01119	03 8d 48 ff ff
	ff		 add	 ecx, DWORD PTR _len_test_2$33156[ebp]
  0111f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01122	3b c2		 cmp	 eax, edx
  01124	75 02		 jne	 SHORT $LN6@helper2
  01126	eb c2		 jmp	 SHORT $LN7@helper2
$LN6@helper2:

; 789  : 
; 790  : 				len_test_2 -= len_test + 1;

  01128	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _len_test$33147[ebp]
  0112e	83 c0 01	 add	 eax, 1
  01131	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _len_test_2$33156[ebp]
  01137	2b c8		 sub	 ecx, eax
  01139	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _len_test_2$33156[ebp], ecx

; 791  : 
; 792  : 				if (len_test_2 >= 2) {

  0113f	83 bd 48 ff ff
	ff 02		 cmp	 DWORD PTR _len_test_2$33156[ebp], 2
  01146	0f 82 f4 02 00
	00		 jb	 $LN5@helper2

; 793  : 					lzma_lzma_state state_2 = state;

  0114c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0114f	89 95 3c ff ff
	ff		 mov	 DWORD PTR _state_2$33162[ebp], edx

; 794  : 					update_match(state_2);

  01155	33 c0		 xor	 eax, eax
  01157	83 bd 3c ff ff
	ff 07		 cmp	 DWORD PTR _state_2$33162[ebp], 7
  0115e	0f 9d c0	 setge	 al
  01161	83 e8 01	 sub	 eax, 1
  01164	83 e0 fd	 and	 eax, -3			; fffffffdH
  01167	83 c0 0a	 add	 eax, 10			; 0000000aH
  0116a	89 85 3c ff ff
	ff		 mov	 DWORD PTR _state_2$33162[ebp], eax

; 795  : 				  {
; 796  : 				    uint32_t pos_state_next
; 797  : 							= (position + len_test) & coder->pos_mask;

  01170	8b 4d 18	 mov	 ecx, DWORD PTR _position$[ebp]
  01173	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  01179	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0117c	23 8a a0 0a 00
	00		 and	 ecx, DWORD PTR [edx+2720]
  01182	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _pos_state_next$33163[ebp], ecx

; 798  : 
; 799  : 					const uint32_t cur_and_len_literal_price = cur_and_len_price
; 800  : 							+ rc_bit_0_price(
; 801  : 								coder->is_match[state_2][pos_state_next])
; 802  : 							+ get_literal_price(coder,
; 803  : 								position + len_test,
; 804  : 								buf[len_test - 1],
; 805  : 								true,
; 806  : 								buf_back[len_test],
; 807  : 								buf[len_test]);

  01188	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _state_2$33162[ebp]
  0118e	c1 e0 05	 shl	 eax, 5
  01191	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  01194	8d 94 01 ac 6a
	00 00		 lea	 edx, DWORD PTR [ecx+eax+27308]
  0119b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _pos_state_next$33163[ebp]
  011a1	0f b7 0c 42	 movzx	 ecx, WORD PTR [edx+eax*2]
  011a5	c1 f9 04	 sar	 ecx, 4
  011a8	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  011af	89 95 cc fe ff
	ff		 mov	 DWORD PTR $T79208[ebp], edx
  011b5	8b b5 50 ff ff
	ff		 mov	 esi, DWORD PTR _cur_and_len_price$33152[ebp]
  011bb	03 b5 cc fe ff
	ff		 add	 esi, DWORD PTR $T79208[ebp]
  011c1	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  011c4	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _len_test$33147[ebp]
  011ca	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  011cd	51		 push	 ecx
  011ce	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _buf_back$33155[ebp]
  011d4	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _len_test$33147[ebp]
  011da	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011dd	50		 push	 eax
  011de	6a 01		 push	 1
  011e0	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  011e3	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _len_test$33147[ebp]
  011e9	0f b6 51 ff	 movzx	 edx, BYTE PTR [ecx-1]
  011ed	52		 push	 edx
  011ee	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  011f1	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _len_test$33147[ebp]
  011f7	50		 push	 eax
  011f8	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  011fb	51		 push	 ecx
  011fc	e8 00 00 00 00	 call	 _get_literal_price
  01201	83 c4 18	 add	 esp, 24			; 00000018H
  01204	03 f0		 add	 esi, eax
  01206	89 b5 38 ff ff
	ff		 mov	 DWORD PTR _cur_and_len_literal_price$33164[ebp], esi

; 808  : 
; 809  : 					update_literal(state_2);

  0120c	83 bd 3c ff ff
	ff 03		 cmp	 DWORD PTR _state_2$33162[ebp], 3
  01213	7f 0c		 jg	 SHORT $LN106@helper2
  01215	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv776[ebp], 0
  0121f	eb 35		 jmp	 SHORT $LN107@helper2
$LN106@helper2:
  01221	83 bd 3c ff ff
	ff 09		 cmp	 DWORD PTR _state_2$33162[ebp], 9
  01228	7f 11		 jg	 SHORT $LN104@helper2
  0122a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _state_2$33162[ebp]
  01230	83 ea 03	 sub	 edx, 3
  01233	89 95 80 fe ff
	ff		 mov	 DWORD PTR tv775[ebp], edx
  01239	eb 0f		 jmp	 SHORT $LN105@helper2
$LN104@helper2:
  0123b	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _state_2$33162[ebp]
  01241	83 e8 06	 sub	 eax, 6
  01244	89 85 80 fe ff
	ff		 mov	 DWORD PTR tv775[ebp], eax
$LN105@helper2:
  0124a	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR tv775[ebp]
  01250	89 8d 84 fe ff
	ff		 mov	 DWORD PTR tv776[ebp], ecx
$LN107@helper2:
  01256	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv776[ebp]
  0125c	89 95 3c ff ff
	ff		 mov	 DWORD PTR _state_2$33162[ebp], edx

; 810  : 					pos_state_next = (pos_state_next + 1) & coder->pos_mask;

  01262	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _pos_state_next$33163[ebp]
  01268	83 c0 01	 add	 eax, 1
  0126b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0126e	23 81 a0 0a 00
	00		 and	 eax, DWORD PTR [ecx+2720]
  01274	89 85 34 ff ff
	ff		 mov	 DWORD PTR _pos_state_next$33163[ebp], eax

; 811  : 
; 812  :                   {
; 813  : 					const uint32_t next_rep_match_price
; 814  : 							= cur_and_len_literal_price
; 815  : 							+ rc_bit_1_price(
; 816  : 								coder->is_match[state_2][pos_state_next])
; 817  : 							+ rc_bit_1_price(coder->is_rep[state_2]);

  0127a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _state_2$33162[ebp]
  01280	c1 e2 05	 shl	 edx, 5
  01283	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  01286	8d 8c 10 ac 6a
	00 00		 lea	 ecx, DWORD PTR [eax+edx+27308]
  0128d	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _pos_state_next$33163[ebp]
  01293	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  01297	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0129c	c1 e8 04	 shr	 eax, 4
  0129f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  012a6	89 8d c8 fe ff
	ff		 mov	 DWORD PTR $T79212[ebp], ecx
  012ac	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _cur_and_len_literal_price$33164[ebp]
  012b2	03 95 c8 fe ff
	ff		 add	 edx, DWORD PTR $T79212[ebp]
  012b8	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _state_2$33162[ebp]
  012be	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  012c1	0f b7 84 41 2c
	6c 00 00	 movzx	 eax, WORD PTR [ecx+eax*2+27692]
  012c9	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  012ce	c1 e8 04	 shr	 eax, 4
  012d1	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  012d8	03 d1		 add	 edx, ecx
  012da	89 95 2c ff ff
	ff		 mov	 DWORD PTR _next_rep_match_price$33165[ebp], edx

; 818  : 
; 819  : 					// for(; len_test_2 >= 2; --len_test_2) {
; 820  : 					const uint32_t offset = cur + len_test + 1 + len_test_2;

  012e0	8b 55 1c	 mov	 edx, DWORD PTR _cur$[ebp]
  012e3	03 95 54 ff ff
	ff		 add	 edx, DWORD PTR _len_test$33147[ebp]
  012e9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _len_test_2$33156[ebp]
  012ef	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  012f3	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _offset$33166[ebp], ecx
$LN4@helper2:

; 821  : 
; 822  : 					while (len_end < offset)

  012f9	8b 55 14	 mov	 edx, DWORD PTR _len_end$[ebp]
  012fc	3b 95 30 ff ff
	ff		 cmp	 edx, DWORD PTR _offset$33166[ebp]
  01302	73 1f		 jae	 SHORT $LN3@helper2

; 823  : 						coder->opts[++len_end].price = RC_INFINITY_PRICE;

  01304	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
  01307	83 c0 01	 add	 eax, 1
  0130a	89 45 14	 mov	 DWORD PTR _len_end$[ebp], eax
  0130d	8b 4d 14	 mov	 ecx, DWORD PTR _len_end$[ebp]
  01310	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  01313	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  01316	c7 84 0a 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [edx+ecx+69124], 1073741824 ; 40000000H
  01321	eb d6		 jmp	 SHORT $LN4@helper2
$LN3@helper2:

; 824  : 
; 825  : 					cur_and_len_price = next_rep_match_price
; 826  : 							+ get_rep_price(coder, 0, len_test_2,
; 827  : 								state_2, pos_state_next);

  01323	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _pos_state_next$33163[ebp]
  01329	69 c0 40 04 00
	00		 imul	 eax, 1088		; 00000440H
  0132f	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  01332	8d 94 01 5c bd
	00 00		 lea	 edx, DWORD PTR [ecx+eax+48476]
  01339	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _len_test_2$33156[ebp]
  0133f	8b 4c 82 f8	 mov	 ecx, DWORD PTR [edx+eax*4-8]
  01343	89 8d c4 fe ff
	ff		 mov	 DWORD PTR $T79220[ebp], ecx
  01349	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _pos_state_next$33163[ebp]
  0134f	52		 push	 edx
  01350	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _state_2$33162[ebp]
  01356	50		 push	 eax
  01357	6a 00		 push	 0
  01359	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0135c	51		 push	 ecx
  0135d	e8 00 00 00 00	 call	 _get_pure_rep_price
  01362	83 c4 10	 add	 esp, 16			; 00000010H
  01365	03 85 c4 fe ff
	ff		 add	 eax, DWORD PTR $T79220[ebp]
  0136b	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _next_rep_match_price$33165[ebp]
  01371	89 85 50 ff ff
	ff		 mov	 DWORD PTR _cur_and_len_price$33152[ebp], eax

; 828  : 
; 829  : 					if (cur_and_len_price < coder->opts[offset].price) {

  01377	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33166[ebp]
  0137d	6b d2 2c	 imul	 edx, 44			; 0000002cH
  01380	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  01383	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cur_and_len_price$33152[ebp]
  01389	3b 8c 10 04 0e
	01 00		 cmp	 ecx, DWORD PTR [eax+edx+69124]
  01390	0f 83 aa 00 00
	00		 jae	 $LN5@helper2

; 830  : 						coder->opts[offset].price = cur_and_len_price;

  01396	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33166[ebp]
  0139c	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0139f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  013a2	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _cur_and_len_price$33152[ebp]
  013a8	89 8c 10 04 0e
	01 00		 mov	 DWORD PTR [eax+edx+69124], ecx

; 831  : 						coder->opts[offset].pos_prev = cur + len_test + 1;

  013af	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _len_test$33147[ebp]
  013b5	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  013b8	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  013bc	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33166[ebp]
  013c2	6b d2 2c	 imul	 edx, 44			; 0000002cH
  013c5	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  013c8	89 8c 10 08 0e
	01 00		 mov	 DWORD PTR [eax+edx+69128], ecx

; 832  : 						coder->opts[offset].back_prev = 0;

  013cf	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _offset$33166[ebp]
  013d5	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  013d8	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  013db	c7 84 0a 0c 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+69132], 0

; 833  : 						coder->opts[offset].prev_1_is_literal = true;

  013e6	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _offset$33166[ebp]
  013ec	6b c0 2c	 imul	 eax, 44			; 0000002cH
  013ef	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  013f2	c6 84 01 f8 0d
	01 00 01	 mov	 BYTE PTR [ecx+eax+69112], 1

; 834  : 						coder->opts[offset].prev_2 = true;

  013fa	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33166[ebp]
  01400	6b d2 2c	 imul	 edx, 44			; 0000002cH
  01403	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  01406	c6 84 10 f9 0d
	01 00 01	 mov	 BYTE PTR [eax+edx+69113], 1

; 835  : 						coder->opts[offset].pos_prev_2 = cur;

  0140e	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _offset$33166[ebp]
  01414	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  01417	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0141a	8b 45 1c	 mov	 eax, DWORD PTR _cur$[ebp]
  0141d	89 84 0a fc 0d
	01 00		 mov	 DWORD PTR [edx+ecx+69116], eax

; 836  : 						coder->opts[offset].back_prev_2
; 837  : 								= cur_back + REPS;

  01424	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _cur_back$33151[ebp]
  0142a	83 c1 04	 add	 ecx, 4
  0142d	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _offset$33166[ebp]
  01433	6b d2 2c	 imul	 edx, 44			; 0000002cH
  01436	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  01439	89 8c 10 00 0e
	01 00		 mov	 DWORD PTR [eax+edx+69120], ecx
$LN5@helper2:

; 838  : 					}
; 839  : 					//}
; 840  : 				  }}
; 841  : 				}
; 842  : 
; 843  : 				if (++i == matches_count)

  01440	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _i$33143[ebp]
  01446	83 c1 01	 add	 ecx, 1
  01449	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _i$33143[ebp], ecx
  0144f	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _i$33143[ebp]
  01455	3b 55 fc	 cmp	 edx, DWORD PTR _matches_count$[ebp]
  01458	75 02		 jne	 SHORT $LN9@helper2

; 844  : 					break;

  0145a	eb 05		 jmp	 SHORT $LN18@helper2
$LN9@helper2:

; 845  : 			} //if
; 846  : 		} //for

  0145c	e9 3e fb ff ff	 jmp	 $LN12@helper2
$LN18@helper2:

; 847  : 	  }}
; 848  : 	} //if
; 849  :   }
; 850  :   }}}
; 851  : 
; 852  : 	return len_end;

  01461	8b 45 14	 mov	 eax, DWORD PTR _len_end$[ebp]
$LN78@helper2:

; 853  : }

  01464	5e		 pop	 esi
  01465	8b e5		 mov	 esp, ebp
  01467	5d		 pop	 ebp
  01468	c3		 ret	 0
_helper2 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _helper1
_TEXT	SEGMENT
tv320 = -188						; size = 4
tv246 = -184						; size = 4
tv416 = -180						; size = 4
tv81 = -176						; size = 4
$T79340 = -156						; size = 4
$T79317 = -148						; size = 4
$T79313 = -144						; size = 4
$T79303 = -140						; size = 4
$T79292 = -136						; size = 4
$T79288 = -132						; size = 4
$T79284 = -128						; size = 4
$T79279 = -124						; size = 4
$T79274 = -120						; size = 4
$T79273 = -116						; size = 4
_x$79266 = -112						; size = 4
_dist$33010 = -108					; size = 4
_cur_and_len_price$33011 = -104				; size = 4
_i$33003 = -100						; size = 4
_normal_match_price$33000 = -96				; size = 4
_len$33001 = -92					; size = 4
_cur_and_len_price$32998 = -88				; size = 4
_price$32994 = -84					; size = 4
_rep_len$32992 = -80					; size = 4
_len$32985 = -76					; size = 4
_len_end$32980 = -72					; size = 4
_short_rep_price$32978 = -68				; size = 4
_rep_match_price$32976 = -64				; size = 4
_match_price$32975 = -60				; size = 4
_pos_state$32974 = -56					; size = 4
_match_byte$32972 = -50					; size = 1
_current_byte$32971 = -49				; size = 1
_buf_back$32964 = -48					; size = 4
_rep_lens$32958 = -44					; size = 16
_buf$32957 = -28					; size = 4
_rep_max_index$32959 = -24				; size = 4
_i$32960 = -20						; size = 4
_buf_avail$32955 = -16					; size = 4
_nice_len$ = -12					; size = 4
_len_main$ = -8						; size = 4
_matches_count$ = -4					; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_back_res$ = 16						; size = 4
_len_res$ = 20						; size = 4
_position$ = 24						; size = 4
_helper1 PROC						; COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	56		 push	 esi

; 294  : 	const uint32_t nice_len = mf->nice_len;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0000d	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00010	89 4d f4	 mov	 DWORD PTR _nice_len$[ebp], ecx

; 295  : 
; 296  : 	uint32_t len_main;
; 297  : 	uint32_t matches_count;
; 298  : 
; 299  : 	if (mf->read_ahead == 0) {

  00013	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00016	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0001a	75 1e		 jne	 SHORT $LN37@helper1

; 300  : 		len_main = mf_find(mf, &matches_count, coder->matches);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001f	05 04 02 00 00	 add	 eax, 516		; 00000204H
  00024	50		 push	 eax
  00025	8d 4d fc	 lea	 ecx, DWORD PTR _matches_count$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _lzma_mf_find
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	89 45 f8	 mov	 DWORD PTR _len_main$[ebp], eax

; 301  : 	} else {

  00038	eb 18		 jmp	 SHORT $LN46@helper1
$LN37@helper1:

; 302  : 		assert(mf->read_ahead == 1);
; 303  : 		len_main = coder->longest_match_length;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0003d	8b 88 98 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2712]
  00043	89 4d f8	 mov	 DWORD PTR _len_main$[ebp], ecx

; 304  : 		matches_count = coder->matches_count;

  00046	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00049	8b 82 94 0a 00
	00		 mov	 eax, DWORD PTR [edx+2708]
  0004f	89 45 fc	 mov	 DWORD PTR _matches_count$[ebp], eax

; 305  : 	}
; 306  : 
; 307  :   {
; 308  : 	const uint32_t buf_avail = my_min(mf_avail(mf) + 1, MATCH_LEN_MAX);

$LN46@helper1:
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00055	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00058	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0005b	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  0005e	83 c0 01	 add	 eax, 1
  00061	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  00066	73 17		 jae	 SHORT $LN40@helper1
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0006b	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0006e	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00071	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00074	83 c0 01	 add	 eax, 1
  00077	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  0007d	eb 0a		 jmp	 SHORT $LN41@helper1
$LN40@helper1:
  0007f	c7 85 50 ff ff
	ff 11 01 00 00	 mov	 DWORD PTR tv81[ebp], 273 ; 00000111H
$LN41@helper1:
  00089	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  0008f	89 4d f0	 mov	 DWORD PTR _buf_avail$32955[ebp], ecx

; 309  : 	if (buf_avail < 2) {

  00092	83 7d f0 02	 cmp	 DWORD PTR _buf_avail$32955[ebp], 2
  00096	73 1a		 jae	 SHORT $LN50@helper1

; 310  : 		*back_res = UINT32_MAX;

  00098	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  0009b	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1

; 311  : 		*len_res = 1;

  000a1	8b 45 14	 mov	 eax, DWORD PTR _len_res$[ebp]
  000a4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 312  : 		return UINT32_MAX;

  000aa	83 c8 ff	 or	 eax, -1
  000ad	e9 d1 06 00 00	 jmp	 $LN38@helper1

; 313  : 	}
; 314  : 
; 315  :   {
; 316  : 	const uint8_t *const buf = mf_ptr(mf) - 1;

$LN50@helper1:
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  000b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b7	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  000ba	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000bd	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  000c1	89 55 e4	 mov	 DWORD PTR _buf$32957[ebp], edx

; 317  : 
; 318  : 	uint32_t rep_lens[REPS];
; 319  : 	uint32_t rep_max_index = 0;

  000c4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rep_max_index$32959[ebp], 0

; 320  : 	uint32_t i;
; 321  : 
; 322  : 	for (i = 0; i < REPS; ++i) {

  000cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$32960[ebp], 0
  000d2	eb 09		 jmp	 SHORT $LN34@helper1
$LN33@helper1:
  000d4	8b 45 ec	 mov	 eax, DWORD PTR _i$32960[ebp]
  000d7	83 c0 01	 add	 eax, 1
  000da	89 45 ec	 mov	 DWORD PTR _i$32960[ebp], eax
$LN34@helper1:
  000dd	83 7d ec 04	 cmp	 DWORD PTR _i$32960[ebp], 4
  000e1	0f 83 e5 00 00
	00		 jae	 $LN32@helper1

; 323  : 		const uint8_t *const buf_back = buf - coder->reps[i] - 1;

  000e7	8b 4d ec	 mov	 ecx, DWORD PTR _i$32960[ebp]
  000ea	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000ed	8b 45 e4	 mov	 eax, DWORD PTR _buf$32957[ebp]
  000f0	2b 84 8a f4 01
	00 00		 sub	 eax, DWORD PTR [edx+ecx*4+500]
  000f7	83 e8 01	 sub	 eax, 1
  000fa	89 45 d0	 mov	 DWORD PTR _buf_back$32964[ebp], eax

; 324  : 
; 325  : 		if (not_equal_16(buf, buf_back)) {

  000fd	8b 4d e4	 mov	 ecx, DWORD PTR _buf$32957[ebp]
  00100	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00103	8b 45 d0	 mov	 eax, DWORD PTR _buf_back$32964[ebp]
  00106	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00109	3b d1		 cmp	 edx, ecx
  0010b	74 0d		 je	 SHORT $LN31@helper1

; 326  : 			rep_lens[i] = 0;

  0010d	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  00110	c7 44 95 d4 00
	00 00 00	 mov	 DWORD PTR _rep_lens$32958[ebp+edx*4], 0

; 327  : 			continue;

  00118	eb ba		 jmp	 SHORT $LN33@helper1
$LN31@helper1:

; 328  : 		}
; 329  : 
; 330  : 		rep_lens[i] = lzma_memcmplen(buf, buf_back, 2, buf_avail);

  0011a	c7 45 8c 02 00
	00 00		 mov	 DWORD PTR $T79273[ebp], 2
$LN56@helper1:
  00121	8b 45 8c	 mov	 eax, DWORD PTR $T79273[ebp]
  00124	3b 45 f0	 cmp	 eax, DWORD PTR _buf_avail$32955[ebp]
  00127	73 78		 jae	 SHORT $LN55@helper1
  00129	8b 4d e4	 mov	 ecx, DWORD PTR _buf$32957[ebp]
  0012c	03 4d 8c	 add	 ecx, DWORD PTR $T79273[ebp]
  0012f	8b 55 d0	 mov	 edx, DWORD PTR _buf_back$32964[ebp]
  00132	03 55 8c	 add	 edx, DWORD PTR $T79273[ebp]
  00135	8b 01		 mov	 eax, DWORD PTR [ecx]
  00137	2b 02		 sub	 eax, DWORD PTR [edx]
  00139	89 45 90	 mov	 DWORD PTR _x$79266[ebp], eax
  0013c	74 58		 je	 SHORT $LN54@helper1
  0013e	8b 4d 90	 mov	 ecx, DWORD PTR _x$79266[ebp]
  00141	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00147	75 12		 jne	 SHORT $LN53@helper1
  00149	8b 55 8c	 mov	 edx, DWORD PTR $T79273[ebp]
  0014c	83 c2 02	 add	 edx, 2
  0014f	89 55 8c	 mov	 DWORD PTR $T79273[ebp], edx
  00152	8b 45 90	 mov	 eax, DWORD PTR _x$79266[ebp]
  00155	c1 e8 10	 shr	 eax, 16			; 00000010H
  00158	89 45 90	 mov	 DWORD PTR _x$79266[ebp], eax
$LN53@helper1:
  0015b	8b 4d 90	 mov	 ecx, DWORD PTR _x$79266[ebp]
  0015e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00164	75 09		 jne	 SHORT $LN52@helper1
  00166	8b 55 8c	 mov	 edx, DWORD PTR $T79273[ebp]
  00169	83 c2 01	 add	 edx, 1
  0016c	89 55 8c	 mov	 DWORD PTR $T79273[ebp], edx
$LN52@helper1:
  0016f	8b 45 8c	 mov	 eax, DWORD PTR $T79273[ebp]
  00172	3b 45 f0	 cmp	 eax, DWORD PTR _buf_avail$32955[ebp]
  00175	73 0b		 jae	 SHORT $LN59@helper1
  00177	8b 4d 8c	 mov	 ecx, DWORD PTR $T79273[ebp]
  0017a	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv416[ebp], ecx
  00180	eb 09		 jmp	 SHORT $LN60@helper1
$LN59@helper1:
  00182	8b 55 f0	 mov	 edx, DWORD PTR _buf_avail$32955[ebp]
  00185	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv416[ebp], edx
$LN60@helper1:
  0018b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv416[ebp]
  00191	89 45 88	 mov	 DWORD PTR $T79274[ebp], eax
  00194	eb 11		 jmp	 SHORT $LN57@helper1
$LN54@helper1:
  00196	8b 4d 8c	 mov	 ecx, DWORD PTR $T79273[ebp]
  00199	83 c1 04	 add	 ecx, 4
  0019c	89 4d 8c	 mov	 DWORD PTR $T79273[ebp], ecx
  0019f	eb 80		 jmp	 SHORT $LN56@helper1
$LN55@helper1:
  001a1	8b 55 f0	 mov	 edx, DWORD PTR _buf_avail$32955[ebp]
  001a4	89 55 88	 mov	 DWORD PTR $T79274[ebp], edx
$LN57@helper1:
  001a7	8b 45 ec	 mov	 eax, DWORD PTR _i$32960[ebp]
  001aa	8b 4d 88	 mov	 ecx, DWORD PTR $T79274[ebp]
  001ad	89 4c 85 d4	 mov	 DWORD PTR _rep_lens$32958[ebp+eax*4], ecx

; 331  : 
; 332  : 		if (rep_lens[i] > rep_lens[rep_max_index])

  001b1	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  001b4	8b 45 e8	 mov	 eax, DWORD PTR _rep_max_index$32959[ebp]
  001b7	8b 4c 95 d4	 mov	 ecx, DWORD PTR _rep_lens$32958[ebp+edx*4]
  001bb	3b 4c 85 d4	 cmp	 ecx, DWORD PTR _rep_lens$32958[ebp+eax*4]
  001bf	76 06		 jbe	 SHORT $LN30@helper1

; 333  : 			rep_max_index = i;

  001c1	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  001c4	89 55 e8	 mov	 DWORD PTR _rep_max_index$32959[ebp], edx
$LN30@helper1:

; 334  : 	}

  001c7	e9 08 ff ff ff	 jmp	 $LN33@helper1
$LN32@helper1:

; 335  : 
; 336  : 	if (rep_lens[rep_max_index] >= nice_len) {

  001cc	8b 45 e8	 mov	 eax, DWORD PTR _rep_max_index$32959[ebp]
  001cf	8b 4c 85 d4	 mov	 ecx, DWORD PTR _rep_lens$32958[ebp+eax*4]
  001d3	3b 4d f4	 cmp	 ecx, DWORD PTR _nice_len$[ebp]
  001d6	72 4b		 jb	 SHORT $LN29@helper1

; 337  : 		*back_res = rep_max_index;

  001d8	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  001db	8b 45 e8	 mov	 eax, DWORD PTR _rep_max_index$32959[ebp]
  001de	89 02		 mov	 DWORD PTR [edx], eax

; 338  : 		*len_res = rep_lens[rep_max_index];

  001e0	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  001e3	8b 55 e8	 mov	 edx, DWORD PTR _rep_max_index$32959[ebp]
  001e6	8b 44 95 d4	 mov	 eax, DWORD PTR _rep_lens$32958[ebp+edx*4]
  001ea	89 01		 mov	 DWORD PTR [ecx], eax

; 339  : 		mf_skip(mf, *len_res - 1);

  001ec	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  001ef	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f1	83 ea 01	 sub	 edx, 1
  001f4	89 55 84	 mov	 DWORD PTR $T79279[ebp], edx
  001f7	74 22		 je	 SHORT $LN62@helper1
  001f9	8b 45 84	 mov	 eax, DWORD PTR $T79279[ebp]
  001fc	50		 push	 eax
  001fd	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00200	51		 push	 ecx
  00201	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  00204	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00207	ff d0		 call	 eax
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0020f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00212	03 55 84	 add	 edx, DWORD PTR $T79279[ebp]
  00215	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00218	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN62@helper1:

; 340  : 		return UINT32_MAX;

  0021b	83 c8 ff	 or	 eax, -1
  0021e	e9 60 05 00 00	 jmp	 $LN38@helper1
$LN29@helper1:

; 341  : 	}
; 342  : 
; 343  : 
; 344  : 	if (len_main >= nice_len) {

  00223	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  00226	3b 4d f4	 cmp	 ecx, DWORD PTR _nice_len$[ebp]
  00229	72 52		 jb	 SHORT $LN28@helper1

; 345  : 		*back_res = coder->matches[matches_count - 1].dist + REPS;

  0022b	8b 55 fc	 mov	 edx, DWORD PTR _matches_count$[ebp]
  0022e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00231	8b 8c d0 00 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx*8+512]
  00238	83 c1 04	 add	 ecx, 4
  0023b	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  0023e	89 0a		 mov	 DWORD PTR [edx], ecx

; 346  : 		*len_res = len_main;

  00240	8b 45 14	 mov	 eax, DWORD PTR _len_res$[ebp]
  00243	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  00246	89 08		 mov	 DWORD PTR [eax], ecx

; 347  : 		mf_skip(mf, len_main - 1);

  00248	8b 55 f8	 mov	 edx, DWORD PTR _len_main$[ebp]
  0024b	83 ea 01	 sub	 edx, 1
  0024e	89 55 80	 mov	 DWORD PTR $T79284[ebp], edx
  00251	74 22		 je	 SHORT $LN65@helper1
  00253	8b 45 80	 mov	 eax, DWORD PTR $T79284[ebp]
  00256	50		 push	 eax
  00257	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  0025a	51		 push	 ecx
  0025b	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0025e	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00261	ff d0		 call	 eax
  00263	83 c4 08	 add	 esp, 8
  00266	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00269	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0026c	03 55 80	 add	 edx, DWORD PTR $T79284[ebp]
  0026f	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00272	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN65@helper1:

; 348  : 		return UINT32_MAX;

  00275	83 c8 ff	 or	 eax, -1
  00278	e9 06 05 00 00	 jmp	 $LN38@helper1
$LN28@helper1:

; 349  : 	}
; 350  : 
; 351  :   {
; 352  : 	const uint8_t current_byte = *buf;

  0027d	8b 4d e4	 mov	 ecx, DWORD PTR _buf$32957[ebp]
  00280	8a 11		 mov	 dl, BYTE PTR [ecx]
  00282	88 55 cf	 mov	 BYTE PTR _current_byte$32971[ebp], dl

; 353  : 	const uint8_t match_byte = *(buf - coder->reps[0] - 1);

  00285	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00288	8b 4d e4	 mov	 ecx, DWORD PTR _buf$32957[ebp]
  0028b	2b 88 f4 01 00
	00		 sub	 ecx, DWORD PTR [eax+500]
  00291	8a 51 ff	 mov	 dl, BYTE PTR [ecx-1]
  00294	88 55 ce	 mov	 BYTE PTR _match_byte$32972[ebp], dl

; 354  : 
; 355  : 	if (len_main < 2 && current_byte != match_byte
; 356  : 			&& rep_lens[rep_max_index] < 2) {

  00297	83 7d f8 02	 cmp	 DWORD PTR _len_main$[ebp], 2
  0029b	73 30		 jae	 SHORT $LN27@helper1
  0029d	0f b6 45 cf	 movzx	 eax, BYTE PTR _current_byte$32971[ebp]
  002a1	0f b6 4d ce	 movzx	 ecx, BYTE PTR _match_byte$32972[ebp]
  002a5	3b c1		 cmp	 eax, ecx
  002a7	74 24		 je	 SHORT $LN27@helper1
  002a9	8b 55 e8	 mov	 edx, DWORD PTR _rep_max_index$32959[ebp]
  002ac	83 7c 95 d4 02	 cmp	 DWORD PTR _rep_lens$32958[ebp+edx*4], 2
  002b1	73 1a		 jae	 SHORT $LN27@helper1

; 357  : 		*back_res = UINT32_MAX;

  002b3	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  002b6	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 358  : 		*len_res = 1;

  002bc	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  002bf	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 359  : 		return UINT32_MAX;

  002c5	83 c8 ff	 or	 eax, -1
  002c8	e9 b6 04 00 00	 jmp	 $LN38@helper1
$LN27@helper1:

; 360  : 	}
; 361  : 
; 362  : 	coder->opts[0].state = coder->state;

  002cd	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002d0	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  002d3	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  002d9	89 8a f4 0d 01
	00		 mov	 DWORD PTR [edx+69108], ecx

; 363  : 
; 364  :   {
; 365  : 	const uint32_t pos_state = position & coder->pos_mask;

  002df	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  002e2	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  002e5	23 82 a0 0a 00
	00		 and	 eax, DWORD PTR [edx+2720]
  002eb	89 45 c8	 mov	 DWORD PTR _pos_state$32974[ebp], eax

; 366  : 
; 367  : 	coder->opts[1].price = rc_bit_0_price(
; 368  : 				coder->is_match[coder->state][pos_state])
; 369  : 			+ get_literal_price(coder, position, buf[-1],
; 370  : 				!is_literal_state(coder->state),
; 371  : 				match_byte, current_byte);

  002ee	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  002f1	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  002f7	c1 e2 05	 shl	 edx, 5
  002fa	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  002fd	8d 8c 10 ac 6a
	00 00		 lea	 ecx, DWORD PTR [eax+edx+27308]
  00304	8b 55 c8	 mov	 edx, DWORD PTR _pos_state$32974[ebp]
  00307	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0030b	c1 f8 04	 sar	 eax, 4
  0030e	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00315	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T79288[ebp], ecx
  0031b	0f b6 55 cf	 movzx	 edx, BYTE PTR _current_byte$32971[ebp]
  0031f	52		 push	 edx
  00320	0f b6 45 ce	 movzx	 eax, BYTE PTR _match_byte$32972[ebp]
  00324	50		 push	 eax
  00325	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00328	33 d2		 xor	 edx, edx
  0032a	83 b9 f0 01 00
	00 07		 cmp	 DWORD PTR [ecx+496], 7
  00331	0f 9d c2	 setge	 dl
  00334	0f b6 c2	 movzx	 eax, dl
  00337	50		 push	 eax
  00338	8b 4d e4	 mov	 ecx, DWORD PTR _buf$32957[ebp]
  0033b	0f b6 51 ff	 movzx	 edx, BYTE PTR [ecx-1]
  0033f	52		 push	 edx
  00340	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  00343	50		 push	 eax
  00344	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00347	51		 push	 ecx
  00348	e8 00 00 00 00	 call	 _get_literal_price
  0034d	83 c4 18	 add	 esp, 24			; 00000018H
  00350	03 85 7c ff ff
	ff		 add	 eax, DWORD PTR $T79288[ebp]
  00356	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00359	89 82 30 0e 01
	00		 mov	 DWORD PTR [edx+69168], eax

; 372  : 
; 373  : 	make_literal(&coder->opts[1]);

  0035f	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00362	05 20 0e 01 00	 add	 eax, 69152		; 00010e20H
  00367	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T79292[ebp], eax
  0036d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T79292[ebp]
  00373	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1
  0037a	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T79292[ebp]
  00380	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 374  : 
; 375  :   {
; 376  : 	const uint32_t match_price = rc_bit_1_price(
; 377  : 			coder->is_match[coder->state][pos_state]);

  00384	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00387	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  0038d	c1 e1 05	 shl	 ecx, 5
  00390	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00393	8d 84 0a ac 6a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+27308]
  0039a	8b 4d c8	 mov	 ecx, DWORD PTR _pos_state$32974[ebp]
  0039d	0f b7 14 48	 movzx	 edx, WORD PTR [eax+ecx*2]
  003a1	81 f2 ff 07 00
	00		 xor	 edx, 2047		; 000007ffH
  003a7	c1 ea 04	 shr	 edx, 4
  003aa	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  003b1	89 45 c4	 mov	 DWORD PTR _match_price$32975[ebp], eax

; 378  : 	const uint32_t rep_match_price = match_price
; 379  : 			+ rc_bit_1_price(coder->is_rep[coder->state]);

  003b4	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  003b7	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  003bd	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  003c0	0f b7 8c 50 2c
	6c 00 00	 movzx	 ecx, WORD PTR [eax+edx*2+27692]
  003c8	81 f1 ff 07 00
	00		 xor	 ecx, 2047		; 000007ffH
  003ce	c1 e9 04	 shr	 ecx, 4
  003d1	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _lzma_rc_prices[ecx]
  003d8	03 55 c4	 add	 edx, DWORD PTR _match_price$32975[ebp]
  003db	89 55 c0	 mov	 DWORD PTR _rep_match_price$32976[ebp], edx

; 380  : 
; 381  : 	if (match_byte == current_byte) {

  003de	0f b6 45 ce	 movzx	 eax, BYTE PTR _match_byte$32972[ebp]
  003e2	0f b6 4d cf	 movzx	 ecx, BYTE PTR _current_byte$32971[ebp]
  003e6	3b c1		 cmp	 eax, ecx
  003e8	0f 85 9f 00 00
	00		 jne	 $LN26@helper1

; 382  : 		const uint32_t short_rep_price = rep_match_price
; 383  : 				+ get_short_rep_price(
; 384  : 					coder, coder->state, pos_state);

  003ee	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  003f1	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  003f7	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T79313[ebp], eax
  003fd	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T79313[ebp]
  00403	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00406	0f b7 84 4a 44
	6c 00 00	 movzx	 eax, WORD PTR [edx+ecx*2+27716]
  0040e	c1 f8 04	 sar	 eax, 4
  00411	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00418	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T79303[ebp], ecx
  0041e	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T79313[ebp]
  00424	c1 e2 05	 shl	 edx, 5
  00427	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0042a	8d 8c 10 8c 6c
	00 00		 lea	 ecx, DWORD PTR [eax+edx+27788]
  00431	8b 55 c8	 mov	 edx, DWORD PTR _pos_state$32974[ebp]
  00434	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00438	c1 f8 04	 sar	 eax, 4
  0043b	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _lzma_rc_prices[eax]
  00442	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR $T79303[ebp]
  00448	03 4d c0	 add	 ecx, DWORD PTR _rep_match_price$32976[ebp]
  0044b	89 4d bc	 mov	 DWORD PTR _short_rep_price$32978[ebp], ecx

; 385  : 
; 386  : 		if (short_rep_price < coder->opts[1].price) {

  0044e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00451	8b 45 bc	 mov	 eax, DWORD PTR _short_rep_price$32978[ebp]
  00454	3b 82 30 0e 01
	00		 cmp	 eax, DWORD PTR [edx+69168]
  0045a	73 31		 jae	 SHORT $LN26@helper1

; 387  : 			coder->opts[1].price = short_rep_price;

  0045c	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0045f	8b 55 bc	 mov	 edx, DWORD PTR _short_rep_price$32978[ebp]
  00462	89 91 30 0e 01
	00		 mov	 DWORD PTR [ecx+69168], edx

; 388  : 			make_short_rep(&coder->opts[1]);

  00468	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0046b	05 20 0e 01 00	 add	 eax, 69152		; 00010e20H
  00470	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T79317[ebp], eax
  00476	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T79317[ebp]
  0047c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00483	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR $T79317[ebp]
  00489	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0
$LN26@helper1:

; 389  : 		}
; 390  : 	}
; 391  : 
; 392  :   {
; 393  : 	const uint32_t len_end = my_max(len_main, rep_lens[rep_max_index]);

  0048d	8b 45 e8	 mov	 eax, DWORD PTR _rep_max_index$32959[ebp]
  00490	8b 4d f8	 mov	 ecx, DWORD PTR _len_main$[ebp]
  00493	3b 4c 85 d4	 cmp	 ecx, DWORD PTR _rep_lens$32958[ebp+eax*4]
  00497	76 0b		 jbe	 SHORT $LN42@helper1
  00499	8b 55 f8	 mov	 edx, DWORD PTR _len_main$[ebp]
  0049c	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], edx
  004a2	eb 0d		 jmp	 SHORT $LN43@helper1
$LN42@helper1:
  004a4	8b 45 e8	 mov	 eax, DWORD PTR _rep_max_index$32959[ebp]
  004a7	8b 4c 85 d4	 mov	 ecx, DWORD PTR _rep_lens$32958[ebp+eax*4]
  004ab	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], ecx
$LN43@helper1:
  004b1	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv246[ebp]
  004b7	89 55 b8	 mov	 DWORD PTR _len_end$32980[ebp], edx

; 394  : 
; 395  : 	if (len_end < 2) {

  004ba	83 7d b8 02	 cmp	 DWORD PTR _len_end$32980[ebp], 2
  004be	73 1f		 jae	 SHORT $LN24@helper1

; 396  : 		*back_res = coder->opts[1].back_prev;

  004c0	8b 45 10	 mov	 eax, DWORD PTR _back_res$[ebp]
  004c3	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  004c6	8b 91 38 0e 01
	00		 mov	 edx, DWORD PTR [ecx+69176]
  004cc	89 10		 mov	 DWORD PTR [eax], edx

; 397  : 		*len_res = 1;

  004ce	8b 45 14	 mov	 eax, DWORD PTR _len_res$[ebp]
  004d1	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 398  : 		return UINT32_MAX;

  004d7	83 c8 ff	 or	 eax, -1
  004da	e9 a4 02 00 00	 jmp	 $LN38@helper1
$LN24@helper1:

; 399  : 	}
; 400  : 
; 401  : 	coder->opts[1].pos_prev = 0;

  004df	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  004e2	c7 81 34 0e 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+69172], 0

; 402  : 
; 403  : 	for (i = 0; i < REPS; ++i)

  004ec	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$32960[ebp], 0
  004f3	eb 09		 jmp	 SHORT $LN23@helper1
$LN22@helper1:
  004f5	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  004f8	83 c2 01	 add	 edx, 1
  004fb	89 55 ec	 mov	 DWORD PTR _i$32960[ebp], edx
$LN23@helper1:
  004fe	83 7d ec 04	 cmp	 DWORD PTR _i$32960[ebp], 4
  00502	73 1c		 jae	 SHORT $LN21@helper1

; 404  : 		coder->opts[0].backs[i] = coder->reps[i];

  00504	8b 45 ec	 mov	 eax, DWORD PTR _i$32960[ebp]
  00507	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0050a	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  0050d	8b 75 08	 mov	 esi, DWORD PTR _coder$[ebp]
  00510	8b 94 96 f4 01
	00 00		 mov	 edx, DWORD PTR [esi+edx*4+500]
  00517	89 94 81 10 0e
	01 00		 mov	 DWORD PTR [ecx+eax*4+69136], edx
  0051e	eb d5		 jmp	 SHORT $LN22@helper1
$LN21@helper1:

; 405  : 
; 406  :   {
; 407  : 	uint32_t len = len_end;

  00520	8b 45 b8	 mov	 eax, DWORD PTR _len_end$32980[ebp]
  00523	89 45 b4	 mov	 DWORD PTR _len$32985[ebp], eax
$LN20@helper1:

; 408  : 	do {
; 409  : 		coder->opts[len].price = RC_INFINITY_PRICE;

  00526	8b 4d b4	 mov	 ecx, DWORD PTR _len$32985[ebp]
  00529	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0052c	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0052f	c7 84 0a 04 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [edx+ecx+69124], 1073741824 ; 40000000H

; 410  : 	} while (--len >= 2);

  0053a	8b 45 b4	 mov	 eax, DWORD PTR _len$32985[ebp]
  0053d	83 e8 01	 sub	 eax, 1
  00540	89 45 b4	 mov	 DWORD PTR _len$32985[ebp], eax
  00543	83 7d b4 02	 cmp	 DWORD PTR _len$32985[ebp], 2
  00547	73 dd		 jae	 SHORT $LN20@helper1

; 411  : 
; 412  : 
; 413  : 	for (i = 0; i < REPS; ++i) {

  00549	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$32960[ebp], 0
  00550	eb 09		 jmp	 SHORT $LN17@helper1
$LN16@helper1:
  00552	8b 4d ec	 mov	 ecx, DWORD PTR _i$32960[ebp]
  00555	83 c1 01	 add	 ecx, 1
  00558	89 4d ec	 mov	 DWORD PTR _i$32960[ebp], ecx
$LN17@helper1:
  0055b	83 7d ec 04	 cmp	 DWORD PTR _i$32960[ebp], 4
  0055f	0f 83 da 00 00
	00		 jae	 $LN103@helper1

; 414  : 		uint32_t rep_len = rep_lens[i];

  00565	8b 55 ec	 mov	 edx, DWORD PTR _i$32960[ebp]
  00568	8b 44 95 d4	 mov	 eax, DWORD PTR _rep_lens$32958[ebp+edx*4]
  0056c	89 45 b0	 mov	 DWORD PTR _rep_len$32992[ebp], eax

; 415  : 		if (rep_len < 2)

  0056f	83 7d b0 02	 cmp	 DWORD PTR _rep_len$32992[ebp], 2
  00573	73 02		 jae	 SHORT $LN14@helper1

; 416  : 			continue;

  00575	eb db		 jmp	 SHORT $LN16@helper1
$LN14@helper1:

; 417  : 
; 418  :       {
; 419  : 		const uint32_t price = rep_match_price + get_pure_rep_price(
; 420  : 				coder, i, coder->state, pos_state);

  00577	8b 4d c8	 mov	 ecx, DWORD PTR _pos_state$32974[ebp]
  0057a	51		 push	 ecx
  0057b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0057e	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  00584	50		 push	 eax
  00585	8b 4d ec	 mov	 ecx, DWORD PTR _i$32960[ebp]
  00588	51		 push	 ecx
  00589	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0058c	52		 push	 edx
  0058d	e8 00 00 00 00	 call	 _get_pure_rep_price
  00592	83 c4 10	 add	 esp, 16			; 00000010H
  00595	03 45 c0	 add	 eax, DWORD PTR _rep_match_price$32976[ebp]
  00598	89 45 ac	 mov	 DWORD PTR _price$32994[ebp], eax
$LN13@helper1:

; 421  : 
; 422  : 		do {
; 423  : 			const uint32_t cur_and_len_price = price
; 424  : 					+ get_len_price(
; 425  : 						&coder->rep_len_encoder,
; 426  : 						rep_len, pos_state);

  0059b	8b 45 c8	 mov	 eax, DWORD PTR _pos_state$32974[ebp]
  0059e	69 c0 40 04 00
	00		 imul	 eax, 1088		; 00000440H
  005a4	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  005a7	8d 94 01 5c bd
	00 00		 lea	 edx, DWORD PTR [ecx+eax+48476]
  005ae	8b 45 b0	 mov	 eax, DWORD PTR _rep_len$32992[ebp]
  005b1	8b 4c 82 f8	 mov	 ecx, DWORD PTR [edx+eax*4-8]
  005b5	89 8d 64 ff ff
	ff		 mov	 DWORD PTR $T79340[ebp], ecx
  005bb	8b 55 ac	 mov	 edx, DWORD PTR _price$32994[ebp]
  005be	03 95 64 ff ff
	ff		 add	 edx, DWORD PTR $T79340[ebp]
  005c4	89 55 a8	 mov	 DWORD PTR _cur_and_len_price$32998[ebp], edx

; 427  : 
; 428  : 			if (cur_and_len_price < coder->opts[rep_len].price) {

  005c7	8b 45 b0	 mov	 eax, DWORD PTR _rep_len$32992[ebp]
  005ca	6b c0 2c	 imul	 eax, 44			; 0000002cH
  005cd	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  005d0	8b 55 a8	 mov	 edx, DWORD PTR _cur_and_len_price$32998[ebp]
  005d3	3b 94 01 04 0e
	01 00		 cmp	 edx, DWORD PTR [ecx+eax+69124]
  005da	73 4b		 jae	 SHORT $LN12@helper1

; 429  : 				coder->opts[rep_len].price = cur_and_len_price;

  005dc	8b 45 b0	 mov	 eax, DWORD PTR _rep_len$32992[ebp]
  005df	6b c0 2c	 imul	 eax, 44			; 0000002cH
  005e2	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  005e5	8b 55 a8	 mov	 edx, DWORD PTR _cur_and_len_price$32998[ebp]
  005e8	89 94 01 04 0e
	01 00		 mov	 DWORD PTR [ecx+eax+69124], edx

; 430  : 				coder->opts[rep_len].pos_prev = 0;

  005ef	8b 45 b0	 mov	 eax, DWORD PTR _rep_len$32992[ebp]
  005f2	6b c0 2c	 imul	 eax, 44			; 0000002cH
  005f5	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  005f8	c7 84 01 08 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+69128], 0

; 431  : 				coder->opts[rep_len].back_prev = i;

  00603	8b 55 b0	 mov	 edx, DWORD PTR _rep_len$32992[ebp]
  00606	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00609	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0060c	8b 4d ec	 mov	 ecx, DWORD PTR _i$32960[ebp]
  0060f	89 8c 10 0c 0e
	01 00		 mov	 DWORD PTR [eax+edx+69132], ecx

; 432  : 				coder->opts[rep_len].prev_1_is_literal = false;

  00616	8b 55 b0	 mov	 edx, DWORD PTR _rep_len$32992[ebp]
  00619	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0061c	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0061f	c6 84 10 f8 0d
	01 00 00	 mov	 BYTE PTR [eax+edx+69112], 0
$LN12@helper1:

; 433  : 			}
; 434  : 		} while (--rep_len >= 2);

  00627	8b 4d b0	 mov	 ecx, DWORD PTR _rep_len$32992[ebp]
  0062a	83 e9 01	 sub	 ecx, 1
  0062d	89 4d b0	 mov	 DWORD PTR _rep_len$32992[ebp], ecx
  00630	83 7d b0 02	 cmp	 DWORD PTR _rep_len$32992[ebp], 2
  00634	0f 83 61 ff ff
	ff		 jae	 $LN13@helper1

; 435  : 	  }
; 436  : 	}

  0063a	e9 13 ff ff ff	 jmp	 $LN16@helper1

; 437  :   }
; 438  : 
; 439  :   {
; 440  : 	const uint32_t normal_match_price = match_price
; 441  : 			+ rc_bit_0_price(coder->is_rep[coder->state]);

$LN103@helper1:
  0063f	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00642	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  00648	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0064b	0f b7 94 41 2c
	6c 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+27692]
  00653	c1 fa 04	 sar	 edx, 4
  00656	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _lzma_rc_prices[edx]
  0065d	03 45 c4	 add	 eax, DWORD PTR _match_price$32975[ebp]
  00660	89 45 a0	 mov	 DWORD PTR _normal_match_price$33000[ebp], eax

; 442  : 	uint32_t len;
; 443  : 
; 444  : 	len = rep_lens[0] >= 2 ? rep_lens[0] + 1 : 2;

  00663	83 7d d4 02	 cmp	 DWORD PTR _rep_lens$32958[ebp], 2
  00667	72 0e		 jb	 SHORT $LN44@helper1
  00669	8b 4d d4	 mov	 ecx, DWORD PTR _rep_lens$32958[ebp]
  0066c	83 c1 01	 add	 ecx, 1
  0066f	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv320[ebp], ecx
  00675	eb 0a		 jmp	 SHORT $LN45@helper1
$LN44@helper1:
  00677	c7 85 44 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv320[ebp], 2
$LN45@helper1:
  00681	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv320[ebp]
  00687	89 55 a4	 mov	 DWORD PTR _len$33001[ebp], edx

; 445  : 	if (len <= len_main) {

  0068a	8b 45 a4	 mov	 eax, DWORD PTR _len$33001[ebp]
  0068d	3b 45 f8	 cmp	 eax, DWORD PTR _len_main$[ebp]
  00690	0f 87 ea 00 00
	00		 ja	 $LN9@helper1

; 446  : 		uint32_t i = 0;

  00696	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _i$33003[ebp], 0
$LN8@helper1:

; 447  : 		while (len > coder->matches[i].len)

  0069d	8b 4d 9c	 mov	 ecx, DWORD PTR _i$33003[ebp]
  006a0	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  006a3	8b 45 a4	 mov	 eax, DWORD PTR _len$33001[ebp]
  006a6	3b 84 ca 04 02
	00 00		 cmp	 eax, DWORD PTR [edx+ecx*8+516]
  006ad	76 0b		 jbe	 SHORT $LN7@helper1

; 448  : 			++i;

  006af	8b 4d 9c	 mov	 ecx, DWORD PTR _i$33003[ebp]
  006b2	83 c1 01	 add	 ecx, 1
  006b5	89 4d 9c	 mov	 DWORD PTR _i$33003[ebp], ecx
  006b8	eb e3		 jmp	 SHORT $LN8@helper1
$LN7@helper1:

; 449  : 
; 450  : 		for(; ; ++len) {

  006ba	eb 09		 jmp	 SHORT $LN6@helper1
$LN5@helper1:
  006bc	8b 55 a4	 mov	 edx, DWORD PTR _len$33001[ebp]
  006bf	83 c2 01	 add	 edx, 1
  006c2	89 55 a4	 mov	 DWORD PTR _len$33001[ebp], edx
$LN6@helper1:

; 451  : 			const uint32_t dist = coder->matches[i].dist;

  006c5	8b 45 9c	 mov	 eax, DWORD PTR _i$33003[ebp]
  006c8	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  006cb	8b 94 c1 08 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*8+520]
  006d2	89 55 94	 mov	 DWORD PTR _dist$33010[ebp], edx

; 452  : 			const uint32_t cur_and_len_price = normal_match_price
; 453  : 					+ get_dist_len_price(coder,
; 454  : 						dist, len, pos_state);

  006d5	8b 45 c8	 mov	 eax, DWORD PTR _pos_state$32974[ebp]
  006d8	50		 push	 eax
  006d9	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  006dc	51		 push	 ecx
  006dd	8b 55 94	 mov	 edx, DWORD PTR _dist$33010[ebp]
  006e0	52		 push	 edx
  006e1	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  006e4	50		 push	 eax
  006e5	e8 00 00 00 00	 call	 _get_dist_len_price
  006ea	83 c4 10	 add	 esp, 16			; 00000010H
  006ed	03 45 a0	 add	 eax, DWORD PTR _normal_match_price$33000[ebp]
  006f0	89 45 98	 mov	 DWORD PTR _cur_and_len_price$33011[ebp], eax

; 455  : 
; 456  : 			if (cur_and_len_price < coder->opts[len].price) {

  006f3	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  006f6	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  006f9	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  006fc	8b 45 98	 mov	 eax, DWORD PTR _cur_and_len_price$33011[ebp]
  006ff	3b 84 0a 04 0e
	01 00		 cmp	 eax, DWORD PTR [edx+ecx+69124]
  00706	73 4e		 jae	 SHORT $LN3@helper1

; 457  : 				coder->opts[len].price = cur_and_len_price;

  00708	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  0070b	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0070e	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00711	8b 45 98	 mov	 eax, DWORD PTR _cur_and_len_price$33011[ebp]
  00714	89 84 0a 04 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69124], eax

; 458  : 				coder->opts[len].pos_prev = 0;

  0071b	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  0071e	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00721	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00724	c7 84 0a 08 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+69128], 0

; 459  : 				coder->opts[len].back_prev = dist + REPS;

  0072f	8b 45 94	 mov	 eax, DWORD PTR _dist$33010[ebp]
  00732	83 c0 04	 add	 eax, 4
  00735	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  00738	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0073b	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0073e	89 84 0a 0c 0e
	01 00		 mov	 DWORD PTR [edx+ecx+69132], eax

; 460  : 				coder->opts[len].prev_1_is_literal = false;

  00745	8b 45 a4	 mov	 eax, DWORD PTR _len$33001[ebp]
  00748	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0074b	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0074e	c6 84 01 f8 0d
	01 00 00	 mov	 BYTE PTR [ecx+eax+69112], 0
$LN3@helper1:

; 461  : 			}
; 462  : 
; 463  : 			if (len == coder->matches[i].len)

  00756	8b 55 9c	 mov	 edx, DWORD PTR _i$33003[ebp]
  00759	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0075c	8b 4d a4	 mov	 ecx, DWORD PTR _len$33001[ebp]
  0075f	3b 8c d0 04 02
	00 00		 cmp	 ecx, DWORD PTR [eax+edx*8+516]
  00766	75 13		 jne	 SHORT $LN2@helper1

; 464  : 				if (++i == matches_count)

  00768	8b 55 9c	 mov	 edx, DWORD PTR _i$33003[ebp]
  0076b	83 c2 01	 add	 edx, 1
  0076e	89 55 9c	 mov	 DWORD PTR _i$33003[ebp], edx
  00771	8b 45 9c	 mov	 eax, DWORD PTR _i$33003[ebp]
  00774	3b 45 fc	 cmp	 eax, DWORD PTR _matches_count$[ebp]
  00777	75 02		 jne	 SHORT $LN2@helper1

; 465  : 					break;

  00779	eb 05		 jmp	 SHORT $LN9@helper1
$LN2@helper1:

; 466  : 		}

  0077b	e9 3c ff ff ff	 jmp	 $LN5@helper1
$LN9@helper1:

; 467  : 	}
; 468  :   }
; 469  : 
; 470  : 	return len_end;

  00780	8b 45 b8	 mov	 eax, DWORD PTR _len_end$32980[ebp]
$LN38@helper1:

; 471  :   }}}}}}
; 472  : }

  00783	5e		 pop	 esi
  00784	8b e5		 mov	 esp, ebp
  00786	5d		 pop	 ebp
  00787	c3		 ret	 0
_helper1 ENDP
PUBLIC	_lzma_lzma_optimum_normal
; Function compile flags: /Odtp
;	COMDAT _lzma_lzma_optimum_normal
_TEXT	SEGMENT
tv158 = -32						; size = 4
$T79480 = -28						; size = 4
_cur$33191 = -24					; size = 4
_reps$33190 = -20					; size = 16
_len_end$33188 = -4					; size = 4
_coder$ = 8						; size = 4
_mf$ = 12						; size = 4
_back_res$ = 16						; size = 4
_len_res$ = 20						; size = 4
_position$ = 24						; size = 4
_lzma_lzma_optimum_normal PROC				; COMDAT

; 861  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 862  : 	// If we have symbols pending, return the next pending symbol.
; 863  : 	if (coder->opts_end_index != coder->opts_current_index) {

  00006	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000c	8b 90 ec 0d 01
	00		 mov	 edx, DWORD PTR [eax+69100]
  00012	3b 91 f0 0d 01
	00		 cmp	 edx, DWORD PTR [ecx+69104]
  00018	74 63		 je	 SHORT $LN9@lzma_lzma_@10

; 864  : 		assert(mf->read_ahead > 0);
; 865  : 		*len_res = coder->opts[coder->opts_current_index].pos_prev
; 866  : 				- coder->opts_current_index;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0001d	8b 88 f0 0d 01
	00		 mov	 ecx, DWORD PTR [eax+69104]
  00023	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00026	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00029	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0002c	8b 8c 0a 08 0e
	01 00		 mov	 ecx, DWORD PTR [edx+ecx+69128]
  00033	2b 88 f0 0d 01
	00		 sub	 ecx, DWORD PTR [eax+69104]
  00039	8b 55 14	 mov	 edx, DWORD PTR _len_res$[ebp]
  0003c	89 0a		 mov	 DWORD PTR [edx], ecx

; 867  : 		*back_res = coder->opts[coder->opts_current_index].back_prev;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00041	8b 88 f0 0d 01
	00		 mov	 ecx, DWORD PTR [eax+69104]
  00047	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0004a	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  0004d	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00050	8b 8c 08 0c 0e
	01 00		 mov	 ecx, DWORD PTR [eax+ecx+69132]
  00057	89 0a		 mov	 DWORD PTR [edx], ecx

; 868  : 		coder->opts_current_index = coder->opts[
; 869  : 				coder->opts_current_index].pos_prev;

  00059	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0005c	8b 82 f0 0d 01
	00		 mov	 eax, DWORD PTR [edx+69104]
  00062	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00068	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  0006b	8b 84 02 08 0e
	01 00		 mov	 eax, DWORD PTR [edx+eax+69128]
  00072	89 81 f0 0d 01
	00		 mov	 DWORD PTR [ecx+69104], eax

; 870  : 		return;

  00078	e9 73 01 00 00	 jmp	 $LN10@lzma_lzma_@10
$LN9@lzma_lzma_@10:

; 871  : 	}
; 872  : 
; 873  : 	// Update the price tables. In LZMA SDK <= 4.60 (and possibly later)
; 874  : 	// this was done in both initialization function and in the main loop.
; 875  : 	// In liblzma they were moved into this single place.
; 876  : 	if (mf->read_ahead == 0) {

  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00080	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00084	75 33		 jne	 SHORT $LN8@lzma_lzma_@10

; 877  : 		if (coder->match_price_count >= (1 << 7))

  00086	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00089	81 ba a4 0d 01
	00 80 00 00 00	 cmp	 DWORD PTR [edx+69028], 128 ; 00000080H
  00093	72 0c		 jb	 SHORT $LN7@lzma_lzma_@10

; 878  : 			fill_dist_prices(coder);

  00095	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _fill_dist_prices
  0009e	83 c4 04	 add	 esp, 4
$LN7@lzma_lzma_@10:

; 879  : 
; 880  : 		if (coder->align_price_count >= ALIGN_SIZE)

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000a4	83 b9 e8 0d 01
	00 10		 cmp	 DWORD PTR [ecx+69096], 16 ; 00000010H
  000ab	72 0c		 jb	 SHORT $LN8@lzma_lzma_@10

; 881  : 			fill_align_prices(coder);

  000ad	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 _fill_align_prices
  000b6	83 c4 04	 add	 esp, 4
$LN8@lzma_lzma_@10:

; 882  : 	}
; 883  : 
; 884  : 	// TODO: This needs quite a bit of cleaning still. But splitting
; 885  : 	// the original function into two pieces makes it at least a little
; 886  : 	// more readable, since those two parts don't share many variables.
; 887  : 
; 888  :   { uint32_t len_end = helper1(coder, mf, back_res, len_res, position);

  000b9	8b 45 18	 mov	 eax, DWORD PTR _position$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d 14	 mov	 ecx, DWORD PTR _len_res$[ebp]
  000c0	51		 push	 ecx
  000c1	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  000c4	52		 push	 edx
  000c5	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  000c8	50		 push	 eax
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _helper1
  000d2	83 c4 14	 add	 esp, 20			; 00000014H
  000d5	89 45 fc	 mov	 DWORD PTR _len_end$33188[ebp], eax

; 889  : 	if (len_end == UINT32_MAX)

  000d8	83 7d fc ff	 cmp	 DWORD PTR _len_end$33188[ebp], -1
  000dc	75 05		 jne	 SHORT $LN5@lzma_lzma_@10

; 890  : 		return;

  000de	e9 0d 01 00 00	 jmp	 $LN10@lzma_lzma_@10
$LN5@lzma_lzma_@10:

; 891  : 
; 892  :   { uint32_t reps[REPS];
; 893  : 	memcpy(reps, coder->reps, sizeof(reps));

  000e3	6a 10		 push	 16			; 00000010H
  000e5	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  000e8	81 c2 f4 01 00
	00		 add	 edx, 500		; 000001f4H
  000ee	52		 push	 edx
  000ef	8d 45 ec	 lea	 eax, DWORD PTR _reps$33190[ebp]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _memcpy
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 894  : 
; 895  :   { uint32_t cur;
; 896  : 	for (cur = 1; cur < len_end; ++cur) {

  000fb	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _cur$33191[ebp], 1
  00102	eb 09		 jmp	 SHORT $LN4@lzma_lzma_@10
$LN3@lzma_lzma_@10:
  00104	8b 4d e8	 mov	 ecx, DWORD PTR _cur$33191[ebp]
  00107	83 c1 01	 add	 ecx, 1
  0010a	89 4d e8	 mov	 DWORD PTR _cur$33191[ebp], ecx
$LN4@lzma_lzma_@10:
  0010d	8b 55 e8	 mov	 edx, DWORD PTR _cur$33191[ebp]
  00110	3b 55 fc	 cmp	 edx, DWORD PTR _len_end$33188[ebp]
  00113	0f 83 bf 00 00
	00		 jae	 $LN2@lzma_lzma_@10

; 897  : 		assert(cur < OPTS);
; 898  : 
; 899  : 		coder->longest_match_length = mf_find(
; 900  : 				mf, &coder->matches_count, coder->matches);

  00119	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  0011c	05 04 02 00 00	 add	 eax, 516		; 00000204H
  00121	50		 push	 eax
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  00125	81 c1 94 0a 00
	00		 add	 ecx, 2708		; 00000a94H
  0012b	51		 push	 ecx
  0012c	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _lzma_mf_find
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  0013b	89 81 98 0a 00
	00		 mov	 DWORD PTR [ecx+2712], eax

; 901  : 
; 902  : 		if (coder->longest_match_length >= mf->nice_len)

  00141	8b 55 08	 mov	 edx, DWORD PTR _coder$[ebp]
  00144	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00147	8b 8a 98 0a 00
	00		 mov	 ecx, DWORD PTR [edx+2712]
  0014d	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  00150	72 05		 jb	 SHORT $LN14@lzma_lzma_@10

; 903  : 			break;

  00152	e9 81 00 00 00	 jmp	 $LN2@lzma_lzma_@10

; 904  : 
; 905  : 		len_end = helper2(coder, reps, mf_ptr(mf) - 1, len_end,
; 906  : 				position + cur, cur, mf->nice_len,
; 907  : 				my_min(mf_avail(mf) + 1, OPTS - 1 - cur));

$LN14@lzma_lzma_@10:
  00157	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  0015a	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  0015d	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00160	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  00163	83 c1 01	 add	 ecx, 1
  00166	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0016b	2b 55 e8	 sub	 edx, DWORD PTR _cur$33191[ebp]
  0016e	3b ca		 cmp	 ecx, edx
  00170	73 14		 jae	 SHORT $LN12@lzma_lzma_@10
  00172	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00175	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00178	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0017b	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  0017e	83 c2 01	 add	 edx, 1
  00181	89 55 e0	 mov	 DWORD PTR tv158[ebp], edx
  00184	eb 0b		 jmp	 SHORT $LN13@lzma_lzma_@10
$LN12@lzma_lzma_@10:
  00186	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  0018b	2b 45 e8	 sub	 eax, DWORD PTR _cur$33191[ebp]
  0018e	89 45 e0	 mov	 DWORD PTR tv158[ebp], eax
$LN13@lzma_lzma_@10:
  00191	8b 4d 0c	 mov	 ecx, DWORD PTR _mf$[ebp]
  00194	8b 11		 mov	 edx, DWORD PTR [ecx]
  00196	8b 45 0c	 mov	 eax, DWORD PTR _mf$[ebp]
  00199	03 50 14	 add	 edx, DWORD PTR [eax+20]
  0019c	89 55 e4	 mov	 DWORD PTR $T79480[ebp], edx
  0019f	8b 4d e0	 mov	 ecx, DWORD PTR tv158[ebp]
  001a2	51		 push	 ecx
  001a3	8b 55 0c	 mov	 edx, DWORD PTR _mf$[ebp]
  001a6	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  001a9	50		 push	 eax
  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _cur$33191[ebp]
  001ad	51		 push	 ecx
  001ae	8b 55 18	 mov	 edx, DWORD PTR _position$[ebp]
  001b1	03 55 e8	 add	 edx, DWORD PTR _cur$33191[ebp]
  001b4	52		 push	 edx
  001b5	8b 45 fc	 mov	 eax, DWORD PTR _len_end$33188[ebp]
  001b8	50		 push	 eax
  001b9	8b 4d e4	 mov	 ecx, DWORD PTR $T79480[ebp]
  001bc	83 e9 01	 sub	 ecx, 1
  001bf	51		 push	 ecx
  001c0	8d 55 ec	 lea	 edx, DWORD PTR _reps$33190[ebp]
  001c3	52		 push	 edx
  001c4	8b 45 08	 mov	 eax, DWORD PTR _coder$[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 _helper2
  001cd	83 c4 20	 add	 esp, 32			; 00000020H
  001d0	89 45 fc	 mov	 DWORD PTR _len_end$33188[ebp], eax

; 908  : 	}

  001d3	e9 2c ff ff ff	 jmp	 $LN3@lzma_lzma_@10
$LN2@lzma_lzma_@10:

; 909  : 
; 910  : 	backward(coder, len_res, back_res, cur);

  001d8	8b 4d e8	 mov	 ecx, DWORD PTR _cur$33191[ebp]
  001db	51		 push	 ecx
  001dc	8b 55 10	 mov	 edx, DWORD PTR _back_res$[ebp]
  001df	52		 push	 edx
  001e0	8b 45 14	 mov	 eax, DWORD PTR _len_res$[ebp]
  001e3	50		 push	 eax
  001e4	8b 4d 08	 mov	 ecx, DWORD PTR _coder$[ebp]
  001e7	51		 push	 ecx
  001e8	e8 00 00 00 00	 call	 _backward
  001ed	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@lzma_lzma_@10:

; 911  :   }}}
; 912  : 	return;
; 913  : }

  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
_lzma_lzma_optimum_normal ENDP
END
