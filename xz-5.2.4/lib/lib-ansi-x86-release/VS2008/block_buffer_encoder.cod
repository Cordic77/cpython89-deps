; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_buffer_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_buffer_encoder.c
;	COMDAT _lzma2_bound
_TEXT	SEGMENT
tv147 = -16						; size = 8
_overhead$32312 = -8					; size = 8
_uncompressed_size$ = 8					; size = 8
_lzma2_bound PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 35   : 	// Prevent integer overflow in overhead calculation.
; 36   : 	if (uncompressed_size > COMPRESSED_SIZE_MAX)

  00006	81 7d 0c ff ff
	ff 7f		 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 2147483647 ; 7fffffffH
  0000d	72 11		 jb	 SHORT $LN2@lzma2_boun
  0000f	77 09		 ja	 SHORT $LN5@lzma2_boun
  00011	81 7d 08 bc fb
	ff ff		 cmp	 DWORD PTR _uncompressed_size$[ebp], -1092 ; fffffbbcH
  00018	76 06		 jbe	 SHORT $LN2@lzma2_boun
$LN5@lzma2_boun:

; 37   : 		return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	33 d2		 xor	 edx, edx
  0001e	eb 73		 jmp	 SHORT $LN3@lzma2_boun
$LN2@lzma2_boun:

; 38   : 
; 39   : 	// Calculate the exact overhead of the LZMA2 headers: Round
; 40   : 	// uncompressed_size up to the next multiple of LZMA2_CHUNK_MAX,
; 41   : 	// multiply by the size of per-chunk header, and add one byte for
; 42   : 	// the end marker.
; 43   :   {
; 44   : 	const uint64_t overhead = ((uncompressed_size + LZMA2_CHUNK_MAX - 1)
; 45   : 				/ LZMA2_CHUNK_MAX)
; 46   : 			* LZMA2_HEADER_UNCOMPRESSED + 1;

  00020	8b 45 08	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  00023	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  0002b	83 d1 00	 adc	 ecx, 0
  0002e	83 e8 01	 sub	 eax, 1
  00031	83 d9 00	 sbb	 ecx, 0
  00034	6a 00		 push	 0
  00036	68 00 00 01 00	 push	 65536			; 00010000H
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __aulldiv
  00042	6a 00		 push	 0
  00044	6a 03		 push	 3
  00046	52		 push	 edx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __allmul
  0004d	83 c0 01	 add	 eax, 1
  00050	83 d2 00	 adc	 edx, 0
  00053	89 45 f8	 mov	 DWORD PTR _overhead$32312[ebp], eax
  00056	89 55 fc	 mov	 DWORD PTR _overhead$32312[ebp+4], edx

; 47   : 
; 48   : 	// Catch the possible integer overflow.
; 49   : 	if (COMPRESSED_SIZE_MAX - overhead < uncompressed_size)

  00059	ba bc fb ff ff	 mov	 edx, -1092		; fffffbbcH
  0005e	2b 55 f8	 sub	 edx, DWORD PTR _overhead$32312[ebp]
  00061	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00066	1b 45 fc	 sbb	 eax, DWORD PTR _overhead$32312[ebp+4]
  00069	89 55 f0	 mov	 DWORD PTR tv147[ebp], edx
  0006c	89 45 f4	 mov	 DWORD PTR tv147[ebp+4], eax
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR tv147[ebp+4]
  00072	3b 4d 0c	 cmp	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  00075	77 10		 ja	 SHORT $LN1@lzma2_boun
  00077	72 08		 jb	 SHORT $LN6@lzma2_boun
  00079	8b 55 f0	 mov	 edx, DWORD PTR tv147[ebp]
  0007c	3b 55 08	 cmp	 edx, DWORD PTR _uncompressed_size$[ebp]
  0007f	73 06		 jae	 SHORT $LN1@lzma2_boun
$LN6@lzma2_boun:

; 50   : 		return 0;

  00081	33 c0		 xor	 eax, eax
  00083	33 d2		 xor	 edx, edx
  00085	eb 0c		 jmp	 SHORT $LN3@lzma2_boun
$LN1@lzma2_boun:

; 51   : 
; 52   : 	return uncompressed_size + overhead;

  00087	8b 45 08	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  0008a	03 45 f8	 add	 eax, DWORD PTR _overhead$32312[ebp]
  0008d	8b 55 0c	 mov	 edx, DWORD PTR _uncompressed_size$[ebp+4]
  00090	13 55 fc	 adc	 edx, DWORD PTR _overhead$32312[ebp+4]
$LN3@lzma2_boun:

; 53   :   }
; 54   : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_lzma2_bound ENDP
PUBLIC	_lzma_block_buffer_bound64
; Function compile flags: /Odtp
;	COMDAT _lzma_block_buffer_bound64
_TEXT	SEGMENT
_lzma2_size$ = -8					; size = 8
_uncompressed_size$ = 8					; size = 8
_lzma_block_buffer_bound64 PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 60   : 	// If the data doesn't compress, we always use uncompressed
; 61   : 	// LZMA2 chunks.
; 62   : 	uint64_t lzma2_size = lzma2_bound(uncompressed_size);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _uncompressed_size$[ebp+4]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _lzma2_bound
  00013	83 c4 08	 add	 esp, 8
  00016	89 45 f8	 mov	 DWORD PTR _lzma2_size$[ebp], eax
  00019	89 55 fc	 mov	 DWORD PTR _lzma2_size$[ebp+4], edx

; 63   : 	if (lzma2_size == 0)

  0001c	8b 55 f8	 mov	 edx, DWORD PTR _lzma2_size$[ebp]
  0001f	0b 55 fc	 or	 edx, DWORD PTR _lzma2_size$[ebp+4]
  00022	75 06		 jne	 SHORT $LN1@lzma_block

; 64   : 		return 0;

  00024	33 c0		 xor	 eax, eax
  00026	33 d2		 xor	 edx, edx
  00028	eb 21		 jmp	 SHORT $LN2@lzma_block
$LN1@lzma_block:

; 65   : 
; 66   : 	// Take Block Padding into account.
; 67   : 	lzma2_size = (lzma2_size + 3) & ~UINT64_C(3);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _lzma2_size$[ebp]
  0002d	83 c0 03	 add	 eax, 3
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _lzma2_size$[ebp+4]
  00033	83 d1 00	 adc	 ecx, 0
  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	89 45 f8	 mov	 DWORD PTR _lzma2_size$[ebp], eax
  0003c	89 4d fc	 mov	 DWORD PTR _lzma2_size$[ebp+4], ecx

; 68   : 
; 69   : 	// No risk of integer overflow because lzma2_bound() already takes
; 70   : 	// into account the size of the headers in the Block.
; 71   : 	return HEADERS_BOUND + lzma2_size;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _lzma2_size$[ebp]
  00042	83 c0 5c	 add	 eax, 92			; 0000005cH
  00045	8b 55 fc	 mov	 edx, DWORD PTR _lzma2_size$[ebp+4]
  00048	83 d2 00	 adc	 edx, 0
$LN2@lzma_block:

; 72   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_lzma_block_buffer_bound64 ENDP
; Function compile flags: /Odtp
;	COMDAT _block_encode_uncompressed
_TEXT	SEGMENT
tv130 = -164						; size = 4
tv189 = -160						; size = 8
tv186 = -152						; size = 8
_copy_size$32351 = -144					; size = 4
_control$32347 = -137					; size = 1
_in_pos$32346 = -136					; size = 4
_filters_orig$32341 = -132				; size = 4
_filters$32340 = -128					; size = 32
_lzma2$ = -96						; size = 96
_block$ = 8						; size = 4
_in$ = 12						; size = 4
_in_size$ = 16						; size = 4
_out$ = 20						; size = 4
_out_pos$ = 24						; size = 4
_out_size$ = 28						; size = 4
_block_encode_uncompressed PROC				; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 94   : 	// Use LZMA2 uncompressed chunks. We wouldn't need a dictionary at
; 95   : 	// all, but LZMA2 always requires a dictionary, so use the minimum
; 96   : 	// value to minimize memory usage of the decoder.
; 97   : 	/*
; 98   : 	lzma_options_lzma lzma2 = {
; 99   : 		.dict_size = LZMA_DICT_SIZE_MIN,
; 100  : 	};
; 101  : 	*/
; 102  : 	lzma_options_lzma lzma2;
; 103  : 	memset (&lzma2, 0, sizeof(lzma2));

  0000b	6a 60		 push	 96			; 00000060H
  0000d	6a 00		 push	 0
  0000f	8d 45 a0	 lea	 eax, DWORD PTR _lzma2$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memset
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  : 	lzma2.dict_size = LZMA_DICT_SIZE_MIN;

  0001b	c7 45 a0 00 10
	00 00		 mov	 DWORD PTR _lzma2$[ebp], 4096 ; 00001000H

; 105  : 
; 106  :   {
; 107  : 	lzma_filter filters[2];
; 108  : 	filters[0].id = LZMA_FILTER_LZMA2;

  00022	c7 45 80 21 00
	00 00		 mov	 DWORD PTR _filters$32340[ebp], 33 ; 00000021H
  00029	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _filters$32340[ebp+4], 0

; 109  : 	filters[0].options = &lzma2;

  00030	8d 4d a0	 lea	 ecx, DWORD PTR _lzma2$[ebp]
  00033	89 4d 88	 mov	 DWORD PTR _filters$32340[ebp+8], ecx

; 110  : 	filters[1].id = LZMA_VLI_UNKNOWN;

  00036	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _filters$32340[ebp+16], -1
  0003d	c7 45 94 ff ff
	ff ff		 mov	 DWORD PTR _filters$32340[ebp+20], -1

; 111  : 
; 112  : 	// Set the above filter options to *block temporarily so that we can
; 113  : 	// encode the Block Header.
; 114  :   {
; 115  : 	lzma_filter *filters_orig = block->filters;

  00044	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00047	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0004a	89 85 7c ff ff
	ff		 mov	 DWORD PTR _filters_orig$32341[ebp], eax

; 116  : 	block->filters = filters;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00053	8d 55 80	 lea	 edx, DWORD PTR _filters$32340[ebp]
  00056	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 117  : 
; 118  : 	if (lzma_block_header_size(block) != LZMA_OK) {

  00059	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _lzma_block_header_size
  00062	83 c4 04	 add	 esp, 4
  00065	85 c0		 test	 eax, eax
  00067	74 16		 je	 SHORT $LN5@block_enco@2

; 119  : 		block->filters = filters_orig;

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  0006c	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _filters_orig$32341[ebp]
  00072	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 120  : 		return LZMA_PROG_ERROR;

  00075	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0007a	e9 dd 01 00 00	 jmp	 $LN6@block_enco@2
$LN5@block_enco@2:

; 121  : 	}
; 122  : 
; 123  : 	// Check that there's enough output space. The caller has already
; 124  : 	// set block->compressed_size to what lzma2_bound() has returned,
; 125  : 	// so we can reuse that value. We know that compressed_size is a
; 126  : 	// known valid VLI and header_size is a small value so their sum
; 127  : 	// will never overflow.
; 128  : 	assert(block->compressed_size == lzma2_bound(in_size));
; 129  : 	if (out_size - *out_pos
; 130  : 			< block->header_size + block->compressed_size) {

  0007f	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00082	8b 4d 1c	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00085	2b 08		 sub	 ecx, DWORD PTR [eax]
  00087	33 d2		 xor	 edx, edx
  00089	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0008c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008f	33 f6		 xor	 esi, esi
  00091	8b 7d 08	 mov	 edi, DWORD PTR _block$[ebp]
  00094	03 47 10	 add	 eax, DWORD PTR [edi+16]
  00097	13 77 14	 adc	 esi, DWORD PTR [edi+20]
  0009a	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], ecx
  000a0	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv186[ebp+4], edx
  000a6	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  000ac	89 b5 64 ff ff
	ff		 mov	 DWORD PTR tv189[ebp+4], esi
  000b2	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv186[ebp+4]
  000b8	3b 8d 64 ff ff
	ff		 cmp	 ecx, DWORD PTR tv189[ebp+4]
  000be	77 26		 ja	 SHORT $LN4@block_enco@2
  000c0	72 0e		 jb	 SHORT $LN10@block_enco@2
  000c2	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv186[ebp]
  000c8	3b 95 60 ff ff
	ff		 cmp	 edx, DWORD PTR tv189[ebp]
  000ce	73 16		 jae	 SHORT $LN4@block_enco@2
$LN10@block_enco@2:

; 131  : 		block->filters = filters_orig;

  000d0	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000d3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _filters_orig$32341[ebp]
  000d9	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 132  : 		return LZMA_BUF_ERROR;

  000dc	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000e1	e9 76 01 00 00	 jmp	 $LN6@block_enco@2
$LN4@block_enco@2:

; 133  : 	}
; 134  : 
; 135  : 	if (lzma_block_header_encode(block, out + *out_pos) != LZMA_OK) {

  000e6	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000e9	8b 45 14	 mov	 eax, DWORD PTR _out$[ebp]
  000ec	03 02		 add	 eax, DWORD PTR [edx]
  000ee	50		 push	 eax
  000ef	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 _lzma_block_header_encode
  000f8	83 c4 08	 add	 esp, 8
  000fb	85 c0		 test	 eax, eax
  000fd	74 16		 je	 SHORT $LN3@block_enco@2

; 136  : 		block->filters = filters_orig;

  000ff	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00102	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _filters_orig$32341[ebp]
  00108	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 137  : 		return LZMA_PROG_ERROR;

  0010b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00110	e9 47 01 00 00	 jmp	 $LN6@block_enco@2
$LN3@block_enco@2:

; 138  : 	}
; 139  : 
; 140  : 	block->filters = filters_orig;

  00115	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00118	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _filters_orig$32341[ebp]
  0011e	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 141  : 	*out_pos += block->header_size;

  00121	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00124	8b 08		 mov	 ecx, DWORD PTR [eax]
  00126	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00129	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0012c	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0012f	89 08		 mov	 DWORD PTR [eax], ecx

; 142  : 
; 143  : 	// Encode the data using LZMA2 uncompressed chunks.
; 144  :   {
; 145  : 	size_t in_pos = 0;

  00131	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _in_pos$32346[ebp], 0

; 146  : 	uint8_t control = 0x01; // Dictionary reset

  0013b	c6 85 77 ff ff
	ff 01		 mov	 BYTE PTR _control$32347[ebp], 1
$LN2@block_enco@2:

; 147  : 
; 148  : 	while (in_pos < in_size) {

  00142	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _in_pos$32346[ebp]
  00148	3b 4d 10	 cmp	 ecx, DWORD PTR _in_size$[ebp]
  0014b	0f 83 f0 00 00
	00		 jae	 $LN1@block_enco@2

; 149  : 		// Control byte: Indicate uncompressed chunk, of which
; 150  : 		// the first resets the dictionary.
; 151  : 		out[(*out_pos)++] = control;

  00151	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00154	8b 02		 mov	 eax, DWORD PTR [edx]
  00156	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  00159	8a 95 77 ff ff
	ff		 mov	 dl, BYTE PTR _control$32347[ebp]
  0015f	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00162	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00165	8b 08		 mov	 ecx, DWORD PTR [eax]
  00167	83 c1 01	 add	 ecx, 1
  0016a	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0016d	89 0a		 mov	 DWORD PTR [edx], ecx

; 152  : 		control = 0x02; // No dictionary reset

  0016f	c6 85 77 ff ff
	ff 02		 mov	 BYTE PTR _control$32347[ebp], 2

; 153  : 
; 154  : 		// Size of the uncompressed chunk
; 155  : 	  {
; 156  : 		const size_t copy_size
; 157  : 				= my_min(in_size - in_pos, LZMA2_CHUNK_MAX);

  00176	8b 45 10	 mov	 eax, DWORD PTR _in_size$[ebp]
  00179	2b 85 78 ff ff
	ff		 sub	 eax, DWORD PTR _in_pos$32346[ebp]
  0017f	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00184	73 11		 jae	 SHORT $LN8@block_enco@2
  00186	8b 4d 10	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00189	2b 8d 78 ff ff
	ff		 sub	 ecx, DWORD PTR _in_pos$32346[ebp]
  0018f	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
  00195	eb 0a		 jmp	 SHORT $LN9@block_enco@2
$LN8@block_enco@2:
  00197	c7 85 5c ff ff
	ff 00 00 01 00	 mov	 DWORD PTR tv130[ebp], 65536 ; 00010000H
$LN9@block_enco@2:
  001a1	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv130[ebp]
  001a7	89 95 70 ff ff
	ff		 mov	 DWORD PTR _copy_size$32351[ebp], edx

; 158  : 		out[(*out_pos)++] = (uint8_t)((copy_size - 1) >> 8);

  001ad	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _copy_size$32351[ebp]
  001b3	83 e8 01	 sub	 eax, 1
  001b6	c1 e8 08	 shr	 eax, 8
  001b9	8b 4d 18	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001be	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  001c1	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  001c4	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]
  001c9	83 c0 01	 add	 eax, 1
  001cc	8b 4d 18	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001cf	89 01		 mov	 DWORD PTR [ecx], eax

; 159  : 		out[(*out_pos)++] = (copy_size - 1) & 0xFF;

  001d1	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _copy_size$32351[ebp]
  001d7	83 ea 01	 sub	 edx, 1
  001da	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001e0	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e5	8b 45 14	 mov	 eax, DWORD PTR _out$[ebp]
  001e8	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  001eb	8b 4d 18	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f0	83 c2 01	 add	 edx, 1
  001f3	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001f6	89 10		 mov	 DWORD PTR [eax], edx

; 160  : 
; 161  : 		// The actual data
; 162  : 		assert(*out_pos + copy_size <= out_size);
; 163  : 		memcpy(out + *out_pos, in + in_pos, copy_size);

  001f8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _copy_size$32351[ebp]
  001fe	51		 push	 ecx
  001ff	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00202	03 95 78 ff ff
	ff		 add	 edx, DWORD PTR _in_pos$32346[ebp]
  00208	52		 push	 edx
  00209	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0020c	8b 4d 14	 mov	 ecx, DWORD PTR _out$[ebp]
  0020f	03 08		 add	 ecx, DWORD PTR [eax]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 _memcpy
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 
; 165  : 		in_pos += copy_size;

  0021a	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _in_pos$32346[ebp]
  00220	03 95 70 ff ff
	ff		 add	 edx, DWORD PTR _copy_size$32351[ebp]
  00226	89 95 78 ff ff
	ff		 mov	 DWORD PTR _in_pos$32346[ebp], edx

; 166  : 		*out_pos += copy_size;

  0022c	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0022f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00231	03 8d 70 ff ff
	ff		 add	 ecx, DWORD PTR _copy_size$32351[ebp]
  00237	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0023a	89 0a		 mov	 DWORD PTR [edx], ecx

; 167  : 	  }
; 168  : 	}

  0023c	e9 01 ff ff ff	 jmp	 $LN2@block_enco@2
$LN1@block_enco@2:

; 169  : 
; 170  : 	// End marker
; 171  : 	out[(*out_pos)++] = 0x00;

  00241	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
  00249	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
  0024d	8b 45 18	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	83 c1 01	 add	 ecx, 1
  00255	8b 55 18	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00258	89 0a		 mov	 DWORD PTR [edx], ecx

; 172  : 	assert(*out_pos <= out_size);
; 173  :   }}}
; 174  : 
; 175  : 	return LZMA_OK;

  0025a	33 c0		 xor	 eax, eax
$LN6@block_enco@2:

; 176  : }

  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
_block_encode_uncompressed ENDP
; Function compile flags: /Odtp
;	COMDAT _block_encode_normal
_TEXT	SEGMENT
tv168 = -80						; size = 4
tv165 = -76						; size = 8
_in_pos$32383 = -68					; size = 4
_raw_encoder$32380 = -64				; size = 48
_ret$32381 = -12					; size = 4
_out_start$32377 = -8					; size = 4
_ret_$32374 = -4					; size = 4
_block$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_size$ = 20						; size = 4
_out$ = 24						; size = 4
_out_pos$ = 28						; size = 4
_out_size$ = 32						; size = 4
_block_encode_normal PROC				; COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	56		 push	 esi
  00007	57		 push	 edi
$LN12@block_enco@3:

; 184  : 	// Find out the size of the Block Header.
; 185  : 	return_if_error(lzma_block_header_size(block));

  00008	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _lzma_block_header_size
  00011	83 c4 04	 add	 esp, 4
  00014	89 45 fc	 mov	 DWORD PTR _ret_$32374[ebp], eax
  00017	83 7d fc 00	 cmp	 DWORD PTR _ret_$32374[ebp], 0
  0001b	74 08		 je	 SHORT $LN11@block_enco@3
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _ret_$32374[ebp]
  00020	e9 4c 01 00 00	 jmp	 $LN13@block_enco@3
$LN11@block_enco@3:
  00025	33 c9		 xor	 ecx, ecx
  00027	75 df		 jne	 SHORT $LN12@block_enco@3

; 186  : 
; 187  : 	// Reserve space for the Block Header and skip it for now.
; 188  : 	if (out_size - *out_pos <= block->header_size)

  00029	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0002c	8b 45 20	 mov	 eax, DWORD PTR _out_size$[ebp]
  0002f	2b 02		 sub	 eax, DWORD PTR [edx]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00034	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00037	77 0a		 ja	 SHORT $LN8@block_enco@3

; 189  : 		return LZMA_BUF_ERROR;

  00039	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0003e	e9 2e 01 00 00	 jmp	 $LN13@block_enco@3
$LN8@block_enco@3:

; 190  : 
; 191  :   {
; 192  : 	const size_t out_start = *out_pos;

  00043	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	89 45 f8	 mov	 DWORD PTR _out_start$32377[ebp], eax

; 193  : 	*out_pos += block->header_size;

  0004b	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00053	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00056	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00059	89 11		 mov	 DWORD PTR [ecx], edx

; 194  : 
; 195  : 	// Limit out_size so that we stop encoding if the output would grow
; 196  : 	// bigger than what uncompressed Block would be.
; 197  : 	if (out_size - *out_pos > block->compressed_size)

  0005b	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0005e	8b 45 20	 mov	 eax, DWORD PTR _out_size$[ebp]
  00061	2b 02		 sub	 eax, DWORD PTR [edx]
  00063	33 c9		 xor	 ecx, ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00068	89 45 b4	 mov	 DWORD PTR tv165[ebp], eax
  0006b	89 4d b8	 mov	 DWORD PTR tv165[ebp+4], ecx
  0006e	89 55 b0	 mov	 DWORD PTR tv168[ebp], edx
  00071	8b 45 b0	 mov	 eax, DWORD PTR tv168[ebp]
  00074	8b 4d b8	 mov	 ecx, DWORD PTR tv165[ebp+4]
  00077	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0007a	72 20		 jb	 SHORT $LN7@block_enco@3
  0007c	77 0b		 ja	 SHORT $LN15@block_enco@3
  0007e	8b 55 b0	 mov	 edx, DWORD PTR tv168[ebp]
  00081	8b 45 b4	 mov	 eax, DWORD PTR tv165[ebp]
  00084	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00087	76 13		 jbe	 SHORT $LN7@block_enco@3
$LN15@block_enco@3:

; 198  : 		out_size = (size_t)(*out_pos + block->compressed_size);

  00089	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0008c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008e	33 c0		 xor	 eax, eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00093	03 51 10	 add	 edx, DWORD PTR [ecx+16]
  00096	13 41 14	 adc	 eax, DWORD PTR [ecx+20]
  00099	89 55 20	 mov	 DWORD PTR _out_size$[ebp], edx
$LN7@block_enco@3:

; 199  : 
; 200  : 	// TODO: In many common cases this could be optimized to use
; 201  : 	// significantly less memory.
; 202  :   {
; 203  : 	lzma_next_coder raw_encoder = LZMA_NEXT_CODER_INIT;

  0009c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000a1	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000a6	8d 7d c0	 lea	 edi, DWORD PTR _raw_encoder$32380[ebp]
  000a9	f3 a5		 rep movsd

; 204  : 	lzma_ret ret = lzma_raw_encoder_init(
; 205  : 			&raw_encoder, allocator, block->filters);

  000ab	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  000ae	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000b1	50		 push	 eax
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  000b5	51		 push	 ecx
  000b6	8d 55 c0	 lea	 edx, DWORD PTR _raw_encoder$32380[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _lzma_raw_encoder_init
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	89 45 f4	 mov	 DWORD PTR _ret$32381[ebp], eax

; 206  : 
; 207  : 	if (ret == LZMA_OK) {

  000c5	83 7d f4 00	 cmp	 DWORD PTR _ret$32381[ebp], 0
  000c9	75 32		 jne	 SHORT $LN6@block_enco@3

; 208  : 		size_t in_pos = 0;

  000cb	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _in_pos$32383[ebp], 0

; 209  : 		ret = raw_encoder.code(raw_encoder.coder, allocator,
; 210  : 				in, &in_pos, in_size, out, out_pos, out_size,
; 211  : 				LZMA_FINISH);

  000d2	6a 03		 push	 3
  000d4	8b 45 20	 mov	 eax, DWORD PTR _out_size$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 18	 mov	 edx, DWORD PTR _out$[ebp]
  000df	52		 push	 edx
  000e0	8b 45 14	 mov	 eax, DWORD PTR _in_size$[ebp]
  000e3	50		 push	 eax
  000e4	8d 4d bc	 lea	 ecx, DWORD PTR _in_pos$32383[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d c0	 mov	 ecx, DWORD PTR _raw_encoder$32380[ebp]
  000f3	51		 push	 ecx
  000f4	ff 55 d4	 call	 DWORD PTR _raw_encoder$32380[ebp+20]
  000f7	83 c4 24	 add	 esp, 36			; 00000024H
  000fa	89 45 f4	 mov	 DWORD PTR _ret$32381[ebp], eax
$LN6@block_enco@3:

; 212  : 	}
; 213  : 
; 214  : 	// NOTE: This needs to be run even if lzma_raw_encoder_init() failed.
; 215  : 	lzma_next_end(&raw_encoder, allocator);

  000fd	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  00100	52		 push	 edx
  00101	8d 45 c0	 lea	 eax, DWORD PTR _raw_encoder$32380[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _lzma_next_end
  0010a	83 c4 08	 add	 esp, 8

; 216  : 
; 217  : 	if (ret == LZMA_STREAM_END) {

  0010d	83 7d f4 01	 cmp	 DWORD PTR _ret$32381[ebp], 1
  00111	75 40		 jne	 SHORT $LN5@block_enco@3

; 218  : 		// Compression was successful. Write the Block Header.
; 219  : 		block->compressed_size
; 220  : 				= *out_pos - (out_start + block->header_size);

  00113	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00116	8b 55 f8	 mov	 edx, DWORD PTR _out_start$32377[ebp]
  00119	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0011c	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	2b ca		 sub	 ecx, edx
  00123	33 d2		 xor	 edx, edx
  00125	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00128	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0012b	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 221  : 		ret = lzma_block_header_encode(block, out + out_start);

  0012e	8b 4d 18	 mov	 ecx, DWORD PTR _out$[ebp]
  00131	03 4d f8	 add	 ecx, DWORD PTR _out_start$32377[ebp]
  00134	51		 push	 ecx
  00135	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00138	52		 push	 edx
  00139	e8 00 00 00 00	 call	 _lzma_block_header_encode
  0013e	83 c4 08	 add	 esp, 8
  00141	89 45 f4	 mov	 DWORD PTR _ret$32381[ebp], eax

; 222  : 		if (ret != LZMA_OK)

  00144	83 7d f4 00	 cmp	 DWORD PTR _ret$32381[ebp], 0
  00148	74 07		 je	 SHORT $LN4@block_enco@3

; 223  : 			ret = LZMA_PROG_ERROR;

  0014a	c7 45 f4 0b 00
	00 00		 mov	 DWORD PTR _ret$32381[ebp], 11 ; 0000000bH
$LN4@block_enco@3:

; 224  : 
; 225  : 	} else if (ret == LZMA_OK) {

  00151	eb 0d		 jmp	 SHORT $LN3@block_enco@3
$LN5@block_enco@3:
  00153	83 7d f4 00	 cmp	 DWORD PTR _ret$32381[ebp], 0
  00157	75 07		 jne	 SHORT $LN3@block_enco@3

; 226  : 		// Output buffer became full.
; 227  : 		ret = LZMA_BUF_ERROR;

  00159	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _ret$32381[ebp], 10 ; 0000000aH
$LN3@block_enco@3:

; 228  : 	}
; 229  : 
; 230  : 	// Reset *out_pos if something went wrong.
; 231  : 	if (ret != LZMA_OK)

  00160	83 7d f4 00	 cmp	 DWORD PTR _ret$32381[ebp], 0
  00164	74 08		 je	 SHORT $LN1@block_enco@3

; 232  : 		*out_pos = out_start;

  00166	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _out_start$32377[ebp]
  0016c	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@block_enco@3:

; 233  : 
; 234  : 	return ret;

  0016e	8b 45 f4	 mov	 eax, DWORD PTR _ret$32381[ebp]
$LN13@block_enco@3:

; 235  :   }}
; 236  : }

  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_block_encode_normal ENDP
; Function compile flags: /Odtp
;	COMDAT _block_buffer_encode
_TEXT	SEGMENT
tv222 = -124						; size = 4
_check$32441 = -120					; size = 104
_i$32434 = -16						; size = 4
_ret_$32431 = -12					; size = 4
_ret$32424 = -8						; size = 4
_check_size$32420 = -4					; size = 4
_block$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_size$ = 20						; size = 4
_out$ = 24						; size = 4
_out_pos$ = 28						; size = 4
_out_size$ = 32						; size = 4
_try_to_compress$ = 36					; size = 1
_block_buffer_encode PROC				; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH

; 245  : 	// Validate the arguments.
; 246  : 	if (block == NULL || (in == NULL && in_size != 0) || out == NULL
; 247  : 			|| out_pos == NULL || *out_pos > out_size)

  00006	83 7d 08 00	 cmp	 DWORD PTR _block$[ebp], 0
  0000a	74 22		 je	 SHORT $LN19@block_buff
  0000c	83 7d 10 00	 cmp	 DWORD PTR _in$[ebp], 0
  00010	75 06		 jne	 SHORT $LN18@block_buff
  00012	83 7d 14 00	 cmp	 DWORD PTR _in_size$[ebp], 0
  00016	75 16		 jne	 SHORT $LN19@block_buff
$LN18@block_buff:
  00018	83 7d 18 00	 cmp	 DWORD PTR _out$[ebp], 0
  0001c	74 10		 je	 SHORT $LN19@block_buff
  0001e	83 7d 1c 00	 cmp	 DWORD PTR _out_pos$[ebp], 0
  00022	74 0a		 je	 SHORT $LN19@block_buff
  00024	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	3b 4d 20	 cmp	 ecx, DWORD PTR _out_size$[ebp]
  0002c	76 0a		 jbe	 SHORT $LN20@block_buff
$LN19@block_buff:

; 248  : 		return LZMA_PROG_ERROR;

  0002e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00033	e9 1b 02 00 00	 jmp	 $LN21@block_buff
$LN20@block_buff:

; 249  : 
; 250  : 	// The contents of the structure may depend on the version so
; 251  : 	// check the version before validating the contents of *block.
; 252  : 	if (block->version > 1)

  00038	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0003b	83 3a 01	 cmp	 DWORD PTR [edx], 1
  0003e	76 0a		 jbe	 SHORT $LN17@block_buff

; 253  : 		return LZMA_OPTIONS_ERROR;

  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	e9 09 02 00 00	 jmp	 $LN21@block_buff
$LN17@block_buff:

; 254  : 
; 255  : 	if ((unsigned int)(block->check) > LZMA_CHECK_ID_MAX
; 256  : 			|| (try_to_compress && block->filters == NULL))

  0004a	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0004d	83 78 08 0f	 cmp	 DWORD PTR [eax+8], 15	; 0000000fH
  00051	77 11		 ja	 SHORT $LN15@block_buff
  00053	0f b6 4d 24	 movzx	 ecx, BYTE PTR _try_to_compress$[ebp]
  00057	85 c9		 test	 ecx, ecx
  00059	74 13		 je	 SHORT $LN16@block_buff
  0005b	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0005e	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00062	75 0a		 jne	 SHORT $LN16@block_buff
$LN15@block_buff:

; 257  : 		return LZMA_PROG_ERROR;

  00064	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00069	e9 e5 01 00 00	 jmp	 $LN21@block_buff
$LN16@block_buff:

; 258  : 
; 259  : 	if (!lzma_check_is_supported(block->check))

  0006e	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00071	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _lzma_check_is_supported
  0007a	83 c4 04	 add	 esp, 4
  0007d	0f b6 d0	 movzx	 edx, al
  00080	85 d2		 test	 edx, edx
  00082	75 0a		 jne	 SHORT $LN14@block_buff

; 260  : 		return LZMA_UNSUPPORTED_CHECK;

  00084	b8 03 00 00 00	 mov	 eax, 3
  00089	e9 c5 01 00 00	 jmp	 $LN21@block_buff
$LN14@block_buff:

; 261  : 
; 262  : 	// Size of a Block has to be a multiple of four, so limit the size
; 263  : 	// here already. This way we don't need to check it again when adding
; 264  : 	// Block Padding.
; 265  : 	out_size -= (out_size - *out_pos) & 3;

  0008e	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00091	8b 4d 20	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00094	2b 08		 sub	 ecx, DWORD PTR [eax]
  00096	83 e1 03	 and	 ecx, 3
  00099	8b 55 20	 mov	 edx, DWORD PTR _out_size$[ebp]
  0009c	2b d1		 sub	 edx, ecx
  0009e	89 55 20	 mov	 DWORD PTR _out_size$[ebp], edx

; 266  : 
; 267  : 	// Get the size of the Check field.
; 268  :   {
; 269  : 	const size_t check_size = lzma_check_size(block->check);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _lzma_check_size
  000ad	83 c4 04	 add	 esp, 4
  000b0	89 45 fc	 mov	 DWORD PTR _check_size$32420[ebp], eax

; 270  : 	assert(check_size != UINT32_MAX);
; 271  : 
; 272  : 	// Reserve space for the Check field.
; 273  : 	if (out_size - *out_pos <= check_size)

  000b3	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  000b6	8b 45 20	 mov	 eax, DWORD PTR _out_size$[ebp]
  000b9	2b 02		 sub	 eax, DWORD PTR [edx]
  000bb	3b 45 fc	 cmp	 eax, DWORD PTR _check_size$32420[ebp]
  000be	77 0a		 ja	 SHORT $LN13@block_buff

; 274  : 		return LZMA_BUF_ERROR;

  000c0	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000c5	e9 89 01 00 00	 jmp	 $LN21@block_buff
$LN13@block_buff:

; 275  : 
; 276  : 	out_size -= check_size;

  000ca	8b 4d 20	 mov	 ecx, DWORD PTR _out_size$[ebp]
  000cd	2b 4d fc	 sub	 ecx, DWORD PTR _check_size$32420[ebp]
  000d0	89 4d 20	 mov	 DWORD PTR _out_size$[ebp], ecx

; 277  : 
; 278  : 	// Initialize block->uncompressed_size and calculate the worst-case
; 279  : 	// value for block->compressed_size.
; 280  : 	block->uncompressed_size = in_size;

  000d3	8b 55 14	 mov	 edx, DWORD PTR _in_size$[ebp]
  000d6	33 c0		 xor	 eax, eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  000db	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  000de	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 281  : 	block->compressed_size = lzma2_bound(in_size);

  000e1	8b 55 14	 mov	 edx, DWORD PTR _in_size$[ebp]
  000e4	33 c0		 xor	 eax, eax
  000e6	50		 push	 eax
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _lzma2_bound
  000ed	83 c4 08	 add	 esp, 8
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  000f3	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000f6	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 282  : 	if (block->compressed_size == 0)

  000f9	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  000fc	89 55 84	 mov	 DWORD PTR tv222[ebp], edx
  000ff	8b 45 84	 mov	 eax, DWORD PTR tv222[ebp]
  00102	8b 4d 84	 mov	 ecx, DWORD PTR tv222[ebp]
  00105	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00108	0b 51 14	 or	 edx, DWORD PTR [ecx+20]
  0010b	75 0a		 jne	 SHORT $LN12@block_buff

; 283  : 		return LZMA_DATA_ERROR;

  0010d	b8 09 00 00 00	 mov	 eax, 9
  00112	e9 3c 01 00 00	 jmp	 $LN21@block_buff
$LN12@block_buff:

; 284  : 
; 285  : 	// Do the actual compression.
; 286  :   {
; 287  : 	lzma_ret ret = LZMA_BUF_ERROR;

  00117	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _ret$32424[ebp], 10 ; 0000000aH

; 288  : 	if (try_to_compress)

  0011e	0f b6 45 24	 movzx	 eax, BYTE PTR _try_to_compress$[ebp]
  00122	85 c0		 test	 eax, eax
  00124	74 27		 je	 SHORT $LN11@block_buff

; 289  : 		ret = block_encode_normal(block, allocator,
; 290  : 				in, in_size, out, out_pos, out_size);

  00126	8b 4d 20	 mov	 ecx, DWORD PTR _out_size$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00131	50		 push	 eax
  00132	8b 4d 14	 mov	 ecx, DWORD PTR _in_size$[ebp]
  00135	51		 push	 ecx
  00136	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  00139	52		 push	 edx
  0013a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _block_encode_normal
  00147	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014a	89 45 f8	 mov	 DWORD PTR _ret$32424[ebp], eax
$LN11@block_buff:

; 291  : 
; 292  : 	if (ret != LZMA_OK) {

  0014d	83 7d f8 00	 cmp	 DWORD PTR _ret$32424[ebp], 0
  00151	74 43		 je	 SHORT $LN10@block_buff

; 293  : 		// If the error was something else than output buffer
; 294  : 		// becoming full, return the error now.
; 295  : 		if (ret != LZMA_BUF_ERROR)

  00153	83 7d f8 0a	 cmp	 DWORD PTR _ret$32424[ebp], 10 ; 0000000aH
  00157	74 08		 je	 SHORT $LN8@block_buff

; 296  : 			return ret;

  00159	8b 45 f8	 mov	 eax, DWORD PTR _ret$32424[ebp]
  0015c	e9 f2 00 00 00	 jmp	 $LN21@block_buff
$LN8@block_buff:

; 297  : 
; 298  : 		// The data was uncompressible (at least with the options
; 299  : 		// given to us) or the output buffer was too small. Use the
; 300  : 		// uncompressed chunks of LZMA2 to wrap the data into a valid
; 301  : 		// Block. If we haven't been given enough output space, even
; 302  : 		// this may fail.
; 303  : 		return_if_error(block_encode_uncompressed(block, in, in_size,
; 304  : 				out, out_pos, out_size));

  00161	8b 55 20	 mov	 edx, DWORD PTR _out_size$[ebp]
  00164	52		 push	 edx
  00165	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00168	50		 push	 eax
  00169	8b 4d 18	 mov	 ecx, DWORD PTR _out$[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 14	 mov	 edx, DWORD PTR _in_size$[ebp]
  00170	52		 push	 edx
  00171	8b 45 10	 mov	 eax, DWORD PTR _in$[ebp]
  00174	50		 push	 eax
  00175	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 _block_encode_uncompressed
  0017e	83 c4 18	 add	 esp, 24			; 00000018H
  00181	89 45 f4	 mov	 DWORD PTR _ret_$32431[ebp], eax
  00184	83 7d f4 00	 cmp	 DWORD PTR _ret_$32431[ebp], 0
  00188	74 08		 je	 SHORT $LN7@block_buff
  0018a	8b 45 f4	 mov	 eax, DWORD PTR _ret_$32431[ebp]
  0018d	e9 c1 00 00 00	 jmp	 $LN21@block_buff
$LN7@block_buff:
  00192	33 d2		 xor	 edx, edx
  00194	75 cb		 jne	 SHORT $LN8@block_buff
$LN10@block_buff:

; 305  : 	}
; 306  :   }
; 307  : 
; 308  : 	assert(*out_pos <= out_size);
; 309  : 
; 310  : 	// Block Padding. No buffer overflow here, because we already adjusted
; 311  : 	// out_size so that (out_size - out_start) is a multiple of four.
; 312  : 	// Thus, if the buffer is full, the loop body can never run.
; 313  :   { size_t i;
; 314  : 
; 315  : 	for (i = (size_t)(block->compressed_size); i & 3; ++i) {

  00196	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00199	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0019c	89 4d f0	 mov	 DWORD PTR _i$32434[ebp], ecx
  0019f	eb 09		 jmp	 SHORT $LN4@block_buff
$LN3@block_buff:
  001a1	8b 55 f0	 mov	 edx, DWORD PTR _i$32434[ebp]
  001a4	83 c2 01	 add	 edx, 1
  001a7	89 55 f0	 mov	 DWORD PTR _i$32434[ebp], edx
$LN4@block_buff:
  001aa	8b 45 f0	 mov	 eax, DWORD PTR _i$32434[ebp]
  001ad	83 e0 03	 and	 eax, 3
  001b0	74 1b		 je	 SHORT $LN2@block_buff

; 316  : 		assert(*out_pos < out_size);
; 317  : 		out[(*out_pos)++] = 0x00;

  001b2	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  001ba	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
  001be	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c3	83 c2 01	 add	 edx, 1
  001c6	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001c9	89 10		 mov	 DWORD PTR [eax], edx

; 318  : 	}

  001cb	eb d4		 jmp	 SHORT $LN3@block_buff
$LN2@block_buff:

; 319  :   }
; 320  : 
; 321  : 	// If there's no Check field, we are done now.
; 322  : 	if (check_size > 0) {

  001cd	83 7d fc 00	 cmp	 DWORD PTR _check_size$32420[ebp], 0
  001d1	76 7e		 jbe	 SHORT $LN1@block_buff

; 323  : 		// Calculate the integrity check. We reserved space for
; 324  : 		// the Check field earlier so we don't need to check for
; 325  : 		// available output space here.
; 326  : 		lzma_check_state check;
; 327  : 		lzma_check_init(&check, block->check);

  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _block$[ebp]
  001d6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001d9	52		 push	 edx
  001da	8d 45 88	 lea	 eax, DWORD PTR _check$32441[ebp]
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 _lzma_check_init
  001e3	83 c4 08	 add	 esp, 8

; 328  : 		lzma_check_update(&check, block->check, in, in_size);

  001e6	8b 4d 14	 mov	 ecx, DWORD PTR _in_size$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 55 10	 mov	 edx, DWORD PTR _in$[ebp]
  001ed	52		 push	 edx
  001ee	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  001f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f4	51		 push	 ecx
  001f5	8d 55 88	 lea	 edx, DWORD PTR _check$32441[ebp]
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 _lzma_check_update
  001fe	83 c4 10	 add	 esp, 16			; 00000010H

; 329  : 		lzma_check_finish(&check, block->check);

  00201	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00204	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00207	51		 push	 ecx
  00208	8d 55 88	 lea	 edx, DWORD PTR _check$32441[ebp]
  0020b	52		 push	 edx
  0020c	e8 00 00 00 00	 call	 _lzma_check_finish
  00211	83 c4 08	 add	 esp, 8

; 330  : 
; 331  : 		memcpy(block->raw_check, check.buffer.u8, check_size);

  00214	8b 45 fc	 mov	 eax, DWORD PTR _check_size$32420[ebp]
  00217	50		 push	 eax
  00218	8d 4d 88	 lea	 ecx, DWORD PTR _check$32441[ebp]
  0021b	51		 push	 ecx
  0021c	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0021f	83 c2 24	 add	 edx, 36			; 00000024H
  00222	52		 push	 edx
  00223	e8 00 00 00 00	 call	 _memcpy
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 332  : 		memcpy(out + *out_pos, check.buffer.u8, check_size);

  0022b	8b 45 fc	 mov	 eax, DWORD PTR _check_size$32420[ebp]
  0022e	50		 push	 eax
  0022f	8d 4d 88	 lea	 ecx, DWORD PTR _check$32441[ebp]
  00232	51		 push	 ecx
  00233	8b 55 1c	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00236	8b 45 18	 mov	 eax, DWORD PTR _out$[ebp]
  00239	03 02		 add	 eax, DWORD PTR [edx]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 _memcpy
  00241	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  : 		*out_pos += check_size;

  00244	8b 4d 1c	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00247	8b 11		 mov	 edx, DWORD PTR [ecx]
  00249	03 55 fc	 add	 edx, DWORD PTR _check_size$32420[ebp]
  0024c	8b 45 1c	 mov	 eax, DWORD PTR _out_pos$[ebp]
  0024f	89 10		 mov	 DWORD PTR [eax], edx
$LN1@block_buff:

; 334  : 	}
; 335  :   }
; 336  : 
; 337  : 	return LZMA_OK;

  00251	33 c0		 xor	 eax, eax
$LN21@block_buff:

; 338  : }

  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
_block_buffer_encode ENDP
PUBLIC	_lzma_block_uncomp_encode
; Function compile flags: /Odtp
;	COMDAT _lzma_block_uncomp_encode
_TEXT	SEGMENT
_block$ = 8						; size = 4
_in$ = 12						; size = 4
_in_size$ = 16						; size = 4
_out$ = 20						; size = 4
_out_pos$ = 24						; size = 4
_out_size$ = 28						; size = 4
_lzma_block_uncomp_encode PROC				; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 	// It won't allocate any memory from heap so no need
; 357  : 	// for lzma_allocator.
; 358  : 	return block_buffer_encode(block, NULL,
; 359  : 			in, in_size, out, out_pos, out_size, false);

  00003	6a 00		 push	 0
  00005	8b 45 1c	 mov	 eax, DWORD PTR _out_size$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 18	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
  00010	52		 push	 edx
  00011	8b 45 10	 mov	 eax, DWORD PTR _in_size$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _in$[ebp]
  00018	51		 push	 ecx
  00019	6a 00		 push	 0
  0001b	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _block_buffer_encode
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 360  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_lzma_block_uncomp_encode ENDP
END
