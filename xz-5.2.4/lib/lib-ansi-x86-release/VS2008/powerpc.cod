; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\powerpc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_powerpc_decoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\powerpc.c
;	COMDAT _powerpc_code
_TEXT	SEGMENT
_src$32367 = -12					; size = 4
_dest$32368 = -8					; size = 4
_i$ = -4						; size = 4
_simple$ = 8						; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_powerpc_code PROC					; COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 4) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN6@powerpc_co
$LN5@powerpc_co:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@powerpc_co:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp]
  00021	0f 87 f1 00 00
	00		 ja	 $LN4@powerpc_co

; 24   : 		// PowerPC branch 6(48) 24(Offset) 1(Abs) 1(Link)
; 25   : 		if ((buffer[i] >> 2) == 0x12
; 26   : 				&& ((buffer[i + 3] & 3) == 1)) {

  00027	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002a	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00030	c1 f8 02	 sar	 eax, 2
  00033	83 f8 12	 cmp	 eax, 18			; 00000012H
  00036	0f 85 d7 00 00
	00		 jne	 $LN3@powerpc_co
  0003c	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003f	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00042	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00046	83 e2 03	 and	 edx, 3
  00049	83 fa 01	 cmp	 edx, 1
  0004c	0f 85 c1 00 00
	00		 jne	 $LN3@powerpc_co

; 27   : 
; 28   : 			const uint32_t src = ((buffer[i + 0] & 3) << 24)
; 29   : 					| (buffer[i + 1] << 16)
; 30   : 					| (buffer[i + 2] << 8)
; 31   : 					| (buffer[i + 3] & (~3));

  00052	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  00055	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00058	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0005b	83 e1 03	 and	 ecx, 3
  0005e	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00061	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00064	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00067	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0006b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006e	0b c8		 or	 ecx, eax
  00070	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00073	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00076	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0007a	c1 e0 08	 shl	 eax, 8
  0007d	0b c8		 or	 ecx, eax
  0007f	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00082	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00085	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00089	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008c	0b c8		 or	 ecx, eax
  0008e	89 4d f4	 mov	 DWORD PTR _src$32367[ebp], ecx

; 32   : 
; 33   : 			uint32_t dest;
; 34   : 			if (is_encoder)

  00091	0f b6 4d 10	 movzx	 ecx, BYTE PTR _is_encoder$[ebp]
  00095	85 c9		 test	 ecx, ecx
  00097	74 0e		 je	 SHORT $LN2@powerpc_co

; 35   : 				dest = now_pos + (uint32_t)(i) + src;

  00099	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  0009c	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0009f	03 55 f4	 add	 edx, DWORD PTR _src$32367[ebp]
  000a2	89 55 f8	 mov	 DWORD PTR _dest$32368[ebp], edx

; 36   : 			else

  000a5	eb 0e		 jmp	 SHORT $LN1@powerpc_co
$LN2@powerpc_co:

; 37   : 				dest = src - (now_pos + (uint32_t)(i));

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _now_pos$[ebp]
  000aa	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _src$32367[ebp]
  000b0	2b c8		 sub	 ecx, eax
  000b2	89 4d f8	 mov	 DWORD PTR _dest$32368[ebp], ecx
$LN1@powerpc_co:

; 38   : 
; 39   : 			buffer[i + 0] = 0x48 | ((dest >> 24) &  0x03);

  000b5	8b 55 f8	 mov	 edx, DWORD PTR _dest$32368[ebp]
  000b8	c1 ea 18	 shr	 edx, 24			; 00000018H
  000bb	83 e2 03	 and	 edx, 3
  000be	83 ca 48	 or	 edx, 72			; 00000048H
  000c1	8b 45 14	 mov	 eax, DWORD PTR _buffer$[ebp]
  000c4	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000c7	88 10		 mov	 BYTE PTR [eax], dl

; 40   : 			buffer[i + 1] = (dest >> 16);

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _dest$32368[ebp]
  000cc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000cf	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  000d2	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000d5	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 41   : 			buffer[i + 2] = (dest >> 8);

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _dest$32368[ebp]
  000db	c1 e8 08	 shr	 eax, 8
  000de	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000e1	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000e4	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 42   : 			buffer[i + 3] &= 0x03;

  000e7	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  000ea	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000ed	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000f1	83 e0 03	 and	 eax, 3
  000f4	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000f7	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000fa	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 43   : 			buffer[i + 3] |= dest;

  000fd	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  00100	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00103	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00107	0b 45 f8	 or	 eax, DWORD PTR _dest$32368[ebp]
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0010d	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00110	88 41 03	 mov	 BYTE PTR [ecx+3], al
$LN3@powerpc_co:

; 44   : 		}
; 45   : 	}

  00113	e9 f7 fe ff ff	 jmp	 $LN5@powerpc_co
$LN4@powerpc_co:

; 46   : 
; 47   : 	return i;

  00118	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 48   : }

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_powerpc_code ENDP
; Function compile flags: /Odtp
;	COMDAT _powerpc_coder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_powerpc_coder_init PROC				; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	return lzma_simple_coder_init(next, allocator, filters,
; 56   : 			&powerpc_code, 0, 4, 4, is_encoder);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00007	50		 push	 eax
  00008	6a 04		 push	 4
  0000a	6a 04		 push	 4
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _powerpc_code
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 57   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_powerpc_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_powerpc_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_powerpc_decoder_init PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   : 	return powerpc_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _powerpc_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 75   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_powerpc_decoder_init ENDP
END
