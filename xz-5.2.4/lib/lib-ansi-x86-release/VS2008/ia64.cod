; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\simple\ia64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_lzma_simple_ia64_decoder_init
?BRANCH_TABLE@?1??ia64_code@@9@9 DD 00H			; `ia64_code'::`2'::BRANCH_TABLE
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	04H
	DD	06H
	DD	06H
	DD	00H
	DD	00H
	DD	07H
	DD	07H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
EXTRN	__aullshr:PROC
EXTRN	__allshl:PROC
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\ia64.c
;	COMDAT _ia64_code
_TEXT	SEGMENT
tv239 = -84						; size = 8
tv224 = -76						; size = 8
_j$32389 = -68						; size = 4
_dest$32388 = -64					; size = 4
_src$32386 = -60					; size = 4
_inst_norm$32384 = -56					; size = 8
_j$32379 = -44						; size = 4
_instruction$32378 = -40				; size = 8
_bit_res$32377 = -28					; size = 4
_byte_pos$32376 = -24					; size = 4
_slot$32371 = -20					; size = 4
_bit_pos$32370 = -16					; size = 4
_instr_template$32368 = -12				; size = 4
_mask$32369 = -8					; size = 4
_i$ = -4						; size = 4
_simple$ = 8						; size = 4
_now_pos$ = 12						; size = 4
_is_encoder$ = 16					; size = 1
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_ia64_code PROC						; COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	56		 push	 esi

; 22   : 	static const uint32_t BRANCH_TABLE[32] = {
; 23   : 		0, 0, 0, 0, 0, 0, 0, 0,
; 24   : 		0, 0, 0, 0, 0, 0, 0, 0,
; 25   : 		4, 4, 6, 6, 0, 0, 7, 7,
; 26   : 		4, 4, 0, 0, 4, 4, 0, 0
; 27   : 	};
; 28   : 
; 29   : 	size_t i;
; 30   : 	for (i = 0; i + 16 <= size; i += 16) {

  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000e	eb 09		 jmp	 SHORT $LN16@ia64_code
$LN15@ia64_code:
  00010	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00013	83 c0 10	 add	 eax, 16			; 00000010H
  00016	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@ia64_code:
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001c	83 c1 10	 add	 ecx, 16			; 00000010H
  0001f	3b 4d 18	 cmp	 ecx, DWORD PTR _size$[ebp]
  00022	0f 87 5c 02 00
	00		 ja	 $LN14@ia64_code

; 31   : 		const uint32_t instr_template = buffer[i] & 0x1F;

  00028	8b 55 14	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00031	83 e0 1f	 and	 eax, 31			; 0000001fH
  00034	89 45 f4	 mov	 DWORD PTR _instr_template$32368[ebp], eax

; 32   : 		const uint32_t mask = BRANCH_TABLE[instr_template];

  00037	8b 4d f4	 mov	 ecx, DWORD PTR _instr_template$32368[ebp]
  0003a	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?BRANCH_TABLE@?1??ia64_code@@9@9[ecx*4]
  00041	89 55 f8	 mov	 DWORD PTR _mask$32369[ebp], edx

; 33   : 		uint32_t bit_pos = 5;

  00044	c7 45 f0 05 00
	00 00		 mov	 DWORD PTR _bit_pos$32370[ebp], 5

; 34   : 		size_t slot;
; 35   : 
; 36   : 		for (slot = 0; slot < 3; ++slot, bit_pos += 41) {

  0004b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _slot$32371[ebp], 0
  00052	eb 12		 jmp	 SHORT $LN13@ia64_code
$LN12@ia64_code:
  00054	8b 45 ec	 mov	 eax, DWORD PTR _slot$32371[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 ec	 mov	 DWORD PTR _slot$32371[ebp], eax
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _bit_pos$32370[ebp]
  00060	83 c1 29	 add	 ecx, 41			; 00000029H
  00063	89 4d f0	 mov	 DWORD PTR _bit_pos$32370[ebp], ecx
$LN13@ia64_code:
  00066	83 7d ec 03	 cmp	 DWORD PTR _slot$32371[ebp], 3
  0006a	0f 83 0f 02 00
	00		 jae	 $LN11@ia64_code

; 37   : 			if (((mask >> slot) & 1) == 0)

  00070	8b 55 f8	 mov	 edx, DWORD PTR _mask$32369[ebp]
  00073	8b 4d ec	 mov	 ecx, DWORD PTR _slot$32371[ebp]
  00076	d3 ea		 shr	 edx, cl
  00078	83 e2 01	 and	 edx, 1
  0007b	75 02		 jne	 SHORT $LN10@ia64_code

; 38   : 				continue;

  0007d	eb d5		 jmp	 SHORT $LN12@ia64_code
$LN10@ia64_code:

; 39   : 
; 40   :           {
; 41   : 			const size_t byte_pos = (bit_pos >> 3);

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _bit_pos$32370[ebp]
  00082	c1 e8 03	 shr	 eax, 3
  00085	89 45 e8	 mov	 DWORD PTR _byte_pos$32376[ebp], eax

; 42   : 			const uint32_t bit_res = bit_pos & 0x7;

  00088	8b 4d f0	 mov	 ecx, DWORD PTR _bit_pos$32370[ebp]
  0008b	83 e1 07	 and	 ecx, 7
  0008e	89 4d e4	 mov	 DWORD PTR _bit_res$32377[ebp], ecx

; 43   : 			uint64_t instruction = 0;

  00091	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _instruction$32378[ebp], 0
  00098	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _instruction$32378[ebp+4], 0

; 44   : 			size_t j;
; 45   : 
; 46   : 			for (j = 0; j < 6; ++j)

  0009f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$32379[ebp], 0
  000a6	eb 09		 jmp	 SHORT $LN9@ia64_code
$LN8@ia64_code:
  000a8	8b 55 d4	 mov	 edx, DWORD PTR _j$32379[ebp]
  000ab	83 c2 01	 add	 edx, 1
  000ae	89 55 d4	 mov	 DWORD PTR _j$32379[ebp], edx
$LN9@ia64_code:
  000b1	83 7d d4 06	 cmp	 DWORD PTR _j$32379[ebp], 6
  000b5	73 2c		 jae	 SHORT $LN7@ia64_code

; 47   : 				instruction += (uint64_t)(
; 48   : 						buffer[i + j + byte_pos])
; 49   : 						<< (8 * j);

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	03 45 d4	 add	 eax, DWORD PTR _j$32379[ebp]
  000bd	03 45 e8	 add	 eax, DWORD PTR _byte_pos$32376[ebp]
  000c0	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  000c7	99		 cdq
  000c8	8b 4d d4	 mov	 ecx, DWORD PTR _j$32379[ebp]
  000cb	c1 e1 03	 shl	 ecx, 3
  000ce	e8 00 00 00 00	 call	 __allshl
  000d3	03 45 d8	 add	 eax, DWORD PTR _instruction$32378[ebp]
  000d6	8b 4d dc	 mov	 ecx, DWORD PTR _instruction$32378[ebp+4]
  000d9	13 ca		 adc	 ecx, edx
  000db	89 45 d8	 mov	 DWORD PTR _instruction$32378[ebp], eax
  000de	89 4d dc	 mov	 DWORD PTR _instruction$32378[ebp+4], ecx
  000e1	eb c5		 jmp	 SHORT $LN8@ia64_code
$LN7@ia64_code:

; 50   : 
; 51   :           {
; 52   : 			uint64_t inst_norm = instruction >> bit_res;

  000e3	8b 45 d8	 mov	 eax, DWORD PTR _instruction$32378[ebp]
  000e6	8b 55 dc	 mov	 edx, DWORD PTR _instruction$32378[ebp+4]
  000e9	8b 4d e4	 mov	 ecx, DWORD PTR _bit_res$32377[ebp]
  000ec	e8 00 00 00 00	 call	 __aullshr
  000f1	89 45 c8	 mov	 DWORD PTR _inst_norm$32384[ebp], eax
  000f4	89 55 cc	 mov	 DWORD PTR _inst_norm$32384[ebp+4], edx

; 53   : 
; 54   : 			if (((inst_norm >> 37) & 0xF) == 0x5
; 55   : 					&& ((inst_norm >> 9) & 0x7) == 0
; 56   : 					/* &&  (inst_norm & 0x3F)== 0 */
; 57   : 					) {

  000f7	8b 45 c8	 mov	 eax, DWORD PTR _inst_norm$32384[ebp]
  000fa	8b 55 cc	 mov	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  000fd	b1 25		 mov	 cl, 37			; 00000025H
  000ff	e8 00 00 00 00	 call	 __aullshr
  00104	83 e0 0f	 and	 eax, 15			; 0000000fH
  00107	83 e2 00	 and	 edx, 0
  0010a	89 45 b4	 mov	 DWORD PTR tv224[ebp], eax
  0010d	89 55 b8	 mov	 DWORD PTR tv224[ebp+4], edx
  00110	83 7d b4 05	 cmp	 DWORD PTR tv224[ebp], 5
  00114	0f 85 60 01 00
	00		 jne	 $LN6@ia64_code
  0011a	83 7d b8 00	 cmp	 DWORD PTR tv224[ebp+4], 0
  0011e	0f 85 56 01 00
	00		 jne	 $LN6@ia64_code
  00124	8b 45 c8	 mov	 eax, DWORD PTR _inst_norm$32384[ebp]
  00127	8b 55 cc	 mov	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  0012a	b1 09		 mov	 cl, 9
  0012c	e8 00 00 00 00	 call	 __aullshr
  00131	83 e0 07	 and	 eax, 7
  00134	83 e2 00	 and	 edx, 0
  00137	89 45 ac	 mov	 DWORD PTR tv239[ebp], eax
  0013a	89 55 b0	 mov	 DWORD PTR tv239[ebp+4], edx
  0013d	8b 55 ac	 mov	 edx, DWORD PTR tv239[ebp]
  00140	0b 55 b0	 or	 edx, DWORD PTR tv239[ebp+4]
  00143	0f 85 31 01 00
	00		 jne	 $LN6@ia64_code

; 58   : 				uint32_t src = (uint32_t)(
; 59   : 						(inst_norm >> 13) & 0xFFFFF);

  00149	8b 45 c8	 mov	 eax, DWORD PTR _inst_norm$32384[ebp]
  0014c	8b 55 cc	 mov	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  0014f	b1 0d		 mov	 cl, 13			; 0000000dH
  00151	e8 00 00 00 00	 call	 __aullshr
  00156	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0015b	83 e2 00	 and	 edx, 0
  0015e	89 45 c4	 mov	 DWORD PTR _src$32386[ebp], eax

; 60   : 				src |= ((inst_norm >> 36) & 1) << 20;

  00161	8b 45 c8	 mov	 eax, DWORD PTR _inst_norm$32384[ebp]
  00164	8b 55 cc	 mov	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  00167	b1 24		 mov	 cl, 36			; 00000024H
  00169	e8 00 00 00 00	 call	 __aullshr
  0016e	83 e0 01	 and	 eax, 1
  00171	83 e2 00	 and	 edx, 0
  00174	b1 14		 mov	 cl, 20			; 00000014H
  00176	e8 00 00 00 00	 call	 __allshl
  0017b	8b 4d c4	 mov	 ecx, DWORD PTR _src$32386[ebp]
  0017e	33 f6		 xor	 esi, esi
  00180	0b c8		 or	 ecx, eax
  00182	0b f2		 or	 esi, edx
  00184	89 4d c4	 mov	 DWORD PTR _src$32386[ebp], ecx

; 61   : 
; 62   : 				src <<= 4;

  00187	8b 55 c4	 mov	 edx, DWORD PTR _src$32386[ebp]
  0018a	c1 e2 04	 shl	 edx, 4
  0018d	89 55 c4	 mov	 DWORD PTR _src$32386[ebp], edx

; 63   : 
; 64   :               {
; 65   : 				uint32_t dest;
; 66   : 				size_t j;
; 67   : 
; 68   : 				if (is_encoder)

  00190	0f b6 45 10	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00194	85 c0		 test	 eax, eax
  00196	74 0e		 je	 SHORT $LN5@ia64_code

; 69   : 					dest = now_pos + (uint32_t)(i) + src;

  00198	8b 4d 0c	 mov	 ecx, DWORD PTR _now_pos$[ebp]
  0019b	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0019e	03 4d c4	 add	 ecx, DWORD PTR _src$32386[ebp]
  001a1	89 4d c0	 mov	 DWORD PTR _dest$32388[ebp], ecx

; 70   : 				else

  001a4	eb 0e		 jmp	 SHORT $LN4@ia64_code
$LN5@ia64_code:

; 71   : 					dest = src - (now_pos + (uint32_t)(i));

  001a6	8b 55 0c	 mov	 edx, DWORD PTR _now_pos$[ebp]
  001a9	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  001ac	8b 45 c4	 mov	 eax, DWORD PTR _src$32386[ebp]
  001af	2b c2		 sub	 eax, edx
  001b1	89 45 c0	 mov	 DWORD PTR _dest$32388[ebp], eax
$LN4@ia64_code:

; 72   : 
; 73   : 				dest >>= 4;

  001b4	8b 4d c0	 mov	 ecx, DWORD PTR _dest$32388[ebp]
  001b7	c1 e9 04	 shr	 ecx, 4
  001ba	89 4d c0	 mov	 DWORD PTR _dest$32388[ebp], ecx

; 74   : 
; 75   : 				inst_norm &= ~((uint64_t)(0x8FFFFF) << 13);

  001bd	8b 55 c8	 mov	 edx, DWORD PTR _inst_norm$32384[ebp]
  001c0	81 e2 ff 1f 00
	00		 and	 edx, 8191		; 00001fffH
  001c6	8b 45 cc	 mov	 eax, DWORD PTR _inst_norm$32384[ebp+4]
  001c9	83 e0 ee	 and	 eax, -18		; ffffffeeH
  001cc	89 55 c8	 mov	 DWORD PTR _inst_norm$32384[ebp], edx
  001cf	89 45 cc	 mov	 DWORD PTR _inst_norm$32384[ebp+4], eax

; 76   : 				inst_norm |= (uint64_t)(dest & 0xFFFFF) << 13;

  001d2	8b 45 c0	 mov	 eax, DWORD PTR _dest$32388[ebp]
  001d5	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  001da	33 d2		 xor	 edx, edx
  001dc	b1 0d		 mov	 cl, 13			; 0000000dH
  001de	e8 00 00 00 00	 call	 __allshl
  001e3	0b 45 c8	 or	 eax, DWORD PTR _inst_norm$32384[ebp]
  001e6	0b 55 cc	 or	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  001e9	89 45 c8	 mov	 DWORD PTR _inst_norm$32384[ebp], eax
  001ec	89 55 cc	 mov	 DWORD PTR _inst_norm$32384[ebp+4], edx

; 77   : 				inst_norm |= (uint64_t)(dest & 0x100000)
; 78   : 						<< (36 - 20);

  001ef	8b 45 c0	 mov	 eax, DWORD PTR _dest$32388[ebp]
  001f2	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  001f7	33 d2		 xor	 edx, edx
  001f9	b1 10		 mov	 cl, 16			; 00000010H
  001fb	e8 00 00 00 00	 call	 __allshl
  00200	0b 45 c8	 or	 eax, DWORD PTR _inst_norm$32384[ebp]
  00203	0b 55 cc	 or	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  00206	89 45 c8	 mov	 DWORD PTR _inst_norm$32384[ebp], eax
  00209	89 55 cc	 mov	 DWORD PTR _inst_norm$32384[ebp+4], edx

; 79   : 
; 80   : 				instruction &= (1 << bit_res) - 1;

  0020c	b8 01 00 00 00	 mov	 eax, 1
  00211	8b 4d e4	 mov	 ecx, DWORD PTR _bit_res$32377[ebp]
  00214	d3 e0		 shl	 eax, cl
  00216	83 e8 01	 sub	 eax, 1
  00219	99		 cdq
  0021a	23 45 d8	 and	 eax, DWORD PTR _instruction$32378[ebp]
  0021d	23 55 dc	 and	 edx, DWORD PTR _instruction$32378[ebp+4]
  00220	89 45 d8	 mov	 DWORD PTR _instruction$32378[ebp], eax
  00223	89 55 dc	 mov	 DWORD PTR _instruction$32378[ebp+4], edx

; 81   : 				instruction |= (inst_norm << bit_res);

  00226	8b 45 c8	 mov	 eax, DWORD PTR _inst_norm$32384[ebp]
  00229	8b 55 cc	 mov	 edx, DWORD PTR _inst_norm$32384[ebp+4]
  0022c	8b 4d e4	 mov	 ecx, DWORD PTR _bit_res$32377[ebp]
  0022f	e8 00 00 00 00	 call	 __allshl
  00234	0b 45 d8	 or	 eax, DWORD PTR _instruction$32378[ebp]
  00237	0b 55 dc	 or	 edx, DWORD PTR _instruction$32378[ebp+4]
  0023a	89 45 d8	 mov	 DWORD PTR _instruction$32378[ebp], eax
  0023d	89 55 dc	 mov	 DWORD PTR _instruction$32378[ebp+4], edx

; 82   : 
; 83   : 				for (j = 0; j < 6; j++)

  00240	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$32389[ebp], 0
  00247	eb 09		 jmp	 SHORT $LN3@ia64_code
$LN2@ia64_code:
  00249	8b 4d bc	 mov	 ecx, DWORD PTR _j$32389[ebp]
  0024c	83 c1 01	 add	 ecx, 1
  0024f	89 4d bc	 mov	 DWORD PTR _j$32389[ebp], ecx
$LN3@ia64_code:
  00252	83 7d bc 06	 cmp	 DWORD PTR _j$32389[ebp], 6
  00256	73 22		 jae	 SHORT $LN6@ia64_code

; 84   : 					buffer[i + j + byte_pos] = (uint8_t)(
; 85   : 							instruction
; 86   : 							>> (8 * j));

  00258	8b 4d bc	 mov	 ecx, DWORD PTR _j$32389[ebp]
  0025b	c1 e1 03	 shl	 ecx, 3
  0025e	8b 45 d8	 mov	 eax, DWORD PTR _instruction$32378[ebp]
  00261	8b 55 dc	 mov	 edx, DWORD PTR _instruction$32378[ebp+4]
  00264	e8 00 00 00 00	 call	 __aullshr
  00269	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0026c	03 55 bc	 add	 edx, DWORD PTR _j$32389[ebp]
  0026f	03 55 e8	 add	 edx, DWORD PTR _byte_pos$32376[ebp]
  00272	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00275	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00278	eb cf		 jmp	 SHORT $LN2@ia64_code
$LN6@ia64_code:

; 87   : 			  }
; 88   : 			}
; 89   : 		  }
; 90   : 		  }
; 91   : 		}

  0027a	e9 d5 fd ff ff	 jmp	 $LN12@ia64_code
$LN11@ia64_code:

; 92   : 	}

  0027f	e9 8c fd ff ff	 jmp	 $LN15@ia64_code
$LN14@ia64_code:

; 93   : 
; 94   : 	return i;

  00284	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 95   : }

  00287	5e		 pop	 esi
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
_ia64_code ENDP
; Function compile flags: /Odtp
;	COMDAT _ia64_coder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_is_encoder$ = 20					; size = 1
_ia64_coder_init PROC					; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	return lzma_simple_coder_init(next, allocator, filters,
; 103  : 			&ia64_code, 0, 16, 16, is_encoder);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _is_encoder$[ebp]
  00007	50		 push	 eax
  00008	6a 10		 push	 16			; 00000010H
  0000a	6a 10		 push	 16			; 00000010H
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _ia64_code
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _filters$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _lzma_simple_coder_init
  00024	83 c4 20	 add	 esp, 32			; 00000020H

; 104  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_ia64_coder_init ENDP
; Function compile flags: /Odtp
;	COMDAT _lzma_simple_ia64_decoder_init
_TEXT	SEGMENT
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_lzma_simple_ia64_decoder_init PROC			; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 121  : 	return ia64_coder_init(next, allocator, filters, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _filters$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _ia64_coder_init
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 122  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_lzma_simple_ia64_decoder_init ENDP
END
