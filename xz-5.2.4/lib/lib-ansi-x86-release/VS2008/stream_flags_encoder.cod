; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\stream_flags_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_encoder.c
;	COMDAT _stream_flags_encode
_TEXT	SEGMENT
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_stream_flags_encode PROC				; COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 	if ((unsigned int)(options->check) > LZMA_CHECK_ID_MAX)

  00003	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00006	83 78 10 0f	 cmp	 DWORD PTR [eax+16], 15	; 0000000fH
  0000a	76 04		 jbe	 SHORT $LN1@stream_fla

; 20   : 		return true;

  0000c	b0 01		 mov	 al, 1
  0000e	eb 14		 jmp	 SHORT $LN2@stream_fla
$LN1@stream_fla:

; 21   : 
; 22   : 	out[0] = 0x00;

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00013	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 23   : 	out[1] = options->check;

  00016	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  0001c	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  0001f	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 24   : 
; 25   : 	return false;

  00022	32 c0		 xor	 al, al
$LN2@stream_fla:

; 26   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_stream_flags_encode ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_common.h
_TEXT	ENDS
;	COMDAT _is_backward_size_valid
_TEXT	SEGMENT
tv71 = -20						; size = 4
tv90 = -16						; size = 8
tv79 = -8						; size = 4
tv74 = -4						; size = 4
_options$ = 8						; size = 4
_is_backward_size_valid PROC				; COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 28   : 	return options->backward_size >= LZMA_BACKWARD_SIZE_MIN
; 29   : 			&& options->backward_size <= LZMA_BACKWARD_SIZE_MAX
; 30   : 			&& (options->backward_size & 3) == 0;

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR tv74[ebp], eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR tv74[ebp]
  0000f	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00013	77 09		 ja	 SHORT $LN5@is_backwar
  00015	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  00018	83 7a 08 04	 cmp	 DWORD PTR [edx+8], 4
  0001c	72 40		 jb	 SHORT $LN3@is_backwar
$LN5@is_backwar:
  0001e	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00027	83 79 0c 04	 cmp	 DWORD PTR [ecx+12], 4
  0002b	77 31		 ja	 SHORT $LN3@is_backwar
  0002d	72 09		 jb	 SHORT $LN6@is_backwar
  0002f	8b 55 f8	 mov	 edx, DWORD PTR tv79[ebp]
  00032	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00036	77 26		 ja	 SHORT $LN3@is_backwar
$LN6@is_backwar:
  00038	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  0003b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003e	83 e1 03	 and	 ecx, 3
  00041	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00044	83 e2 00	 and	 edx, 0
  00047	89 4d f0	 mov	 DWORD PTR tv90[ebp], ecx
  0004a	89 55 f4	 mov	 DWORD PTR tv90[ebp+4], edx
  0004d	8b 45 f0	 mov	 eax, DWORD PTR tv90[ebp]
  00050	0b 45 f4	 or	 eax, DWORD PTR tv90[ebp+4]
  00053	75 09		 jne	 SHORT $LN3@is_backwar
  00055	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN4@is_backwar
$LN3@is_backwar:
  0005e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@is_backwar:
  00065	8a 45 ec	 mov	 al, BYTE PTR tv71[ebp]

; 31   : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_is_backward_size_valid ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT _write32ne
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_num$ = 12						; size = 4
_write32ne PROC						; COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	*(uint32_t *)buf = num;

  00003	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 	return;
; 269  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_write32ne ENDP
PUBLIC	_lzma_stream_footer_encode
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_encoder.c
;	COMDAT _lzma_stream_footer_encode
_TEXT	SEGMENT
tv133 = -28						; size = 4
tv149 = -24						; size = 8
tv138 = -16						; size = 4
tv75 = -12						; size = 4
$T77099 = -8						; size = 4
_crc$32249 = -4						; size = 4
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_stream_footer_encode PROC				; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 61   : 	assert(2 * 4 + LZMA_STREAM_FLAGS_SIZE + sizeof(lzma_footer_magic)
; 62   : 			== LZMA_STREAM_HEADER_SIZE);
; 63   : 
; 64   : 	if (options->version != 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	74 0a		 je	 SHORT $LN3@lzma_strea

; 65   : 		return LZMA_OPTIONS_ERROR;

  0000e	b8 08 00 00 00	 mov	 eax, 8
  00013	e9 eb 00 00 00	 jmp	 $LN4@lzma_strea
$LN3@lzma_strea:

; 66   : 
; 67   : 	// Backward Size
; 68   : 	if (!is_backward_size_valid(options))

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0001b	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
  0001e	8b 55 f4	 mov	 edx, DWORD PTR tv75[ebp]
  00021	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00025	77 09		 ja	 SHORT $LN14@lzma_strea
  00027	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0002a	83 78 08 04	 cmp	 DWORD PTR [eax+8], 4
  0002e	72 40		 jb	 SHORT $LN8@lzma_strea
$LN14@lzma_strea:
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  00033	89 4d f0	 mov	 DWORD PTR tv138[ebp], ecx
  00036	8b 55 f0	 mov	 edx, DWORD PTR tv138[ebp]
  00039	83 7a 0c 04	 cmp	 DWORD PTR [edx+12], 4
  0003d	77 31		 ja	 SHORT $LN8@lzma_strea
  0003f	72 09		 jb	 SHORT $LN15@lzma_strea
  00041	8b 45 f0	 mov	 eax, DWORD PTR tv138[ebp]
  00044	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00048	77 26		 ja	 SHORT $LN8@lzma_strea
$LN15@lzma_strea:
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _options$[ebp]
  0004d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00050	83 e2 03	 and	 edx, 3
  00053	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00056	83 e0 00	 and	 eax, 0
  00059	89 55 e8	 mov	 DWORD PTR tv149[ebp], edx
  0005c	89 45 ec	 mov	 DWORD PTR tv149[ebp+4], eax
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv149[ebp]
  00062	0b 4d ec	 or	 ecx, DWORD PTR tv149[ebp+4]
  00065	75 09		 jne	 SHORT $LN8@lzma_strea
  00067	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  0006e	eb 07		 jmp	 SHORT $LN6@lzma_strea
$LN8@lzma_strea:
  00070	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN6@lzma_strea:
  00077	0f b6 55 e4	 movzx	 edx, BYTE PTR tv133[ebp]
  0007b	85 d2		 test	 edx, edx
  0007d	75 07		 jne	 SHORT $LN2@lzma_strea

; 69   : 		return LZMA_PROG_ERROR;

  0007f	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00084	eb 7d		 jmp	 SHORT $LN4@lzma_strea
$LN2@lzma_strea:

; 70   : 
; 71   : 	unaligned_write32le(out + 4, options->backward_size / 4 - 1);

  00086	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00089	6a 00		 push	 0
  0008b	6a 04		 push	 4
  0008d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00090	51		 push	 ecx
  00091	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 __aulldiv
  0009a	83 e8 01	 sub	 eax, 1
  0009d	83 da 00	 sbb	 edx, 0
  000a0	89 45 f8	 mov	 DWORD PTR $T77099[ebp], eax
  000a3	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR $T77099[ebp]
  000a9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 72   : 
; 73   : 	// Stream Flags
; 74   : 	if (stream_flags_encode(options, out + 2 * 4))

  000ac	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  000af	83 c2 08	 add	 edx, 8
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _stream_flags_encode
  000bc	83 c4 08	 add	 esp, 8
  000bf	0f b6 c8	 movzx	 ecx, al
  000c2	85 c9		 test	 ecx, ecx
  000c4	74 07		 je	 SHORT $LN1@lzma_strea

; 75   : 		return LZMA_PROG_ERROR;

  000c6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000cb	eb 36		 jmp	 SHORT $LN4@lzma_strea
$LN1@lzma_strea:

; 76   : 
; 77   : 	// CRC32
; 78   :   {
; 79   : 	const uint32_t crc = lzma_crc32(
; 80   : 			out + 4, 4 + LZMA_STREAM_FLAGS_SIZE, 0);

  000cd	6a 00		 push	 0
  000cf	6a 06		 push	 6
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  000d4	83 c2 04	 add	 edx, 4
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 _lzma_crc32
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	89 45 fc	 mov	 DWORD PTR _crc$32249[ebp], eax

; 81   : 
; 82   : 	unaligned_write32le(out, crc);

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _crc$32249[ebp]
  000e9	89 08		 mov	 DWORD PTR [eax], ecx

; 83   :   }
; 84   : 
; 85   : 	// Magic
; 86   : 	memcpy(out + 2 * 4 + LZMA_STREAM_FLAGS_SIZE,
; 87   : 			lzma_footer_magic, sizeof(lzma_footer_magic));

  000eb	6a 02		 push	 2
  000ed	68 00 00 00 00	 push	 OFFSET _lzma_footer_magic
  000f2	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  000f5	83 c2 0a	 add	 edx, 10			; 0000000aH
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _memcpy
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : 
; 89   : 	return LZMA_OK;

  00101	33 c0		 xor	 eax, eax
$LN4@lzma_strea:

; 90   : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
_lzma_stream_footer_encode ENDP
_TEXT	ENDS
PUBLIC	_lzma_stream_header_encode
; Function compile flags: /Odtp
;	COMDAT _lzma_stream_header_encode
_TEXT	SEGMENT
_crc$32237 = -4						; size = 4
_options$ = 8						; size = 4
_out$ = 12						; size = 4
_lzma_stream_header_encode PROC				; COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 32   : 	assert(sizeof(lzma_header_magic) + LZMA_STREAM_FLAGS_SIZE
; 33   : 			+ 4 == LZMA_STREAM_HEADER_SIZE);
; 34   : 
; 35   : 	if (options->version != 0)

  00004	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00007	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000a	74 07		 je	 SHORT $LN2@lzma_strea@2

; 36   : 		return LZMA_OPTIONS_ERROR;

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	eb 55		 jmp	 SHORT $LN3@lzma_strea@2
$LN2@lzma_strea@2:

; 37   : 
; 38   : 	// Magic
; 39   : 	memcpy(out, lzma_header_magic, sizeof(lzma_header_magic));

  00013	6a 06		 push	 6
  00015	68 00 00 00 00	 push	 OFFSET _lzma_header_magic
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _memcpy
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 40   : 
; 41   : 	// Stream Flags
; 42   : 	if (stream_flags_encode(options, out + sizeof(lzma_header_magic)))

  00026	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00029	83 c2 06	 add	 edx, 6
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _options$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _stream_flags_encode
  00036	83 c4 08	 add	 esp, 8
  00039	0f b6 c8	 movzx	 ecx, al
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 07		 je	 SHORT $LN1@lzma_strea@2

; 43   : 		return LZMA_PROG_ERROR;

  00040	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00045	eb 21		 jmp	 SHORT $LN3@lzma_strea@2
$LN1@lzma_strea@2:

; 44   : 
; 45   : 	// CRC32 of the Stream Header
; 46   :   {
; 47   : 	const uint32_t crc = lzma_crc32(out + sizeof(lzma_header_magic),
; 48   : 			LZMA_STREAM_FLAGS_SIZE, 0);

  00047	6a 00		 push	 0
  00049	6a 02		 push	 2
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0004e	83 c2 06	 add	 edx, 6
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _lzma_crc32
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	89 45 fc	 mov	 DWORD PTR _crc$32237[ebp], eax

; 49   : 
; 50   : 	unaligned_write32le(out + sizeof(lzma_header_magic)
; 51   : 			+ LZMA_STREAM_FLAGS_SIZE, crc);

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _crc$32237[ebp]
  00063	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 52   :   }
; 53   : 
; 54   : 	return LZMA_OK;

  00066	33 c0		 xor	 eax, eax
$LN3@lzma_strea@2:

; 55   : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_lzma_stream_header_encode ENDP
END
