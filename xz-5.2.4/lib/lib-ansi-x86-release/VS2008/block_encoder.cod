; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\SDK\C\Library\Algorithms\Information theory and signal processing\Coding theory\Lossless compression algorithms\Dictionary coders\Lempel?Ziv\Lempel?Ziv?Markov chain (LZMA)\xz\src\c89\liblzma\common\block_encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_encoder.c
;	COMDAT _block_encoder_update
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_filters$ = 16						; size = 4
_reversed_filters$ = 20					; size = 4
_block_encoder_update PROC				; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 153  : 	lzma_block_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 154  : 
; 155  : 	if (coder->sequence != SEQ_CODE)

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0000d	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00011	74 07		 je	 SHORT $LN1@block_enco

; 156  : 		return LZMA_PROG_ERROR;

  00013	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00018	eb 14		 jmp	 SHORT $LN2@block_enco
$LN1@block_enco:

; 157  : 
; 158  : 	return lzma_next_filter_update(
; 159  : 			&coder->next, allocator, reversed_filters);

  0001a	8b 55 14	 mov	 edx, DWORD PTR _reversed_filters$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _lzma_next_filter_update
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@block_enco:

; 160  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_block_encoder_update ENDP
; Function compile flags: /Odtp
;	COMDAT _block_encoder_end
_TEXT	SEGMENT
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_block_encoder_end PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 141  : 	lzma_block_coder *coder = coder_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 142  : 	lzma_next_end(&coder->next, allocator);

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _lzma_next_end
  00017	83 c4 08	 add	 esp, 8

; 143  : 	lzma_free(coder, allocator);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _lzma_free
  00027	83 c4 08	 add	 esp, 8

; 144  : 	return;
; 145  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_block_encoder_end ENDP
; Function compile flags: /Odtp
;	COMDAT _block_encode
_TEXT	SEGMENT
tv306 = -72						; size = 8
tv253 = -64						; size = 8
tv250 = -56						; size = 8
tv70 = -48						; size = 4
tv210 = -44						; size = 8
tv207 = -36						; size = 8
_check_size$32341 = -28					; size = 4
_in_start$32324 = -24					; size = 4
_ret$32326 = -20					; size = 4
_out_used$32328 = -16					; size = 4
_out_start$32325 = -12					; size = 4
_in_used$32327 = -8					; size = 4
_coder$ = -4						; size = 4
_coder_ptr$ = 8						; size = 4
_allocator$ = 12					; size = 4
_in$ = 16						; size = 4
_in_pos$ = 20						; size = 4
_in_size$ = 24						; size = 4
_out$ = 28						; size = 4
_out_pos$ = 32						; size = 4
_out_size$ = 36						; size = 4
_action$ = 40						; size = 4
_block_encode PROC					; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	56		 push	 esi

; 53   : 	lzma_block_coder *coder = coder_ptr;

  00007	8b 45 08	 mov	 eax, DWORD PTR _coder_ptr$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _coder$[ebp], eax

; 54   : 
; 55   : 	// Check that our amount of input stays in proper limits.
; 56   : 	if (LZMA_VLI_MAX - coder->uncompressed_size < in_size - *in_pos)

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00010	83 ca ff	 or	 edx, -1
  00013	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00016	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001b	1b 41 44	 sbb	 eax, DWORD PTR [ecx+68]
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  00021	8b 75 18	 mov	 esi, DWORD PTR _in_size$[ebp]
  00024	2b 31		 sub	 esi, DWORD PTR [ecx]
  00026	33 c9		 xor	 ecx, ecx
  00028	89 55 dc	 mov	 DWORD PTR tv207[ebp], edx
  0002b	89 45 e0	 mov	 DWORD PTR tv207[ebp+4], eax
  0002e	89 75 d4	 mov	 DWORD PTR tv210[ebp], esi
  00031	89 4d d8	 mov	 DWORD PTR tv210[ebp+4], ecx
  00034	8b 55 e0	 mov	 edx, DWORD PTR tv207[ebp+4]
  00037	3b 55 d8	 cmp	 edx, DWORD PTR tv210[ebp+4]
  0003a	77 14		 ja	 SHORT $LN14@block_enco@4
  0003c	72 08		 jb	 SHORT $LN17@block_enco@4
  0003e	8b 45 dc	 mov	 eax, DWORD PTR tv207[ebp]
  00041	3b 45 d4	 cmp	 eax, DWORD PTR tv210[ebp]
  00044	73 0a		 jae	 SHORT $LN14@block_enco@4
$LN17@block_enco@4:

; 57   : 		return LZMA_DATA_ERROR;

  00046	b8 09 00 00 00	 mov	 eax, 9
  0004b	e9 6d 02 00 00	 jmp	 $LN15@block_enco@4
$LN14@block_enco@4:

; 58   : 
; 59   : 	switch (coder->sequence) {

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00053	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00056	89 55 d0	 mov	 DWORD PTR tv70[ebp], edx
  00059	83 7d d0 00	 cmp	 DWORD PTR tv70[ebp], 0
  0005d	74 19		 je	 SHORT $LN11@block_enco@4
  0005f	83 7d d0 01	 cmp	 DWORD PTR tv70[ebp], 1
  00063	0f 84 47 01 00
	00		 je	 $LN6@block_enco@4
  00069	83 7d d0 02	 cmp	 DWORD PTR tv70[ebp], 2
  0006d	0f 84 d7 01 00
	00		 je	 $LN2@block_enco@4
  00073	e9 40 02 00 00	 jmp	 $LN12@block_enco@4
$LN11@block_enco@4:

; 60   : 	case SEQ_CODE: {
; 61   : 		const size_t in_start = *in_pos;

  00078	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	89 4d e8	 mov	 DWORD PTR _in_start$32324[ebp], ecx

; 62   : 		const size_t out_start = *out_pos;

  00080	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	89 45 f4	 mov	 DWORD PTR _out_start$32325[ebp], eax

; 63   : 
; 64   : 		const lzma_ret ret = coder->next.code(coder->next.coder,
; 65   : 				allocator, in, in_pos, in_size,
; 66   : 				out, out_pos, out_size, action);

  00088	8b 4d 28	 mov	 ecx, DWORD PTR _action$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 55 24	 mov	 edx, DWORD PTR _out_size$[ebp]
  0008f	52		 push	 edx
  00090	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 1c	 mov	 ecx, DWORD PTR _out$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 18	 mov	 edx, DWORD PTR _in_size$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 14	 mov	 eax, DWORD PTR _in_pos$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  000ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ad	51		 push	 ecx
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000b1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000b4	ff d0		 call	 eax
  000b6	83 c4 24	 add	 esp, 36			; 00000024H
  000b9	89 45 ec	 mov	 DWORD PTR _ret$32326[ebp], eax

; 67   : 
; 68   : 		const size_t in_used = *in_pos - in_start;

  000bc	8b 4d 14	 mov	 ecx, DWORD PTR _in_pos$[ebp]
  000bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c1	2b 55 e8	 sub	 edx, DWORD PTR _in_start$32324[ebp]
  000c4	89 55 f8	 mov	 DWORD PTR _in_used$32327[ebp], edx

; 69   : 		const size_t out_used = *out_pos - out_start;

  000c7	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	2b 4d f4	 sub	 ecx, DWORD PTR _out_start$32325[ebp]
  000cf	89 4d f0	 mov	 DWORD PTR _out_used$32328[ebp], ecx

; 70   : 
; 71   : 		if (COMPRESSED_SIZE_MAX - coder->compressed_size < out_used)

  000d2	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  000d5	b8 bc fb ff ff	 mov	 eax, -1092		; fffffbbcH
  000da	2b 42 38	 sub	 eax, DWORD PTR [edx+56]
  000dd	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  000e2	1b 4a 3c	 sbb	 ecx, DWORD PTR [edx+60]
  000e5	8b 55 f0	 mov	 edx, DWORD PTR _out_used$32328[ebp]
  000e8	33 f6		 xor	 esi, esi
  000ea	89 45 c8	 mov	 DWORD PTR tv250[ebp], eax
  000ed	89 4d cc	 mov	 DWORD PTR tv250[ebp+4], ecx
  000f0	89 55 c0	 mov	 DWORD PTR tv253[ebp], edx
  000f3	89 75 c4	 mov	 DWORD PTR tv253[ebp+4], esi
  000f6	8b 45 cc	 mov	 eax, DWORD PTR tv250[ebp+4]
  000f9	3b 45 c4	 cmp	 eax, DWORD PTR tv253[ebp+4]
  000fc	77 14		 ja	 SHORT $LN10@block_enco@4
  000fe	72 08		 jb	 SHORT $LN18@block_enco@4
  00100	8b 4d c8	 mov	 ecx, DWORD PTR tv250[ebp]
  00103	3b 4d c0	 cmp	 ecx, DWORD PTR tv253[ebp]
  00106	73 0a		 jae	 SHORT $LN10@block_enco@4
$LN18@block_enco@4:

; 72   : 			return LZMA_DATA_ERROR;

  00108	b8 09 00 00 00	 mov	 eax, 9
  0010d	e9 ab 01 00 00	 jmp	 $LN15@block_enco@4
$LN10@block_enco@4:

; 73   : 
; 74   : 		coder->compressed_size += out_used;

  00112	8b 55 f0	 mov	 edx, DWORD PTR _out_used$32328[ebp]
  00115	33 c0		 xor	 eax, eax
  00117	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0011a	03 51 38	 add	 edx, DWORD PTR [ecx+56]
  0011d	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00120	13 c8		 adc	 ecx, eax
  00122	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00125	89 50 38	 mov	 DWORD PTR [eax+56], edx
  00128	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 75   : 
; 76   : 		// No need to check for overflow because we have already
; 77   : 		// checked it at the beginning of this function.
; 78   : 		coder->uncompressed_size += in_used;

  0012b	8b 4d f8	 mov	 ecx, DWORD PTR _in_used$32327[ebp]
  0012e	33 d2		 xor	 edx, edx
  00130	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00133	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00136	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00139	13 c2		 adc	 eax, edx
  0013b	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0013e	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
  00141	89 42 44	 mov	 DWORD PTR [edx+68], eax

; 79   : 
; 80   : 		lzma_check_update(&coder->check, coder->block->check,
; 81   : 				in + in_start, in_used);

  00144	8b 45 f8	 mov	 eax, DWORD PTR _in_used$32327[ebp]
  00147	50		 push	 eax
  00148	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  0014b	03 4d e8	 add	 ecx, DWORD PTR _in_start$32324[ebp]
  0014e	51		 push	 ecx
  0014f	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00152	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00155	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00158	51		 push	 ecx
  00159	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0015c	83 c2 50	 add	 edx, 80			; 00000050H
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 _lzma_check_update
  00165	83 c4 10	 add	 esp, 16			; 00000010H

; 82   : 
; 83   : 		if (ret != LZMA_STREAM_END || action == LZMA_SYNC_FLUSH)

  00168	83 7d ec 01	 cmp	 DWORD PTR _ret$32326[ebp], 1
  0016c	75 06		 jne	 SHORT $LN8@block_enco@4
  0016e	83 7d 28 01	 cmp	 DWORD PTR _action$[ebp], 1
  00172	75 08		 jne	 SHORT $LN9@block_enco@4
$LN8@block_enco@4:

; 84   : 			return ret;

  00174	8b 45 ec	 mov	 eax, DWORD PTR _ret$32326[ebp]
  00177	e9 41 01 00 00	 jmp	 $LN15@block_enco@4
$LN9@block_enco@4:

; 85   : 
; 86   : 		assert(*in_pos == in_size);
; 87   : 		assert(action == LZMA_FINISH);
; 88   : 
; 89   : 		// Copy the values into coder->block. The caller
; 90   : 		// may use this information to construct Index.
; 91   : 		coder->block->compressed_size = coder->compressed_size;

  0017c	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0017f	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00182	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00185	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00188	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0018b	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  0018e	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 92   : 		coder->block->uncompressed_size = coder->uncompressed_size;

  00191	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00194	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00197	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  0019a	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0019d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001a0	8b 52 44	 mov	 edx, DWORD PTR [edx+68]
  001a3	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 93   : 
; 94   : 		coder->sequence = SEQ_PADDING;

  001a6	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  001a9	c7 40 34 01 00
	00 00		 mov	 DWORD PTR [eax+52], 1
$LN6@block_enco@4:

; 95   : 	}
; 96   : 
; 97   : 	// Fall through
; 98   : 
; 99   : 	case SEQ_PADDING:
; 100  : 		// Pad Compressed Data to a multiple of four bytes. We can
; 101  : 		// use coder->compressed_size for this since we don't need
; 102  : 		// it for anything else anymore.
; 103  : 		while (coder->compressed_size & 3) {

  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001b3	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001b6	83 e2 03	 and	 edx, 3
  001b9	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  001bc	83 e0 00	 and	 eax, 0
  001bf	89 55 b8	 mov	 DWORD PTR tv306[ebp], edx
  001c2	89 45 bc	 mov	 DWORD PTR tv306[ebp+4], eax
  001c5	8b 4d b8	 mov	 ecx, DWORD PTR tv306[ebp]
  001c8	0b 4d bc	 or	 ecx, DWORD PTR tv306[ebp+4]
  001cb	74 44		 je	 SHORT $LN5@block_enco@4

; 104  : 			if (*out_pos >= out_size)

  001cd	8b 55 20	 mov	 edx, DWORD PTR _out_pos$[ebp]
  001d0	8b 02		 mov	 eax, DWORD PTR [edx]
  001d2	3b 45 24	 cmp	 eax, DWORD PTR _out_size$[ebp]
  001d5	72 07		 jb	 SHORT $LN4@block_enco@4

; 105  : 				return LZMA_OK;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 df 00 00 00	 jmp	 $LN15@block_enco@4
$LN4@block_enco@4:

; 106  : 
; 107  : 			out[*out_pos] = 0x00;

  001de	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e3	8b 45 1c	 mov	 eax, DWORD PTR _out$[ebp]
  001e6	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 108  : 			++*out_pos;

  001ea	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  001ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ef	83 c2 01	 add	 edx, 1
  001f2	8b 45 20	 mov	 eax, DWORD PTR _out_pos$[ebp]
  001f5	89 10		 mov	 DWORD PTR [eax], edx

; 109  : 			++coder->compressed_size;

  001f7	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  001fa	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001fd	83 c2 01	 add	 edx, 1
  00200	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00203	83 d0 00	 adc	 eax, 0
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00209	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  0020c	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 110  : 		}

  0020f	eb 9f		 jmp	 SHORT $LN6@block_enco@4
$LN5@block_enco@4:

; 111  : 
; 112  : 		if (coder->block->check == LZMA_CHECK_NONE)

  00211	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00214	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00217	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0021b	75 0a		 jne	 SHORT $LN3@block_enco@4

; 113  : 			return LZMA_STREAM_END;

  0021d	b8 01 00 00 00	 mov	 eax, 1
  00222	e9 96 00 00 00	 jmp	 $LN15@block_enco@4
$LN3@block_enco@4:

; 114  : 
; 115  : 		lzma_check_finish(&coder->check, coder->block->check);

  00227	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  0022a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0022d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00230	50		 push	 eax
  00231	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00234	83 c1 50	 add	 ecx, 80			; 00000050H
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 _lzma_check_finish
  0023d	83 c4 08	 add	 esp, 8

; 116  : 
; 117  : 		coder->sequence = SEQ_CHECK;

  00240	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00243	c7 42 34 02 00
	00 00		 mov	 DWORD PTR [edx+52], 2
$LN2@block_enco@4:

; 118  : 
; 119  : 	// Fall through
; 120  : 
; 121  : 	case SEQ_CHECK: {
; 122  : 		const size_t check_size = lzma_check_size(coder->block->check);

  0024a	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0024d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00250	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 _lzma_check_size
  00259	83 c4 04	 add	 esp, 4
  0025c	89 45 e4	 mov	 DWORD PTR _check_size$32341[ebp], eax

; 123  : 		lzma_bufcpy(coder->check.buffer.u8, &coder->pos, check_size,
; 124  : 				out, out_pos, out_size);

  0025f	8b 45 24	 mov	 eax, DWORD PTR _out_size$[ebp]
  00262	50		 push	 eax
  00263	8b 4d 20	 mov	 ecx, DWORD PTR _out_pos$[ebp]
  00266	51		 push	 ecx
  00267	8b 55 1c	 mov	 edx, DWORD PTR _out$[ebp]
  0026a	52		 push	 edx
  0026b	8b 45 e4	 mov	 eax, DWORD PTR _check_size$32341[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  00272	83 c1 48	 add	 ecx, 72			; 00000048H
  00275	51		 push	 ecx
  00276	8b 55 fc	 mov	 edx, DWORD PTR _coder$[ebp]
  00279	83 c2 50	 add	 edx, 80			; 00000050H
  0027c	52		 push	 edx
  0027d	e8 00 00 00 00	 call	 _lzma_bufcpy
  00282	83 c4 18	 add	 esp, 24			; 00000018H

; 125  : 		if (coder->pos < check_size)

  00285	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  00288	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0028b	3b 4d e4	 cmp	 ecx, DWORD PTR _check_size$32341[ebp]
  0028e	73 04		 jae	 SHORT $LN1@block_enco@4

; 126  : 			return LZMA_OK;

  00290	33 c0		 xor	 eax, eax
  00292	eb 29		 jmp	 SHORT $LN15@block_enco@4
$LN1@block_enco@4:

; 127  : 
; 128  : 		memcpy(coder->block->raw_check, coder->check.buffer.u8,
; 129  : 				check_size);

  00294	8b 55 e4	 mov	 edx, DWORD PTR _check_size$32341[ebp]
  00297	52		 push	 edx
  00298	8b 45 fc	 mov	 eax, DWORD PTR _coder$[ebp]
  0029b	83 c0 50	 add	 eax, 80			; 00000050H
  0029e	50		 push	 eax
  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _coder$[ebp]
  002a2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002a5	83 c2 24	 add	 edx, 36			; 00000024H
  002a8	52		 push	 edx
  002a9	e8 00 00 00 00	 call	 _memcpy
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  : 		return LZMA_STREAM_END;

  002b1	b8 01 00 00 00	 mov	 eax, 1
  002b6	eb 05		 jmp	 SHORT $LN15@block_enco@4
$LN12@block_enco@4:

; 131  : 	}
; 132  : 	}
; 133  : 
; 134  : 	return LZMA_PROG_ERROR;

  002b8	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
$LN15@block_enco@4:

; 135  : }

  002bd	5e		 pop	 esi
  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
_block_encode ENDP
PUBLIC	_lzma_block_encoder_init
; Function compile flags: /Odtp
;	COMDAT _lzma_block_encoder_init
_TEXT	SEGMENT
_coder$32381 = -4					; size = 4
_next$ = 8						; size = 4
_allocator$ = 12					; size = 4
_block$ = 16						; size = 4
_lzma_block_encoder_init PROC				; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
$LN10@lzma_block@8:

; 167  : 	lzma_next_coder_init(&lzma_block_encoder_init, next, allocator);

  00006	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00009	81 78 10 00 00
	00 00		 cmp	 DWORD PTR [eax+16], OFFSET _lzma_block_encoder_init
  00010	74 10		 je	 SHORT $LN7@lzma_block@8
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _allocator$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 _lzma_next_end
  0001f	83 c4 08	 add	 esp, 8
$LN7@lzma_block@8:
  00022	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  00025	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _lzma_block_encoder_init
  0002c	33 c9		 xor	 ecx, ecx
  0002e	75 d6		 jne	 SHORT $LN10@lzma_block@8

; 168  : 
; 169  : 	if (block == NULL)

  00030	83 7d 10 00	 cmp	 DWORD PTR _block$[ebp], 0
  00034	75 0a		 jne	 SHORT $LN6@lzma_block@8

; 170  : 		return LZMA_PROG_ERROR;

  00036	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0003b	e9 18 01 00 00	 jmp	 $LN11@lzma_block@8
$LN6@lzma_block@8:

; 171  : 
; 172  : 	// The contents of the structure may depend on the version so
; 173  : 	// check the version first.
; 174  : 	if (block->version > 1)

  00040	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  00043	83 3a 01	 cmp	 DWORD PTR [edx], 1
  00046	76 0a		 jbe	 SHORT $LN5@lzma_block@8

; 175  : 		return LZMA_OPTIONS_ERROR;

  00048	b8 08 00 00 00	 mov	 eax, 8
  0004d	e9 06 01 00 00	 jmp	 $LN11@lzma_block@8
$LN5@lzma_block@8:

; 176  : 
; 177  : 	// If the Check ID is not supported, we cannot calculate the check and
; 178  : 	// thus not create a proper Block.
; 179  : 	if ((unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  00052	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  00055	83 78 08 0f	 cmp	 DWORD PTR [eax+8], 15	; 0000000fH
  00059	76 0a		 jbe	 SHORT $LN4@lzma_block@8

; 180  : 		return LZMA_PROG_ERROR;

  0005b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00060	e9 f3 00 00 00	 jmp	 $LN11@lzma_block@8
$LN4@lzma_block@8:

; 181  : 
; 182  : 	if (!lzma_check_is_supported(block->check))

  00065	8b 4d 10	 mov	 ecx, DWORD PTR _block$[ebp]
  00068	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _lzma_check_is_supported
  00071	83 c4 04	 add	 esp, 4
  00074	0f b6 c0	 movzx	 eax, al
  00077	85 c0		 test	 eax, eax
  00079	75 0a		 jne	 SHORT $LN3@lzma_block@8

; 183  : 		return LZMA_UNSUPPORTED_CHECK;

  0007b	b8 03 00 00 00	 mov	 eax, 3
  00080	e9 d3 00 00 00	 jmp	 $LN11@lzma_block@8
$LN3@lzma_block@8:

; 184  : 
; 185  : 	// Allocate and initialize *next->coder if needed.
; 186  :   {
; 187  : 	lzma_block_coder *coder = next->coder;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  00088	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008a	89 55 fc	 mov	 DWORD PTR _coder$32381[ebp], edx

; 188  : 	if (coder == NULL) {

  0008d	83 7d fc 00	 cmp	 DWORD PTR _coder$32381[ebp], 0
  00091	75 59		 jne	 SHORT $LN2@lzma_block@8

; 189  : 		coder = lzma_alloc(sizeof(lzma_block_coder), allocator);

  00093	8b 45 0c	 mov	 eax, DWORD PTR _allocator$[ebp]
  00096	50		 push	 eax
  00097	68 b8 00 00 00	 push	 184			; 000000b8H
  0009c	e8 00 00 00 00	 call	 _lzma_alloc
  000a1	83 c4 08	 add	 esp, 8
  000a4	89 45 fc	 mov	 DWORD PTR _coder$32381[ebp], eax

; 190  : 		if (coder == NULL)

  000a7	83 7d fc 00	 cmp	 DWORD PTR _coder$32381[ebp], 0
  000ab	75 0a		 jne	 SHORT $LN1@lzma_block@8

; 191  : 			return LZMA_MEM_ERROR;

  000ad	b8 05 00 00 00	 mov	 eax, 5
  000b2	e9 a1 00 00 00	 jmp	 $LN11@lzma_block@8
$LN1@lzma_block@8:

; 192  : 
; 193  : 		next->coder = coder;

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  000ba	8b 55 fc	 mov	 edx, DWORD PTR _coder$32381[ebp]
  000bd	89 11		 mov	 DWORD PTR [ecx], edx

; 194  : 		next->code = &block_encode;

  000bf	8b 45 08	 mov	 eax, DWORD PTR _next$[ebp]
  000c2	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _block_encode

; 195  : 		next->end = &block_encoder_end;

  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _next$[ebp]
  000cc	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _block_encoder_end

; 196  : 		next->update = &block_encoder_update;

  000d3	8b 55 08	 mov	 edx, DWORD PTR _next$[ebp]
  000d6	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _block_encoder_update

; 197  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000dd	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000e2	be 00 00 00 00	 mov	 esi, OFFSET _LZMA_NEXT_CODER_INIT
  000e7	8b 7d fc	 mov	 edi, DWORD PTR _coder$32381[ebp]
  000ea	f3 a5		 rep movsd
$LN2@lzma_block@8:

; 198  : 	}
; 199  : 
; 200  : 	// Basic initializations
; 201  : 	coder->sequence = SEQ_CODE;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _coder$32381[ebp]
  000ef	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 202  : 	coder->block = block;

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32381[ebp]
  000f9	8b 55 10	 mov	 edx, DWORD PTR _block$[ebp]
  000fc	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 203  : 	coder->compressed_size = 0;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _coder$32381[ebp]
  00102	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  00109	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 204  : 	coder->uncompressed_size = 0;

  00110	8b 4d fc	 mov	 ecx, DWORD PTR _coder$32381[ebp]
  00113	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  0011a	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 205  : 	coder->pos = 0;

  00121	8b 55 fc	 mov	 edx, DWORD PTR _coder$32381[ebp]
  00124	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 206  : 
; 207  : 	// Initialize the check
; 208  : 	lzma_check_init(&coder->check, block->check);

  0012b	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  0012e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00131	51		 push	 ecx
  00132	8b 55 fc	 mov	 edx, DWORD PTR _coder$32381[ebp]
  00135	83 c2 50	 add	 edx, 80			; 00000050H
  00138	52		 push	 edx
  00139	e8 00 00 00 00	 call	 _lzma_check_init
  0013e	83 c4 08	 add	 esp, 8

; 209  : 
; 210  : 	// Initialize the requested filters.
; 211  : 	return lzma_raw_encoder_init(&coder->next, allocator, block->filters);

  00141	8b 45 10	 mov	 eax, DWORD PTR _block$[ebp]
  00144	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00147	51		 push	 ecx
  00148	8b 55 0c	 mov	 edx, DWORD PTR _allocator$[ebp]
  0014b	52		 push	 edx
  0014c	8b 45 fc	 mov	 eax, DWORD PTR _coder$32381[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _lzma_raw_encoder_init
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@lzma_block@8:

; 212  :   }
; 213  : }

  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
_lzma_block_encoder_init ENDP
END
