; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_ia64_decoder_init
	ORG $+2
?BRANCH_TABLE@?1??ia64_code@@9@9 DD 00H			; `ia64_code'::`2'::BRANCH_TABLE
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	04H
	DD	06H
	DD	06H
	DD	00H
	DD	00H
	DD	07H
	DD	07H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\ia64.c
pdata	SEGMENT
$pdata$ia64_code DD imagerel ia64_code
	DD	imagerel ia64_code+747
	DD	imagerel $unwind$ia64_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ia64_code DD 011701H
	DD	0c217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ia64_code
_TEXT	SEGMENT
i$ = 0
mask$32960 = 8
instr_template$32959 = 12
bit_pos$32961 = 16
slot$32962 = 24
byte_pos$32967 = 32
bit_res$32968 = 40
instruction$32969 = 48
j$32970 = 56
inst_norm$32975 = 64
src$32977 = 72
dest$32979 = 76
j$32980 = 80
simple$ = 112
now_pos$ = 120
is_encoder$ = 128
buffer$ = 136
size$ = 144
ia64_code PROC						; COMDAT

; 21   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 22   : 	static const uint32_t BRANCH_TABLE[32] = {
; 23   : 		0, 0, 0, 0, 0, 0, 0, 0,
; 24   : 		0, 0, 0, 0, 0, 0, 0, 0,
; 25   : 		4, 4, 6, 6, 0, 0, 7, 7,
; 26   : 		4, 4, 0, 0, 4, 4, 0, 0
; 27   : 	};
; 28   : 
; 29   : 	size_t i;
; 30   : 	for (i = 0; i + 16 <= size; i += 16) {

  00017	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001f	eb 0c		 jmp	 SHORT $LN16@ia64_code
$LN15@ia64_code:
  00021	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00025	48 83 c0 10	 add	 rax, 16
  00029	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN16@ia64_code:
  0002d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00031	48 83 c0 10	 add	 rax, 16
  00035	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR size$[rsp]
  0003d	0f 87 9f 02 00
	00		 ja	 $LN14@ia64_code

; 31   : 		const uint32_t instr_template = buffer[i] & 0x1F;

  00043	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00047	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0004f	48 03 c1	 add	 rax, rcx
  00052	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00055	83 e0 1f	 and	 eax, 31
  00058	89 44 24 0c	 mov	 DWORD PTR instr_template$32959[rsp], eax

; 32   : 		const uint32_t mask = BRANCH_TABLE[instr_template];

  0005c	8b 4c 24 0c	 mov	 ecx, DWORD PTR instr_template$32959[rsp]
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?BRANCH_TABLE@?1??ia64_code@@9@9
  00067	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0006a	89 44 24 08	 mov	 DWORD PTR mask$32960[rsp], eax

; 33   : 		uint32_t bit_pos = 5;

  0006e	c7 44 24 10 05
	00 00 00	 mov	 DWORD PTR bit_pos$32961[rsp], 5

; 34   : 		size_t slot;
; 35   : 
; 36   : 		for (slot = 0; slot < 3; ++slot, bit_pos += 41) {

  00076	48 c7 44 24 18
	00 00 00 00	 mov	 QWORD PTR slot$32962[rsp], 0
  0007f	eb 19		 jmp	 SHORT $LN13@ia64_code
$LN12@ia64_code:
  00081	48 8b 44 24 18	 mov	 rax, QWORD PTR slot$32962[rsp]
  00086	48 83 c0 01	 add	 rax, 1
  0008a	48 89 44 24 18	 mov	 QWORD PTR slot$32962[rsp], rax
  0008f	8b 44 24 10	 mov	 eax, DWORD PTR bit_pos$32961[rsp]
  00093	83 c0 29	 add	 eax, 41			; 00000029H
  00096	89 44 24 10	 mov	 DWORD PTR bit_pos$32961[rsp], eax
$LN13@ia64_code:
  0009a	48 83 7c 24 18
	03		 cmp	 QWORD PTR slot$32962[rsp], 3
  000a0	0f 83 37 02 00
	00		 jae	 $LN11@ia64_code

; 37   : 			if (((mask >> slot) & 1) == 0)

  000a6	48 8b 44 24 18	 mov	 rax, QWORD PTR slot$32962[rsp]
  000ab	0f b6 c8	 movzx	 ecx, al
  000ae	8b 44 24 08	 mov	 eax, DWORD PTR mask$32960[rsp]
  000b2	d3 e8		 shr	 eax, cl
  000b4	83 e0 01	 and	 eax, 1
  000b7	85 c0		 test	 eax, eax
  000b9	75 02		 jne	 SHORT $LN10@ia64_code

; 38   : 				continue;

  000bb	eb c4		 jmp	 SHORT $LN12@ia64_code
$LN10@ia64_code:

; 39   : 
; 40   :           {
; 41   : 			const size_t byte_pos = (bit_pos >> 3);

  000bd	8b 44 24 10	 mov	 eax, DWORD PTR bit_pos$32961[rsp]
  000c1	c1 e8 03	 shr	 eax, 3
  000c4	8b c0		 mov	 eax, eax
  000c6	48 89 44 24 20	 mov	 QWORD PTR byte_pos$32967[rsp], rax

; 42   : 			const uint32_t bit_res = bit_pos & 0x7;

  000cb	8b 44 24 10	 mov	 eax, DWORD PTR bit_pos$32961[rsp]
  000cf	83 e0 07	 and	 eax, 7
  000d2	89 44 24 28	 mov	 DWORD PTR bit_res$32968[rsp], eax

; 43   : 			uint64_t instruction = 0;

  000d6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR instruction$32969[rsp], 0

; 44   : 			size_t j;
; 45   : 
; 46   : 			for (j = 0; j < 6; ++j)

  000df	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$32970[rsp], 0
  000e8	eb 0e		 jmp	 SHORT $LN9@ia64_code
$LN8@ia64_code:
  000ea	48 8b 44 24 38	 mov	 rax, QWORD PTR j$32970[rsp]
  000ef	48 83 c0 01	 add	 rax, 1
  000f3	48 89 44 24 38	 mov	 QWORD PTR j$32970[rsp], rax
$LN9@ia64_code:
  000f8	48 83 7c 24 38
	06		 cmp	 QWORD PTR j$32970[rsp], 6
  000fe	73 41		 jae	 SHORT $LN7@ia64_code

; 47   : 				instruction += (uint64_t)(
; 48   : 						buffer[i + j + byte_pos])
; 49   : 						<< (8 * j);

  00100	48 8b 44 24 38	 mov	 rax, QWORD PTR j$32970[rsp]
  00105	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00109	48 03 c8	 add	 rcx, rax
  0010c	48 03 4c 24 20	 add	 rcx, QWORD PTR byte_pos$32967[rsp]
  00111	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00119	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR j$32970[rsp]
  00122	48 c1 e0 03	 shl	 rax, 3
  00126	0f b6 c8	 movzx	 ecx, al
  00129	48 8b c2	 mov	 rax, rdx
  0012c	48 d3 e0	 shl	 rax, cl
  0012f	48 8b c8	 mov	 rcx, rax
  00132	48 8b 44 24 30	 mov	 rax, QWORD PTR instruction$32969[rsp]
  00137	48 03 c1	 add	 rax, rcx
  0013a	48 89 44 24 30	 mov	 QWORD PTR instruction$32969[rsp], rax
  0013f	eb a9		 jmp	 SHORT $LN8@ia64_code
$LN7@ia64_code:

; 50   : 
; 51   :           {
; 52   : 			uint64_t inst_norm = instruction >> bit_res;

  00141	8b 44 24 28	 mov	 eax, DWORD PTR bit_res$32968[rsp]
  00145	0f b6 c8	 movzx	 ecx, al
  00148	48 8b 44 24 30	 mov	 rax, QWORD PTR instruction$32969[rsp]
  0014d	48 d3 e8	 shr	 rax, cl
  00150	48 89 44 24 40	 mov	 QWORD PTR inst_norm$32975[rsp], rax

; 53   : 
; 54   : 			if (((inst_norm >> 37) & 0xF) == 0x5
; 55   : 					&& ((inst_norm >> 9) & 0x7) == 0
; 56   : 					/* &&  (inst_norm & 0x3F)== 0 */
; 57   : 					) {

  00155	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  0015a	48 c1 e8 25	 shr	 rax, 37			; 00000025H
  0015e	48 83 e0 0f	 and	 rax, 15
  00162	48 83 f8 05	 cmp	 rax, 5
  00166	0f 85 6c 01 00
	00		 jne	 $LN6@ia64_code
  0016c	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00171	48 c1 e8 09	 shr	 rax, 9
  00175	48 83 e0 07	 and	 rax, 7
  00179	48 85 c0	 test	 rax, rax
  0017c	0f 85 56 01 00
	00		 jne	 $LN6@ia64_code

; 58   : 				uint32_t src = (uint32_t)(
; 59   : 						(inst_norm >> 13) & 0xFFFFF);

  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00187	48 c1 e8 0d	 shr	 rax, 13
  0018b	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  00191	89 44 24 48	 mov	 DWORD PTR src$32977[rsp], eax

; 60   : 				src |= ((inst_norm >> 36) & 1) << 20;

  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst_norm$32975[rsp]
  0019a	48 c1 e9 24	 shr	 rcx, 36			; 00000024H
  0019e	48 83 e1 01	 and	 rcx, 1
  001a2	48 c1 e1 14	 shl	 rcx, 20
  001a6	8b 44 24 48	 mov	 eax, DWORD PTR src$32977[rsp]
  001aa	48 0b c1	 or	 rax, rcx
  001ad	89 44 24 48	 mov	 DWORD PTR src$32977[rsp], eax

; 61   : 
; 62   : 				src <<= 4;

  001b1	8b 44 24 48	 mov	 eax, DWORD PTR src$32977[rsp]
  001b5	c1 e0 04	 shl	 eax, 4
  001b8	89 44 24 48	 mov	 DWORD PTR src$32977[rsp], eax

; 63   : 
; 64   :               {
; 65   : 				uint32_t dest;
; 66   : 				size_t j;
; 67   : 
; 68   : 				if (is_encoder)

  001bc	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  001c4	85 c0		 test	 eax, eax
  001c6	74 13		 je	 SHORT $LN5@ia64_code

; 69   : 					dest = now_pos + (uint32_t)(i) + src;

  001c8	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  001cb	8b 44 24 78	 mov	 eax, DWORD PTR now_pos$[rsp]
  001cf	03 c1		 add	 eax, ecx
  001d1	03 44 24 48	 add	 eax, DWORD PTR src$32977[rsp]
  001d5	89 44 24 4c	 mov	 DWORD PTR dest$32979[rsp], eax

; 70   : 				else

  001d9	eb 13		 jmp	 SHORT $LN4@ia64_code
$LN5@ia64_code:

; 71   : 					dest = src - (now_pos + (uint32_t)(i));

  001db	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  001de	8b 4c 24 78	 mov	 ecx, DWORD PTR now_pos$[rsp]
  001e2	03 c8		 add	 ecx, eax
  001e4	8b 44 24 48	 mov	 eax, DWORD PTR src$32977[rsp]
  001e8	2b c1		 sub	 eax, ecx
  001ea	89 44 24 4c	 mov	 DWORD PTR dest$32979[rsp], eax
$LN4@ia64_code:

; 72   : 
; 73   : 				dest >>= 4;

  001ee	8b 44 24 4c	 mov	 eax, DWORD PTR dest$32979[rsp]
  001f2	c1 e8 04	 shr	 eax, 4
  001f5	89 44 24 4c	 mov	 DWORD PTR dest$32979[rsp], eax

; 74   : 
; 75   : 				inst_norm &= ~((uint64_t)(0x8FFFFF) << 13);

  001f9	48 b9 ff 1f 00
	00 ee ff ff ff	 mov	 rcx, -77309403137	; ffffffee00001fffH
  00203	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00208	48 23 c1	 and	 rax, rcx
  0020b	48 89 44 24 40	 mov	 QWORD PTR inst_norm$32975[rsp], rax

; 76   : 				inst_norm |= (uint64_t)(dest & 0xFFFFF) << 13;

  00210	8b 44 24 4c	 mov	 eax, DWORD PTR dest$32979[rsp]
  00214	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  00219	8b c8		 mov	 ecx, eax
  0021b	48 c1 e1 0d	 shl	 rcx, 13
  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00224	48 0b c1	 or	 rax, rcx
  00227	48 89 44 24 40	 mov	 QWORD PTR inst_norm$32975[rsp], rax

; 77   : 				inst_norm |= (uint64_t)(dest & 0x100000)
; 78   : 						<< (36 - 20);

  0022c	8b 44 24 4c	 mov	 eax, DWORD PTR dest$32979[rsp]
  00230	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00235	8b c8		 mov	 ecx, eax
  00237	48 c1 e1 10	 shl	 rcx, 16
  0023b	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00240	48 0b c1	 or	 rax, rcx
  00243	48 89 44 24 40	 mov	 QWORD PTR inst_norm$32975[rsp], rax

; 79   : 
; 80   : 				instruction &= (1 << bit_res) - 1;

  00248	8b 4c 24 28	 mov	 ecx, DWORD PTR bit_res$32968[rsp]
  0024c	b8 01 00 00 00	 mov	 eax, 1
  00251	d3 e0		 shl	 eax, cl
  00253	83 e8 01	 sub	 eax, 1
  00256	48 63 c8	 movsxd	 rcx, eax
  00259	48 8b 44 24 30	 mov	 rax, QWORD PTR instruction$32969[rsp]
  0025e	48 23 c1	 and	 rax, rcx
  00261	48 89 44 24 30	 mov	 QWORD PTR instruction$32969[rsp], rax

; 81   : 				instruction |= (inst_norm << bit_res);

  00266	8b 44 24 28	 mov	 eax, DWORD PTR bit_res$32968[rsp]
  0026a	0f b6 c8	 movzx	 ecx, al
  0026d	48 8b 44 24 40	 mov	 rax, QWORD PTR inst_norm$32975[rsp]
  00272	48 d3 e0	 shl	 rax, cl
  00275	48 8b c8	 mov	 rcx, rax
  00278	48 8b 44 24 30	 mov	 rax, QWORD PTR instruction$32969[rsp]
  0027d	48 0b c1	 or	 rax, rcx
  00280	48 89 44 24 30	 mov	 QWORD PTR instruction$32969[rsp], rax

; 82   : 
; 83   : 				for (j = 0; j < 6; j++)

  00285	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$32980[rsp], 0
  0028e	eb 0e		 jmp	 SHORT $LN3@ia64_code
$LN2@ia64_code:
  00290	48 8b 44 24 50	 mov	 rax, QWORD PTR j$32980[rsp]
  00295	48 83 c0 01	 add	 rax, 1
  00299	48 89 44 24 50	 mov	 QWORD PTR j$32980[rsp], rax
$LN3@ia64_code:
  0029e	48 83 7c 24 50
	06		 cmp	 QWORD PTR j$32980[rsp], 6
  002a4	73 32		 jae	 SHORT $LN1@ia64_code

; 84   : 					buffer[i + j + byte_pos] = (uint8_t)(
; 85   : 							instruction
; 86   : 							>> (8 * j));

  002a6	48 8b 44 24 50	 mov	 rax, QWORD PTR j$32980[rsp]
  002ab	48 c1 e0 03	 shl	 rax, 3
  002af	0f b6 c8	 movzx	 ecx, al
  002b2	48 8b 54 24 30	 mov	 rdx, QWORD PTR instruction$32969[rsp]
  002b7	48 d3 ea	 shr	 rdx, cl
  002ba	48 8b 44 24 50	 mov	 rax, QWORD PTR j$32980[rsp]
  002bf	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  002c3	48 03 c8	 add	 rcx, rax
  002c6	48 03 4c 24 20	 add	 rcx, QWORD PTR byte_pos$32967[rsp]
  002cb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  002d3	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  002d6	eb b8		 jmp	 SHORT $LN2@ia64_code
$LN1@ia64_code:
$LN6@ia64_code:

; 87   : 			  }
; 88   : 			}
; 89   : 		  }
; 90   : 		  }
; 91   : 		}

  002d8	e9 a4 fd ff ff	 jmp	 $LN12@ia64_code
$LN11@ia64_code:

; 92   : 	}

  002dd	e9 3f fd ff ff	 jmp	 $LN15@ia64_code
$LN14@ia64_code:

; 93   : 
; 94   : 	return i;

  002e2	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]

; 95   : }

  002e6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ea	c3		 ret	 0
ia64_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$ia64_coder_init DD imagerel ia64_coder_init
	DD	imagerel ia64_coder_init+91
	DD	imagerel $unwind$ia64_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ia64_coder_init DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ia64_coder_init
_TEXT	SEGMENT
next$ = 80
allocator$ = 88
filters$ = 96
is_encoder$ = 104
ia64_coder_init PROC					; COMDAT

; 101  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 102  : 	return lzma_simple_coder_init(next, allocator, filters,
; 103  : 			&ia64_code, 0, 16, 16, is_encoder);

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0001d	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00021	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  00029	48 c7 44 24 28
	10 00 00 00	 mov	 QWORD PTR [rsp+40], 16
  00032	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:ia64_code
  00042	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  00047	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00051	e8 00 00 00 00	 call	 lzma_simple_coder_init

; 104  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
ia64_coder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_ia64_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$lzma_simple_ia64_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_ia64_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_ia64_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_simple_ia64_decoder_init PROC			; COMDAT

; 120  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 121  : 	return ia64_coder_init(next, allocator, filters, false);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00025	e8 00 00 00 00	 call	 ia64_coder_init

; 122  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
lzma_simple_ia64_decoder_init ENDP
END
