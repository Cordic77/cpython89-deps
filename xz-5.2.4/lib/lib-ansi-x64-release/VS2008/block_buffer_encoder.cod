; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_buffer_encoder.c
pdata	SEGMENT
$pdata$lzma2_bound DD imagerel lzma2_bound
	DD	imagerel lzma2_bound+105
	DD	imagerel $unwind$lzma2_bound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_bound DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_bound
_TEXT	SEGMENT
overhead$32903 = 0
uncompressed_size$ = 32
lzma2_bound PROC					; COMDAT

; 34   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 35   : 	// Prevent integer overflow in overhead calculation.
; 36   : 	if (uncompressed_size > COMPRESSED_SIZE_MAX)

  00009	48 b8 bc fb ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854774716 ; 7ffffffffffffbbcH
  00013	48 39 44 24 20	 cmp	 QWORD PTR uncompressed_size$[rsp], rax
  00018	76 04		 jbe	 SHORT $LN2@lzma2_boun

; 37   : 		return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 46		 jmp	 SHORT $LN3@lzma2_boun
$LN2@lzma2_boun:

; 38   : 
; 39   : 	// Calculate the exact overhead of the LZMA2 headers: Round
; 40   : 	// uncompressed_size up to the next multiple of LZMA2_CHUNK_MAX,
; 41   : 	// multiply by the size of per-chunk header, and add one byte for
; 42   : 	// the end marker.
; 43   :   {
; 44   : 	const uint64_t overhead = ((uncompressed_size + LZMA2_CHUNK_MAX - 1)
; 45   : 				/ LZMA2_CHUNK_MAX)
; 46   : 			* LZMA2_HEADER_UNCOMPRESSED + 1;

  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR uncompressed_size$[rsp]
  00023	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00029	33 d2		 xor	 edx, edx
  0002b	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00030	48 f7 f1	 div	 rcx
  00033	48 6b c0 03	 imul	 rax, 3
  00037	48 83 c0 01	 add	 rax, 1
  0003b	48 89 04 24	 mov	 QWORD PTR overhead$32903[rsp], rax

; 47   : 
; 48   : 	// Catch the possible integer overflow.
; 49   : 	if (COMPRESSED_SIZE_MAX - overhead < uncompressed_size)

  0003f	48 b8 bc fb ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854774716 ; 7ffffffffffffbbcH
  00049	48 2b 04 24	 sub	 rax, QWORD PTR overhead$32903[rsp]
  0004d	48 3b 44 24 20	 cmp	 rax, QWORD PTR uncompressed_size$[rsp]
  00052	73 04		 jae	 SHORT $LN1@lzma2_boun

; 50   : 		return 0;

  00054	33 c0		 xor	 eax, eax
  00056	eb 0c		 jmp	 SHORT $LN3@lzma2_boun
$LN1@lzma2_boun:

; 51   : 
; 52   : 	return uncompressed_size + overhead;

  00058	48 8b 0c 24	 mov	 rcx, QWORD PTR overhead$32903[rsp]
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR uncompressed_size$[rsp]
  00061	48 03 c1	 add	 rax, rcx
$LN3@lzma2_boun:

; 53   :   }
; 54   : }

  00064	48 83 c4 18	 add	 rsp, 24
  00068	c3		 ret	 0
lzma2_bound ENDP
PUBLIC	lzma_block_buffer_bound64
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_buffer_bound64 DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$lzma_block_buffer_bound64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_buffer_bound64 DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_buffer_bound64
_TEXT	SEGMENT
lzma2_size$ = 32
uncompressed_size$ = 64
lzma_block_buffer_bound64 PROC				; COMDAT

; 59   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 60   : 	// If the data doesn't compress, we always use uncompressed
; 61   : 	// LZMA2 chunks.
; 62   : 	uint64_t lzma2_size = lzma2_bound(uncompressed_size);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR uncompressed_size$[rsp]
  0000e	e8 00 00 00 00	 call	 lzma2_bound
  00013	48 89 44 24 20	 mov	 QWORD PTR lzma2_size$[rsp], rax

; 63   : 	if (lzma2_size == 0)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR lzma2_size$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN1@lzma_block

; 64   : 		return 0;

  00020	33 c0		 xor	 eax, eax
  00022	eb 1b		 jmp	 SHORT $LN2@lzma_block
$LN1@lzma_block:

; 65   : 
; 66   : 	// Take Block Padding into account.
; 67   : 	lzma2_size = (lzma2_size + 3) & ~UINT64_C(3);

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR lzma2_size$[rsp]
  00029	48 83 c0 03	 add	 rax, 3
  0002d	48 83 e0 fc	 and	 rax, -4
  00031	48 89 44 24 20	 mov	 QWORD PTR lzma2_size$[rsp], rax

; 68   : 
; 69   : 	// No risk of integer overflow because lzma2_bound() already takes
; 70   : 	// into account the size of the headers in the Block.
; 71   : 	return HEADERS_BOUND + lzma2_size;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR lzma2_size$[rsp]
  0003b	48 83 c0 5c	 add	 rax, 92			; 0000005cH
$LN2@lzma_block:

; 72   : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
lzma_block_buffer_bound64 ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_encode_uncompressed DD imagerel block_encode_uncompressed
	DD	imagerel block_encode_uncompressed+875
	DD	imagerel $unwind$block_encode_uncompressed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encode_uncompressed DD 021b01H
	DD	01d011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encode_uncompressed
_TEXT	SEGMENT
lzma2$ = 32
filters$32930 = 144
filters_orig$32931 = 176
in_pos$32936 = 184
control$32937 = 192
copy_size$32941 = 200
tv130 = 208
block$ = 240
in$ = 248
in_size$ = 256
out$ = 264
out_pos$ = 272
out_size$ = 280
block_encode_uncompressed PROC				; COMDAT

; 93   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 94   : 	// Use LZMA2 uncompressed chunks. We wouldn't need a dictionary at
; 95   : 	// all, but LZMA2 always requires a dictionary, so use the minimum
; 96   : 	// value to minimize memory usage of the decoder.
; 97   : 	/*
; 98   : 	lzma_options_lzma lzma2 = {
; 99   : 		.dict_size = LZMA_DICT_SIZE_MIN,
; 100  : 	};
; 101  : 	*/
; 102  : 	lzma_options_lzma lzma2;
; 103  : 	memset (&lzma2, 0, sizeof(lzma2));

  0001b	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  00021	33 d2		 xor	 edx, edx
  00023	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lzma2$[rsp]
  00028	e8 00 00 00 00	 call	 memset

; 104  : 	lzma2.dict_size = LZMA_DICT_SIZE_MIN;

  0002d	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR lzma2$[rsp], 4096 ; 00001000H

; 105  : 
; 106  :   {
; 107  : 	lzma_filter filters[2];
; 108  : 	filters[0].id = LZMA_FILTER_LZMA2;

  00035	48 c7 84 24 90
	00 00 00 21 00
	00 00		 mov	 QWORD PTR filters$32930[rsp], 33 ; 00000021H

; 109  : 	filters[0].options = &lzma2;

  00041	48 8d 44 24 20	 lea	 rax, QWORD PTR lzma2$[rsp]
  00046	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR filters$32930[rsp+8], rax

; 110  : 	filters[1].id = LZMA_VLI_UNKNOWN;

  0004e	48 c7 84 24 a0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR filters$32930[rsp+16], -1

; 111  : 
; 112  : 	// Set the above filter options to *block temporarily so that we can
; 113  : 	// encode the Block Header.
; 114  :   {
; 115  : 	lzma_filter *filters_orig = block->filters;

  0005a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00062	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00066	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR filters_orig$32931[rsp], rax

; 116  : 	block->filters = filters;

  0006e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00076	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR filters$32930[rsp]
  0007e	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 117  : 
; 118  : 	if (lzma_block_header_size(block) != LZMA_OK) {

  00082	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  0008a	e8 00 00 00 00	 call	 lzma_block_header_size
  0008f	85 c0		 test	 eax, eax
  00091	74 1e		 je	 SHORT $LN5@block_enco@2

; 119  : 		block->filters = filters_orig;

  00093	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  0009b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR filters_orig$32931[rsp]
  000a3	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 120  : 		return LZMA_PROG_ERROR;

  000a7	b8 0b 00 00 00	 mov	 eax, 11
  000ac	e9 b2 02 00 00	 jmp	 $LN6@block_enco@2
$LN5@block_enco@2:

; 121  : 	}
; 122  : 
; 123  : 	// Check that there's enough output space. The caller has already
; 124  : 	// set block->compressed_size to what lzma2_bound() has returned,
; 125  : 	// so we can reuse that value. We know that compressed_size is a
; 126  : 	// known valid VLI and header_size is a small value so their sum
; 127  : 	// will never overflow.
; 128  : 	assert(block->compressed_size == lzma2_bound(in_size));
; 129  : 	if (out_size - *out_pos
; 130  : 			< block->header_size + block->compressed_size) {

  000b1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR out_size$[rsp]
  000c4	48 2b d0	 sub	 rdx, rax
  000c7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000cf	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  000da	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000de	48 3b d0	 cmp	 rdx, rax
  000e1	73 1e		 jae	 SHORT $LN4@block_enco@2

; 131  : 		block->filters = filters_orig;

  000e3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  000eb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR filters_orig$32931[rsp]
  000f3	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 132  : 		return LZMA_BUF_ERROR;

  000f7	b8 0a 00 00 00	 mov	 eax, 10
  000fc	e9 62 02 00 00	 jmp	 $LN6@block_enco@2
$LN4@block_enco@2:

; 133  : 	}
; 134  : 
; 135  : 	if (lzma_block_header_encode(block, out + *out_pos) != LZMA_OK) {

  00101	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00109	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00114	48 03 d0	 add	 rdx, rax
  00117	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  0011f	e8 00 00 00 00	 call	 lzma_block_header_encode
  00124	85 c0		 test	 eax, eax
  00126	74 1e		 je	 SHORT $LN3@block_enco@2

; 136  : 		block->filters = filters_orig;

  00128	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00130	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR filters_orig$32931[rsp]
  00138	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 137  : 		return LZMA_PROG_ERROR;

  0013c	b8 0b 00 00 00	 mov	 eax, 11
  00141	e9 1d 02 00 00	 jmp	 $LN6@block_enco@2
$LN3@block_enco@2:

; 138  : 	}
; 139  : 
; 140  : 	block->filters = filters_orig;

  00146	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  0014e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR filters_orig$32931[rsp]
  00156	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 141  : 	*out_pos += block->header_size;

  0015a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00162	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00165	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0016d	48 03 08	 add	 rcx, QWORD PTR [rax]
  00170	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00178	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  : 
; 143  : 	// Encode the data using LZMA2 uncompressed chunks.
; 144  :   {
; 145  : 	size_t in_pos = 0;

  0017b	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR in_pos$32936[rsp], 0

; 146  : 	uint8_t control = 0x01; // Dictionary reset

  00187	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR control$32937[rsp], 1
$LN2@block_enco@2:

; 147  : 
; 148  : 	while (in_pos < in_size) {

  0018f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00197	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR in_pos$32936[rsp], rax
  0019f	0f 83 8b 01 00
	00		 jae	 $LN1@block_enco@2

; 149  : 		// Control byte: Indicate uncompressed chunk, of which
; 150  : 		// the first resets the dictionary.
; 151  : 		out[(*out_pos)++] = control;

  001a5	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR out_pos$[rsp]
  001ad	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001b0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  001b8	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR control$32937[rsp]
  001c0	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  001c3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  001cb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ce	48 83 c1 01	 add	 rcx, 1
  001d2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  001da	48 89 08	 mov	 QWORD PTR [rax], rcx

; 152  : 		control = 0x02; // No dictionary reset

  001dd	c6 84 24 c0 00
	00 00 02	 mov	 BYTE PTR control$32937[rsp], 2

; 153  : 
; 154  : 		// Size of the uncompressed chunk
; 155  : 	  {
; 156  : 		const size_t copy_size
; 157  : 				= my_min(in_size - in_pos, LZMA2_CHUNK_MAX);

  001e5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$32936[rsp]
  001ed	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001f5	48 2b c1	 sub	 rax, rcx
  001f8	48 3d 00 00 01
	00		 cmp	 rax, 65536		; 00010000H
  001fe	73 1d		 jae	 SHORT $LN8@block_enco@2
  00200	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$32936[rsp]
  00208	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00210	48 2b c1	 sub	 rax, rcx
  00213	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
  0021b	eb 0c		 jmp	 SHORT $LN9@block_enco@2
$LN8@block_enco@2:
  0021d	48 c7 84 24 d0
	00 00 00 00 00
	01 00		 mov	 QWORD PTR tv130[rsp], 65536 ; 00010000H
$LN9@block_enco@2:
  00229	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv130[rsp]
  00231	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR copy_size$32941[rsp], rax

; 158  : 		out[(*out_pos)++] = (uint8_t)((copy_size - 1) >> 8);

  00239	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR copy_size$32941[rsp]
  00241	48 83 ea 01	 sub	 rdx, 1
  00245	48 c1 ea 08	 shr	 rdx, 8
  00249	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00251	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00254	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0025c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0025f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00267	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0026a	48 83 c1 01	 add	 rcx, 1
  0026e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00276	48 89 08	 mov	 QWORD PTR [rax], rcx

; 159  : 		out[(*out_pos)++] = (copy_size - 1) & 0xFF;

  00279	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR copy_size$32941[rsp]
  00281	48 83 ea 01	 sub	 rdx, 1
  00285	48 81 e2 ff 00
	00 00		 and	 rdx, 255		; 000000ffH
  0028c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00294	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00297	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0029f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  002a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  002aa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002ad	48 83 c1 01	 add	 rcx, 1
  002b1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  002b9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 160  : 
; 161  : 		// The actual data
; 162  : 		assert(*out_pos + copy_size <= out_size);
; 163  : 		memcpy(out + *out_pos, in + in_pos, copy_size);

  002bc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$32936[rsp]
  002c4	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR in$[rsp]
  002cc	48 03 d0	 add	 rdx, rax
  002cf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  002d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002da	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  002e2	48 03 c8	 add	 rcx, rax
  002e5	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR copy_size$32941[rsp]
  002ed	e8 00 00 00 00	 call	 memcpy

; 164  : 
; 165  : 		in_pos += copy_size;

  002f2	4c 8b 9c 24 c8
	00 00 00	 mov	 r11, QWORD PTR copy_size$32941[rsp]
  002fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$32936[rsp]
  00302	49 03 c3	 add	 rax, r11
  00305	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR in_pos$32936[rsp], rax

; 166  : 		*out_pos += copy_size;

  0030d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00315	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00318	48 03 8c 24 c8
	00 00 00	 add	 rcx, QWORD PTR copy_size$32941[rsp]
  00320	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00328	48 89 08	 mov	 QWORD PTR [rax], rcx

; 167  : 	  }
; 168  : 	}

  0032b	e9 5f fe ff ff	 jmp	 $LN2@block_enco@2
$LN1@block_enco@2:

; 169  : 
; 170  : 	// End marker
; 171  : 	out[(*out_pos)++] = 0x00;

  00330	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00338	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0033b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00343	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  00347	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0034f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00352	48 83 c1 01	 add	 rcx, 1
  00356	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0035e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 172  : 	assert(*out_pos <= out_size);
; 173  :   }}}
; 174  : 
; 175  : 	return LZMA_OK;

  00361	33 c0		 xor	 eax, eax
$LN6@block_enco@2:

; 176  : }

  00363	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0036a	c3		 ret	 0
block_encode_uncompressed ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_encode_normal DD imagerel block_encode_normal
	DD	imagerel block_encode_normal+576
	DD	imagerel $unwind$block_encode_normal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encode_normal DD 041d01H
	DD	01b011dH
	DD	060157016H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encode_normal
_TEXT	SEGMENT
ret_$32964 = 80
out_start$32967 = 88
ret$32971 = 96
raw_encoder$32970 = 112
in_pos$32973 = 192
block$ = 240
allocator$ = 248
in$ = 256
in_size$ = 264
out$ = 272
out_pos$ = 280
out_size$ = 288
block_encode_normal PROC				; COMDAT

; 183  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
$LN12@block_enco@3:

; 184  : 	// Find out the size of the Block Header.
; 185  : 	return_if_error(lzma_block_header_size(block));

  0001d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00025	e8 00 00 00 00	 call	 lzma_block_header_size
  0002a	89 44 24 50	 mov	 DWORD PTR ret_$32964[rsp], eax
  0002e	83 7c 24 50 00	 cmp	 DWORD PTR ret_$32964[rsp], 0
  00033	74 09		 je	 SHORT $LN9@block_enco@3
  00035	8b 44 24 50	 mov	 eax, DWORD PTR ret_$32964[rsp]
  00039	e9 f8 01 00 00	 jmp	 $LN13@block_enco@3
$LN9@block_enco@3:
  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 d9		 jne	 SHORT $LN12@block_enco@3

; 186  : 
; 187  : 	// Reserve space for the Block Header and skip it for now.
; 188  : 	if (out_size - *out_pos <= block->header_size)

  00044	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR out_size$[rsp]
  00057	48 2b c8	 sub	 rcx, rax
  0005a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00062	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00065	48 3b c8	 cmp	 rcx, rax
  00068	77 0a		 ja	 SHORT $LN8@block_enco@3

; 189  : 		return LZMA_BUF_ERROR;

  0006a	b8 0a 00 00 00	 mov	 eax, 10
  0006f	e9 c2 01 00 00	 jmp	 $LN13@block_enco@3
$LN8@block_enco@3:

; 190  : 
; 191  :   {
; 192  : 	const size_t out_start = *out_pos;

  00074	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 89 44 24 58	 mov	 QWORD PTR out_start$32967[rsp], rax

; 193  : 	*out_pos += block->header_size;

  00084	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  0008c	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0008f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00097	48 03 08	 add	 rcx, QWORD PTR [rax]
  0009a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000a2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 194  : 
; 195  : 	// Limit out_size so that we stop encoding if the output would grow
; 196  : 	// bigger than what uncompressed Block would be.
; 197  : 	if (out_size - *out_pos > block->compressed_size)

  000a5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR out_size$[rsp]
  000b8	48 2b c8	 sub	 rcx, rax
  000bb	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000c3	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  000c7	76 1f		 jbe	 SHORT $LN7@block_enco@3

; 198  : 		out_size = (size_t)(*out_pos + block->compressed_size);

  000c9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  000dc	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000e0	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR out_size$[rsp], rax
$LN7@block_enco@3:

; 199  : 
; 200  : 	// TODO: In many common cases this could be optimized to use
; 201  : 	// significantly less memory.
; 202  :   {
; 203  : 	lzma_next_coder raw_encoder = LZMA_NEXT_CODER_INIT;

  000e8	48 8d 7c 24 70	 lea	 rdi, QWORD PTR raw_encoder$32970[rsp]
  000ed	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000f4	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000f9	f3 a4		 rep movsb

; 204  : 	lzma_ret ret = lzma_raw_encoder_init(
; 205  : 			&raw_encoder, allocator, block->filters);

  000fb	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR block$[rsp]
  00103	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00107	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0010f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raw_encoder$32970[rsp]
  00114	e8 00 00 00 00	 call	 lzma_raw_encoder_init
  00119	89 44 24 60	 mov	 DWORD PTR ret$32971[rsp], eax

; 206  : 
; 207  : 	if (ret == LZMA_OK) {

  0011d	83 7c 24 60 00	 cmp	 DWORD PTR ret$32971[rsp], 0
  00122	75 70		 jne	 SHORT $LN6@block_enco@3

; 208  : 		size_t in_pos = 0;

  00124	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR in_pos$32973[rsp], 0

; 209  : 		ret = raw_encoder.code(raw_encoder.coder, allocator,
; 210  : 				in, &in_pos, in_size, out, out_pos, out_size,
; 211  : 				LZMA_FINISH);

  00130	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR [rsp+64], 3
  00138	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00140	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00145	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0014d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00152	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0015a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00167	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016c	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR in_pos$32973[rsp]
  00174	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0017c	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raw_encoder$32970[rsp]
  00189	ff 94 24 88 00
	00 00		 call	 QWORD PTR raw_encoder$32970[rsp+24]
  00190	89 44 24 60	 mov	 DWORD PTR ret$32971[rsp], eax
$LN6@block_enco@3:

; 212  : 	}
; 213  : 
; 214  : 	// NOTE: This needs to be run even if lzma_raw_encoder_init() failed.
; 215  : 	lzma_next_end(&raw_encoder, allocator);

  00194	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0019c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raw_encoder$32970[rsp]
  001a1	e8 00 00 00 00	 call	 lzma_next_end

; 216  : 
; 217  : 	if (ret == LZMA_STREAM_END) {

  001a6	83 7c 24 60 01	 cmp	 DWORD PTR ret$32971[rsp], 1
  001ab	75 5f		 jne	 SHORT $LN5@block_enco@3

; 218  : 		// Compression was successful. Write the Block Header.
; 219  : 		block->compressed_size
; 220  : 				= *out_pos - (out_start + block->header_size);

  001ad	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  001b5	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  001b8	48 8b 44 24 58	 mov	 rax, QWORD PTR out_start$32967[rsp]
  001bd	48 03 c1	 add	 rax, rcx
  001c0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  001c8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001cb	48 2b c8	 sub	 rcx, rax
  001ce	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  001d6	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 221  : 		ret = lzma_block_header_encode(block, out + out_start);

  001da	48 8b 44 24 58	 mov	 rax, QWORD PTR out_start$32967[rsp]
  001df	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001e7	48 03 d0	 add	 rdx, rax
  001ea	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  001f2	e8 00 00 00 00	 call	 lzma_block_header_encode
  001f7	89 44 24 60	 mov	 DWORD PTR ret$32971[rsp], eax

; 222  : 		if (ret != LZMA_OK)

  001fb	83 7c 24 60 00	 cmp	 DWORD PTR ret$32971[rsp], 0
  00200	74 08		 je	 SHORT $LN4@block_enco@3

; 223  : 			ret = LZMA_PROG_ERROR;

  00202	c7 44 24 60 0b
	00 00 00	 mov	 DWORD PTR ret$32971[rsp], 11
$LN4@block_enco@3:

; 224  : 
; 225  : 	} else if (ret == LZMA_OK) {

  0020a	eb 0f		 jmp	 SHORT $LN3@block_enco@3
$LN5@block_enco@3:
  0020c	83 7c 24 60 00	 cmp	 DWORD PTR ret$32971[rsp], 0
  00211	75 08		 jne	 SHORT $LN2@block_enco@3

; 226  : 		// Output buffer became full.
; 227  : 		ret = LZMA_BUF_ERROR;

  00213	c7 44 24 60 0a
	00 00 00	 mov	 DWORD PTR ret$32971[rsp], 10
$LN2@block_enco@3:
$LN3@block_enco@3:

; 228  : 	}
; 229  : 
; 230  : 	// Reset *out_pos if something went wrong.
; 231  : 	if (ret != LZMA_OK)

  0021b	83 7c 24 60 00	 cmp	 DWORD PTR ret$32971[rsp], 0
  00220	74 10		 je	 SHORT $LN1@block_enco@3

; 232  : 		*out_pos = out_start;

  00222	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0022a	48 8b 44 24 58	 mov	 rax, QWORD PTR out_start$32967[rsp]
  0022f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@block_enco@3:

; 233  : 
; 234  : 	return ret;

  00232	8b 44 24 60	 mov	 eax, DWORD PTR ret$32971[rsp]
$LN13@block_enco@3:

; 235  :   }}
; 236  : }

  00236	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0023d	5f		 pop	 rdi
  0023e	5e		 pop	 rsi
  0023f	c3		 ret	 0
block_encode_normal ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_buffer_encode DD imagerel block_buffer_encode
	DD	imagerel block_buffer_encode+927
	DD	imagerel $unwind$block_buffer_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_buffer_encode DD 021b01H
	DD	01b011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_buffer_encode
_TEXT	SEGMENT
check_size$33010 = 64
ret$33014 = 72
ret_$33021 = 76
i$33024 = 80
check$33031 = 96
block$ = 224
allocator$ = 232
in$ = 240
in_size$ = 248
out$ = 256
out_pos$ = 264
out_size$ = 272
try_to_compress$ = 280
block_buffer_encode PROC				; COMDAT

; 244  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 245  : 	// Validate the arguments.
; 246  : 	if (block == NULL || (in == NULL && in_size != 0) || out == NULL
; 247  : 			|| out_pos == NULL || *out_pos > out_size)

  0001b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR block$[rsp], 0
  00024	74 41		 je	 SHORT $LN19@block_buff
  00026	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR in$[rsp], 0
  0002f	75 0b		 jne	 SHORT $LN18@block_buff
  00031	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR in_size$[rsp], 0
  0003a	75 2b		 jne	 SHORT $LN19@block_buff
$LN18@block_buff:
  0003c	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR out$[rsp], 0
  00045	74 20		 je	 SHORT $LN19@block_buff
  00047	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR out_pos$[rsp], 0
  00050	74 15		 je	 SHORT $LN19@block_buff
  00052	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0005a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00062	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00065	76 0a		 jbe	 SHORT $LN20@block_buff
$LN19@block_buff:

; 248  : 		return LZMA_PROG_ERROR;

  00067	b8 0b 00 00 00	 mov	 eax, 11
  0006c	e9 26 03 00 00	 jmp	 $LN21@block_buff
$LN20@block_buff:

; 249  : 
; 250  : 	// The contents of the structure may depend on the version so
; 251  : 	// check the version before validating the contents of *block.
; 252  : 	if (block->version > 1)

  00071	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00079	83 38 01	 cmp	 DWORD PTR [rax], 1
  0007c	76 0a		 jbe	 SHORT $LN17@block_buff

; 253  : 		return LZMA_OPTIONS_ERROR;

  0007e	b8 08 00 00 00	 mov	 eax, 8
  00083	e9 0f 03 00 00	 jmp	 $LN21@block_buff
$LN17@block_buff:

; 254  : 
; 255  : 	if ((unsigned int)(block->check) > LZMA_CHECK_ID_MAX
; 256  : 			|| (try_to_compress && block->filters == NULL))

  00088	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00090	83 78 08 0f	 cmp	 DWORD PTR [rax+8], 15
  00094	77 1b		 ja	 SHORT $LN15@block_buff
  00096	0f b6 84 24 18
	01 00 00	 movzx	 eax, BYTE PTR try_to_compress$[rsp]
  0009e	85 c0		 test	 eax, eax
  000a0	74 19		 je	 SHORT $LN16@block_buff
  000a2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000aa	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000af	75 0a		 jne	 SHORT $LN16@block_buff
$LN15@block_buff:

; 257  : 		return LZMA_PROG_ERROR;

  000b1	b8 0b 00 00 00	 mov	 eax, 11
  000b6	e9 dc 02 00 00	 jmp	 $LN21@block_buff
$LN16@block_buff:

; 258  : 
; 259  : 	if (!lzma_check_is_supported(block->check))

  000bb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000c3	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000c6	e8 00 00 00 00	 call	 lzma_check_is_supported
  000cb	0f b6 c0	 movzx	 eax, al
  000ce	85 c0		 test	 eax, eax
  000d0	75 0a		 jne	 SHORT $LN14@block_buff

; 260  : 		return LZMA_UNSUPPORTED_CHECK;

  000d2	b8 03 00 00 00	 mov	 eax, 3
  000d7	e9 bb 02 00 00	 jmp	 $LN21@block_buff
$LN14@block_buff:

; 261  : 
; 262  : 	// Size of a Block has to be a multiple of four, so limit the size
; 263  : 	// here already. This way we don't need to check it again when adding
; 264  : 	// Block Padding.
; 265  : 	out_size -= (out_size - *out_pos) & 3;

  000dc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR out_size$[rsp]
  000ef	48 2b c8	 sub	 rcx, rax
  000f2	48 83 e1 03	 and	 rcx, 3
  000f6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000fe	48 2b c1	 sub	 rax, rcx
  00101	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR out_size$[rsp], rax

; 266  : 
; 267  : 	// Get the size of the Check field.
; 268  :   {
; 269  : 	const size_t check_size = lzma_check_size(block->check);

  00109	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00111	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00114	e8 00 00 00 00	 call	 lzma_check_size
  00119	8b c0		 mov	 eax, eax
  0011b	48 89 44 24 40	 mov	 QWORD PTR check_size$33010[rsp], rax

; 270  : 	assert(check_size != UINT32_MAX);
; 271  : 
; 272  : 	// Reserve space for the Check field.
; 273  : 	if (out_size - *out_pos <= check_size)

  00120	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00128	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0012b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00133	48 2b c1	 sub	 rax, rcx
  00136	48 3b 44 24 40	 cmp	 rax, QWORD PTR check_size$33010[rsp]
  0013b	77 0a		 ja	 SHORT $LN13@block_buff

; 274  : 		return LZMA_BUF_ERROR;

  0013d	b8 0a 00 00 00	 mov	 eax, 10
  00142	e9 50 02 00 00	 jmp	 $LN21@block_buff
$LN13@block_buff:

; 275  : 
; 276  : 	out_size -= check_size;

  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR check_size$33010[rsp]
  0014c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00154	48 2b c1	 sub	 rax, rcx
  00157	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR out_size$[rsp], rax

; 277  : 
; 278  : 	// Initialize block->uncompressed_size and calculate the worst-case
; 279  : 	// value for block->compressed_size.
; 280  : 	block->uncompressed_size = in_size;

  0015f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00167	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0016f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 281  : 	block->compressed_size = lzma2_bound(in_size);

  00173	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR in_size$[rsp]
  0017b	e8 00 00 00 00	 call	 lzma2_bound
  00180	4c 8b d8	 mov	 r11, rax
  00183	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  0018b	4c 89 58 10	 mov	 QWORD PTR [rax+16], r11

; 282  : 	if (block->compressed_size == 0)

  0018f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00197	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0019c	75 0a		 jne	 SHORT $LN12@block_buff

; 283  : 		return LZMA_DATA_ERROR;

  0019e	b8 09 00 00 00	 mov	 eax, 9
  001a3	e9 ef 01 00 00	 jmp	 $LN21@block_buff
$LN12@block_buff:

; 284  : 
; 285  : 	// Do the actual compression.
; 286  :   {
; 287  : 	lzma_ret ret = LZMA_BUF_ERROR;

  001a8	c7 44 24 48 0a
	00 00 00	 mov	 DWORD PTR ret$33014[rsp], 10

; 288  : 	if (try_to_compress)

  001b0	0f b6 84 24 18
	01 00 00	 movzx	 eax, BYTE PTR try_to_compress$[rsp]
  001b8	85 c0		 test	 eax, eax
  001ba	74 50		 je	 SHORT $LN11@block_buff

; 289  : 		ret = block_encode_normal(block, allocator,
; 290  : 				in, in_size, out, out_pos, out_size);

  001bc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  001c4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001c9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  001d1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  001de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e3	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR in_size$[rsp]
  001eb	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  001f3	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001fb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00203	e8 00 00 00 00	 call	 block_encode_normal
  00208	89 44 24 48	 mov	 DWORD PTR ret$33014[rsp], eax
$LN11@block_buff:

; 291  : 
; 292  : 	if (ret != LZMA_OK) {

  0020c	83 7c 24 48 00	 cmp	 DWORD PTR ret$33014[rsp], 0
  00211	74 69		 je	 SHORT $LN10@block_buff

; 293  : 		// If the error was something else than output buffer
; 294  : 		// becoming full, return the error now.
; 295  : 		if (ret != LZMA_BUF_ERROR)

  00213	83 7c 24 48 0a	 cmp	 DWORD PTR ret$33014[rsp], 10
  00218	74 09		 je	 SHORT $LN9@block_buff

; 296  : 			return ret;

  0021a	8b 44 24 48	 mov	 eax, DWORD PTR ret$33014[rsp]
  0021e	e9 74 01 00 00	 jmp	 $LN21@block_buff
$LN9@block_buff:
$LN8@block_buff:

; 297  : 
; 298  : 		// The data was uncompressible (at least with the options
; 299  : 		// given to us) or the output buffer was too small. Use the
; 300  : 		// uncompressed chunks of LZMA2 to wrap the data into a valid
; 301  : 		// Block. If we haven't been given enough output space, even
; 302  : 		// this may fail.
; 303  : 		return_if_error(block_encode_uncompressed(block, in, in_size,
; 304  : 				out, out_pos, out_size));

  00223	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0022b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00230	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00238	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023d	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR out$[rsp]
  00245	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  0024d	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR in$[rsp]
  00255	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  0025d	e8 00 00 00 00	 call	 block_encode_uncompressed
  00262	89 44 24 4c	 mov	 DWORD PTR ret_$33021[rsp], eax
  00266	83 7c 24 4c 00	 cmp	 DWORD PTR ret_$33021[rsp], 0
  0026b	74 09		 je	 SHORT $LN5@block_buff
  0026d	8b 44 24 4c	 mov	 eax, DWORD PTR ret_$33021[rsp]
  00271	e9 21 01 00 00	 jmp	 $LN21@block_buff
$LN5@block_buff:
  00276	33 c0		 xor	 eax, eax
  00278	85 c0		 test	 eax, eax
  0027a	75 a7		 jne	 SHORT $LN8@block_buff
$LN10@block_buff:

; 305  : 	}
; 306  :   }
; 307  : 
; 308  : 	assert(*out_pos <= out_size);
; 309  : 
; 310  : 	// Block Padding. No buffer overflow here, because we already adjusted
; 311  : 	// out_size so that (out_size - out_start) is a multiple of four.
; 312  : 	// Thus, if the buffer is full, the loop body can never run.
; 313  :   { size_t i;
; 314  : 
; 315  : 	for (i = (size_t)(block->compressed_size); i & 3; ++i) {

  0027c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00284	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00288	48 89 44 24 50	 mov	 QWORD PTR i$33024[rsp], rax
  0028d	eb 0e		 jmp	 SHORT $LN4@block_buff
$LN3@block_buff:
  0028f	48 8b 44 24 50	 mov	 rax, QWORD PTR i$33024[rsp]
  00294	48 83 c0 01	 add	 rax, 1
  00298	48 89 44 24 50	 mov	 QWORD PTR i$33024[rsp], rax
$LN4@block_buff:
  0029d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$33024[rsp]
  002a2	48 83 e0 03	 and	 rax, 3
  002a6	48 85 c0	 test	 rax, rax
  002a9	74 33		 je	 SHORT $LN2@block_buff

; 316  : 		assert(*out_pos < out_size);
; 317  : 		out[(*out_pos)++] = 0x00;

  002ab	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  002b3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  002be	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  002c2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  002ca	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002cd	48 83 c1 01	 add	 rcx, 1
  002d1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  002d9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 318  : 	}

  002dc	eb b1		 jmp	 SHORT $LN3@block_buff
$LN2@block_buff:

; 319  :   }
; 320  : 
; 321  : 	// If there's no Check field, we are done now.
; 322  : 	if (check_size > 0) {

  002de	48 83 7c 24 40
	00		 cmp	 QWORD PTR check_size$33010[rsp], 0
  002e4	0f 86 ab 00 00
	00		 jbe	 $LN1@block_buff

; 323  : 		// Calculate the integrity check. We reserved space for
; 324  : 		// the Check field earlier so we don't need to check for
; 325  : 		// available output space here.
; 326  : 		lzma_check_state check;
; 327  : 		lzma_check_init(&check, block->check);

  002ea	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  002f2	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  002f5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR check$33031[rsp]
  002fa	e8 00 00 00 00	 call	 lzma_check_init

; 328  : 		lzma_check_update(&check, block->check, in, in_size);

  002ff	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR in_size$[rsp]
  00307	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0030f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00317	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  0031a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR check$33031[rsp]
  0031f	e8 00 00 00 00	 call	 lzma_check_update

; 329  : 		lzma_check_finish(&check, block->check);

  00324	4c 8b 9c 24 e0
	00 00 00	 mov	 r11, QWORD PTR block$[rsp]
  0032c	41 8b 53 08	 mov	 edx, DWORD PTR [r11+8]
  00330	48 8d 4c 24 60	 lea	 rcx, QWORD PTR check$33031[rsp]
  00335	e8 00 00 00 00	 call	 lzma_check_finish

; 330  : 
; 331  : 		memcpy(block->raw_check, check.buffer.u8, check_size);

  0033a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00342	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00346	4c 8b 44 24 40	 mov	 r8, QWORD PTR check_size$33010[rsp]
  0034b	48 8d 54 24 60	 lea	 rdx, QWORD PTR check$33031[rsp]
  00350	e8 00 00 00 00	 call	 memcpy

; 332  : 		memcpy(out + *out_pos, check.buffer.u8, check_size);

  00355	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0035d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00360	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00368	48 03 c8	 add	 rcx, rax
  0036b	4c 8b 44 24 40	 mov	 r8, QWORD PTR check_size$33010[rsp]
  00370	48 8d 54 24 60	 lea	 rdx, QWORD PTR check$33031[rsp]
  00375	e8 00 00 00 00	 call	 memcpy

; 333  : 		*out_pos += check_size;

  0037a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00382	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00385	48 03 4c 24 40	 add	 rcx, QWORD PTR check_size$33010[rsp]
  0038a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00392	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@block_buff:

; 334  : 	}
; 335  :   }
; 336  : 
; 337  : 	return LZMA_OK;

  00395	33 c0		 xor	 eax, eax
$LN21@block_buff:

; 338  : }

  00397	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0039e	c3		 ret	 0
block_buffer_encode ENDP
PUBLIC	lzma_block_uncomp_encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_uncomp_encode DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$lzma_block_uncomp_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_uncomp_encode DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_uncomp_encode
_TEXT	SEGMENT
block$ = 80
in$ = 88
in_size$ = 96
out$ = 104
out_pos$ = 112
out_size$ = 120
lzma_block_uncomp_encode PROC				; COMDAT

; 355  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 356  : 	// It won't allocate any memory from heap so no need
; 357  : 	// for lzma_allocator.
; 358  : 	return block_buffer_encode(block, NULL,
; 359  : 			in, in_size, out, out_pos, out_size, false);

  00018	c6 44 24 38 00	 mov	 BYTE PTR [rsp+56], 0
  0001d	48 8b 44 24 78	 mov	 rax, QWORD PTR out_size$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR out_pos$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00031	48 8b 44 24 68	 mov	 rax, QWORD PTR out$[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR in_size$[rsp]
  00040	4c 8b 44 24 58	 mov	 r8, QWORD PTR in$[rsp]
  00045	33 d2		 xor	 edx, edx
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR block$[rsp]
  0004c	e8 00 00 00 00	 call	 block_buffer_encode

; 360  : }

  00051	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00055	c3		 ret	 0
lzma_block_uncomp_encode ENDP
END
