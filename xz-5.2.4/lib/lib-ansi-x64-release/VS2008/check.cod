; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

?available_checks@?2??lzma_check_is_supported@@9@9 DB 01H ; `lzma_check_is_supported'::`3'::available_checks
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?check_sizes@?2??lzma_check_size@@9@9 DB 00H		; `lzma_check_size'::`3'::check_sizes
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	010H
	DB	010H
	DB	010H
	DB	020H
	DB	020H
	DB	020H
	DB	040H
	DB	040H
	DB	040H
PUBLIC	lzma_check_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\check\check.c
pdata	SEGMENT
$pdata$lzma_check_init DD imagerel $LN10
	DD	imagerel $LN10+90
	DD	imagerel $unwind$lzma_check_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_check_init DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_check_init
_TEXT	SEGMENT
tv64 = 32
check$ = 64
type$ = 72
lzma_check_init PROC					; COMDAT

; 89   : {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   : 	switch (type) {

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR type$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0001a	74 12		 je	 SHORT $LN4@lzma_check
  0001c	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  00021	74 19		 je	 SHORT $LN3@lzma_check
  00023	83 7c 24 20 0a	 cmp	 DWORD PTR tv64[rsp], 10
  00028	74 21		 je	 SHORT $LN2@lzma_check
  0002a	eb 29		 jmp	 SHORT $LN1@lzma_check

; 91   : 	case LZMA_CHECK_NONE:
; 92   : 		break;

  0002c	eb 27		 jmp	 SHORT $LN6@lzma_check
$LN4@lzma_check:

; 93   : 
; 94   : #ifdef HAVE_CHECK_CRC32
; 95   : 	case LZMA_CHECK_CRC32:
; 96   : 		check->state.crc32 = 0;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  00033	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 97   : 		break;

  0003a	eb 19		 jmp	 SHORT $LN6@lzma_check
$LN3@lzma_check:

; 98   : #endif
; 99   : 
; 100  : #ifdef HAVE_CHECK_CRC64
; 101  : 	case LZMA_CHECK_CRC64:
; 102  : 		check->state.crc64 = 0;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  00041	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 103  : 		break;

  00049	eb 0a		 jmp	 SHORT $LN6@lzma_check
$LN2@lzma_check:

; 104  : #endif
; 105  : 
; 106  : #ifdef HAVE_CHECK_SHA256
; 107  : 	case LZMA_CHECK_SHA256:
; 108  : 		lzma_sha256_init(check);

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR check$[rsp]
  00050	e8 00 00 00 00	 call	 lzma_sha256_init
$LN1@lzma_check:
$LN6@lzma_check:

; 109  : 		break;
; 110  : #endif
; 111  : 
; 112  : 	default:
; 113  : 		break;
; 114  : 	}
; 115  : 
; 116  : 	return;
; 117  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
lzma_check_init ENDP
_TEXT	ENDS
PUBLIC	lzma_check_size
; Function compile flags: /Odtp
;	COMDAT lzma_check_size
_TEXT	SEGMENT
type$ = 8
lzma_check_size PROC					; COMDAT

; 67   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 68   : 	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)

  00004	83 7c 24 08 0f	 cmp	 DWORD PTR type$[rsp], 15
  00009	76 07		 jbe	 SHORT $LN1@lzma_check@2

; 69   : 		return UINT32_MAX;

  0000b	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00010	eb 0f		 jmp	 SHORT $LN2@lzma_check@2
$LN1@lzma_check@2:

; 70   : 
; 71   : 	// See file-format.txt section 2.1.1.2.
; 72   :   {
; 73   : 	static const uint8_t check_sizes[LZMA_CHECK_ID_MAX + 1] = {
; 74   : 		0,
; 75   : 		4, 4, 4,
; 76   : 		8, 8, 8,
; 77   : 		16, 16, 16,
; 78   : 		32, 32, 32,
; 79   : 		64, 64, 64
; 80   : 	};
; 81   : 
; 82   : 	return check_sizes[(unsigned int)(type)];

  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR type$[rsp]
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?check_sizes@?2??lzma_check_size@@9@9
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
$LN2@lzma_check@2:

; 83   :   }
; 84   : }

  00021	f3 c3		 fatret	 0
lzma_check_size ENDP
_TEXT	ENDS
PUBLIC	lzma_check_is_supported
; Function compile flags: /Odtp
;	COMDAT lzma_check_is_supported
_TEXT	SEGMENT
type$ = 8
lzma_check_is_supported PROC				; COMDAT

; 18   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 19   : 	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)

  00004	83 7c 24 08 0f	 cmp	 DWORD PTR type$[rsp], 15
  00009	76 04		 jbe	 SHORT $LN1@lzma_check@3

; 20   : 		return false;

  0000b	32 c0		 xor	 al, al
  0000d	eb 0e		 jmp	 SHORT $LN2@lzma_check@3
$LN1@lzma_check@3:

; 21   : 
; 22   :   {
; 23   : 	static const lzma_bool available_checks[LZMA_CHECK_ID_MAX + 1] = {
; 24   : 		true,   // LZMA_CHECK_NONE
; 25   : 
; 26   : #ifdef HAVE_CHECK_CRC32
; 27   : 		true,
; 28   : #else
; 29   : 		false,
; 30   : #endif
; 31   : 
; 32   : 		false,  // Reserved
; 33   : 		false,  // Reserved
; 34   : 
; 35   : #ifdef HAVE_CHECK_CRC64
; 36   : 		true,
; 37   : #else
; 38   : 		false,
; 39   : #endif
; 40   : 
; 41   : 		false,  // Reserved
; 42   : 		false,  // Reserved
; 43   : 		false,  // Reserved
; 44   : 		false,  // Reserved
; 45   : 		false,  // Reserved
; 46   : 
; 47   : #ifdef HAVE_CHECK_SHA256
; 48   : 		true,
; 49   : #else
; 50   : 		false,
; 51   : #endif
; 52   : 
; 53   : 		false,  // Reserved
; 54   : 		false,  // Reserved
; 55   : 		false,  // Reserved
; 56   : 		false,  // Reserved
; 57   : 		false,  // Reserved
; 58   : 	};
; 59   : 
; 60   : 	return available_checks[(unsigned int)(type)];

  0000f	8b 4c 24 08	 mov	 ecx, DWORD PTR type$[rsp]
  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?available_checks@?2??lzma_check_is_supported@@9@9
  0001a	8a 04 08	 mov	 al, BYTE PTR [rax+rcx]
$LN2@lzma_check@3:

; 61   :   }
; 62   : }

  0001d	f3 c3		 fatret	 0
lzma_check_is_supported ENDP
PUBLIC	lzma_check_finish
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_check_finish DD imagerel $LN9
	DD	imagerel $LN9+95
	DD	imagerel $unwind$lzma_check_finish
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_check_finish DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_check_finish
_TEXT	SEGMENT
tv64 = 32
check$ = 64
type$ = 72
lzma_check_finish PROC					; COMDAT

; 153  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 154  : 	switch (type) {

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR type$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0001a	74 10		 je	 SHORT $LN4@lzma_check@4
  0001c	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  00021	74 1a		 je	 SHORT $LN3@lzma_check@4
  00023	83 7c 24 20 0a	 cmp	 DWORD PTR tv64[rsp], 10
  00028	74 26		 je	 SHORT $LN2@lzma_check@4
  0002a	eb 2e		 jmp	 SHORT $LN1@lzma_check@4
$LN4@lzma_check@4:

; 155  : #ifdef HAVE_CHECK_CRC32
; 156  : 	case LZMA_CHECK_CRC32:
; 157  : 		check->buffer.u32[0] = conv32le(check->state.crc32);

  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR check$[rsp]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  00036	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00039	89 01		 mov	 DWORD PTR [rcx], eax

; 158  : 		break;

  0003b	eb 1d		 jmp	 SHORT $LN5@lzma_check@4
$LN3@lzma_check@4:

; 159  : #endif
; 160  : 
; 161  : #ifdef HAVE_CHECK_CRC64
; 162  : 	case LZMA_CHECK_CRC64:
; 163  : 		check->buffer.u64[0] = conv64le(check->state.crc64);

  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR check$[rsp]
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  00047	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0004b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 164  : 		break;

  0004e	eb 0a		 jmp	 SHORT $LN5@lzma_check@4
$LN2@lzma_check@4:

; 165  : #endif
; 166  : 
; 167  : #ifdef HAVE_CHECK_SHA256
; 168  : 	case LZMA_CHECK_SHA256:
; 169  : 		lzma_sha256_finish(check);

  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR check$[rsp]
  00055	e8 00 00 00 00	 call	 lzma_sha256_finish
$LN1@lzma_check@4:
$LN5@lzma_check@4:

; 170  : 		break;
; 171  : #endif
; 172  : 
; 173  : 	default:
; 174  : 		break;
; 175  : 	}
; 176  : 
; 177  : 	return;
; 178  : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
lzma_check_finish ENDP
_TEXT	ENDS
PUBLIC	lzma_check_update
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_check_update DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$lzma_check_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_check_update DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_check_update
_TEXT	SEGMENT
tv64 = 32
check$ = 64
type$ = 72
buf$ = 80
size$ = 88
lzma_check_update PROC					; COMDAT

; 123  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 124  : 	switch (type) {

  00017	8b 44 24 48	 mov	 eax, DWORD PTR type$[rsp]
  0001b	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00024	74 10		 je	 SHORT $LN4@lzma_check@5
  00026	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  0002b	74 2f		 je	 SHORT $LN3@lzma_check@5
  0002d	83 7c 24 20 0a	 cmp	 DWORD PTR tv64[rsp], 10
  00032	74 4e		 je	 SHORT $LN2@lzma_check@5
  00034	eb 60		 jmp	 SHORT $LN1@lzma_check@5
$LN4@lzma_check@5:

; 125  : #ifdef HAVE_CHECK_CRC32
; 126  : 	case LZMA_CHECK_CRC32:
; 127  : 		check->state.crc32 = lzma_crc32(buf, size, check->state.crc32);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  0003b	44 8b 40 40	 mov	 r8d, DWORD PTR [rax+64]
  0003f	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  00049	e8 00 00 00 00	 call	 lzma_crc32
  0004e	44 8b d8	 mov	 r11d, eax
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  00056	44 89 58 40	 mov	 DWORD PTR [rax+64], r11d

; 128  : 		break;

  0005a	eb 3a		 jmp	 SHORT $LN5@lzma_check@5
$LN3@lzma_check@5:

; 129  : #endif
; 130  : 
; 131  : #ifdef HAVE_CHECK_CRC64
; 132  : 	case LZMA_CHECK_CRC64:
; 133  : 		check->state.crc64 = lzma_crc64(buf, size, check->state.crc64);

  0005c	4c 8b 44 24 40	 mov	 r8, QWORD PTR check$[rsp]
  00061	4d 8b 40 40	 mov	 r8, QWORD PTR [r8+64]
  00065	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  0006f	e8 00 00 00 00	 call	 lzma_crc64
  00074	4c 8b d8	 mov	 r11, rax
  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR check$[rsp]
  0007c	4c 89 58 40	 mov	 QWORD PTR [rax+64], r11

; 134  : 		break;

  00080	eb 14		 jmp	 SHORT $LN5@lzma_check@5
$LN2@lzma_check@5:

; 135  : #endif
; 136  : 
; 137  : #ifdef HAVE_CHECK_SHA256
; 138  : 	case LZMA_CHECK_SHA256:
; 139  : 		lzma_sha256_update(buf, size, check);

  00082	4c 8b 44 24 40	 mov	 r8, QWORD PTR check$[rsp]
  00087	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  00091	e8 00 00 00 00	 call	 lzma_sha256_update
$LN1@lzma_check@5:
$LN5@lzma_check@5:

; 140  : 		break;
; 141  : #endif
; 142  : 
; 143  : 	default:
; 144  : 		break;
; 145  : 	}
; 146  : 
; 147  : 	return;
; 148  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
lzma_check_update ENDP
END
