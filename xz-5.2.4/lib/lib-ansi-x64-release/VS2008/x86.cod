; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_x86_decoder_init
?MASK_TO_ALLOWED_STATUS@?1??x86_code@@9@9 DB 01H	; `x86_code'::`2'::MASK_TO_ALLOWED_STATUS
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
?MASK_TO_BIT_NUMBER@?1??x86_code@@9@9 DD 00H		; `x86_code'::`2'::MASK_TO_BIT_NUMBER
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\x86.c
pdata	SEGMENT
$pdata$x86_code DD imagerel x86_code
	DD	imagerel x86_code+867
	DD	imagerel $unwind$x86_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x86_code DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT x86_code
_TEXT	SEGMENT
simple$ = 0
prev_mask$ = 8
prev_pos$ = 12
buffer_pos$32967 = 16
limit$32966 = 24
b$32971 = 32
offset$32973 = 36
i$32978 = 40
dest$32988 = 44
src$32984 = 48
i$32997 = 52
simple_ptr$ = 80
now_pos$ = 88
is_encoder$ = 96
buffer$ = 104
size$ = 112
x86_code PROC						; COMDAT

; 29   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 30   : 	static const bool MASK_TO_ALLOWED_STATUS[8]
; 31   : 		= { true, true, true, false, true, false, false, false };
; 32   : 
; 33   : 	static const uint32_t MASK_TO_BIT_NUMBER[8]
; 34   : 			= { 0, 1, 2, 2, 3, 3, 3, 3 };
; 35   : 
; 36   : 	lzma_simple_x86 *simple = simple_ptr;

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR simple_ptr$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR simple$[rsp], rax

; 37   : 	uint32_t prev_mask = simple->prev_mask;

  00020	48 8b 04 24	 mov	 rax, QWORD PTR simple$[rsp]
  00024	8b 00		 mov	 eax, DWORD PTR [rax]
  00026	89 44 24 08	 mov	 DWORD PTR prev_mask$[rsp], eax

; 38   : 	uint32_t prev_pos = simple->prev_pos;

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR simple$[rsp]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00031	89 44 24 0c	 mov	 DWORD PTR prev_pos$[rsp], eax

; 39   : 
; 40   : 	if (size < 5)

  00035	48 83 7c 24 70
	05		 cmp	 QWORD PTR size$[rsp], 5
  0003b	73 07		 jae	 SHORT $LN21@x86_code

; 41   : 		return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 1a 03 00 00	 jmp	 $LN22@x86_code
$LN21@x86_code:

; 42   : 
; 43   : 	if (now_pos - prev_pos > 5)

  00044	8b 4c 24 0c	 mov	 ecx, DWORD PTR prev_pos$[rsp]
  00048	8b 44 24 58	 mov	 eax, DWORD PTR now_pos$[rsp]
  0004c	2b c1		 sub	 eax, ecx
  0004e	83 f8 05	 cmp	 eax, 5
  00051	76 0b		 jbe	 SHORT $LN20@x86_code

; 44   : 		prev_pos = now_pos - 5;

  00053	8b 44 24 58	 mov	 eax, DWORD PTR now_pos$[rsp]
  00057	83 e8 05	 sub	 eax, 5
  0005a	89 44 24 0c	 mov	 DWORD PTR prev_pos$[rsp], eax
$LN20@x86_code:

; 45   : 
; 46   :   {
; 47   : 	const size_t limit = size - 5;

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR size$[rsp]
  00063	48 83 e8 05	 sub	 rax, 5
  00067	48 89 44 24 18	 mov	 QWORD PTR limit$32966[rsp], rax

; 48   : 	size_t buffer_pos = 0;

  0006c	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR buffer_pos$32967[rsp], 0
$LN24@x86_code:
$LN19@x86_code:

; 49   : 
; 50   : 	while (buffer_pos <= limit) {

  00075	48 8b 44 24 18	 mov	 rax, QWORD PTR limit$32966[rsp]
  0007a	48 39 44 24 10	 cmp	 QWORD PTR buffer_pos$32967[rsp], rax
  0007f	0f 87 bf 02 00
	00		 ja	 $LN18@x86_code

; 51   : 		uint8_t b = buffer[buffer_pos];

  00085	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  0008f	48 03 c1	 add	 rax, rcx
  00092	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00095	88 44 24 20	 mov	 BYTE PTR b$32971[rsp], al

; 52   : 		if (b != 0xE8 && b != 0xE9) {

  00099	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  0009e	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  000a3	74 1c		 je	 SHORT $LN17@x86_code
  000a5	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  000aa	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  000af	74 10		 je	 SHORT $LN17@x86_code

; 53   : 			++buffer_pos;

  000b1	48 8b 44 24 10	 mov	 rax, QWORD PTR buffer_pos$32967[rsp]
  000b6	48 83 c0 01	 add	 rax, 1
  000ba	48 89 44 24 10	 mov	 QWORD PTR buffer_pos$32967[rsp], rax

; 54   : 			continue;

  000bf	eb b4		 jmp	 SHORT $LN19@x86_code
$LN17@x86_code:

; 55   : 		}
; 56   : 
; 57   :       {
; 58   : 		const uint32_t offset = now_pos + (uint32_t)(buffer_pos)
; 59   : 				- prev_pos;

  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR buffer_pos$32967[rsp]
  000c5	8b 44 24 58	 mov	 eax, DWORD PTR now_pos$[rsp]
  000c9	03 c1		 add	 eax, ecx
  000cb	2b 44 24 0c	 sub	 eax, DWORD PTR prev_pos$[rsp]
  000cf	89 44 24 24	 mov	 DWORD PTR offset$32973[rsp], eax

; 60   : 		prev_pos = now_pos + (uint32_t)(buffer_pos);

  000d3	8b 4c 24 10	 mov	 ecx, DWORD PTR buffer_pos$32967[rsp]
  000d7	8b 44 24 58	 mov	 eax, DWORD PTR now_pos$[rsp]
  000db	03 c1		 add	 eax, ecx
  000dd	89 44 24 0c	 mov	 DWORD PTR prev_pos$[rsp], eax

; 61   : 
; 62   : 		if (offset > 5) {

  000e1	83 7c 24 24 05	 cmp	 DWORD PTR offset$32973[rsp], 5
  000e6	76 0a		 jbe	 SHORT $LN16@x86_code

; 63   : 			prev_mask = 0;

  000e8	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR prev_mask$[rsp], 0

; 64   : 		} else {

  000f0	eb 36		 jmp	 SHORT $LN15@x86_code
$LN16@x86_code:

; 65   : 			uint32_t i;
; 66   : 			for (i = 0; i < offset; ++i) {

  000f2	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$32978[rsp], 0
  000fa	eb 0b		 jmp	 SHORT $LN14@x86_code
$LN13@x86_code:
  000fc	8b 44 24 28	 mov	 eax, DWORD PTR i$32978[rsp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 44 24 28	 mov	 DWORD PTR i$32978[rsp], eax
$LN14@x86_code:
  00107	8b 44 24 24	 mov	 eax, DWORD PTR offset$32973[rsp]
  0010b	39 44 24 28	 cmp	 DWORD PTR i$32978[rsp], eax
  0010f	73 17		 jae	 SHORT $LN12@x86_code

; 67   : 				prev_mask &= 0x77;

  00111	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  00115	83 e0 77	 and	 eax, 119		; 00000077H
  00118	89 44 24 08	 mov	 DWORD PTR prev_mask$[rsp], eax

; 68   : 				prev_mask <<= 1;

  0011c	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  00120	d1 e0		 shl	 eax, 1
  00122	89 44 24 08	 mov	 DWORD PTR prev_mask$[rsp], eax

; 69   : 			}

  00126	eb d4		 jmp	 SHORT $LN13@x86_code
$LN12@x86_code:
$LN15@x86_code:

; 70   : 		}
; 71   : 
; 72   : 		b = buffer[buffer_pos + 4];

  00128	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  00132	48 03 c1	 add	 rax, rcx
  00135	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00139	88 44 24 20	 mov	 BYTE PTR b$32971[rsp], al

; 73   : 
; 74   : 		if (Test86MSByte(b)
; 75   : 			&& MASK_TO_ALLOWED_STATUS[(prev_mask >> 1) & 0x7]
; 76   : 				&& (prev_mask >> 1) < 0x10) {

  0013d	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  00142	85 c0		 test	 eax, eax
  00144	74 10		 je	 SHORT $LN10@x86_code
  00146	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  0014b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00150	0f 85 b0 01 00
	00		 jne	 $LN11@x86_code
$LN10@x86_code:
  00156	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  0015a	d1 e8		 shr	 eax, 1
  0015c	83 e0 07	 and	 eax, 7
  0015f	8b c8		 mov	 ecx, eax
  00161	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?MASK_TO_ALLOWED_STATUS@?1??x86_code@@9@9
  00168	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 84 92 01 00
	00		 je	 $LN11@x86_code
  00174	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  00178	d1 e8		 shr	 eax, 1
  0017a	83 f8 10	 cmp	 eax, 16
  0017d	0f 83 83 01 00
	00		 jae	 $LN11@x86_code

; 77   : 
; 78   : 			uint32_t src = ((uint32_t)(b) << 24)
; 79   : 				| ((uint32_t)(buffer[buffer_pos + 3]) << 16)
; 80   : 				| ((uint32_t)(buffer[buffer_pos + 2]) << 8)
; 81   : 				| (buffer[buffer_pos + 1]);

  00183	0f b6 54 24 20	 movzx	 edx, BYTE PTR b$32971[rsp]
  00188	c1 e2 18	 shl	 edx, 24
  0018b	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  00190	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  00195	48 03 c1	 add	 rax, rcx
  00198	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0019c	c1 e0 10	 shl	 eax, 16
  0019f	0b d0		 or	 edx, eax
  001a1	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  001a6	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  001ab	48 03 c1	 add	 rax, rcx
  001ae	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001b2	c1 e0 08	 shl	 eax, 8
  001b5	0b d0		 or	 edx, eax
  001b7	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  001bc	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  001c1	48 03 c1	 add	 rax, rcx
  001c4	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  001c8	8b c2		 mov	 eax, edx
  001ca	0b c1		 or	 eax, ecx
  001cc	89 44 24 30	 mov	 DWORD PTR src$32984[rsp], eax
$LN9@x86_code:

; 82   : 
; 83   : 			uint32_t dest;
; 84   : 			while (true) {

  001d0	33 c0		 xor	 eax, eax
  001d2	83 f8 01	 cmp	 eax, 1
  001d5	0f 84 b1 00 00
	00		 je	 $LN8@x86_code

; 85   : 				if (is_encoder)

  001db	0f b6 44 24 60	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  001e0	85 c0		 test	 eax, eax
  001e2	74 18		 je	 SHORT $LN7@x86_code

; 86   : 					dest = src + (now_pos + (uint32_t)(
; 87   : 							buffer_pos) + 5);

  001e4	8b 44 24 10	 mov	 eax, DWORD PTR buffer_pos$32967[rsp]
  001e8	8b 4c 24 58	 mov	 ecx, DWORD PTR now_pos$[rsp]
  001ec	03 c8		 add	 ecx, eax
  001ee	8b 44 24 30	 mov	 eax, DWORD PTR src$32984[rsp]
  001f2	8d 44 08 05	 lea	 eax, DWORD PTR [rax+rcx+5]
  001f6	89 44 24 2c	 mov	 DWORD PTR dest$32988[rsp], eax

; 88   : 				else

  001fa	eb 16		 jmp	 SHORT $LN6@x86_code
$LN7@x86_code:

; 89   : 					dest = src - (now_pos + (uint32_t)(
; 90   : 							buffer_pos) + 5);

  001fc	8b 4c 24 58	 mov	 ecx, DWORD PTR now_pos$[rsp]
  00200	8b 44 24 10	 mov	 eax, DWORD PTR buffer_pos$32967[rsp]
  00204	8d 4c 01 05	 lea	 ecx, DWORD PTR [rcx+rax+5]
  00208	8b 44 24 30	 mov	 eax, DWORD PTR src$32984[rsp]
  0020c	2b c1		 sub	 eax, ecx
  0020e	89 44 24 2c	 mov	 DWORD PTR dest$32988[rsp], eax
$LN6@x86_code:

; 91   : 
; 92   : 				if (prev_mask == 0)

  00212	83 7c 24 08 00	 cmp	 DWORD PTR prev_mask$[rsp], 0
  00217	75 02		 jne	 SHORT $LN5@x86_code

; 93   : 					break;

  00219	eb 71		 jmp	 SHORT $LN8@x86_code
$LN5@x86_code:

; 94   : 
; 95   :               {
; 96   : 				const uint32_t i = MASK_TO_BIT_NUMBER[
; 97   : 						prev_mask >> 1];

  0021b	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  0021f	d1 e8		 shr	 eax, 1
  00221	8b c8		 mov	 ecx, eax
  00223	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?MASK_TO_BIT_NUMBER@?1??x86_code@@9@9
  0022a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0022d	89 44 24 34	 mov	 DWORD PTR i$32997[rsp], eax

; 98   : 
; 99   : 				b = (uint8_t)(dest >> (24 - i * 8));

  00231	8b 4c 24 34	 mov	 ecx, DWORD PTR i$32997[rsp]
  00235	c1 e1 03	 shl	 ecx, 3
  00238	b8 18 00 00 00	 mov	 eax, 24
  0023d	2b c1		 sub	 eax, ecx
  0023f	0f b6 c8	 movzx	 ecx, al
  00242	8b 44 24 2c	 mov	 eax, DWORD PTR dest$32988[rsp]
  00246	d3 e8		 shr	 eax, cl
  00248	88 44 24 20	 mov	 BYTE PTR b$32971[rsp], al

; 100  : 
; 101  : 				if (!Test86MSByte(b))

  0024c	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  00251	85 c0		 test	 eax, eax
  00253	74 0e		 je	 SHORT $LN4@x86_code
  00255	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  0025a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0025f	74 02		 je	 SHORT $LN4@x86_code

; 102  : 					break;

  00261	eb 29		 jmp	 SHORT $LN8@x86_code
$LN4@x86_code:

; 103  : 
; 104  : 				src = dest ^ ((1 << (32 - i * 8)) - 1);

  00263	8b 44 24 34	 mov	 eax, DWORD PTR i$32997[rsp]
  00267	c1 e0 03	 shl	 eax, 3
  0026a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0026f	2b c8		 sub	 ecx, eax
  00271	b8 01 00 00 00	 mov	 eax, 1
  00276	d3 e0		 shl	 eax, cl
  00278	8b c8		 mov	 ecx, eax
  0027a	83 e9 01	 sub	 ecx, 1
  0027d	8b 44 24 2c	 mov	 eax, DWORD PTR dest$32988[rsp]
  00281	33 c1		 xor	 eax, ecx
  00283	89 44 24 30	 mov	 DWORD PTR src$32984[rsp], eax

; 105  : 			  }
; 106  : 			}

  00287	e9 44 ff ff ff	 jmp	 $LN9@x86_code
$LN8@x86_code:

; 107  : 
; 108  : 			buffer[buffer_pos + 4]
; 109  : 					= (uint8_t)(~(((dest >> 24) & 1) - 1));

  0028c	8b 54 24 2c	 mov	 edx, DWORD PTR dest$32988[rsp]
  00290	c1 ea 18	 shr	 edx, 24
  00293	83 e2 01	 and	 edx, 1
  00296	83 ea 01	 sub	 edx, 1
  00299	f7 d2		 not	 edx
  0029b	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  002a0	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  002a5	48 03 c1	 add	 rax, rcx
  002a8	88 50 04	 mov	 BYTE PTR [rax+4], dl

; 110  : 			buffer[buffer_pos + 3] = (uint8_t)(dest >> 16);

  002ab	8b 54 24 2c	 mov	 edx, DWORD PTR dest$32988[rsp]
  002af	c1 ea 10	 shr	 edx, 16
  002b2	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  002b7	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  002bc	48 03 c1	 add	 rax, rcx
  002bf	88 50 03	 mov	 BYTE PTR [rax+3], dl

; 111  : 			buffer[buffer_pos + 2] = (uint8_t)(dest >> 8);

  002c2	8b 54 24 2c	 mov	 edx, DWORD PTR dest$32988[rsp]
  002c6	c1 ea 08	 shr	 edx, 8
  002c9	48 8b 4c 24 10	 mov	 rcx, QWORD PTR buffer_pos$32967[rsp]
  002ce	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  002d3	48 03 c1	 add	 rax, rcx
  002d6	88 50 02	 mov	 BYTE PTR [rax+2], dl

; 112  : 			buffer[buffer_pos + 1] = (uint8_t)(dest);

  002d9	48 8b 44 24 10	 mov	 rax, QWORD PTR buffer_pos$32967[rsp]
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  002e3	48 03 c8	 add	 rcx, rax
  002e6	0f b6 44 24 2c	 movzx	 eax, BYTE PTR dest$32988[rsp]
  002eb	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 113  : 			buffer_pos += 5;

  002ee	48 8b 44 24 10	 mov	 rax, QWORD PTR buffer_pos$32967[rsp]
  002f3	48 83 c0 05	 add	 rax, 5
  002f7	48 89 44 24 10	 mov	 QWORD PTR buffer_pos$32967[rsp], rax

; 114  : 			prev_mask = 0;

  002fc	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR prev_mask$[rsp], 0

; 115  : 
; 116  : 		} else {

  00304	eb 39		 jmp	 SHORT $LN3@x86_code
$LN11@x86_code:

; 117  : 			++buffer_pos;

  00306	48 8b 44 24 10	 mov	 rax, QWORD PTR buffer_pos$32967[rsp]
  0030b	48 83 c0 01	 add	 rax, 1
  0030f	48 89 44 24 10	 mov	 QWORD PTR buffer_pos$32967[rsp], rax

; 118  : 			prev_mask |= 1;

  00314	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  00318	83 c8 01	 or	 eax, 1
  0031b	89 44 24 08	 mov	 DWORD PTR prev_mask$[rsp], eax

; 119  : 			if (Test86MSByte(b))

  0031f	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  00324	85 c0		 test	 eax, eax
  00326	74 0c		 je	 SHORT $LN1@x86_code
  00328	0f b6 44 24 20	 movzx	 eax, BYTE PTR b$32971[rsp]
  0032d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00332	75 0b		 jne	 SHORT $LN2@x86_code
$LN1@x86_code:

; 120  : 				prev_mask |= 0x10;

  00334	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  00338	83 c8 10	 or	 eax, 16
  0033b	89 44 24 08	 mov	 DWORD PTR prev_mask$[rsp], eax
$LN2@x86_code:
$LN3@x86_code:

; 121  : 		}
; 122  : 	}
; 123  :   }

  0033f	e9 31 fd ff ff	 jmp	 $LN24@x86_code
$LN18@x86_code:

; 124  : 
; 125  : 	simple->prev_mask = prev_mask;

  00344	48 8b 0c 24	 mov	 rcx, QWORD PTR simple$[rsp]
  00348	8b 44 24 08	 mov	 eax, DWORD PTR prev_mask$[rsp]
  0034c	89 01		 mov	 DWORD PTR [rcx], eax

; 126  : 	simple->prev_pos = prev_pos;

  0034e	48 8b 0c 24	 mov	 rcx, QWORD PTR simple$[rsp]
  00352	8b 44 24 0c	 mov	 eax, DWORD PTR prev_pos$[rsp]
  00356	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 127  : 
; 128  : 	return buffer_pos;

  00359	48 8b 44 24 10	 mov	 rax, QWORD PTR buffer_pos$32967[rsp]
$LN22@x86_code:

; 129  :   }
; 130  : }

  0035e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00362	c3		 ret	 0
x86_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$x86_coder_init DD imagerel x86_coder_init
	DD	imagerel x86_coder_init+162
	DD	imagerel $unwind$x86_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x86_coder_init DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT x86_coder_init
_TEXT	SEGMENT
ret$ = 64
simple$33021 = 72
coder$33020 = 80
next$ = 112
allocator$ = 120
filters$ = 128
is_encoder$ = 136
x86_coder_init PROC					; COMDAT

; 136  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 137  : 	const lzma_ret ret = lzma_simple_coder_init(next, allocator, filters,
; 138  : 			&x86_code, sizeof(lzma_simple_x86), 5, 1, is_encoder);

  00018	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  00020	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00024	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR [rsp+48], 1
  0002c	48 c7 44 24 28
	05 00 00 00	 mov	 QWORD PTR [rsp+40], 5
  00035	48 c7 44 24 20
	08 00 00 00	 mov	 QWORD PTR [rsp+32], 8
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:x86_code
  00045	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  0004d	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  00052	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  00057	e8 00 00 00 00	 call	 lzma_simple_coder_init
  0005c	89 44 24 40	 mov	 DWORD PTR ret$[rsp], eax

; 139  : 
; 140  : 	if (ret == LZMA_OK) {

  00060	83 7c 24 40 00	 cmp	 DWORD PTR ret$[rsp], 0
  00065	75 32		 jne	 SHORT $LN1@x86_coder_

; 141  : 		lzma_simple_coder *coder = next->coder;

  00067	48 8b 44 24 70	 mov	 rax, QWORD PTR next$[rsp]
  0006c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006f	48 89 44 24 50	 mov	 QWORD PTR coder$33020[rsp], rax

; 142  : 		lzma_simple_x86 *simple = coder->simple;

  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$33020[rsp]
  00079	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007d	48 89 44 24 48	 mov	 QWORD PTR simple$33021[rsp], rax

; 143  : 		simple->prev_mask = 0;

  00082	48 8b 44 24 48	 mov	 rax, QWORD PTR simple$33021[rsp]
  00087	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 144  : 		simple->prev_pos = (uint32_t)(-5);

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR simple$33021[rsp]
  00092	c7 40 04 fb ff
	ff ff		 mov	 DWORD PTR [rax+4], -5	; fffffffbH
$LN1@x86_coder_:

; 145  : 	}
; 146  : 
; 147  : 	return ret;

  00099	8b 44 24 40	 mov	 eax, DWORD PTR ret$[rsp]

; 148  : }

  0009d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000a1	c3		 ret	 0
x86_coder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_x86_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$lzma_simple_x86_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_x86_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_x86_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_simple_x86_decoder_init PROC			; COMDAT

; 164  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 165  : 	return x86_coder_init(next, allocator, filters, false);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00025	e8 00 00 00 00	 call	 x86_coder_init

; 166  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
lzma_simple_x86_decoder_init ENDP
END
