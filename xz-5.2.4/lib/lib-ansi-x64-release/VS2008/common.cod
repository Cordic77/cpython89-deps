; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	LZMA_NEXT_CODER_INIT
PUBLIC	??_C@_05LHKAPBBA@5?42?44?$AA@			; `string'
EXTRN	malloc:PROC
EXTRN	calloc:PROC
EXTRN	free:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
;	COMDAT ??_C@_05LHKAPBBA@5?42?44?$AA@
CONST	SEGMENT
??_C@_05LHKAPBBA@5?42?44?$AA@ DB '5.2.4', 00H		; `string'
	ORG $+16
LZMA_NEXT_CODER_INIT DQ 0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
PUBLIC	lzma_code
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\common.c
pdata	SEGMENT
$pdata$lzma_code DD imagerel $LN50
	DD	imagerel $LN50+1481
	DD	imagerel $unwind$lzma_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_code DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_code
_TEXT	SEGMENT
out_pos$32964 = 80
in_pos$32963 = 88
ret$32965 = 96
tv137 = 100
tv138 = 104
tv209 = 108
strm$ = 128
action$ = 136
lzma_code PROC						; COMDAT

; 214  : {

$LN50:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 215  : 	// Sanity checks
; 216  : 	if ((strm->next_in == NULL && strm->avail_in != 0)
; 217  : 			|| (strm->next_out == NULL && strm->avail_out != 0)
; 218  : 			|| strm->internal == NULL
; 219  : 			|| strm->internal->next.code == NULL
; 220  : 			|| (unsigned int)(action) > LZMA_ACTION_MAX
; 221  : 			|| !strm->internal->supported_actions[action])

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00015	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00019	75 0f		 jne	 SHORT $LN42@lzma_code
  0001b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	75 67		 jne	 SHORT $LN43@lzma_code
$LN42@lzma_code:
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00032	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00037	75 0f		 jne	 SHORT $LN41@lzma_code
  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00041	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00046	75 49		 jne	 SHORT $LN43@lzma_code
$LN41@lzma_code:
  00048	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00055	74 3a		 je	 SHORT $LN43@lzma_code
  00057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0005f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00063	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00068	74 27		 je	 SHORT $LN43@lzma_code
  0006a	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR action$[rsp], 4
  00072	77 1d		 ja	 SHORT $LN43@lzma_code
  00074	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0007c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00080	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR action$[rsp]
  00088	0f b6 44 01 58	 movzx	 eax, BYTE PTR [rcx+rax+88]
  0008d	85 c0		 test	 eax, eax
  0008f	75 0a		 jne	 SHORT $LN44@lzma_code
$LN43@lzma_code:

; 222  : 		return LZMA_PROG_ERROR;

  00091	b8 0b 00 00 00	 mov	 eax, 11
  00096	e9 d9 04 00 00	 jmp	 $LN45@lzma_code
$LN44@lzma_code:

; 223  : 
; 224  : 	// Check if unsupported members have been set to non-zero or non-NULL,
; 225  : 	// which would indicate that some new feature is wanted.
; 226  : 	if (strm->reserved_ptr1 != NULL
; 227  : 			|| strm->reserved_ptr2 != NULL
; 228  : 			|| strm->reserved_ptr3 != NULL
; 229  : 			|| strm->reserved_ptr4 != NULL
; 230  : 			|| strm->reserved_int1 != 0
; 231  : 			|| strm->reserved_int2 != 0
; 232  : 			|| strm->reserved_int3 != 0
; 233  : 			|| strm->reserved_int4 != 0
; 234  : 			|| strm->reserved_enum1 != LZMA_RESERVED_ENUM
; 235  : 			|| strm->reserved_enum2 != LZMA_RESERVED_ENUM)

  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a3	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000a8	0f 85 8b 00 00
	00		 jne	 $LN39@lzma_code
  000ae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b6	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  000bb	75 7c		 jne	 SHORT $LN39@lzma_code
  000bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c5	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000ca	75 6d		 jne	 SHORT $LN39@lzma_code
  000cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000d4	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  000d9	75 5e		 jne	 SHORT $LN39@lzma_code
  000db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000e3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000e8	75 4f		 jne	 SHORT $LN39@lzma_code
  000ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000f2	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000f7	75 40		 jne	 SHORT $LN39@lzma_code
  000f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00101	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00106	75 31		 jne	 SHORT $LN39@lzma_code
  00108	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00110	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00115	75 22		 jne	 SHORT $LN39@lzma_code
  00117	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0011f	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  00126	75 11		 jne	 SHORT $LN39@lzma_code
  00128	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00130	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00137	74 0a		 je	 SHORT $LN40@lzma_code
$LN39@lzma_code:

; 236  : 		return LZMA_OPTIONS_ERROR;

  00139	b8 08 00 00 00	 mov	 eax, 8
  0013e	e9 31 04 00 00	 jmp	 $LN45@lzma_code
$LN40@lzma_code:

; 237  : 
; 238  : 	switch (strm->internal->sequence) {

  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0014b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0014f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00152	89 44 24 64	 mov	 DWORD PTR tv137[rsp], eax
  00156	83 7c 24 64 05	 cmp	 DWORD PTR tv137[rsp], 5
  0015b	0f 87 77 01 00
	00		 ja	 $LN15@lzma_code
  00161	48 63 44 24 64	 movsxd	 rax, DWORD PTR tv137[rsp]
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0016d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN49@lzma_code[rcx+rax*4]
  00174	48 03 c1	 add	 rax, rcx
  00177	ff e0		 jmp	 rax
$LN36@lzma_code:

; 239  : 	case ISEQ_RUN:
; 240  : 		switch (action) {

  00179	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00180	89 44 24 68	 mov	 DWORD PTR tv138[rsp], eax
  00184	83 7c 24 68 01	 cmp	 DWORD PTR tv138[rsp], 1
  00189	74 19		 je	 SHORT $LN32@lzma_code
  0018b	83 7c 24 68 02	 cmp	 DWORD PTR tv138[rsp], 2
  00190	74 27		 je	 SHORT $LN31@lzma_code
  00192	83 7c 24 68 03	 cmp	 DWORD PTR tv138[rsp], 3
  00197	74 35		 je	 SHORT $LN30@lzma_code
  00199	83 7c 24 68 04	 cmp	 DWORD PTR tv138[rsp], 4
  0019e	74 43		 je	 SHORT $LN29@lzma_code
  001a0	eb 54		 jmp	 SHORT $LN34@lzma_code

; 241  : 		case LZMA_RUN:
; 242  : 			break;

  001a2	eb 52		 jmp	 SHORT $LN34@lzma_code
$LN32@lzma_code:

; 243  : 
; 244  : 		case LZMA_SYNC_FLUSH:
; 245  : 			strm->internal->sequence = ISEQ_SYNC_FLUSH;

  001a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  001ac	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001b0	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 246  : 			break;

  001b7	eb 3d		 jmp	 SHORT $LN34@lzma_code
$LN31@lzma_code:

; 247  : 
; 248  : 		case LZMA_FULL_FLUSH:
; 249  : 			strm->internal->sequence = ISEQ_FULL_FLUSH;

  001b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  001c1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001c5	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 250  : 			break;

  001cc	eb 28		 jmp	 SHORT $LN34@lzma_code
$LN30@lzma_code:

; 251  : 
; 252  : 		case LZMA_FINISH:
; 253  : 			strm->internal->sequence = ISEQ_FINISH;

  001ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  001d6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001da	c7 40 48 03 00
	00 00		 mov	 DWORD PTR [rax+72], 3

; 254  : 			break;

  001e1	eb 13		 jmp	 SHORT $LN34@lzma_code
$LN29@lzma_code:

; 255  : 
; 256  : 		case LZMA_FULL_BARRIER:
; 257  : 			strm->internal->sequence = ISEQ_FULL_BARRIER;

  001e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  001eb	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001ef	c7 40 48 04 00
	00 00		 mov	 DWORD PTR [rax+72], 4
$LN34@lzma_code:

; 258  : 			break;
; 259  : 		}
; 260  : 
; 261  : 		break;

  001f6	e9 e7 00 00 00	 jmp	 $LN37@lzma_code
$LN28@lzma_code:

; 262  : 
; 263  : 	case ISEQ_SYNC_FLUSH:
; 264  : 		// The same action must be used until we return
; 265  : 		// LZMA_STREAM_END, and the amount of input must not change.
; 266  : 		if (action != LZMA_SYNC_FLUSH
; 267  : 				|| strm->internal->avail_in != strm->avail_in)

  001fb	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR action$[rsp], 1
  00203	75 1e		 jne	 SHORT $LN26@lzma_code
  00205	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0020d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00211	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00219	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0021d	48 39 41 50	 cmp	 QWORD PTR [rcx+80], rax
  00221	74 0a		 je	 SHORT $LN27@lzma_code
$LN26@lzma_code:

; 268  : 			return LZMA_PROG_ERROR;

  00223	b8 0b 00 00 00	 mov	 eax, 11
  00228	e9 47 03 00 00	 jmp	 $LN45@lzma_code
$LN27@lzma_code:

; 269  : 
; 270  : 		break;

  0022d	e9 b0 00 00 00	 jmp	 $LN37@lzma_code
$LN25@lzma_code:

; 271  : 
; 272  : 	case ISEQ_FULL_FLUSH:
; 273  : 		if (action != LZMA_FULL_FLUSH
; 274  : 				|| strm->internal->avail_in != strm->avail_in)

  00232	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR action$[rsp], 2
  0023a	75 1e		 jne	 SHORT $LN23@lzma_code
  0023c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00244	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00248	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00250	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00254	48 39 41 50	 cmp	 QWORD PTR [rcx+80], rax
  00258	74 0a		 je	 SHORT $LN24@lzma_code
$LN23@lzma_code:

; 275  : 			return LZMA_PROG_ERROR;

  0025a	b8 0b 00 00 00	 mov	 eax, 11
  0025f	e9 10 03 00 00	 jmp	 $LN45@lzma_code
$LN24@lzma_code:

; 276  : 
; 277  : 		break;

  00264	eb 7c		 jmp	 SHORT $LN37@lzma_code
$LN22@lzma_code:

; 278  : 
; 279  : 	case ISEQ_FINISH:
; 280  : 		if (action != LZMA_FINISH
; 281  : 				|| strm->internal->avail_in != strm->avail_in)

  00266	83 bc 24 88 00
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  0026e	75 1e		 jne	 SHORT $LN20@lzma_code
  00270	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00278	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0027c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00284	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00288	48 39 41 50	 cmp	 QWORD PTR [rcx+80], rax
  0028c	74 0a		 je	 SHORT $LN21@lzma_code
$LN20@lzma_code:

; 282  : 			return LZMA_PROG_ERROR;

  0028e	b8 0b 00 00 00	 mov	 eax, 11
  00293	e9 dc 02 00 00	 jmp	 $LN45@lzma_code
$LN21@lzma_code:

; 283  : 
; 284  : 		break;

  00298	eb 48		 jmp	 SHORT $LN37@lzma_code
$LN19@lzma_code:

; 285  : 
; 286  : 	case ISEQ_FULL_BARRIER:
; 287  : 		if (action != LZMA_FULL_BARRIER
; 288  : 				|| strm->internal->avail_in != strm->avail_in)

  0029a	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR action$[rsp], 4
  002a2	75 1e		 jne	 SHORT $LN17@lzma_code
  002a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002ac	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  002b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  002b8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002bc	48 39 41 50	 cmp	 QWORD PTR [rcx+80], rax
  002c0	74 0a		 je	 SHORT $LN18@lzma_code
$LN17@lzma_code:

; 289  : 			return LZMA_PROG_ERROR;

  002c2	b8 0b 00 00 00	 mov	 eax, 11
  002c7	e9 a8 02 00 00	 jmp	 $LN45@lzma_code
$LN18@lzma_code:

; 290  : 
; 291  : 		break;

  002cc	eb 14		 jmp	 SHORT $LN37@lzma_code
$LN16@lzma_code:

; 292  : 
; 293  : 	case ISEQ_END:
; 294  : 		return LZMA_STREAM_END;

  002ce	b8 01 00 00 00	 mov	 eax, 1
  002d3	e9 9c 02 00 00	 jmp	 $LN45@lzma_code
$LN15@lzma_code:

; 295  : 
; 296  : 	case ISEQ_ERROR:
; 297  : 	default:
; 298  : 		return LZMA_PROG_ERROR;

  002d8	b8 0b 00 00 00	 mov	 eax, 11
  002dd	e9 92 02 00 00	 jmp	 $LN45@lzma_code
$LN37@lzma_code:

; 299  : 	}
; 300  : 
; 301  :   {
; 302  : 	size_t in_pos = 0;

  002e2	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR in_pos$32963[rsp], 0

; 303  : 	size_t out_pos = 0;

  002eb	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR out_pos$32964[rsp], 0

; 304  : 	lzma_ret ret = strm->internal->next.code(
; 305  : 			strm->internal->next.coder, strm->allocator,
; 306  : 			strm->next_in, &in_pos, strm->avail_in,
; 307  : 			strm->next_out, &out_pos, strm->avail_out, action);

  002f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002fc	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00300	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR strm$[rsp]
  00308	4d 8b 52 38	 mov	 r10, QWORD PTR [r10+56]
  0030c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00313	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00317	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0031f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00323	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00328	48 8d 44 24 50	 lea	 rax, QWORD PTR out_pos$32964[rsp]
  0032d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00332	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0033a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0033e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00343	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0034b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0034f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00354	4c 8d 4c 24 58	 lea	 r9, QWORD PTR in_pos$32963[rsp]
  00359	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR strm$[rsp]
  00361	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00364	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0036c	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00370	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00373	41 ff 52 18	 call	 QWORD PTR [r10+24]
  00377	89 44 24 60	 mov	 DWORD PTR ret$32965[rsp], eax

; 308  : 
; 309  : 	strm->next_in += in_pos;

  0037b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00383	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00386	48 03 4c 24 58	 add	 rcx, QWORD PTR in_pos$32963[rsp]
  0038b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00393	48 89 08	 mov	 QWORD PTR [rax], rcx

; 310  : 	strm->avail_in -= in_pos;

  00396	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0039e	48 8b 44 24 58	 mov	 rax, QWORD PTR in_pos$32963[rsp]
  003a3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  003a7	48 2b c8	 sub	 rcx, rax
  003aa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003b2	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 311  : 	strm->total_in += in_pos;

  003b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003be	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003c2	48 03 4c 24 58	 add	 rcx, QWORD PTR in_pos$32963[rsp]
  003c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003cf	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 312  : 
; 313  : 	strm->next_out += out_pos;

  003d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003db	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  003df	48 03 4c 24 50	 add	 rcx, QWORD PTR out_pos$32964[rsp]
  003e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003ec	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 314  : 	strm->avail_out -= out_pos;

  003f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003f8	48 8b 44 24 50	 mov	 rax, QWORD PTR out_pos$32964[rsp]
  003fd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00401	48 2b c8	 sub	 rcx, rax
  00404	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0040c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 315  : 	strm->total_out += out_pos;

  00410	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00418	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0041c	48 03 4c 24 50	 add	 rcx, QWORD PTR out_pos$32964[rsp]
  00421	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00429	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 316  : 
; 317  : 	strm->internal->avail_in = strm->avail_in;

  0042d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00435	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00439	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00441	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00445	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 318  : 
; 319  : 	// Cast is needed to silence a warning about LZMA_TIMED_OUT, which
; 320  : 	// isn't part of lzma_ret enumeration.
; 321  : 	switch ((unsigned int)(ret)) {

  00449	8b 44 24 60	 mov	 eax, DWORD PTR ret$32965[rsp]
  0044d	89 44 24 6c	 mov	 DWORD PTR tv209[rsp], eax
  00451	83 7c 24 6c 20	 cmp	 DWORD PTR tv209[rsp], 32 ; 00000020H
  00456	0f 87 01 01 00
	00		 ja	 $LN1@lzma_code
  0045c	8b 44 24 6c	 mov	 eax, DWORD PTR tv209[rsp]
  00460	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00467	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN47@lzma_code[rcx+rax]
  0046f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN48@lzma_code[rcx+rax*4]
  00476	48 03 c1	 add	 rax, rcx
  00479	ff e0		 jmp	 rax
$LN12@lzma_code:

; 322  : 	case LZMA_OK:
; 323  : 		// Don't return LZMA_BUF_ERROR when it happens the first time.
; 324  : 		// This is to avoid returning LZMA_BUF_ERROR when avail_out
; 325  : 		// was zero but still there was no more data left to written
; 326  : 		// to next_out.
; 327  : 		if (out_pos == 0 && in_pos == 0) {

  0047b	48 83 7c 24 50
	00		 cmp	 QWORD PTR out_pos$32964[rsp], 0
  00481	75 38		 jne	 SHORT $LN11@lzma_code
  00483	48 83 7c 24 58
	00		 cmp	 QWORD PTR in_pos$32963[rsp], 0
  00489	75 30		 jne	 SHORT $LN11@lzma_code

; 328  : 			if (strm->internal->allow_buf_error)

  0048b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00493	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00497	0f b6 40 5d	 movzx	 eax, BYTE PTR [rax+93]
  0049b	85 c0		 test	 eax, eax
  0049d	74 0a		 je	 SHORT $LN10@lzma_code

; 329  : 				ret = LZMA_BUF_ERROR;

  0049f	c7 44 24 60 0a
	00 00 00	 mov	 DWORD PTR ret$32965[rsp], 10

; 330  : 			else

  004a7	eb 10		 jmp	 SHORT $LN9@lzma_code
$LN10@lzma_code:

; 331  : 				strm->internal->allow_buf_error = true;

  004a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  004b1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  004b5	c6 40 5d 01	 mov	 BYTE PTR [rax+93], 1
$LN9@lzma_code:

; 332  : 		} else {

  004b9	eb 10		 jmp	 SHORT $LN8@lzma_code
$LN11@lzma_code:

; 333  : 			strm->internal->allow_buf_error = false;

  004bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  004c3	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  004c7	c6 40 5d 00	 mov	 BYTE PTR [rax+93], 0
$LN8@lzma_code:

; 334  : 		}
; 335  : 		break;

  004cb	e9 a0 00 00 00	 jmp	 $LN13@lzma_code
$LN7@lzma_code:

; 336  : 
; 337  : 	case LZMA_TIMED_OUT:
; 338  : 		strm->internal->allow_buf_error = false;

  004d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  004d8	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  004dc	c6 40 5d 00	 mov	 BYTE PTR [rax+93], 0

; 339  : 		ret = LZMA_OK;

  004e0	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ret$32965[rsp], 0

; 340  : 		break;

  004e8	e9 83 00 00 00	 jmp	 $LN13@lzma_code
$LN6@lzma_code:

; 341  : 
; 342  : 	case LZMA_STREAM_END:
; 343  : 		if (strm->internal->sequence == ISEQ_SYNC_FLUSH
; 344  : 				|| strm->internal->sequence == ISEQ_FULL_FLUSH
; 345  : 				|| strm->internal->sequence
; 346  : 					== ISEQ_FULL_BARRIER)

  004ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  004f5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  004f9	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  004fd	74 24		 je	 SHORT $LN4@lzma_code
  004ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00507	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0050b	83 78 48 02	 cmp	 DWORD PTR [rax+72], 2
  0050f	74 12		 je	 SHORT $LN4@lzma_code
  00511	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00519	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0051d	83 78 48 04	 cmp	 DWORD PTR [rax+72], 4
  00521	75 15		 jne	 SHORT $LN5@lzma_code
$LN4@lzma_code:

; 347  : 			strm->internal->sequence = ISEQ_RUN;

  00523	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0052b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0052f	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 348  : 		else

  00536	eb 13		 jmp	 SHORT $LN3@lzma_code
$LN5@lzma_code:

; 349  : 			strm->internal->sequence = ISEQ_END;

  00538	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00540	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00544	c7 40 48 05 00
	00 00		 mov	 DWORD PTR [rax+72], 5
$LN3@lzma_code:
$LN2@lzma_code:

; 350  : 
; 351  : 	// Fall through
; 352  : 
; 353  : 	case LZMA_NO_CHECK:
; 354  : 	case LZMA_UNSUPPORTED_CHECK:
; 355  : 	case LZMA_GET_CHECK:
; 356  : 	case LZMA_MEMLIMIT_ERROR:
; 357  : 		// Something else than LZMA_OK, but not a fatal error,
; 358  : 		// that is, coding may be continued (except if ISEQ_END).
; 359  : 		strm->internal->allow_buf_error = false;

  0054b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00553	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00557	c6 40 5d 00	 mov	 BYTE PTR [rax+93], 0

; 360  : 		break;

  0055b	eb 13		 jmp	 SHORT $LN13@lzma_code
$LN1@lzma_code:

; 361  : 
; 362  : 	default:
; 363  : 		// All the other errors are fatal; coding cannot be continued.
; 364  : 		assert(ret != LZMA_BUF_ERROR);
; 365  : 		strm->internal->sequence = ISEQ_ERROR;

  0055d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00565	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00569	c7 40 48 06 00
	00 00		 mov	 DWORD PTR [rax+72], 6
$LN13@lzma_code:

; 366  : 		break;
; 367  : 	}
; 368  : 
; 369  : 	return ret;

  00570	8b 44 24 60	 mov	 eax, DWORD PTR ret$32965[rsp]
$LN45@lzma_code:

; 370  :   }
; 371  : }

  00574	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00578	c3		 ret	 0
  00579	0f 1f 00	 npad	 3
$LN49@lzma_code:
  0057c	00 00 00 00	 DD	 $LN36@lzma_code
  00580	00 00 00 00	 DD	 $LN28@lzma_code
  00584	00 00 00 00	 DD	 $LN25@lzma_code
  00588	00 00 00 00	 DD	 $LN22@lzma_code
  0058c	00 00 00 00	 DD	 $LN19@lzma_code
  00590	00 00 00 00	 DD	 $LN16@lzma_code
$LN48@lzma_code:
  00594	00 00 00 00	 DD	 $LN12@lzma_code
  00598	00 00 00 00	 DD	 $LN6@lzma_code
  0059c	00 00 00 00	 DD	 $LN2@lzma_code
  005a0	00 00 00 00	 DD	 $LN7@lzma_code
  005a4	00 00 00 00	 DD	 $LN1@lzma_code
$LN47@lzma_code:
  005a8	00		 DB	 0
  005a9	01		 DB	 1
  005aa	02		 DB	 2
  005ab	02		 DB	 2
  005ac	02		 DB	 2
  005ad	04		 DB	 4
  005ae	02		 DB	 2
  005af	04		 DB	 4
  005b0	04		 DB	 4
  005b1	04		 DB	 4
  005b2	04		 DB	 4
  005b3	04		 DB	 4
  005b4	04		 DB	 4
  005b5	04		 DB	 4
  005b6	04		 DB	 4
  005b7	04		 DB	 4
  005b8	04		 DB	 4
  005b9	04		 DB	 4
  005ba	04		 DB	 4
  005bb	04		 DB	 4
  005bc	04		 DB	 4
  005bd	04		 DB	 4
  005be	04		 DB	 4
  005bf	04		 DB	 4
  005c0	04		 DB	 4
  005c1	04		 DB	 4
  005c2	04		 DB	 4
  005c3	04		 DB	 4
  005c4	04		 DB	 4
  005c5	04		 DB	 4
  005c6	04		 DB	 4
  005c7	04		 DB	 4
  005c8	03		 DB	 3
lzma_code ENDP
_TEXT	ENDS
PUBLIC	lzma_next_filter_update
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_next_filter_update DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$lzma_next_filter_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_next_filter_update DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_next_filter_update
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
reversed_filters$ = 64
lzma_next_filter_update PROC				; COMDAT

; 145  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 146  : 	// Check that the application isn't trying to change the Filter ID.
; 147  : 	// End of filters is indicated with LZMA_VLI_UNKNOWN in both
; 148  : 	// reversed_filters[0].id and next->id.
; 149  : 	if (reversed_filters[0].id != next->id)

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR reversed_filters$[rsp]
  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00024	74 07		 je	 SHORT $LN2@lzma_next_

; 150  : 		return LZMA_PROG_ERROR;

  00026	b8 0b 00 00 00	 mov	 eax, 11
  0002b	eb 2c		 jmp	 SHORT $LN3@lzma_next_
$LN2@lzma_next_:

; 151  : 
; 152  : 	if (reversed_filters[0].id == LZMA_VLI_UNKNOWN)

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR reversed_filters$[rsp]
  00032	48 83 38 ff	 cmp	 QWORD PTR [rax], -1
  00036	75 04		 jne	 SHORT $LN1@lzma_next_

; 153  : 		return LZMA_OK;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 1d		 jmp	 SHORT $LN3@lzma_next_
$LN1@lzma_next_:

; 154  : 
; 155  : 	assert(next->update != NULL);
; 156  : 	return next->update(next->coder, allocator, NULL, reversed_filters);

  0003c	4c 8b 4c 24 40	 mov	 r9, QWORD PTR reversed_filters$[rsp]
  00041	45 33 c0	 xor	 r8d, r8d
  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  00056	ff 50 40	 call	 QWORD PTR [rax+64]
$LN3@lzma_next_:

; 157  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
lzma_next_filter_update ENDP
_TEXT	ENDS
PUBLIC	lzma_bufcpy
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_bufcpy DD imagerel $LN5
	DD	imagerel $LN5+204
	DD	imagerel $unwind$lzma_bufcpy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_bufcpy DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_bufcpy
_TEXT	SEGMENT
out_avail$ = 32
in_avail$ = 40
copy_size$ = 48
tv67 = 56
in$ = 80
in_pos$ = 88
in_size$ = 96
out$ = 104
out_pos$ = 112
out_size$ = 120
lzma_bufcpy PROC					; COMDAT

; 117  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 118  : 	const size_t in_avail = in_size - *in_pos;

  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0001d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00020	48 8b 44 24 60	 mov	 rax, QWORD PTR in_size$[rsp]
  00025	48 2b c1	 sub	 rax, rcx
  00028	48 89 44 24 28	 mov	 QWORD PTR in_avail$[rsp], rax

; 119  : 	const size_t out_avail = out_size - *out_pos;

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00032	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00035	48 8b 44 24 78	 mov	 rax, QWORD PTR out_size$[rsp]
  0003a	48 2b c1	 sub	 rax, rcx
  0003d	48 89 44 24 20	 mov	 QWORD PTR out_avail$[rsp], rax

; 120  : 	const size_t copy_size = my_min(in_avail, out_avail);

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR out_avail$[rsp]
  00047	48 39 44 24 28	 cmp	 QWORD PTR in_avail$[rsp], rax
  0004c	73 0c		 jae	 SHORT $LN3@lzma_bufcp
  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR in_avail$[rsp]
  00053	48 89 44 24 38	 mov	 QWORD PTR tv67[rsp], rax
  00058	eb 0a		 jmp	 SHORT $LN4@lzma_bufcp
$LN3@lzma_bufcp:
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR out_avail$[rsp]
  0005f	48 89 44 24 38	 mov	 QWORD PTR tv67[rsp], rax
$LN4@lzma_bufcp:
  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR tv67[rsp]
  00069	48 89 44 24 30	 mov	 QWORD PTR copy_size$[rsp], rax

; 121  : 
; 122  : 	memcpy(out + *out_pos, in + *in_pos, copy_size);

  0006e	48 8b 44 24 58	 mov	 rax, QWORD PTR in_pos$[rsp]
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00076	48 8b 54 24 50	 mov	 rdx, QWORD PTR in$[rsp]
  0007b	48 03 d0	 add	 rdx, rax
  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR out_pos$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 8b 4c 24 68	 mov	 rcx, QWORD PTR out$[rsp]
  0008b	48 03 c8	 add	 rcx, rax
  0008e	4c 8b 44 24 30	 mov	 r8, QWORD PTR copy_size$[rsp]
  00093	e8 00 00 00 00	 call	 memcpy

; 123  : 
; 124  : 	*in_pos += copy_size;

  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0009d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a0	48 03 4c 24 30	 add	 rcx, QWORD PTR copy_size$[rsp]
  000a5	48 8b 44 24 58	 mov	 rax, QWORD PTR in_pos$[rsp]
  000aa	48 89 08	 mov	 QWORD PTR [rax], rcx

; 125  : 	*out_pos += copy_size;

  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000b2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b5	48 03 4c 24 30	 add	 rcx, QWORD PTR copy_size$[rsp]
  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR out_pos$[rsp]
  000bf	48 89 08	 mov	 QWORD PTR [rax], rcx

; 126  : 
; 127  : 	return copy_size;

  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR copy_size$[rsp]

; 128  : }

  000c7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cb	c3		 ret	 0
lzma_bufcpy ENDP
_TEXT	ENDS
PUBLIC	lzma_free
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_free DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$lzma_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_free DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_free
_TEXT	SEGMENT
ptr$ = 48
allocator$ = 56
lzma_free PROC						; COMDAT

; 99   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 100  : 	if (allocator != NULL && allocator->free != NULL)

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR allocator$[rsp], 0
  00014	74 24		 je	 SHORT $LN2@lzma_free
  00016	48 8b 44 24 38	 mov	 rax, QWORD PTR allocator$[rsp]
  0001b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00020	74 18		 je	 SHORT $LN2@lzma_free

; 101  : 		allocator->free(allocator->opaque, ptr);

  00022	48 8b 54 24 30	 mov	 rdx, QWORD PTR ptr$[rsp]
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR allocator$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR allocator$[rsp]
  00035	ff 50 08	 call	 QWORD PTR [rax+8]

; 102  : 	else

  00038	eb 0a		 jmp	 SHORT $LN1@lzma_free
$LN2@lzma_free:

; 103  : 		free(ptr);

  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0003f	e8 00 00 00 00	 call	 free
$LN1@lzma_free:

; 104  : 
; 105  : 	return;
; 106  : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
lzma_free ENDP
_TEXT	ENDS
PUBLIC	lzma_alloc
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_alloc DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$lzma_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_alloc DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_alloc
_TEXT	SEGMENT
ptr$32825 = 32
size$ = 64
allocator$ = 72
lzma_alloc PROC						; COMDAT

; 56   : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 57   : 	// Some malloc() variants return NULL if called with size == 0.
; 58   : 	if (size == 0)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  00014	75 09		 jne	 SHORT $LN3@lzma_alloc

; 59   : 		size = 1;

  00016	48 c7 44 24 40
	01 00 00 00	 mov	 QWORD PTR size$[rsp], 1
$LN3@lzma_alloc:

; 60   : 
; 61   :   {
; 62   : 	void *ptr;
; 63   : 
; 64   : 	if (allocator != NULL && allocator->alloc != NULL)

  0001f	48 83 7c 24 48
	00		 cmp	 QWORD PTR allocator$[rsp], 0
  00025	74 2c		 je	 SHORT $LN2@lzma_alloc
  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR allocator$[rsp]
  0002c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00030	74 21		 je	 SHORT $LN2@lzma_alloc

; 65   : 		ptr = allocator->alloc(allocator->opaque, 1, size);

  00032	4c 8b 44 24 40	 mov	 r8, QWORD PTR size$[rsp]
  00037	ba 01 00 00 00	 mov	 edx, 1
  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR allocator$[rsp]
  00041	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR allocator$[rsp]
  0004a	ff 10		 call	 QWORD PTR [rax]
  0004c	48 89 44 24 20	 mov	 QWORD PTR ptr$32825[rsp], rax

; 66   : 	else

  00051	eb 0f		 jmp	 SHORT $LN1@lzma_alloc
$LN2@lzma_alloc:

; 67   : 		ptr = malloc(size);

  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00058	e8 00 00 00 00	 call	 malloc
  0005d	48 89 44 24 20	 mov	 QWORD PTR ptr$32825[rsp], rax
$LN1@lzma_alloc:

; 68   : 
; 69   : 	return ptr;

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$32825[rsp]

; 70   :   }
; 71   : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
lzma_alloc ENDP
_TEXT	ENDS
PUBLIC	lzma_version_string
; Function compile flags: /Odtp
;	COMDAT lzma_version_string
_TEXT	SEGMENT
lzma_version_string PROC				; COMDAT

; 46   : 	return LZMA_VERSION_STRING;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LHKAPBBA@5?42?44?$AA@

; 47   : }

  00007	c3		 ret	 0
lzma_version_string ENDP
PUBLIC	lzma_strm_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_strm_init DD imagerel $LN6
	DD	imagerel $LN6+204
	DD	imagerel $unwind$lzma_strm_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_strm_init DD 030b01H
	DD	07007420bH
	DD	06006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_strm_init
_TEXT	SEGMENT
strm$ = 64
lzma_strm_init PROC					; COMDAT

; 187  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 188  : 	if (strm == NULL)

  0000b	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00011	75 0a		 jne	 SHORT $LN3@lzma_strm_

; 189  : 		return LZMA_PROG_ERROR;

  00013	b8 0b 00 00 00	 mov	 eax, 11
  00018	e9 a8 00 00 00	 jmp	 $LN4@lzma_strm_
$LN3@lzma_strm_:

; 190  : 
; 191  : 	if (strm->internal == NULL) {

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 49		 jne	 SHORT $LN2@lzma_strm_

; 192  : 		strm->internal = lzma_alloc(sizeof(lzma_internal),
; 193  : 				strm->allocator);

  00029	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0002e	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00032	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00037	e8 00 00 00 00	 call	 lzma_alloc
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 89 50 38	 mov	 QWORD PTR [rax+56], rdx

; 194  : 		if (strm->internal == NULL)

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0004d	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00052	75 07		 jne	 SHORT $LN1@lzma_strm_

; 195  : 			return LZMA_MEM_ERROR;

  00054	b8 05 00 00 00	 mov	 eax, 5
  00059	eb 6a		 jmp	 SHORT $LN4@lzma_strm_
$LN1@lzma_strm_:

; 196  : 
; 197  : 		strm->internal->next = LZMA_NEXT_CODER_INIT;

  0005b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR strm$[rsp]
  00060	48 8b 7f 38	 mov	 rdi, QWORD PTR [rdi+56]
  00064	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  0006b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00070	f3 a4		 rep movsb
$LN2@lzma_strm_:

; 198  : 	}
; 199  : 
; 200  : 	memzero(strm->internal->supported_actions,
; 201  : 			sizeof(strm->internal->supported_actions));

  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00077	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0007b	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0007f	41 b8 05 00 00
	00		 mov	 r8d, 5
  00085	33 d2		 xor	 edx, edx
  00087	e8 00 00 00 00	 call	 memset

; 202  : 	strm->internal->sequence = ISEQ_RUN;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00091	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00095	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 203  : 	strm->internal->allow_buf_error = false;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000a5	c6 40 5d 00	 mov	 BYTE PTR [rax+93], 0

; 204  : 
; 205  : 	strm->total_in = 0;

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ae	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 206  : 	strm->total_out = 0;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000bb	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 207  : 
; 208  : 	return LZMA_OK;

  000c3	33 c0		 xor	 eax, eax
$LN4@lzma_strm_:

; 209  : }

  000c5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c9	5f		 pop	 rdi
  000ca	5e		 pop	 rsi
  000cb	c3		 ret	 0
lzma_strm_init ENDP
_TEXT	ENDS
PUBLIC	lzma_next_end
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_next_end DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$lzma_next_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_next_end DD 031001H
	DD	0700c4210H
	DD	0600bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_next_end
_TEXT	SEGMENT
next$ = 64
allocator$ = 72
lzma_next_end PROC					; COMDAT

; 162  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 163  : 	if (next->init != (uintptr_t)(NULL)) {

  00010	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  00015	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0001a	74 48		 je	 SHORT $LN3@lzma_next_@2

; 164  : 		// To avoid tiny end functions that simply call
; 165  : 		// lzma_free(coder, allocator), we allow leaving next->end
; 166  : 		// NULL and call lzma_free() here.
; 167  : 		if (next->end != NULL)

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  00021	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00026	74 17		 je	 SHORT $LN2@lzma_next_@2

; 168  : 			next->end(next->coder, allocator);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00032	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  0003a	ff 50 20	 call	 QWORD PTR [rax+32]

; 169  : 		else

  0003d	eb 12		 jmp	 SHORT $LN1@lzma_next_@2
$LN2@lzma_next_@2:

; 170  : 			lzma_free(next->coder, allocator);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	e8 00 00 00 00	 call	 lzma_free
$LN1@lzma_next_@2:

; 171  : 
; 172  : 		// Reset the variables so the we don't accidentally think
; 173  : 		// that it is an already initialized coder.
; 174  : 		*next = LZMA_NEXT_CODER_INIT;

  00051	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  00058	48 8b 7c 24 40	 mov	 rdi, QWORD PTR next$[rsp]
  0005d	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00062	f3 a4		 rep movsb
$LN3@lzma_next_@2:

; 175  : 	}
; 176  : 
; 177  : 	return;
; 178  : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	5f		 pop	 rdi
  00069	5e		 pop	 rsi
  0006a	c3		 ret	 0
lzma_next_end ENDP
_TEXT	ENDS
PUBLIC	lzma_next_filter_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_next_filter_init DD imagerel $LN9
	DD	imagerel $LN9+153
	DD	imagerel $unwind$lzma_next_filter_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_next_filter_init DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_next_filter_init
_TEXT	SEGMENT
tv80 = 32
next$ = 64
allocator$ = 72
filters$ = 80
lzma_next_filter_init PROC				; COMDAT

; 134  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@lzma_next_@3:

; 135  : 	lzma_next_coder_init(filters[0].init, next, allocator);

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filters$[rsp]
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00025	74 0f		 je	 SHORT $LN1@lzma_next_@3
  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_next_end
$LN1@lzma_next_@3:
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR filters$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 c5		 jne	 SHORT $LN4@lzma_next_@3

; 136  : 	next->id = filters[0].id;

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR filters$[rsp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 137  : 	return filters[0].init == NULL
; 138  : 			? LZMA_OK : filters[0].init(next, allocator, filters);

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR filters$[rsp]
  00064	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00069	75 0a		 jne	 SHORT $LN7@lzma_next_@3
  0006b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00073	eb 1b		 jmp	 SHORT $LN8@lzma_next_@3
$LN7@lzma_next_@3:
  00075	4c 8b 44 24 50	 mov	 r8, QWORD PTR filters$[rsp]
  0007a	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR filters$[rsp]
  00089	ff 50 08	 call	 QWORD PTR [rax+8]
  0008c	89 44 24 20	 mov	 DWORD PTR tv80[rsp], eax
$LN8@lzma_next_@3:
  00090	8b 44 24 20	 mov	 eax, DWORD PTR tv80[rsp]

; 139  : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
lzma_next_filter_init ENDP
PUBLIC	lzma_end
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_end DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$lzma_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_end DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_end
_TEXT	SEGMENT
strm$ = 48
lzma_end PROC						; COMDAT

; 376  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 377  : 	if (strm != NULL && strm->internal != NULL) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 47		 je	 SHORT $LN1@lzma_end
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0001b	74 3b		 je	 SHORT $LN1@lzma_end

; 378  : 		lzma_next_end(&strm->internal->next, strm->allocator);

  0001d	48 8b 54 24 30	 mov	 rdx, QWORD PTR strm$[rsp]
  00022	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  0002b	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0002f	e8 00 00 00 00	 call	 lzma_next_end

; 379  : 		lzma_free(strm->internal, strm->allocator);

  00034	48 8b 54 24 30	 mov	 rdx, QWORD PTR strm$[rsp]
  00039	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00042	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00046	e8 00 00 00 00	 call	 lzma_free

; 380  : 		strm->internal = NULL;

  0004b	4c 8b 5c 24 30	 mov	 r11, QWORD PTR strm$[rsp]
  00050	49 c7 43 38 00
	00 00 00	 mov	 QWORD PTR [r11+56], 0
$LN1@lzma_end:

; 381  : 	}
; 382  : 
; 383  : 	return;
; 384  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
lzma_end ENDP
END
