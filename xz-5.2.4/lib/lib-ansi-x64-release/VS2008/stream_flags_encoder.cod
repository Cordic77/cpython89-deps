; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_encoder.c
;	COMDAT stream_flags_encode
_TEXT	SEGMENT
options$ = 8
out$ = 16
stream_flags_encode PROC				; COMDAT

; 18   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 19   : 	if ((unsigned int)(options->check) > LZMA_CHECK_ID_MAX)

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR options$[rsp]
  0000f	83 78 10 0f	 cmp	 DWORD PTR [rax+16], 15
  00013	76 04		 jbe	 SHORT $LN1@stream_fla

; 20   : 		return true;

  00015	b0 01		 mov	 al, 1
  00017	eb 1b		 jmp	 SHORT $LN2@stream_fla
$LN1@stream_fla:

; 21   : 
; 22   : 	out[0] = 0x00;

  00019	48 8b 44 24 10	 mov	 rax, QWORD PTR out$[rsp]
  0001e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 23   : 	out[1] = options->check;

  00021	48 8b 4c 24 10	 mov	 rcx, QWORD PTR out$[rsp]
  00026	48 8b 44 24 08	 mov	 rax, QWORD PTR options$[rsp]
  0002b	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  0002f	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 24   : 
; 25   : 	return false;

  00032	32 c0		 xor	 al, al
$LN2@stream_fla:

; 26   : }

  00034	f3 c3		 fatret	 0
stream_flags_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_common.h
pdata	SEGMENT
$pdata$is_backward_size_valid DD imagerel is_backward_size_valid
	DD	imagerel is_backward_size_valid+84
	DD	imagerel $unwind$is_backward_size_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_backward_size_valid DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_backward_size_valid
_TEXT	SEGMENT
tv71 = 0
options$ = 32
is_backward_size_valid PROC				; COMDAT

; 27   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 28   : 	return options->backward_size >= LZMA_BACKWARD_SIZE_MIN
; 29   : 			&& options->backward_size <= LZMA_BACKWARD_SIZE_MAX
; 30   : 			&& (options->backward_size & 3) == 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  00013	72 30		 jb	 SHORT $LN3@is_backwar
  00015	48 8b 4c 24 20	 mov	 rcx, QWORD PTR options$[rsp]
  0001a	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  00024	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00028	77 1b		 ja	 SHORT $LN3@is_backwar
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00033	48 83 e0 03	 and	 rax, 3
  00037	48 85 c0	 test	 rax, rax
  0003a	75 09		 jne	 SHORT $LN3@is_backwar
  0003c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv71[rsp], 1
  00043	eb 07		 jmp	 SHORT $LN4@is_backwar
$LN3@is_backwar:
  00045	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv71[rsp], 0
$LN4@is_backwar:
  0004c	8a 04 24	 mov	 al, BYTE PTR tv71[rsp]

; 31   : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
is_backward_size_valid ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT write32ne
_TEXT	SEGMENT
buf$ = 8
num$ = 16
write32ne PROC						; COMDAT

; 266  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  : 	*(uint32_t *)buf = num;

  00009	48 8b 4c 24 08	 mov	 rcx, QWORD PTR buf$[rsp]
  0000e	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00012	89 01		 mov	 DWORD PTR [rcx], eax

; 268  : 	return;
; 269  : }

  00014	c3		 ret	 0
write32ne ENDP
PUBLIC	lzma_stream_footer_encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_footer_encode DD imagerel $LN14
	DD	imagerel $LN14+265
	DD	imagerel $unwind$lzma_stream_footer_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_footer_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_encoder.c
xdata	ENDS
;	COMDAT lzma_stream_footer_encode
_TEXT	SEGMENT
crc$32840 = 32
$T80561 = 36
tv133 = 40
options$ = 64
out$ = 72
lzma_stream_footer_encode PROC				; COMDAT

; 60   : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 61   : 	assert(2 * 4 + LZMA_STREAM_FLAGS_SIZE + sizeof(lzma_footer_magic)
; 62   : 			== LZMA_STREAM_HEADER_SIZE);
; 63   : 
; 64   : 	if (options->version != 0)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 0a		 je	 SHORT $LN3@lzma_strea

; 65   : 		return LZMA_OPTIONS_ERROR;

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	e9 e2 00 00 00	 jmp	 $LN4@lzma_strea
$LN3@lzma_strea:

; 66   : 
; 67   : 	// Backward Size
; 68   : 	if (!is_backward_size_valid(options))

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00027	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  0002c	72 31		 jb	 SHORT $LN8@lzma_strea
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  00033	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  0003d	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00041	77 1c		 ja	 SHORT $LN8@lzma_strea
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00048	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004c	48 83 e0 03	 and	 rax, 3
  00050	48 85 c0	 test	 rax, rax
  00053	75 0a		 jne	 SHORT $LN8@lzma_strea
  00055	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN9@lzma_strea
$LN8@lzma_strea:
  0005f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@lzma_strea:
  00067	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv133[rsp]
  0006c	85 c0		 test	 eax, eax
  0006e	75 0a		 jne	 SHORT $LN2@lzma_strea

; 69   : 		return LZMA_PROG_ERROR;

  00070	b8 0b 00 00 00	 mov	 eax, 11
  00075	e9 8a 00 00 00	 jmp	 $LN4@lzma_strea
$LN2@lzma_strea:

; 70   : 
; 71   : 	unaligned_write32le(out + 4, options->backward_size / 4 - 1);

  0007a	33 d2		 xor	 edx, edx
  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00081	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00085	b9 04 00 00 00	 mov	 ecx, 4
  0008a	48 f7 f1	 div	 rcx
  0008d	48 83 e8 01	 sub	 rax, 1
  00091	89 44 24 24	 mov	 DWORD PTR $T80561[rsp], eax
  00095	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR $T80561[rsp]
  0009e	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 72   : 
; 73   : 	// Stream Flags
; 74   : 	if (stream_flags_encode(options, out + 2 * 4))

  000a1	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  000a6	48 83 c2 08	 add	 rdx, 8
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  000af	e8 00 00 00 00	 call	 stream_flags_encode
  000b4	0f b6 c0	 movzx	 eax, al
  000b7	85 c0		 test	 eax, eax
  000b9	74 07		 je	 SHORT $LN1@lzma_strea

; 75   : 		return LZMA_PROG_ERROR;

  000bb	b8 0b 00 00 00	 mov	 eax, 11
  000c0	eb 42		 jmp	 SHORT $LN4@lzma_strea
$LN1@lzma_strea:

; 76   : 
; 77   : 	// CRC32
; 78   :   {
; 79   : 	const uint32_t crc = lzma_crc32(
; 80   : 			out + 4, 4 + LZMA_STREAM_FLAGS_SIZE, 0);

  000c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  000c7	48 83 c1 04	 add	 rcx, 4
  000cb	45 33 c0	 xor	 r8d, r8d
  000ce	ba 06 00 00 00	 mov	 edx, 6
  000d3	e8 00 00 00 00	 call	 lzma_crc32
  000d8	89 44 24 20	 mov	 DWORD PTR crc$32840[rsp], eax

; 81   : 
; 82   : 	unaligned_write32le(out, crc);

  000dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  000e1	8b 44 24 20	 mov	 eax, DWORD PTR crc$32840[rsp]
  000e5	89 01		 mov	 DWORD PTR [rcx], eax

; 83   :   }
; 84   : 
; 85   : 	// Magic
; 86   : 	memcpy(out + 2 * 4 + LZMA_STREAM_FLAGS_SIZE,
; 87   : 			lzma_footer_magic, sizeof(lzma_footer_magic));

  000e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  000ec	48 83 c1 0a	 add	 rcx, 10
  000f0	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_footer_magic
  000fd	e8 00 00 00 00	 call	 memcpy

; 88   : 
; 89   : 	return LZMA_OK;

  00102	33 c0		 xor	 eax, eax
$LN4@lzma_strea:

; 90   : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
lzma_stream_footer_encode ENDP
_TEXT	ENDS
PUBLIC	lzma_stream_header_encode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$lzma_stream_header_encode DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$lzma_stream_header_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_header_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_encoder.c
xdata	ENDS
;	COMDAT lzma_stream_header_encode
_TEXT	SEGMENT
crc$32828 = 32
options$ = 64
out$ = 72
lzma_stream_header_encode PROC				; COMDAT

; 31   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 32   : 	assert(sizeof(lzma_header_magic) + LZMA_STREAM_FLAGS_SIZE
; 33   : 			+ 4 == LZMA_STREAM_HEADER_SIZE);
; 34   : 
; 35   : 	if (options->version != 0)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 07		 je	 SHORT $LN2@lzma_strea@2

; 36   : 		return LZMA_OPTIONS_ERROR;

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	eb 60		 jmp	 SHORT $LN3@lzma_strea@2
$LN2@lzma_strea@2:

; 37   : 
; 38   : 	// Magic
; 39   : 	memcpy(out, lzma_header_magic, sizeof(lzma_header_magic));

  0001f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_header_magic
  0002c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  00031	e8 00 00 00 00	 call	 memcpy

; 40   : 
; 41   : 	// Stream Flags
; 42   : 	if (stream_flags_encode(options, out + sizeof(lzma_header_magic)))

  00036	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  0003b	48 83 c2 06	 add	 rdx, 6
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  00044	e8 00 00 00 00	 call	 stream_flags_encode
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	74 07		 je	 SHORT $LN1@lzma_strea@2

; 43   : 		return LZMA_PROG_ERROR;

  00050	b8 0b 00 00 00	 mov	 eax, 11
  00055	eb 28		 jmp	 SHORT $LN3@lzma_strea@2
$LN1@lzma_strea@2:

; 44   : 
; 45   : 	// CRC32 of the Stream Header
; 46   :   {
; 47   : 	const uint32_t crc = lzma_crc32(out + sizeof(lzma_header_magic),
; 48   : 			LZMA_STREAM_FLAGS_SIZE, 0);

  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  0005c	48 83 c1 06	 add	 rcx, 6
  00060	45 33 c0	 xor	 r8d, r8d
  00063	ba 02 00 00 00	 mov	 edx, 2
  00068	e8 00 00 00 00	 call	 lzma_crc32
  0006d	89 44 24 20	 mov	 DWORD PTR crc$32828[rsp], eax

; 49   : 
; 50   : 	unaligned_write32le(out + sizeof(lzma_header_magic)
; 51   : 			+ LZMA_STREAM_FLAGS_SIZE, crc);

  00071	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  00076	8b 44 24 20	 mov	 eax, DWORD PTR crc$32828[rsp]
  0007a	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 52   :   }
; 53   : 
; 54   : 	return LZMA_OK;

  0007d	33 c0		 xor	 eax, eax
$LN3@lzma_strea@2:

; 55   : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
lzma_stream_header_encode ENDP
END
