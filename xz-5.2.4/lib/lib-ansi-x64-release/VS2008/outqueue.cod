; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_outq_is_readable
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\outqueue.c
pdata	SEGMENT
$pdata$lzma_outq_is_readable DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$lzma_outq_is_readable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_is_readable DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_is_readable
_TEXT	SEGMENT
i$ = 0
outq$ = 32
lzma_outq_is_readable PROC				; COMDAT

; 139  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 140  : 	uint32_t i = outq->bufs_pos - outq->bufs_used;

  00009	48 8b 54 24 20	 mov	 rdx, QWORD PTR outq$[rsp]
  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00016	8b 42 1c	 mov	 eax, DWORD PTR [rdx+28]
  00019	2b c1		 sub	 eax, ecx
  0001b	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 141  : 	if (outq->bufs_pos < outq->bufs_used)

  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR outq$[rsp]
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00028	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0002b	39 41 1c	 cmp	 DWORD PTR [rcx+28], eax
  0002e	73 10		 jae	 SHORT $LN1@lzma_outq_

; 142  : 		i += outq->bufs_allocated;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00035	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00038	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0003b	03 c1		 add	 eax, ecx
  0003d	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN1@lzma_outq_:

; 143  : 
; 144  : 	return outq->bufs[i].finished;

  00040	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00043	48 6b c9 28	 imul	 rcx, 40			; 00000028H
  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	8a 44 08 20	 mov	 al, BYTE PTR [rax+rcx+32]

; 145  : }

  00053	48 83 c4 18	 add	 rsp, 24
  00057	c3		 ret	 0
lzma_outq_is_readable ENDP
_TEXT	ENDS
PUBLIC	lzma_outq_get_buf
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_get_buf DD imagerel $LN4
	DD	imagerel $LN4+164
	DD	imagerel $unwind$lzma_outq_get_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_get_buf DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_get_buf
_TEXT	SEGMENT
buf$32926 = 0
outq$ = 32
lzma_outq_get_buf PROC					; COMDAT

; 115  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 116  : 	// Caller must have checked it with lzma_outq_has_buf().
; 117  : 	assert(outq->bufs_used < outq->bufs_allocated);
; 118  : 
; 119  : 	// Initialize the new buffer.
; 120  :   {
; 121  : 	lzma_outbuf *buf = &outq->bufs[outq->bufs_pos];

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0000e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00011	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00015	48 8b 4c 24 20	 mov	 rcx, QWORD PTR outq$[rsp]
  0001a	48 03 01	 add	 rax, QWORD PTR [rcx]
  0001d	48 89 04 24	 mov	 QWORD PTR buf$32926[rsp], rax

; 122  : 	buf->buf = outq->bufs_mem + outq->bufs_pos * outq->buf_size_max;

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00026	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0002e	48 0f af 48 10	 imul	 rcx, QWORD PTR [rax+16]
  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00038	48 03 48 08	 add	 rcx, QWORD PTR [rax+8]
  0003c	48 8b 04 24	 mov	 rax, QWORD PTR buf$32926[rsp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 123  : 	buf->size = 0;

  00043	48 8b 04 24	 mov	 rax, QWORD PTR buf$32926[rsp]
  00047	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 124  : 	buf->finished = false;

  0004f	48 8b 04 24	 mov	 rax, QWORD PTR buf$32926[rsp]
  00053	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 125  : 
; 126  : 	// Update the queue state.
; 127  : 	if (++outq->bufs_pos == outq->bufs_allocated)

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0005c	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0005f	83 c1 01	 add	 ecx, 1
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00067	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR outq$[rsp]
  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00074	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00077	39 41 1c	 cmp	 DWORD PTR [rcx+28], eax
  0007a	75 0c		 jne	 SHORT $LN1@lzma_outq_@2

; 128  : 		outq->bufs_pos = 0;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00081	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
$LN1@lzma_outq_@2:

; 129  : 
; 130  : 	++outq->bufs_used;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0008d	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00090	83 c1 01	 add	 ecx, 1
  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00098	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 131  : 
; 132  : 	return buf;

  0009b	48 8b 04 24	 mov	 rax, QWORD PTR buf$32926[rsp]

; 133  :   }
; 134  : }

  0009f	48 83 c4 18	 add	 rsp, 24
  000a3	c3		 ret	 0
lzma_outq_get_buf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT get_options
_TEXT	SEGMENT
bufs_alloc_size$ = 8
bufs_count$ = 16
buf_size_max$ = 24
threads$ = 32
get_options PROC					; COMDAT

; 25   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 26   : 	if (threads > LZMA_THREADS_MAX || buf_size_max > BUF_SIZE_MAX)

  00014	81 7c 24 20 00
	40 00 00	 cmp	 DWORD PTR threads$[rsp], 16384 ; 00004000H
  0001c	77 11		 ja	 SHORT $LN1@get_option
  0001e	48 b8 ff ff ff
	ff ff ff 00 00	 mov	 rax, 281474976710655	; 0000ffffffffffffH
  00028	48 39 44 24 18	 cmp	 QWORD PTR buf_size_max$[rsp], rax
  0002d	76 07		 jbe	 SHORT $LN2@get_option
$LN1@get_option:

; 27   : 		return LZMA_OPTIONS_ERROR;

  0002f	b8 08 00 00 00	 mov	 eax, 8
  00034	eb 24		 jmp	 SHORT $LN3@get_option
$LN2@get_option:

; 28   : 
; 29   : 	// The number of buffers is twice the number of threads.
; 30   : 	// This wastes RAM but keeps the threads busy when buffers
; 31   : 	// finish out of order.
; 32   : 	//
; 33   : 	// NOTE: If this is changed, update BUF_SIZE_MAX too.
; 34   : 	*bufs_count = threads * 2;

  00036	8b 4c 24 20	 mov	 ecx, DWORD PTR threads$[rsp]
  0003a	d1 e1		 shl	 ecx, 1
  0003c	48 8b 44 24 10	 mov	 rax, QWORD PTR bufs_count$[rsp]
  00041	89 08		 mov	 DWORD PTR [rax], ecx

; 35   : 	*bufs_alloc_size = *bufs_count * buf_size_max;

  00043	48 8b 44 24 10	 mov	 rax, QWORD PTR bufs_count$[rsp]
  00048	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004a	48 0f af 4c 24
	18		 imul	 rcx, QWORD PTR buf_size_max$[rsp]
  00050	48 8b 44 24 08	 mov	 rax, QWORD PTR bufs_alloc_size$[rsp]
  00055	48 89 08	 mov	 QWORD PTR [rax], rcx

; 36   : 
; 37   : 	return LZMA_OK;

  00058	33 c0		 xor	 eax, eax
$LN3@get_option:

; 38   : }

  0005a	f3 c3		 fatret	 0
get_options ENDP
PUBLIC	lzma_outq_read
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_read DD imagerel $LN7
	DD	imagerel $LN7+297
	DD	imagerel $unwind$lzma_outq_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_read DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_read
_TEXT	SEGMENT
i$32947 = 48
buf$32949 = 56
outq$ = 80
out$ = 88
out_pos$ = 96
out_size$ = 104
unpadded_size$ = 112
uncompressed_size$ = 120
lzma_outq_read PROC					; COMDAT

; 153  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 154  : 	// There must be at least one buffer from which to read.
; 155  : 	if (outq->bufs_used == 0)

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  0001d	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00021	75 07		 jne	 SHORT $LN4@lzma_outq_@5

; 156  : 		return LZMA_OK;

  00023	33 c0		 xor	 eax, eax
  00025	e9 fa 00 00 00	 jmp	 $LN5@lzma_outq_@5
$LN4@lzma_outq_@5:

; 157  : 
; 158  : 	// Get the buffer.
; 159  :   {
; 160  : 	uint32_t i = outq->bufs_pos - outq->bufs_used;

  0002a	48 8b 54 24 50	 mov	 rdx, QWORD PTR outq$[rsp]
  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  00034	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00037	8b 42 1c	 mov	 eax, DWORD PTR [rdx+28]
  0003a	2b c1		 sub	 eax, ecx
  0003c	89 44 24 30	 mov	 DWORD PTR i$32947[rsp], eax

; 161  : 	if (outq->bufs_pos < outq->bufs_used)

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR outq$[rsp]
  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  0004a	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0004d	39 41 1c	 cmp	 DWORD PTR [rcx+28], eax
  00050	73 12		 jae	 SHORT $LN3@lzma_outq_@5

; 162  : 		i += outq->bufs_allocated;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  00057	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0005a	8b 44 24 30	 mov	 eax, DWORD PTR i$32947[rsp]
  0005e	03 c1		 add	 eax, ecx
  00060	89 44 24 30	 mov	 DWORD PTR i$32947[rsp], eax
$LN3@lzma_outq_@5:

; 163  : 
; 164  :   {
; 165  : 	lzma_outbuf *buf = &outq->bufs[i];

  00064	8b 44 24 30	 mov	 eax, DWORD PTR i$32947[rsp]
  00068	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR outq$[rsp]
  00071	48 03 01	 add	 rax, QWORD PTR [rcx]
  00074	48 89 44 24 38	 mov	 QWORD PTR buf$32949[rsp], rax

; 166  : 
; 167  : 	// If it isn't finished yet, we cannot read from it.
; 168  : 	if (!buf->finished)

  00079	48 8b 44 24 38	 mov	 rax, QWORD PTR buf$32949[rsp]
  0007e	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00082	85 c0		 test	 eax, eax
  00084	75 07		 jne	 SHORT $LN2@lzma_outq_@5

; 169  : 		return LZMA_OK;

  00086	33 c0		 xor	 eax, eax
  00088	e9 97 00 00 00	 jmp	 $LN5@lzma_outq_@5
$LN2@lzma_outq_@5:

; 170  : 
; 171  : 	// Copy from the buffer to output.
; 172  : 	lzma_bufcpy(buf->buf, &outq->read_pos, buf->size,
; 173  : 			out, out_pos, out_size);

  0008d	48 8b 54 24 50	 mov	 rdx, QWORD PTR outq$[rsp]
  00092	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR out_size$[rsp]
  0009b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a0	48 8b 44 24 60	 mov	 rax, QWORD PTR out_pos$[rsp]
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	4c 8b 4c 24 58	 mov	 r9, QWORD PTR out$[rsp]
  000af	4c 8b 44 24 38	 mov	 r8, QWORD PTR buf$32949[rsp]
  000b4	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  000b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buf$32949[rsp]
  000bd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c0	e8 00 00 00 00	 call	 lzma_bufcpy

; 174  : 
; 175  : 	// Return if we didn't get all the data from the buffer.
; 176  : 	if (outq->read_pos < buf->size)

  000c5	4c 8b 5c 24 50	 mov	 r11, QWORD PTR outq$[rsp]
  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR buf$32949[rsp]
  000cf	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d3	49 39 43 28	 cmp	 QWORD PTR [r11+40], rax
  000d7	73 04		 jae	 SHORT $LN1@lzma_outq_@5

; 177  : 		return LZMA_OK;

  000d9	33 c0		 xor	 eax, eax
  000db	eb 47		 jmp	 SHORT $LN5@lzma_outq_@5
$LN1@lzma_outq_@5:

; 178  : 
; 179  : 	// The buffer was finished. Tell the caller its size information.
; 180  : 	*unpadded_size = buf->unpadded_size;

  000dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR unpadded_size$[rsp]
  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR buf$32949[rsp]
  000e7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000eb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 181  : 	*uncompressed_size = buf->uncompressed_size;

  000ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR uncompressed_size$[rsp]
  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR buf$32949[rsp]
  000f8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000fc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 182  :   }}
; 183  : 
; 184  : 	// Free this buffer for further use.
; 185  : 	--outq->bufs_used;

  000ff	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  00104	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00107	83 e9 01	 sub	 ecx, 1
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  0010f	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 186  : 	outq->read_pos = 0;

  00112	48 8b 44 24 50	 mov	 rax, QWORD PTR outq$[rsp]
  00117	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 187  : 
; 188  : 	return LZMA_STREAM_END;

  0011f	b8 01 00 00 00	 mov	 eax, 1
$LN5@lzma_outq_@5:

; 189  : }

  00124	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00128	c3		 ret	 0
lzma_outq_read ENDP
_TEXT	ENDS
PUBLIC	lzma_outq_end
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_end DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$lzma_outq_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_end DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_end
_TEXT	SEGMENT
outq$ = 48
allocator$ = 56
lzma_outq_end PROC					; COMDAT

; 102  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 103  : 	lzma_free(outq->bufs, allocator);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR outq$[rsp]
  00018	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001b	e8 00 00 00 00	 call	 lzma_free

; 104  : 	outq->bufs = NULL;

  00020	4c 8b 5c 24 30	 mov	 r11, QWORD PTR outq$[rsp]
  00025	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0

; 105  : 
; 106  : 	lzma_free(outq->bufs_mem, allocator);

  0002c	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR outq$[rsp]
  00036	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003a	e8 00 00 00 00	 call	 lzma_free

; 107  : 	outq->bufs_mem = NULL;

  0003f	4c 8b 5c 24 30	 mov	 r11, QWORD PTR outq$[rsp]
  00044	49 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [r11+8], 0

; 108  : 
; 109  : 	return;
; 110  : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
lzma_outq_end ENDP
_TEXT	ENDS
PUBLIC	lzma_outq_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_init DD imagerel $LN11
	DD	imagerel $LN11+291
	DD	imagerel $unwind$lzma_outq_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_init DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_init
_TEXT	SEGMENT
bufs_alloc_size$ = 32
bufs_count$ = 40
ret_$32904 = 44
outq$ = 64
allocator$ = 72
buf_size_max$ = 80
threads$ = 88
lzma_outq_init PROC					; COMDAT

; 59   : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_outq_@6:

; 60   : 	uint64_t bufs_alloc_size;
; 61   : 	uint32_t bufs_count;
; 62   : 
; 63   : 	// Set bufs_count and bufs_alloc_size.
; 64   : 	return_if_error(get_options(&bufs_alloc_size, &bufs_count,
; 65   : 			buf_size_max, threads));

  00018	44 8b 4c 24 58	 mov	 r9d, DWORD PTR threads$[rsp]
  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR buf_size_max$[rsp]
  00022	48 8d 54 24 28	 lea	 rdx, QWORD PTR bufs_count$[rsp]
  00027	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bufs_alloc_size$[rsp]
  0002c	e8 00 00 00 00	 call	 get_options
  00031	89 44 24 2c	 mov	 DWORD PTR ret_$32904[rsp], eax
  00035	83 7c 24 2c 00	 cmp	 DWORD PTR ret_$32904[rsp], 0
  0003a	74 09		 je	 SHORT $LN5@lzma_outq_@6
  0003c	8b 44 24 2c	 mov	 eax, DWORD PTR ret_$32904[rsp]
  00040	e9 d9 00 00 00	 jmp	 $LN9@lzma_outq_@6
$LN5@lzma_outq_@6:
  00045	33 c0		 xor	 eax, eax
  00047	85 c0		 test	 eax, eax
  00049	75 cd		 jne	 SHORT $LN8@lzma_outq_@6

; 66   : 
; 67   : 	// Allocate memory if needed.
; 68   : 	if (outq->buf_size_max != buf_size_max
; 69   : 			|| outq->bufs_allocated != bufs_count) {

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR buf_size_max$[rsp]
  00055	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00059	75 0e		 jne	 SHORT $LN3@lzma_outq_@6
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  00060	8b 44 24 28	 mov	 eax, DWORD PTR bufs_count$[rsp]
  00064	39 41 18	 cmp	 DWORD PTR [rcx+24], eax
  00067	74 74		 je	 SHORT $LN4@lzma_outq_@6
$LN3@lzma_outq_@6:

; 70   : 		lzma_outq_end(outq, allocator);

  00069	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  00073	e8 00 00 00 00	 call	 lzma_outq_end

; 71   : 
; 72   : #if SIZE_MAX < UINT64_MAX
; 73   : 		if (bufs_alloc_size > SIZE_MAX)
; 74   : 			return LZMA_MEM_ERROR;
; 75   : #endif
; 76   : 
; 77   : 		outq->bufs = lzma_alloc(bufs_count * sizeof(lzma_outbuf),
; 78   : 				allocator);

  00078	8b 4c 24 28	 mov	 ecx, DWORD PTR bufs_count$[rsp]
  0007c	48 6b c9 28	 imul	 rcx, 40			; 00000028H
  00080	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00085	e8 00 00 00 00	 call	 lzma_alloc
  0008a	4c 8b d8	 mov	 r11, rax
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  00092	4c 89 18	 mov	 QWORD PTR [rax], r11

; 79   : 		outq->bufs_mem = lzma_alloc((size_t)(bufs_alloc_size),
; 80   : 				allocator);

  00095	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bufs_alloc_size$[rsp]
  0009f	e8 00 00 00 00	 call	 lzma_alloc
  000a4	4c 8b d8	 mov	 r11, rax
  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  000ac	4c 89 58 08	 mov	 QWORD PTR [rax+8], r11

; 81   : 
; 82   : 		if (outq->bufs == NULL || outq->bufs_mem == NULL) {

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  000b5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000b9	74 0c		 je	 SHORT $LN1@lzma_outq_@6
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  000c0	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c5	75 16		 jne	 SHORT $LN2@lzma_outq_@6
$LN1@lzma_outq_@6:

; 83   : 			lzma_outq_end(outq, allocator);

  000c7	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  000d1	e8 00 00 00 00	 call	 lzma_outq_end

; 84   : 			return LZMA_MEM_ERROR;

  000d6	b8 05 00 00 00	 mov	 eax, 5
  000db	eb 41		 jmp	 SHORT $LN9@lzma_outq_@6
$LN2@lzma_outq_@6:
$LN4@lzma_outq_@6:

; 85   : 		}
; 86   : 	}
; 87   : 
; 88   : 	// Initialize the rest of the main structure. Initialization of
; 89   : 	// outq->bufs[] is done when they are actually needed.
; 90   : 	outq->buf_size_max = (size_t)(buf_size_max);

  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR buf_size_max$[rsp]
  000e7	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 91   : 	outq->bufs_allocated = bufs_count;

  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outq$[rsp]
  000f0	8b 44 24 28	 mov	 eax, DWORD PTR bufs_count$[rsp]
  000f4	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 92   : 	outq->bufs_pos = 0;

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  000fc	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 93   : 	outq->bufs_used = 0;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  00108	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 94   : 	outq->read_pos = 0;

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR outq$[rsp]
  00114	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 95   : 
; 96   : 	return LZMA_OK;

  0011c	33 c0		 xor	 eax, eax
$LN9@lzma_outq_@6:

; 97   : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
lzma_outq_init ENDP
_TEXT	ENDS
PUBLIC	lzma_outq_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_memusage DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$lzma_outq_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_memusage DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_memusage
_TEXT	SEGMENT
bufs_alloc_size$ = 32
bufs_count$ = 40
buf_size_max$ = 64
threads$ = 72
lzma_outq_memusage PROC					; COMDAT

; 43   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 44   : 	uint64_t bufs_alloc_size;
; 45   : 	uint32_t bufs_count;
; 46   : 
; 47   : 	if (get_options(&bufs_alloc_size, &bufs_count, buf_size_max, threads)
; 48   : 			!= LZMA_OK)

  0000d	44 8b 4c 24 48	 mov	 r9d, DWORD PTR threads$[rsp]
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf_size_max$[rsp]
  00017	48 8d 54 24 28	 lea	 rdx, QWORD PTR bufs_count$[rsp]
  0001c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bufs_alloc_size$[rsp]
  00021	e8 00 00 00 00	 call	 get_options
  00026	85 c0		 test	 eax, eax
  00028	74 09		 je	 SHORT $LN1@lzma_outq_@7

; 49   : 		return UINT64_MAX;

  0002a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00031	eb 12		 jmp	 SHORT $LN2@lzma_outq_@7
$LN1@lzma_outq_@7:

; 50   : 
; 51   : 	return sizeof(lzma_outq) + bufs_count * sizeof(lzma_outbuf)
; 52   : 			+ bufs_alloc_size;

  00033	8b 4c 24 28	 mov	 ecx, DWORD PTR bufs_count$[rsp]
  00037	48 6b c9 28	 imul	 rcx, 40			; 00000028H
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR bufs_alloc_size$[rsp]
  00040	48 8d 44 01 30	 lea	 rax, QWORD PTR [rcx+rax+48]
$LN2@lzma_outq_@7:

; 53   : }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
lzma_outq_memusage ENDP
END
