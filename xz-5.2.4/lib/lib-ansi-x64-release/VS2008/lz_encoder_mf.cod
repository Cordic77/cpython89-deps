; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
;	COMDAT move_pending
_TEXT	SEGMENT
mf$ = 8
move_pending PROC					; COMDAT

; 186  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 187  : 	++mf->read_pos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000a	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0000d	83 c1 01	 add	 ecx, 1
  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  00015	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 188  : 	assert(mf->read_pos <= mf->write_pos);
; 189  : 	++mf->pending;

  00018	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0001d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00020	83 c1 01	 add	 ecx, 1
  00023	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  00028	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 190  : }

  0002b	c3		 ret	 0
move_pending ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize DD imagerel normalize
	DD	imagerel normalize+285
	DD	imagerel $unwind$normalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT normalize
_TEXT	SEGMENT
subvalue$33088 = 0
i$33089 = 4
mf$ = 32
normalize PROC						; COMDAT

; 113  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 114  : 	assert(mf->read_pos + mf->offset == MUST_NORMALIZE_POS);
; 115  : 
; 116  : 	// In future we may not want to touch the lowest bits, because there
; 117  : 	// may be match finders that use larger resolution than one byte.
; 118  :   {
; 119  : 	const uint32_t subvalue
; 120  : 			= (MUST_NORMALIZE_POS - mf->cyclic_size);

  00009	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  0000e	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00013	2b 41 54	 sub	 eax, DWORD PTR [rcx+84]
  00016	89 04 24	 mov	 DWORD PTR subvalue$33088[rsp], eax

; 121  : 				// & (~(UINT32_C(1) << 10) - 1);
; 122  : 	uint32_t i;
; 123  : 
; 124  : 	for (i = 0; i < mf->hash_count; ++i) {

  00019	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$33089[rsp], 0
  00021	eb 0b		 jmp	 SHORT $LN10@normalize
$LN9@normalize:
  00023	8b 44 24 04	 mov	 eax, DWORD PTR i$33089[rsp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 44 24 04	 mov	 DWORD PTR i$33089[rsp], eax
$LN10@normalize:
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  00033	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00036	39 44 24 04	 cmp	 DWORD PTR i$33089[rsp], eax
  0003a	73 52		 jae	 SHORT $LN8@normalize

; 125  : 		// If the distance is greater than the dictionary size,
; 126  : 		// we can simply mark the hash element as empty.
; 127  : 		if (mf->hash[i] <= subvalue)

  0003c	8b 54 24 04	 mov	 edx, DWORD PTR i$33089[rsp]
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  00045	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00049	8b 04 24	 mov	 eax, DWORD PTR subvalue$33088[rsp]
  0004c	39 04 91	 cmp	 DWORD PTR [rcx+rdx*4], eax
  0004f	77 16		 ja	 SHORT $LN7@normalize

; 128  : 			mf->hash[i] = EMPTY_HASH_VALUE;

  00051	8b 4c 24 04	 mov	 ecx, DWORD PTR i$33089[rsp]
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  0005a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0005e	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [rax+rcx*4], 0

; 129  : 		else

  00065	eb 25		 jmp	 SHORT $LN6@normalize
$LN7@normalize:

; 130  : 			mf->hash[i] -= subvalue;

  00067	8b 54 24 04	 mov	 edx, DWORD PTR i$33089[rsp]
  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  00070	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00074	8b 04 24	 mov	 eax, DWORD PTR subvalue$33088[rsp]
  00077	8b 14 91	 mov	 edx, DWORD PTR [rcx+rdx*4]
  0007a	2b d0		 sub	 edx, eax
  0007c	8b 4c 24 04	 mov	 ecx, DWORD PTR i$33089[rsp]
  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  00085	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00089	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN6@normalize:

; 131  : 	}

  0008c	eb 95		 jmp	 SHORT $LN9@normalize
$LN8@normalize:

; 132  : 
; 133  : 	for (i = 0; i < mf->sons_count; ++i) {

  0008e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$33089[rsp], 0
  00096	eb 0b		 jmp	 SHORT $LN5@normalize
$LN4@normalize:
  00098	8b 44 24 04	 mov	 eax, DWORD PTR i$33089[rsp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 44 24 04	 mov	 DWORD PTR i$33089[rsp], eax
$LN5@normalize:
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  000a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ab	39 44 24 04	 cmp	 DWORD PTR i$33089[rsp], eax
  000af	73 52		 jae	 SHORT $LN3@normalize

; 134  : 		// Do the same for mf->son.
; 135  : 		//
; 136  : 		// NOTE: There may be uninitialized elements in mf->son.
; 137  : 		// Valgrind may complain that the "if" below depends on
; 138  : 		// an uninitialized value. In this case it is safe to ignore
; 139  : 		// the warning. See also the comments in lz_encoder_init()
; 140  : 		// in lz_encoder.c.
; 141  : 		if (mf->son[i] <= subvalue)

  000b1	8b 54 24 04	 mov	 edx, DWORD PTR i$33089[rsp]
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  000ba	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000be	8b 04 24	 mov	 eax, DWORD PTR subvalue$33088[rsp]
  000c1	39 04 91	 cmp	 DWORD PTR [rcx+rdx*4], eax
  000c4	77 16		 ja	 SHORT $LN2@normalize

; 142  : 			mf->son[i] = EMPTY_HASH_VALUE;

  000c6	8b 4c 24 04	 mov	 ecx, DWORD PTR i$33089[rsp]
  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  000cf	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000d3	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [rax+rcx*4], 0

; 143  : 		else

  000da	eb 25		 jmp	 SHORT $LN1@normalize
$LN2@normalize:

; 144  : 			mf->son[i] -= subvalue;

  000dc	8b 54 24 04	 mov	 edx, DWORD PTR i$33089[rsp]
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  000e5	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000e9	8b 04 24	 mov	 eax, DWORD PTR subvalue$33088[rsp]
  000ec	8b 14 91	 mov	 edx, DWORD PTR [rcx+rdx*4]
  000ef	2b d0		 sub	 edx, eax
  000f1	8b 4c 24 04	 mov	 ecx, DWORD PTR i$33089[rsp]
  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  000fa	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000fe	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN1@normalize:

; 145  : 	}

  00101	eb 95		 jmp	 SHORT $LN4@normalize
$LN3@normalize:

; 146  : 
; 147  : 	// Update offset to match the new locations.
; 148  : 	mf->offset -= subvalue;

  00103	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mf$[rsp]
  00108	8b 04 24	 mov	 eax, DWORD PTR subvalue$33088[rsp]
  0010b	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0010e	2b c8		 sub	 ecx, eax
  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR mf$[rsp]
  00115	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 149  :   }
; 150  : 
; 151  : 	return;
; 152  : }

  00118	48 83 c4 18	 add	 rsp, 24
  0011c	c3		 ret	 0
normalize ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_memcmplen DD imagerel lzma_memcmplen
	DD	imagerel lzma_memcmplen+160
	DD	imagerel $unwind$lzma_memcmplen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_memcmplen DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_memcmplen
_TEXT	SEGMENT
x$33062 = 0
tmp$33066 = 8
tv76 = 12
buf1$ = 32
buf2$ = 40
len$ = 48
limit$ = 56
lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24
$LN3@lzma_memcm:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {

  00018	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0001c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00020	73 75		 jae	 SHORT $LN2@lzma_memcm

; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);

  00022	44 8b 44 24 30	 mov	 r8d, DWORD PTR len$[rsp]
  00027	8b 54 24 30	 mov	 edx, DWORD PTR len$[rsp]
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buf1$[rsp]
  00030	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf2$[rsp]
  00035	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00039	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	48 89 04 24	 mov	 QWORD PTR x$33062[rsp], rax

; 66   : 		if (x != 0) {

  00044	48 83 3c 24 00	 cmp	 QWORD PTR x$33062[rsp], 0
  00049	74 3f		 je	 SHORT $LN1@lzma_memcm

; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);

  0004b	48 8b 04 24	 mov	 rax, QWORD PTR x$33062[rsp]
  0004f	48 0f bc c0	 bsf	 rax, rax
  00053	89 44 24 08	 mov	 DWORD PTR tmp$33066[rsp], eax

; 70   : 			len += (uint32_t)tmp >> 3;

  00057	8b 4c 24 08	 mov	 ecx, DWORD PTR tmp$33066[rsp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00062	03 c1		 add	 eax, ecx
  00064	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);

  00068	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0006c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00070	73 0a		 jae	 SHORT $LN6@lzma_memcm
  00072	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00076	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
  0007a	eb 08		 jmp	 SHORT $LN7@lzma_memcm
$LN6@lzma_memcm:
  0007c	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00080	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
$LN7@lzma_memcm:
  00084	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
  00088	eb 11		 jmp	 SHORT $LN4@lzma_memcm
$LN1@lzma_memcm:

; 75   : 		}
; 76   : 
; 77   : 		len += 8;

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0008e	83 c0 08	 add	 eax, 8
  00091	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 78   : 	}

  00095	eb 81		 jmp	 SHORT $LN3@lzma_memcm
$LN2@lzma_memcm:

; 79   : 
; 80   : 	return limit;

  00097	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
$LN4@lzma_memcm:

; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {
; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);
; 125  : 		if (x != 0) {
; 126  : 			if ((x & 0xFFFF) == 0) {
; 127  : 				len += 2;
; 128  : 				x >>= 16;
; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)
; 132  : 				++len;
; 133  : 
; 134  : 			return my_min(len, limit);
; 135  : 		}
; 136  : 
; 137  : 		len += 4;
; 138  : 	}
; 139  : 
; 140  : 	return limit;
; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0009b	48 83 c4 18	 add	 rsp, 24
  0009f	c3		 ret	 0
lzma_memcmplen ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
_TEXT	ENDS
;	COMDAT mf_avail
_TEXT	SEGMENT
mf$ = 8
mf_avail PROC						; COMDAT

; 230  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 231  : 	return mf->write_pos - mf->read_pos;

  00005	48 8b 54 24 08	 mov	 rdx, QWORD PTR mf$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00012	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00015	2b c1		 sub	 eax, ecx

; 232  : }

  00017	c3		 ret	 0
mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_ptr
_TEXT	SEGMENT
mf$ = 8
mf_ptr	PROC						; COMDAT

; 222  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 223  : 	return mf->buffer + mf->read_pos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR mf$[rsp]
  00012	48 03 01	 add	 rax, QWORD PTR [rcx]

; 224  : }

  00015	c3		 ret	 0
mf_ptr	ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$bt_skip_func DD imagerel bt_skip_func
	DD	imagerel bt_skip_func+700
	DD	imagerel $unwind$bt_skip_func
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bt_skip_func DD 011601H
	DD	0c216H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT bt_skip_func
_TEXT	SEGMENT
len0$ = 0
ptr0$ = 8
len1$ = 16
ptr1$ = 24
delta$33318 = 32
pair$33321 = 40
len$33323 = 48
pb$33322 = 56
x$80115 = 64
tmp$80117 = 72
$T80118 = 76
tv80 = 80
tv89 = 84
tv157 = 88
len_limit$ = 112
pos$ = 120
cur$ = 128
cur_match$ = 136
depth$ = 144
son$ = 152
cyclic_pos$ = 160
cyclic_size$ = 168
bt_skip_func PROC					; COMDAT

; 553  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 554  : 	uint32_t *ptr0 = son + (cyclic_pos << 1) + 1;

  00016	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  0001d	d1 e0		 shl	 eax, 1
  0001f	8b c8		 mov	 ecx, eax
  00021	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  00029	48 8d 44 88 04	 lea	 rax, QWORD PTR [rax+rcx*4+4]
  0002e	48 89 44 24 08	 mov	 QWORD PTR ptr0$[rsp], rax

; 555  : 	uint32_t *ptr1 = son + (cyclic_pos << 1);

  00033	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  0003a	d1 e0		 shl	 eax, 1
  0003c	8b c8		 mov	 ecx, eax
  0003e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  00046	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0004a	48 89 44 24 18	 mov	 QWORD PTR ptr1$[rsp], rax

; 556  : 
; 557  : 	uint32_t len0 = 0;

  0004f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR len0$[rsp], 0

; 558  : 	uint32_t len1 = 0;

  00056	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR len1$[rsp], 0
$LN8@bt_skip_fu:

; 559  : 
; 560  : 	while (true) {

  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 01	 cmp	 eax, 1
  00063	0f 84 4e 02 00
	00		 je	 $LN7@bt_skip_fu

; 561  : 		const uint32_t delta = pos - cur_match;

  00069	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cur_match$[rsp]
  00070	8b 44 24 78	 mov	 eax, DWORD PTR pos$[rsp]
  00074	2b c1		 sub	 eax, ecx
  00076	89 44 24 20	 mov	 DWORD PTR delta$33318[rsp], eax

; 562  : 		if (depth-- == 0 || delta >= cyclic_size) {

  0007a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR depth$[rsp]
  00081	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR depth$[rsp]
  00088	83 e8 01	 sub	 eax, 1
  0008b	89 84 24 90 00
	00 00		 mov	 DWORD PTR depth$[rsp], eax
  00092	85 c9		 test	 ecx, ecx
  00094	74 0d		 je	 SHORT $LN5@bt_skip_fu
  00096	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR cyclic_size$[rsp]
  0009d	39 44 24 20	 cmp	 DWORD PTR delta$33318[rsp], eax
  000a1	72 1b		 jb	 SHORT $LN6@bt_skip_fu
$LN5@bt_skip_fu:

; 563  : 			*ptr0 = EMPTY_HASH_VALUE;

  000a3	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr0$[rsp]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 564  : 			*ptr1 = EMPTY_HASH_VALUE;

  000ae	48 8b 44 24 18	 mov	 rax, QWORD PTR ptr1$[rsp]
  000b3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 565  : 			return;

  000b9	e9 f9 01 00 00	 jmp	 $LN9@bt_skip_fu
$LN6@bt_skip_fu:

; 566  : 		}
; 567  : 
; 568  : 	  {
; 569  : 		uint32_t *pair = son + ((cyclic_pos - delta
; 570  : 				+ (delta > cyclic_pos ? cyclic_size : 0))
; 571  : 				<< 1);

  000be	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  000c5	39 44 24 20	 cmp	 DWORD PTR delta$33318[rsp], eax
  000c9	76 0d		 jbe	 SHORT $LN11@bt_skip_fu
  000cb	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR cyclic_size$[rsp]
  000d2	89 44 24 50	 mov	 DWORD PTR tv80[rsp], eax
  000d6	eb 08		 jmp	 SHORT $LN12@bt_skip_fu
$LN11@bt_skip_fu:
  000d8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN12@bt_skip_fu:
  000e0	8b 4c 24 20	 mov	 ecx, DWORD PTR delta$33318[rsp]
  000e4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  000eb	2b c1		 sub	 eax, ecx
  000ed	03 44 24 50	 add	 eax, DWORD PTR tv80[rsp]
  000f1	d1 e0		 shl	 eax, 1
  000f3	8b c8		 mov	 ecx, eax
  000f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  000fd	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  00101	48 89 44 24 28	 mov	 QWORD PTR pair$33321[rsp], rax

; 572  : 		const uint8_t *pb = cur - delta;

  00106	8b 4c 24 20	 mov	 ecx, DWORD PTR delta$33318[rsp]
  0010a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  00112	48 2b c1	 sub	 rax, rcx
  00115	48 89 44 24 38	 mov	 QWORD PTR pb$33322[rsp], rax

; 573  : 		uint32_t len = my_min(len0, len1);

  0011a	8b 44 24 10	 mov	 eax, DWORD PTR len1$[rsp]
  0011e	39 04 24	 cmp	 DWORD PTR len0$[rsp], eax
  00121	73 09		 jae	 SHORT $LN13@bt_skip_fu
  00123	8b 04 24	 mov	 eax, DWORD PTR len0$[rsp]
  00126	89 44 24 54	 mov	 DWORD PTR tv89[rsp], eax
  0012a	eb 08		 jmp	 SHORT $LN14@bt_skip_fu
$LN13@bt_skip_fu:
  0012c	8b 44 24 10	 mov	 eax, DWORD PTR len1$[rsp]
  00130	89 44 24 54	 mov	 DWORD PTR tv89[rsp], eax
$LN14@bt_skip_fu:
  00134	8b 44 24 54	 mov	 eax, DWORD PTR tv89[rsp]
  00138	89 44 24 30	 mov	 DWORD PTR len$33323[rsp], eax

; 574  : 
; 575  : 		if (pb[len] == cur[len]) {

  0013c	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33323[rsp]
  00140	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33322[rsp]
  00145	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00149	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33323[rsp]
  0014d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  00155	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00159	3b d0		 cmp	 edx, eax
  0015b	0f 85 cf 00 00
	00		 jne	 $LN4@bt_skip_fu

; 576  : 			len = lzma_memcmplen(pb, cur, len + 1, len_limit);

  00161	8b 44 24 30	 mov	 eax, DWORD PTR len$33323[rsp]
  00165	83 c0 01	 add	 eax, 1
  00168	89 44 24 4c	 mov	 DWORD PTR $T80118[rsp], eax
$LN17@bt_skip_fu:
  0016c	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  00170	39 44 24 4c	 cmp	 DWORD PTR $T80118[rsp], eax
  00174	0f 83 82 00 00
	00		 jae	 $LN16@bt_skip_fu
  0017a	44 8b 44 24 4c	 mov	 r8d, DWORD PTR $T80118[rsp]
  0017f	8b 54 24 4c	 mov	 edx, DWORD PTR $T80118[rsp]
  00183	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33322[rsp]
  00188	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$[rsp]
  00190	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00194	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  00198	48 2b c1	 sub	 rax, rcx
  0019b	48 89 44 24 40	 mov	 QWORD PTR x$80115[rsp], rax
  001a0	48 83 7c 24 40
	00		 cmp	 QWORD PTR x$80115[rsp], 0
  001a6	74 44		 je	 SHORT $LN15@bt_skip_fu
  001a8	48 8b 44 24 40	 mov	 rax, QWORD PTR x$80115[rsp]
  001ad	48 0f bc c0	 bsf	 rax, rax
  001b1	89 44 24 48	 mov	 DWORD PTR tmp$80117[rsp], eax
  001b5	8b 4c 24 48	 mov	 ecx, DWORD PTR tmp$80117[rsp]
  001b9	c1 e9 03	 shr	 ecx, 3
  001bc	8b 44 24 4c	 mov	 eax, DWORD PTR $T80118[rsp]
  001c0	03 c1		 add	 eax, ecx
  001c2	89 44 24 4c	 mov	 DWORD PTR $T80118[rsp], eax
  001c6	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  001ca	39 44 24 4c	 cmp	 DWORD PTR $T80118[rsp], eax
  001ce	73 0a		 jae	 SHORT $LN20@bt_skip_fu
  001d0	8b 44 24 4c	 mov	 eax, DWORD PTR $T80118[rsp]
  001d4	89 44 24 58	 mov	 DWORD PTR tv157[rsp], eax
  001d8	eb 08		 jmp	 SHORT $LN21@bt_skip_fu
$LN20@bt_skip_fu:
  001da	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  001de	89 44 24 58	 mov	 DWORD PTR tv157[rsp], eax
$LN21@bt_skip_fu:
  001e2	8b 44 24 58	 mov	 eax, DWORD PTR tv157[rsp]
  001e6	89 44 24 30	 mov	 DWORD PTR len$33323[rsp], eax
  001ea	eb 18		 jmp	 SHORT $LN18@bt_skip_fu
$LN15@bt_skip_fu:
  001ec	8b 44 24 4c	 mov	 eax, DWORD PTR $T80118[rsp]
  001f0	83 c0 08	 add	 eax, 8
  001f3	89 44 24 4c	 mov	 DWORD PTR $T80118[rsp], eax
  001f7	e9 70 ff ff ff	 jmp	 $LN17@bt_skip_fu
$LN16@bt_skip_fu:
  001fc	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  00200	89 44 24 30	 mov	 DWORD PTR len$33323[rsp], eax
$LN18@bt_skip_fu:

; 577  : 
; 578  : 			if (len == len_limit) {

  00204	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  00208	39 44 24 30	 cmp	 DWORD PTR len$33323[rsp], eax
  0020c	75 22		 jne	 SHORT $LN3@bt_skip_fu

; 579  : 				*ptr1 = pair[0];

  0020e	48 8b 4c 24 18	 mov	 rcx, QWORD PTR ptr1$[rsp]
  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33321[rsp]
  00218	8b 00		 mov	 eax, DWORD PTR [rax]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 580  : 				*ptr0 = pair[1];

  0021c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ptr0$[rsp]
  00221	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33321[rsp]
  00226	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00229	89 01		 mov	 DWORD PTR [rcx], eax

; 581  : 				return;

  0022b	e9 87 00 00 00	 jmp	 $LN9@bt_skip_fu
$LN3@bt_skip_fu:
$LN4@bt_skip_fu:

; 582  : 			}
; 583  : 		}
; 584  : 
; 585  : 		if (pb[len] < cur[len]) {

  00230	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33323[rsp]
  00234	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33322[rsp]
  00239	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0023d	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33323[rsp]
  00241	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  00249	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0024d	3b d0		 cmp	 edx, eax
  0024f	7d 34		 jge	 SHORT $LN2@bt_skip_fu

; 586  : 			*ptr1 = cur_match;

  00251	48 8b 4c 24 18	 mov	 rcx, QWORD PTR ptr1$[rsp]
  00256	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR cur_match$[rsp]
  0025d	89 01		 mov	 DWORD PTR [rcx], eax

; 587  : 			ptr1 = pair + 1;

  0025f	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33321[rsp]
  00264	48 83 c0 04	 add	 rax, 4
  00268	48 89 44 24 18	 mov	 QWORD PTR ptr1$[rsp], rax

; 588  : 			cur_match = *ptr1;

  0026d	48 8b 44 24 18	 mov	 rax, QWORD PTR ptr1$[rsp]
  00272	8b 00		 mov	 eax, DWORD PTR [rax]
  00274	89 84 24 88 00
	00 00		 mov	 DWORD PTR cur_match$[rsp], eax

; 589  : 			len1 = len;

  0027b	8b 44 24 30	 mov	 eax, DWORD PTR len$33323[rsp]
  0027f	89 44 24 10	 mov	 DWORD PTR len1$[rsp], eax

; 590  : 		} else {

  00283	eb 2d		 jmp	 SHORT $LN1@bt_skip_fu
$LN2@bt_skip_fu:

; 591  : 			*ptr0 = cur_match;

  00285	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ptr0$[rsp]
  0028a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR cur_match$[rsp]
  00291	89 01		 mov	 DWORD PTR [rcx], eax

; 592  : 			ptr0 = pair;

  00293	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33321[rsp]
  00298	48 89 44 24 08	 mov	 QWORD PTR ptr0$[rsp], rax

; 593  : 			cur_match = *ptr0;

  0029d	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr0$[rsp]
  002a2	8b 00		 mov	 eax, DWORD PTR [rax]
  002a4	89 84 24 88 00
	00 00		 mov	 DWORD PTR cur_match$[rsp], eax

; 594  : 			len0 = len;

  002ab	8b 44 24 30	 mov	 eax, DWORD PTR len$33323[rsp]
  002af	89 04 24	 mov	 DWORD PTR len0$[rsp], eax
$LN1@bt_skip_fu:

; 595  : 		}
; 596  : 	  }
; 597  : 	}

  002b2	e9 a7 fd ff ff	 jmp	 $LN8@bt_skip_fu
$LN7@bt_skip_fu:
$LN9@bt_skip_fu:

; 598  : }

  002b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002bb	c3		 ret	 0
bt_skip_func ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$bt_find_func DD imagerel bt_find_func
	DD	imagerel bt_find_func+792
	DD	imagerel $unwind$bt_find_func
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bt_find_func DD 011601H
	DD	0c216H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT bt_find_func
_TEXT	SEGMENT
len0$ = 0
ptr0$ = 8
len1$ = 16
ptr1$ = 24
delta$33282 = 32
pair$33285 = 40
len$33287 = 48
pb$33286 = 56
x$80137 = 64
tmp$80139 = 72
$T80140 = 76
tv80 = 80
tv89 = 84
tv161 = 88
len_limit$ = 112
pos$ = 120
cur$ = 128
cur_match$ = 136
depth$ = 144
son$ = 152
cyclic_pos$ = 160
cyclic_size$ = 168
matches$ = 176
len_best$ = 184
bt_find_func PROC					; COMDAT

; 487  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 488  : 	uint32_t *ptr0 = son + (cyclic_pos << 1) + 1;

  00016	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  0001d	d1 e0		 shl	 eax, 1
  0001f	8b c8		 mov	 ecx, eax
  00021	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  00029	48 8d 44 88 04	 lea	 rax, QWORD PTR [rax+rcx*4+4]
  0002e	48 89 44 24 08	 mov	 QWORD PTR ptr0$[rsp], rax

; 489  : 	uint32_t *ptr1 = son + (cyclic_pos << 1);

  00033	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  0003a	d1 e0		 shl	 eax, 1
  0003c	8b c8		 mov	 ecx, eax
  0003e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  00046	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0004a	48 89 44 24 18	 mov	 QWORD PTR ptr1$[rsp], rax

; 490  : 
; 491  : 	uint32_t len0 = 0;

  0004f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR len0$[rsp], 0

; 492  : 	uint32_t len1 = 0;

  00056	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR len1$[rsp], 0
$LN9@bt_find_fu:

; 493  : 
; 494  : 	while (true) {

  0005e	33 c0		 xor	 eax, eax
  00060	83 f8 01	 cmp	 eax, 1
  00063	0f 84 aa 02 00
	00		 je	 $LN8@bt_find_fu

; 495  : 		const uint32_t delta = pos - cur_match;

  00069	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cur_match$[rsp]
  00070	8b 44 24 78	 mov	 eax, DWORD PTR pos$[rsp]
  00074	2b c1		 sub	 eax, ecx
  00076	89 44 24 20	 mov	 DWORD PTR delta$33282[rsp], eax

; 496  : 		if (depth-- == 0 || delta >= cyclic_size) {

  0007a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR depth$[rsp]
  00081	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR depth$[rsp]
  00088	83 e8 01	 sub	 eax, 1
  0008b	89 84 24 90 00
	00 00		 mov	 DWORD PTR depth$[rsp], eax
  00092	85 c9		 test	 ecx, ecx
  00094	74 0d		 je	 SHORT $LN6@bt_find_fu
  00096	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR cyclic_size$[rsp]
  0009d	39 44 24 20	 cmp	 DWORD PTR delta$33282[rsp], eax
  000a1	72 23		 jb	 SHORT $LN7@bt_find_fu
$LN6@bt_find_fu:

; 497  : 			*ptr0 = EMPTY_HASH_VALUE;

  000a3	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr0$[rsp]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 498  : 			*ptr1 = EMPTY_HASH_VALUE;

  000ae	48 8b 44 24 18	 mov	 rax, QWORD PTR ptr1$[rsp]
  000b3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 499  : 			return matches;

  000b9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  000c1	e9 4d 02 00 00	 jmp	 $LN10@bt_find_fu
$LN7@bt_find_fu:

; 500  : 		}
; 501  : 
; 502  : 	  {
; 503  : 		uint32_t *const pair = son + ((cyclic_pos - delta
; 504  : 				+ (delta > cyclic_pos ? cyclic_size : 0))
; 505  : 				<< 1);

  000c6	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  000cd	39 44 24 20	 cmp	 DWORD PTR delta$33282[rsp], eax
  000d1	76 0d		 jbe	 SHORT $LN12@bt_find_fu
  000d3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR cyclic_size$[rsp]
  000da	89 44 24 50	 mov	 DWORD PTR tv80[rsp], eax
  000de	eb 08		 jmp	 SHORT $LN13@bt_find_fu
$LN12@bt_find_fu:
  000e0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN13@bt_find_fu:
  000e8	8b 4c 24 20	 mov	 ecx, DWORD PTR delta$33282[rsp]
  000ec	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  000f3	2b c1		 sub	 eax, ecx
  000f5	03 44 24 50	 add	 eax, DWORD PTR tv80[rsp]
  000f9	d1 e0		 shl	 eax, 1
  000fb	8b c8		 mov	 ecx, eax
  000fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR son$[rsp]
  00105	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  00109	48 89 44 24 28	 mov	 QWORD PTR pair$33285[rsp], rax

; 506  : 
; 507  : 		const uint8_t *const pb = cur - delta;

  0010e	8b 4c 24 20	 mov	 ecx, DWORD PTR delta$33282[rsp]
  00112	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  0011a	48 2b c1	 sub	 rax, rcx
  0011d	48 89 44 24 38	 mov	 QWORD PTR pb$33286[rsp], rax

; 508  : 		uint32_t len = my_min(len0, len1);

  00122	8b 44 24 10	 mov	 eax, DWORD PTR len1$[rsp]
  00126	39 04 24	 cmp	 DWORD PTR len0$[rsp], eax
  00129	73 09		 jae	 SHORT $LN14@bt_find_fu
  0012b	8b 04 24	 mov	 eax, DWORD PTR len0$[rsp]
  0012e	89 44 24 54	 mov	 DWORD PTR tv89[rsp], eax
  00132	eb 08		 jmp	 SHORT $LN15@bt_find_fu
$LN14@bt_find_fu:
  00134	8b 44 24 10	 mov	 eax, DWORD PTR len1$[rsp]
  00138	89 44 24 54	 mov	 DWORD PTR tv89[rsp], eax
$LN15@bt_find_fu:
  0013c	8b 44 24 54	 mov	 eax, DWORD PTR tv89[rsp]
  00140	89 44 24 30	 mov	 DWORD PTR len$33287[rsp], eax

; 509  : 
; 510  : 		if (pb[len] == cur[len]) {

  00144	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33287[rsp]
  00148	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33286[rsp]
  0014d	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00151	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33287[rsp]
  00155	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  0015d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00161	3b d0		 cmp	 edx, eax
  00163	0f 85 23 01 00
	00		 jne	 $LN5@bt_find_fu

; 511  : 			len = lzma_memcmplen(pb, cur, len + 1, len_limit);

  00169	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  0016d	83 c0 01	 add	 eax, 1
  00170	89 44 24 4c	 mov	 DWORD PTR $T80140[rsp], eax
$LN18@bt_find_fu:
  00174	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  00178	39 44 24 4c	 cmp	 DWORD PTR $T80140[rsp], eax
  0017c	0f 83 82 00 00
	00		 jae	 $LN17@bt_find_fu
  00182	44 8b 44 24 4c	 mov	 r8d, DWORD PTR $T80140[rsp]
  00187	8b 54 24 4c	 mov	 edx, DWORD PTR $T80140[rsp]
  0018b	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33286[rsp]
  00190	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$[rsp]
  00198	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0019c	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  001a0	48 2b c1	 sub	 rax, rcx
  001a3	48 89 44 24 40	 mov	 QWORD PTR x$80137[rsp], rax
  001a8	48 83 7c 24 40
	00		 cmp	 QWORD PTR x$80137[rsp], 0
  001ae	74 44		 je	 SHORT $LN16@bt_find_fu
  001b0	48 8b 44 24 40	 mov	 rax, QWORD PTR x$80137[rsp]
  001b5	48 0f bc c0	 bsf	 rax, rax
  001b9	89 44 24 48	 mov	 DWORD PTR tmp$80139[rsp], eax
  001bd	8b 4c 24 48	 mov	 ecx, DWORD PTR tmp$80139[rsp]
  001c1	c1 e9 03	 shr	 ecx, 3
  001c4	8b 44 24 4c	 mov	 eax, DWORD PTR $T80140[rsp]
  001c8	03 c1		 add	 eax, ecx
  001ca	89 44 24 4c	 mov	 DWORD PTR $T80140[rsp], eax
  001ce	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  001d2	39 44 24 4c	 cmp	 DWORD PTR $T80140[rsp], eax
  001d6	73 0a		 jae	 SHORT $LN21@bt_find_fu
  001d8	8b 44 24 4c	 mov	 eax, DWORD PTR $T80140[rsp]
  001dc	89 44 24 58	 mov	 DWORD PTR tv161[rsp], eax
  001e0	eb 08		 jmp	 SHORT $LN22@bt_find_fu
$LN21@bt_find_fu:
  001e2	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  001e6	89 44 24 58	 mov	 DWORD PTR tv161[rsp], eax
$LN22@bt_find_fu:
  001ea	8b 44 24 58	 mov	 eax, DWORD PTR tv161[rsp]
  001ee	89 44 24 30	 mov	 DWORD PTR len$33287[rsp], eax
  001f2	eb 18		 jmp	 SHORT $LN19@bt_find_fu
$LN16@bt_find_fu:
  001f4	8b 44 24 4c	 mov	 eax, DWORD PTR $T80140[rsp]
  001f8	83 c0 08	 add	 eax, 8
  001fb	89 44 24 4c	 mov	 DWORD PTR $T80140[rsp], eax
  001ff	e9 70 ff ff ff	 jmp	 $LN18@bt_find_fu
$LN17@bt_find_fu:
  00204	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  00208	89 44 24 30	 mov	 DWORD PTR len$33287[rsp], eax
$LN19@bt_find_fu:

; 512  : 
; 513  : 			if (len_best < len) {

  0020c	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  00210	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR len_best$[rsp], eax
  00217	73 73		 jae	 SHORT $LN4@bt_find_fu

; 514  : 				len_best = len;

  00219	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  0021d	89 84 24 b8 00
	00 00		 mov	 DWORD PTR len_best$[rsp], eax

; 515  : 				matches->len = len;

  00224	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  0022c	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  00230	89 01		 mov	 DWORD PTR [rcx], eax

; 516  : 				matches->dist = delta - 1;

  00232	8b 4c 24 20	 mov	 ecx, DWORD PTR delta$33282[rsp]
  00236	83 e9 01	 sub	 ecx, 1
  00239	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00241	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 517  : 				++matches;

  00244	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  0024c	48 83 c0 08	 add	 rax, 8
  00250	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR matches$[rsp], rax

; 518  : 
; 519  : 				if (len == len_limit) {

  00258	8b 44 24 70	 mov	 eax, DWORD PTR len_limit$[rsp]
  0025c	39 44 24 30	 cmp	 DWORD PTR len$33287[rsp], eax
  00260	75 2a		 jne	 SHORT $LN3@bt_find_fu

; 520  : 					*ptr1 = pair[0];

  00262	48 8b 4c 24 18	 mov	 rcx, QWORD PTR ptr1$[rsp]
  00267	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33285[rsp]
  0026c	8b 00		 mov	 eax, DWORD PTR [rax]
  0026e	89 01		 mov	 DWORD PTR [rcx], eax

; 521  : 					*ptr0 = pair[1];

  00270	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ptr0$[rsp]
  00275	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33285[rsp]
  0027a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0027d	89 01		 mov	 DWORD PTR [rcx], eax

; 522  : 					return matches;

  0027f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00287	e9 87 00 00 00	 jmp	 $LN10@bt_find_fu
$LN3@bt_find_fu:
$LN4@bt_find_fu:
$LN5@bt_find_fu:

; 523  : 				}
; 524  : 			}
; 525  : 		}
; 526  : 
; 527  : 		if (pb[len] < cur[len]) {

  0028c	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33287[rsp]
  00290	48 8b 44 24 38	 mov	 rax, QWORD PTR pb$33286[rsp]
  00295	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00299	8b 4c 24 30	 mov	 ecx, DWORD PTR len$33287[rsp]
  0029d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cur$[rsp]
  002a5	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002a9	3b d0		 cmp	 edx, eax
  002ab	7d 34		 jge	 SHORT $LN2@bt_find_fu

; 528  : 			*ptr1 = cur_match;

  002ad	48 8b 4c 24 18	 mov	 rcx, QWORD PTR ptr1$[rsp]
  002b2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR cur_match$[rsp]
  002b9	89 01		 mov	 DWORD PTR [rcx], eax

; 529  : 			ptr1 = pair + 1;

  002bb	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33285[rsp]
  002c0	48 83 c0 04	 add	 rax, 4
  002c4	48 89 44 24 18	 mov	 QWORD PTR ptr1$[rsp], rax

; 530  : 			cur_match = *ptr1;

  002c9	48 8b 44 24 18	 mov	 rax, QWORD PTR ptr1$[rsp]
  002ce	8b 00		 mov	 eax, DWORD PTR [rax]
  002d0	89 84 24 88 00
	00 00		 mov	 DWORD PTR cur_match$[rsp], eax

; 531  : 			len1 = len;

  002d7	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  002db	89 44 24 10	 mov	 DWORD PTR len1$[rsp], eax

; 532  : 		} else {

  002df	eb 2d		 jmp	 SHORT $LN1@bt_find_fu
$LN2@bt_find_fu:

; 533  : 			*ptr0 = cur_match;

  002e1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ptr0$[rsp]
  002e6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR cur_match$[rsp]
  002ed	89 01		 mov	 DWORD PTR [rcx], eax

; 534  : 			ptr0 = pair;

  002ef	48 8b 44 24 28	 mov	 rax, QWORD PTR pair$33285[rsp]
  002f4	48 89 44 24 08	 mov	 QWORD PTR ptr0$[rsp], rax

; 535  : 			cur_match = *ptr0;

  002f9	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr0$[rsp]
  002fe	8b 00		 mov	 eax, DWORD PTR [rax]
  00300	89 84 24 88 00
	00 00		 mov	 DWORD PTR cur_match$[rsp], eax

; 536  : 			len0 = len;

  00307	8b 44 24 30	 mov	 eax, DWORD PTR len$33287[rsp]
  0030b	89 04 24	 mov	 DWORD PTR len0$[rsp], eax
$LN1@bt_find_fu:

; 537  : 		}
; 538  : 	  }
; 539  : 	}

  0030e	e9 4b fd ff ff	 jmp	 $LN9@bt_find_fu
$LN8@bt_find_fu:
$LN10@bt_find_fu:

; 540  : }

  00313	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00317	c3		 ret	 0
bt_find_func ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$hc_find_func DD imagerel hc_find_func
	DD	imagerel hc_find_func+495
	DD	imagerel $unwind$hc_find_func
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hc_find_func DD 011601H
	DD	06216H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT hc_find_func
_TEXT	SEGMENT
delta$33137 = 0
pb$33140 = 8
len$33142 = 16
x$80157 = 24
tmp$80159 = 32
$T80160 = 36
tv76 = 40
tv145 = 44
len_limit$ = 64
pos$ = 72
cur$ = 80
cur_match$ = 88
depth$ = 96
son$ = 104
cyclic_pos$ = 112
cyclic_size$ = 120
matches$ = 128
len_best$ = 136
hc_find_func PROC					; COMDAT

; 273  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 274  : 	son[cyclic_pos] = cur_match;

  00016	8b 54 24 70	 mov	 edx, DWORD PTR cyclic_pos$[rsp]
  0001a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR son$[rsp]
  0001f	8b 44 24 58	 mov	 eax, DWORD PTR cur_match$[rsp]
  00023	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN7@hc_find_fu:

; 275  : 
; 276  : 	while (true) {

  00026	33 c0		 xor	 eax, eax
  00028	83 f8 01	 cmp	 eax, 1
  0002b	0f 84 b9 01 00
	00		 je	 $LN6@hc_find_fu

; 277  : 		const uint32_t delta = pos - cur_match;

  00031	8b 4c 24 58	 mov	 ecx, DWORD PTR cur_match$[rsp]
  00035	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  00039	2b c1		 sub	 eax, ecx
  0003b	89 04 24	 mov	 DWORD PTR delta$33137[rsp], eax

; 278  : 		if (depth-- == 0 || delta >= cyclic_size)

  0003e	8b 4c 24 60	 mov	 ecx, DWORD PTR depth$[rsp]
  00042	8b 44 24 60	 mov	 eax, DWORD PTR depth$[rsp]
  00046	83 e8 01	 sub	 eax, 1
  00049	89 44 24 60	 mov	 DWORD PTR depth$[rsp], eax
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 09		 je	 SHORT $LN4@hc_find_fu
  00051	8b 44 24 78	 mov	 eax, DWORD PTR cyclic_size$[rsp]
  00055	39 04 24	 cmp	 DWORD PTR delta$33137[rsp], eax
  00058	72 0d		 jb	 SHORT $LN5@hc_find_fu
$LN4@hc_find_fu:

; 279  : 			return matches;

  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00062	e9 83 01 00 00	 jmp	 $LN8@hc_find_fu
$LN5@hc_find_fu:

; 280  : 
; 281  : 	  {
; 282  : 		const uint8_t *const pb = cur - delta;

  00067	8b 0c 24	 mov	 ecx, DWORD PTR delta$33137[rsp]
  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR cur$[rsp]
  0006f	48 2b c1	 sub	 rax, rcx
  00072	48 89 44 24 08	 mov	 QWORD PTR pb$33140[rsp], rax

; 283  : 		cur_match = son[cyclic_pos - delta
; 284  : 				+ (delta > cyclic_pos ? cyclic_size : 0)];

  00077	8b 44 24 70	 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  0007b	39 04 24	 cmp	 DWORD PTR delta$33137[rsp], eax
  0007e	76 0a		 jbe	 SHORT $LN10@hc_find_fu
  00080	8b 44 24 78	 mov	 eax, DWORD PTR cyclic_size$[rsp]
  00084	89 44 24 28	 mov	 DWORD PTR tv76[rsp], eax
  00088	eb 08		 jmp	 SHORT $LN11@hc_find_fu
$LN10@hc_find_fu:
  0008a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN11@hc_find_fu:
  00092	8b 0c 24	 mov	 ecx, DWORD PTR delta$33137[rsp]
  00095	8b 44 24 70	 mov	 eax, DWORD PTR cyclic_pos$[rsp]
  00099	2b c1		 sub	 eax, ecx
  0009b	03 44 24 28	 add	 eax, DWORD PTR tv76[rsp]
  0009f	8b c8		 mov	 ecx, eax
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR son$[rsp]
  000a6	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000a9	89 44 24 58	 mov	 DWORD PTR cur_match$[rsp], eax

; 285  : 
; 286  : 		if (pb[len_best] == cur[len_best] && pb[0] == cur[0]) {

  000ad	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR len_best$[rsp]
  000b4	48 8b 44 24 08	 mov	 rax, QWORD PTR pb$33140[rsp]
  000b9	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  000bd	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR len_best$[rsp]
  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR cur$[rsp]
  000c9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000cd	3b d0		 cmp	 edx, eax
  000cf	0f 85 10 01 00
	00		 jne	 $LN3@hc_find_fu
  000d5	48 8b 44 24 08	 mov	 rax, QWORD PTR pb$33140[rsp]
  000da	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR cur$[rsp]
  000e2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e5	3b c8		 cmp	 ecx, eax
  000e7	0f 85 f8 00 00
	00		 jne	 $LN3@hc_find_fu

; 287  : 			uint32_t len = lzma_memcmplen(pb, cur, 1, len_limit);

  000ed	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR $T80160[rsp], 1
$LN14@hc_find_fu:
  000f5	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$[rsp]
  000f9	39 44 24 24	 cmp	 DWORD PTR $T80160[rsp], eax
  000fd	73 7f		 jae	 SHORT $LN13@hc_find_fu
  000ff	44 8b 44 24 24	 mov	 r8d, DWORD PTR $T80160[rsp]
  00104	8b 54 24 24	 mov	 edx, DWORD PTR $T80160[rsp]
  00108	48 8b 44 24 08	 mov	 rax, QWORD PTR pb$33140[rsp]
  0010d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cur$[rsp]
  00112	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00116	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  0011a	48 2b c1	 sub	 rax, rcx
  0011d	48 89 44 24 18	 mov	 QWORD PTR x$80157[rsp], rax
  00122	48 83 7c 24 18
	00		 cmp	 QWORD PTR x$80157[rsp], 0
  00128	74 44		 je	 SHORT $LN12@hc_find_fu
  0012a	48 8b 44 24 18	 mov	 rax, QWORD PTR x$80157[rsp]
  0012f	48 0f bc c0	 bsf	 rax, rax
  00133	89 44 24 20	 mov	 DWORD PTR tmp$80159[rsp], eax
  00137	8b 4c 24 20	 mov	 ecx, DWORD PTR tmp$80159[rsp]
  0013b	c1 e9 03	 shr	 ecx, 3
  0013e	8b 44 24 24	 mov	 eax, DWORD PTR $T80160[rsp]
  00142	03 c1		 add	 eax, ecx
  00144	89 44 24 24	 mov	 DWORD PTR $T80160[rsp], eax
  00148	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$[rsp]
  0014c	39 44 24 24	 cmp	 DWORD PTR $T80160[rsp], eax
  00150	73 0a		 jae	 SHORT $LN17@hc_find_fu
  00152	8b 44 24 24	 mov	 eax, DWORD PTR $T80160[rsp]
  00156	89 44 24 2c	 mov	 DWORD PTR tv145[rsp], eax
  0015a	eb 08		 jmp	 SHORT $LN18@hc_find_fu
$LN17@hc_find_fu:
  0015c	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$[rsp]
  00160	89 44 24 2c	 mov	 DWORD PTR tv145[rsp], eax
$LN18@hc_find_fu:
  00164	8b 44 24 2c	 mov	 eax, DWORD PTR tv145[rsp]
  00168	89 44 24 10	 mov	 DWORD PTR len$33142[rsp], eax
  0016c	eb 18		 jmp	 SHORT $LN15@hc_find_fu
$LN12@hc_find_fu:
  0016e	8b 44 24 24	 mov	 eax, DWORD PTR $T80160[rsp]
  00172	83 c0 08	 add	 eax, 8
  00175	89 44 24 24	 mov	 DWORD PTR $T80160[rsp], eax
  00179	e9 77 ff ff ff	 jmp	 $LN14@hc_find_fu
$LN13@hc_find_fu:
  0017e	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$[rsp]
  00182	89 44 24 10	 mov	 DWORD PTR len$33142[rsp], eax
$LN15@hc_find_fu:

; 288  : 
; 289  : 			if (len_best < len) {

  00186	8b 44 24 10	 mov	 eax, DWORD PTR len$33142[rsp]
  0018a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR len_best$[rsp], eax
  00191	73 52		 jae	 SHORT $LN2@hc_find_fu

; 290  : 				len_best = len;

  00193	8b 44 24 10	 mov	 eax, DWORD PTR len$33142[rsp]
  00197	89 84 24 88 00
	00 00		 mov	 DWORD PTR len_best$[rsp], eax

; 291  : 				matches->len = len;

  0019e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  001a6	8b 44 24 10	 mov	 eax, DWORD PTR len$33142[rsp]
  001aa	89 01		 mov	 DWORD PTR [rcx], eax

; 292  : 				matches->dist = delta - 1;

  001ac	8b 0c 24	 mov	 ecx, DWORD PTR delta$33137[rsp]
  001af	83 e9 01	 sub	 ecx, 1
  001b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  001ba	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 293  : 				++matches;

  001bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  001c5	48 83 c0 08	 add	 rax, 8
  001c9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR matches$[rsp], rax

; 294  : 
; 295  : 				if (len == len_limit)

  001d1	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$[rsp]
  001d5	39 44 24 10	 cmp	 DWORD PTR len$33142[rsp], eax
  001d9	75 0a		 jne	 SHORT $LN1@hc_find_fu

; 296  : 					return matches;

  001db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  001e3	eb 05		 jmp	 SHORT $LN8@hc_find_fu
$LN1@hc_find_fu:
$LN2@hc_find_fu:
$LN3@hc_find_fu:

; 297  : 			}
; 298  : 		}
; 299  : 	  }
; 300  : 	}

  001e5	e9 3c fe ff ff	 jmp	 $LN7@hc_find_fu
$LN6@hc_find_fu:
$LN8@hc_find_fu:

; 301  : }

  001ea	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ee	c3		 ret	 0
hc_find_func ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$move_pos DD imagerel move_pos
	DD	imagerel move_pos+113
	DD	imagerel $unwind$move_pos
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$move_pos DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT move_pos
_TEXT	SEGMENT
mf$ = 48
move_pos PROC						; COMDAT

; 158  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 159  : 	if (++mf->cyclic_pos == mf->cyclic_size)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  0000e	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00011	83 c1 01	 add	 ecx, 1
  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00019	89 48 50	 mov	 DWORD PTR [rax+80], ecx
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00026	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00029	39 41 50	 cmp	 DWORD PTR [rcx+80], eax
  0002c	75 0c		 jne	 SHORT $LN2@move_pos

; 160  : 		mf->cyclic_pos = 0;

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00033	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0
$LN2@move_pos:

; 161  : 
; 162  : 	++mf->read_pos;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  0003f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00042	83 c1 01	 add	 ecx, 1
  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  0004a	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 163  : 	assert(mf->read_pos <= mf->write_pos);
; 164  : 
; 165  : 	if (unlikely(mf->read_pos + mf->offset == UINT32_MAX))

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00052	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  0005a	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  0005d	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00060	75 0a		 jne	 SHORT $LN1@move_pos

; 166  : 		normalize(mf);

  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  00067	e8 00 00 00 00	 call	 normalize
$LN1@move_pos:

; 167  : }

  0006c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00070	c3		 ret	 0
move_pos ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_mf_find DD imagerel $LN17
	DD	imagerel $LN17+412
	DD	imagerel $unwind$lzma_mf_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_find DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_find
_TEXT	SEGMENT
count$ = 32
len_best$ = 36
limit$33079 = 40
p2$33082 = 48
p1$33081 = 56
x$80183 = 64
tmp$80185 = 72
$T80189 = 76
tv148 = 80
mf$ = 112
count_ptr$ = 120
matches$ = 128
lzma_mf_find PROC					; COMDAT

; 24   : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 25   : 	// Call the match finder. It returns the number of length-distance
; 26   : 	// pairs found.
; 27   : 	// FIXME: Minimum count is zero, what _exactly_ is the maximum?
; 28   : 	const uint32_t count = mf->find(mf, matches);

  00013	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR matches$[rsp]
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00025	ff 50 30	 call	 QWORD PTR [rax+48]
  00028	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax

; 29   : 
; 30   : 	// Length of the longest match; assume that no matches were found
; 31   : 	// and thus the maximum length is zero.
; 32   : 	uint32_t len_best = 0;

  0002c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len_best$[rsp], 0

; 33   : 
; 34   : 	if (count > 0) {

  00034	83 7c 24 20 00	 cmp	 DWORD PTR count$[rsp], 0
  00039	0f 86 36 01 00
	00		 jbe	 $LN3@lzma_mf_fi

; 35   : #ifndef NDEBUG
; 36   : 		// Validate the matches.
; 37   : 		uint32_t i;
; 38   : 
; 39   : 		for (i = 0; i < count; ++i) {
; 40   : 			assert(matches[i].len <= mf->nice_len);
; 41   : 			assert(matches[i].dist < mf->read_pos);
; 42   : 			assert(memcmp(mf_ptr(mf) - 1,
; 43   : 				mf_ptr(mf) - matches[i].dist - 2,
; 44   : 				matches[i].len) == 0);
; 45   : 		}
; 46   : #endif
; 47   : 
; 48   : 		// The last used element in the array contains
; 49   : 		// the longest match.
; 50   : 		len_best = matches[count - 1].len;

  0003f	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  00043	83 e8 01	 sub	 eax, 1
  00046	8b c8		 mov	 ecx, eax
  00048	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00050	8b 04 c8	 mov	 eax, DWORD PTR [rax+rcx*8]
  00053	89 44 24 24	 mov	 DWORD PTR len_best$[rsp], eax

; 51   : 
; 52   : 		// If a match of maximum search length was found, try to
; 53   : 		// extend the match to maximum possible length.
; 54   : 		if (len_best == mf->nice_len) {

  00057	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  0005c	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0005f	39 44 24 24	 cmp	 DWORD PTR len_best$[rsp], eax
  00063	0f 85 0c 01 00
	00		 jne	 $LN2@lzma_mf_fi

; 55   : 			// The limit for the match length is either the
; 56   : 			// maximum match length supported by the LZ-based
; 57   : 			// encoder or the number of bytes left in the
; 58   : 			// dictionary, whichever is smaller.
; 59   : 			uint32_t limit = mf_avail(mf) + 1;

  00069	48 8b 54 24 70	 mov	 rdx, QWORD PTR mf$[rsp]
  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00073	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00076	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00079	2b c1		 sub	 eax, ecx
  0007b	83 c0 01	 add	 eax, 1
  0007e	89 44 24 28	 mov	 DWORD PTR limit$33079[rsp], eax

; 60   : 			if (limit > mf->match_len_max)

  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00087	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0008a	39 44 24 28	 cmp	 DWORD PTR limit$33079[rsp], eax
  0008e	76 0c		 jbe	 SHORT $LN1@lzma_mf_fi

; 61   : 				limit = mf->match_len_max;

  00090	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00095	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00098	89 44 24 28	 mov	 DWORD PTR limit$33079[rsp], eax
$LN1@lzma_mf_fi:

; 62   : 
; 63   : 			// Pointer to the byte we just ran through
; 64   : 			// the match finder.
; 65   : 		  {
; 66   : 			const uint8_t *p1 = mf_ptr(mf) - 1;

  0009c	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000a1	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000a4	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  000b1	48 89 44 24 38	 mov	 QWORD PTR p1$33081[rsp], rax

; 67   : 
; 68   : 			// Pointer to the beginning of the match. We need -1
; 69   : 			// here because the match distances are zero based.
; 70   : 			const uint8_t *p2 = p1 - matches[count - 1].dist - 1;

  000b6	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  000ba	83 e8 01	 sub	 eax, 1
  000bd	8b c8		 mov	 ecx, eax
  000bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  000c7	8b 4c c8 04	 mov	 ecx, DWORD PTR [rax+rcx*8+4]
  000cb	48 8b 44 24 38	 mov	 rax, QWORD PTR p1$33081[rsp]
  000d0	48 2b c1	 sub	 rax, rcx
  000d3	48 83 e8 01	 sub	 rax, 1
  000d7	48 89 44 24 30	 mov	 QWORD PTR p2$33082[rsp], rax

; 71   : 
; 72   : 			len_best = lzma_memcmplen(p1, p2, len_best, limit);

  000dc	8b 44 24 24	 mov	 eax, DWORD PTR len_best$[rsp]
  000e0	89 44 24 4c	 mov	 DWORD PTR $T80189[rsp], eax
$LN12@lzma_mf_fi:
  000e4	8b 44 24 28	 mov	 eax, DWORD PTR limit$33079[rsp]
  000e8	39 44 24 4c	 cmp	 DWORD PTR $T80189[rsp], eax
  000ec	73 7f		 jae	 SHORT $LN11@lzma_mf_fi
  000ee	44 8b 44 24 4c	 mov	 r8d, DWORD PTR $T80189[rsp]
  000f3	8b 54 24 4c	 mov	 edx, DWORD PTR $T80189[rsp]
  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR p1$33081[rsp]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p2$33082[rsp]
  00101	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00105	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  00109	48 2b c1	 sub	 rax, rcx
  0010c	48 89 44 24 40	 mov	 QWORD PTR x$80183[rsp], rax
  00111	48 83 7c 24 40
	00		 cmp	 QWORD PTR x$80183[rsp], 0
  00117	74 44		 je	 SHORT $LN10@lzma_mf_fi
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR x$80183[rsp]
  0011e	48 0f bc c0	 bsf	 rax, rax
  00122	89 44 24 48	 mov	 DWORD PTR tmp$80185[rsp], eax
  00126	8b 4c 24 48	 mov	 ecx, DWORD PTR tmp$80185[rsp]
  0012a	c1 e9 03	 shr	 ecx, 3
  0012d	8b 44 24 4c	 mov	 eax, DWORD PTR $T80189[rsp]
  00131	03 c1		 add	 eax, ecx
  00133	89 44 24 4c	 mov	 DWORD PTR $T80189[rsp], eax
  00137	8b 44 24 28	 mov	 eax, DWORD PTR limit$33079[rsp]
  0013b	39 44 24 4c	 cmp	 DWORD PTR $T80189[rsp], eax
  0013f	73 0a		 jae	 SHORT $LN15@lzma_mf_fi
  00141	8b 44 24 4c	 mov	 eax, DWORD PTR $T80189[rsp]
  00145	89 44 24 50	 mov	 DWORD PTR tv148[rsp], eax
  00149	eb 08		 jmp	 SHORT $LN16@lzma_mf_fi
$LN15@lzma_mf_fi:
  0014b	8b 44 24 28	 mov	 eax, DWORD PTR limit$33079[rsp]
  0014f	89 44 24 50	 mov	 DWORD PTR tv148[rsp], eax
$LN16@lzma_mf_fi:
  00153	8b 44 24 50	 mov	 eax, DWORD PTR tv148[rsp]
  00157	89 44 24 24	 mov	 DWORD PTR len_best$[rsp], eax
  0015b	eb 18		 jmp	 SHORT $LN13@lzma_mf_fi
$LN10@lzma_mf_fi:
  0015d	8b 44 24 4c	 mov	 eax, DWORD PTR $T80189[rsp]
  00161	83 c0 08	 add	 eax, 8
  00164	89 44 24 4c	 mov	 DWORD PTR $T80189[rsp], eax
  00168	e9 77 ff ff ff	 jmp	 $LN12@lzma_mf_fi
$LN11@lzma_mf_fi:
  0016d	8b 44 24 28	 mov	 eax, DWORD PTR limit$33079[rsp]
  00171	89 44 24 24	 mov	 DWORD PTR len_best$[rsp], eax
$LN13@lzma_mf_fi:
$LN2@lzma_mf_fi:
$LN3@lzma_mf_fi:

; 73   : 		  }
; 74   : 		}
; 75   : 	}
; 76   : 
; 77   : 	*count_ptr = count;

  00175	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count_ptr$[rsp]
  0017a	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  0017e	89 01		 mov	 DWORD PTR [rcx], eax

; 78   : 
; 79   : 	// Finally update the read position to indicate that match finder was
; 80   : 	// run for this dictionary offset.
; 81   : 	++mf->read_ahead;

  00180	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00185	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00188	83 c1 01	 add	 ecx, 1
  0018b	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00190	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 82   : 
; 83   : 	return len_best;

  00193	8b 44 24 24	 mov	 eax, DWORD PTR len_best$[rsp]

; 84   : }

  00197	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0019b	c3		 ret	 0
lzma_mf_find ENDP
PUBLIC	lzma_mf_bt4_skip
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_bt4_skip DD imagerel $LN17
	DD	imagerel $LN17+561
	DD	imagerel $unwind$lzma_mf_bt4_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt4_skip DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt4_skip
_TEXT	SEGMENT
len_limit$33472 = 64
cur$33478 = 72
pos$33479 = 80
temp$33480 = 84
hash_3_value$33482 = 88
hash_value$33484 = 92
hash_2_value$33481 = 96
cur_match$33486 = 100
mf$ = 128
amount$ = 136
lzma_mf_bt4_skip PROC					; COMDAT

; 779  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN10@lzma_mf_bt:

; 780  : 	do {
; 781  : 		header_skip(true, 4);

  0000d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00015	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00020	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00023	2b c1		 sub	 eax, ecx
  00025	89 44 24 40	 mov	 DWORD PTR len_limit$33472[rsp], eax
  00029	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00031	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$33472[rsp]
  00035	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00038	77 11		 ja	 SHORT $LN7@lzma_mf_bt
  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00042	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00045	89 44 24 40	 mov	 DWORD PTR len_limit$33472[rsp], eax
  00049	eb 2e		 jmp	 SHORT $LN6@lzma_mf_bt
$LN7@lzma_mf_bt:
  0004b	83 7c 24 40 04	 cmp	 DWORD PTR len_limit$33472[rsp], 4
  00050	72 15		 jb	 SHORT $LN4@lzma_mf_bt
  00052	33 c0		 xor	 eax, eax
  00054	83 f8 01	 cmp	 eax, 1
  00057	74 20		 je	 SHORT $LN5@lzma_mf_bt
  00059	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00061	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00065	75 12		 jne	 SHORT $LN5@lzma_mf_bt
$LN4@lzma_mf_bt:
  00067	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0006f	e8 00 00 00 00	 call	 move_pending
  00074	e9 94 01 00 00	 jmp	 $LN9@lzma_mf_bt
$LN5@lzma_mf_bt:
$LN6@lzma_mf_bt:
  00079	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00081	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00084	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0008c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0008f	48 89 44 24 48	 mov	 QWORD PTR cur$33478[rsp], rax
  00094	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0009c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0009f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000a7	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000aa	89 44 24 50	 mov	 DWORD PTR pos$33479[rsp], eax

; 782  : 
; 783  : 	  {
; 784  : 		hash_4_calc();

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33478[rsp]
  000b3	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33478[rsp]
  000c3	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c7	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000cb	33 c1		 xor	 eax, ecx
  000cd	89 44 24 54	 mov	 DWORD PTR temp$33480[rsp], eax
  000d1	8b 44 24 54	 mov	 eax, DWORD PTR temp$33480[rsp]
  000d5	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000da	89 44 24 60	 mov	 DWORD PTR hash_2_value$33481[rsp], eax
  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33478[rsp]
  000e3	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000e7	c1 e1 08	 shl	 ecx, 8
  000ea	8b 44 24 54	 mov	 eax, DWORD PTR temp$33480[rsp]
  000ee	33 c1		 xor	 eax, ecx
  000f0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000f5	89 44 24 58	 mov	 DWORD PTR hash_3_value$33482[rsp], eax
  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33478[rsp]
  000fe	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00102	c1 e0 08	 shl	 eax, 8
  00105	8b 54 24 54	 mov	 edx, DWORD PTR temp$33480[rsp]
  00109	33 d0		 xor	 edx, eax
  0010b	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33478[rsp]
  00110	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00114	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  0011b	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0011e	c1 e1 05	 shl	 ecx, 5
  00121	8b c2		 mov	 eax, edx
  00123	33 c1		 xor	 eax, ecx
  00125	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0012d	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  00130	89 44 24 5c	 mov	 DWORD PTR hash_value$33484[rsp], eax

; 785  : 
; 786  : 	  {
; 787  : 		const uint32_t cur_match
; 788  : 				= mf->hash[FIX_4_HASH_SIZE + hash_value];

  00134	8b 44 24 5c	 mov	 eax, DWORD PTR hash_value$33484[rsp]
  00138	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  0013d	8b c8		 mov	 ecx, eax
  0013f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00147	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0014b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0014e	89 44 24 64	 mov	 DWORD PTR cur_match$33486[rsp], eax

; 789  : 
; 790  : 		mf->hash[hash_2_value] = pos;

  00152	8b 54 24 60	 mov	 edx, DWORD PTR hash_2_value$33481[rsp]
  00156	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0015e	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00162	8b 44 24 50	 mov	 eax, DWORD PTR pos$33479[rsp]
  00166	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 791  : 		mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  00169	8b 44 24 58	 mov	 eax, DWORD PTR hash_3_value$33482[rsp]
  0016d	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00172	8b d0		 mov	 edx, eax
  00174	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0017c	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00180	8b 44 24 50	 mov	 eax, DWORD PTR pos$33479[rsp]
  00184	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 792  : 		mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  00187	8b 44 24 5c	 mov	 eax, DWORD PTR hash_value$33484[rsp]
  0018b	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  00190	8b d0		 mov	 edx, eax
  00192	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0019a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0019e	8b 44 24 50	 mov	 eax, DWORD PTR pos$33479[rsp]
  001a2	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_bt:

; 793  : 
; 794  : 		bt_skip();

  001a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001ad	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  001b0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  001b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001bc	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  001bf	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001cb	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  001cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001dc	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  001df	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e3	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cur_match$33486[rsp]
  001e8	4c 8b 44 24 48	 mov	 r8, QWORD PTR cur$33478[rsp]
  001ed	8b 54 24 50	 mov	 edx, DWORD PTR pos$33479[rsp]
  001f1	8b 4c 24 40	 mov	 ecx, DWORD PTR len_limit$33472[rsp]
  001f5	e8 00 00 00 00	 call	 bt_skip_func
  001fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00202	e8 00 00 00 00	 call	 move_pos
  00207	33 c0		 xor	 eax, eax
  00209	85 c0		 test	 eax, eax
  0020b	75 98		 jne	 SHORT $LN3@lzma_mf_bt
$LN9@lzma_mf_bt:

; 795  : 	  }}
; 796  : 
; 797  :     }}  //MiSt: header_skip()
; 798  : 	} while (--amount != 0);

  0020d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR amount$[rsp]
  00214	83 e8 01	 sub	 eax, 1
  00217	89 84 24 88 00
	00 00		 mov	 DWORD PTR amount$[rsp], eax
  0021e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR amount$[rsp], 0
  00226	0f 85 e1 fd ff
	ff		 jne	 $LN10@lzma_mf_bt

; 799  : }

  0022c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00230	c3		 ret	 0
lzma_mf_bt4_skip ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_bt4_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_mf_bt4_find DD imagerel $LN29
	DD	imagerel $LN29+1316
	DD	imagerel $unwind$lzma_mf_bt4_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt4_find DD 021101H
	DD	0150111H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt4_find
_TEXT	SEGMENT
len_limit$33432 = 80
cur$33438 = 88
pos$33439 = 96
matches_count$33440 = 100
temp$33441 = 104
hash_3_value$33443 = 108
hash_value$33445 = 112
hash_2_value$33442 = 116
cur_match$33449 = 120
delta3$33448 = 124
delta2$33447 = 128
len_best$33450 = 132
x$82140 = 136
tmp$82142 = 144
$T82143 = 148
tv255 = 152
mf$ = 176
matches$ = 184
lzma_mf_bt4_find PROC					; COMDAT

; 723  : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 724  : 	header_find(true, 4);

  00011	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00019	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00024	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00027	2b c1		 sub	 eax, ecx
  00029	89 44 24 50	 mov	 DWORD PTR len_limit$33432[rsp], eax
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00035	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  00039	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0003c	77 11		 ja	 SHORT $LN15@lzma_mf_bt@2
  0003e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00046	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00049	89 44 24 50	 mov	 DWORD PTR len_limit$33432[rsp], eax
  0004d	eb 30		 jmp	 SHORT $LN14@lzma_mf_bt@2
$LN15@lzma_mf_bt@2:
  0004f	83 7c 24 50 04	 cmp	 DWORD PTR len_limit$33432[rsp], 4
  00054	72 15		 jb	 SHORT $LN12@lzma_mf_bt@2
  00056	33 c0		 xor	 eax, eax
  00058	83 f8 01	 cmp	 eax, 1
  0005b	74 22		 je	 SHORT $LN13@lzma_mf_bt@2
  0005d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00065	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00069	75 14		 jne	 SHORT $LN13@lzma_mf_bt@2
$LN12@lzma_mf_bt@2:
  0006b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00073	e8 00 00 00 00	 call	 move_pending
  00078	33 c0		 xor	 eax, eax
  0007a	e9 9d 04 00 00	 jmp	 $LN16@lzma_mf_bt@2
$LN13@lzma_mf_bt@2:
$LN14@lzma_mf_bt@2:
  0007f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00087	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0008a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00092	48 03 01	 add	 rax, QWORD PTR [rcx]
  00095	48 89 44 24 58	 mov	 QWORD PTR cur$33438[rsp], rax
  0009a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000a2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000ad	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000b0	89 44 24 60	 mov	 DWORD PTR pos$33439[rsp], eax
  000b4	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR matches_count$33440[rsp], 0

; 725  : 
; 726  :   {
; 727  : 	hash_4_calc();

  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  000c1	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  000d1	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d5	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000d9	33 c1		 xor	 eax, ecx
  000db	89 44 24 68	 mov	 DWORD PTR temp$33441[rsp], eax
  000df	8b 44 24 68	 mov	 eax, DWORD PTR temp$33441[rsp]
  000e3	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000e8	89 44 24 74	 mov	 DWORD PTR hash_2_value$33442[rsp], eax
  000ec	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  000f1	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000f5	c1 e1 08	 shl	 ecx, 8
  000f8	8b 44 24 68	 mov	 eax, DWORD PTR temp$33441[rsp]
  000fc	33 c1		 xor	 eax, ecx
  000fe	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00103	89 44 24 6c	 mov	 DWORD PTR hash_3_value$33443[rsp], eax
  00107	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  0010c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00110	c1 e0 08	 shl	 eax, 8
  00113	8b 54 24 68	 mov	 edx, DWORD PTR temp$33441[rsp]
  00117	33 d0		 xor	 edx, eax
  00119	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  0011e	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00122	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  00129	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0012c	c1 e1 05	 shl	 ecx, 5
  0012f	8b c2		 mov	 eax, edx
  00131	33 c1		 xor	 eax, ecx
  00133	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0013b	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  0013e	89 44 24 70	 mov	 DWORD PTR hash_value$33445[rsp], eax

; 728  : 
; 729  :   {
; 730  : 	uint32_t delta2 = pos - mf->hash[hash_2_value];

  00142	8b 4c 24 74	 mov	 ecx, DWORD PTR hash_2_value$33442[rsp]
  00146	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0014e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00152	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  00155	8b 44 24 60	 mov	 eax, DWORD PTR pos$33439[rsp]
  00159	2b c1		 sub	 eax, ecx
  0015b	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta2$33447[rsp], eax

; 731  : 	const uint32_t delta3
; 732  : 			= pos - mf->hash[FIX_3_HASH_SIZE + hash_3_value];

  00162	8b 44 24 6c	 mov	 eax, DWORD PTR hash_3_value$33443[rsp]
  00166	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0016b	8b c8		 mov	 ecx, eax
  0016d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00175	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00179	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0017c	8b 44 24 60	 mov	 eax, DWORD PTR pos$33439[rsp]
  00180	2b c1		 sub	 eax, ecx
  00182	89 44 24 7c	 mov	 DWORD PTR delta3$33448[rsp], eax

; 733  : 	const uint32_t cur_match = mf->hash[FIX_4_HASH_SIZE + hash_value];

  00186	8b 44 24 70	 mov	 eax, DWORD PTR hash_value$33445[rsp]
  0018a	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  0018f	8b c8		 mov	 ecx, eax
  00191	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00199	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0019d	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  001a0	89 44 24 78	 mov	 DWORD PTR cur_match$33449[rsp], eax

; 734  : 
; 735  : 	mf->hash[hash_2_value] = pos;

  001a4	8b 54 24 74	 mov	 edx, DWORD PTR hash_2_value$33442[rsp]
  001a8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001b0	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001b4	8b 44 24 60	 mov	 eax, DWORD PTR pos$33439[rsp]
  001b8	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 736  : 	mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  001bb	8b 44 24 6c	 mov	 eax, DWORD PTR hash_3_value$33443[rsp]
  001bf	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  001c4	8b d0		 mov	 edx, eax
  001c6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001ce	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001d2	8b 44 24 60	 mov	 eax, DWORD PTR pos$33439[rsp]
  001d6	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 737  : 	mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  001d9	8b 44 24 70	 mov	 eax, DWORD PTR hash_value$33445[rsp]
  001dd	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  001e2	8b d0		 mov	 edx, eax
  001e4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001ec	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001f0	8b 44 24 60	 mov	 eax, DWORD PTR pos$33439[rsp]
  001f4	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 738  : 
; 739  :   {
; 740  : 	uint32_t len_best = 1;

  001f7	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR len_best$33450[rsp], 1

; 741  : 
; 742  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00202	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0020a	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0020d	39 84 24 80 00
	00 00		 cmp	 DWORD PTR delta2$33447[rsp], eax
  00214	73 54		 jae	 SHORT $LN11@lzma_mf_bt@2
  00216	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR delta2$33447[rsp]
  0021d	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  00222	48 2b c1	 sub	 rax, rcx
  00225	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00228	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  0022d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00230	3b c8		 cmp	 ecx, eax
  00232	75 36		 jne	 SHORT $LN11@lzma_mf_bt@2

; 743  : 		len_best = 2;

  00234	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR len_best$33450[rsp], 2

; 744  : 		matches[0].len = 2;

  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00247	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 745  : 		matches[0].dist = delta2 - 1;

  0024d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR delta2$33447[rsp]
  00254	83 e9 01	 sub	 ecx, 1
  00257	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  0025f	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 746  : 		matches_count = 1;

  00262	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR matches_count$33440[rsp], 1
$LN11@lzma_mf_bt@2:

; 747  : 	}
; 748  : 
; 749  : 	if (delta2 != delta3 && delta3 < mf->cyclic_size
; 750  : 			&& *(cur - delta3) == *cur) {

  0026a	8b 44 24 7c	 mov	 eax, DWORD PTR delta3$33448[rsp]
  0026e	39 84 24 80 00
	00 00		 cmp	 DWORD PTR delta2$33447[rsp], eax
  00275	74 64		 je	 SHORT $LN10@lzma_mf_bt@2
  00277	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0027f	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00282	39 44 24 7c	 cmp	 DWORD PTR delta3$33448[rsp], eax
  00286	73 53		 jae	 SHORT $LN10@lzma_mf_bt@2
  00288	8b 4c 24 7c	 mov	 ecx, DWORD PTR delta3$33448[rsp]
  0028c	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  00291	48 2b c1	 sub	 rax, rcx
  00294	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00297	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  0029c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0029f	3b c8		 cmp	 ecx, eax
  002a1	75 38		 jne	 SHORT $LN10@lzma_mf_bt@2

; 751  : 		len_best = 3;

  002a3	c7 84 24 84 00
	00 00 03 00 00
	00		 mov	 DWORD PTR len_best$33450[rsp], 3

; 752  : 		matches[matches_count++].dist = delta3 - 1;

  002ae	8b 54 24 7c	 mov	 edx, DWORD PTR delta3$33448[rsp]
  002b2	83 ea 01	 sub	 edx, 1
  002b5	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33440[rsp]
  002b9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  002c1	89 54 c8 04	 mov	 DWORD PTR [rax+rcx*8+4], edx
  002c5	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33440[rsp]
  002c9	83 c0 01	 add	 eax, 1
  002cc	89 44 24 64	 mov	 DWORD PTR matches_count$33440[rsp], eax

; 753  : 		delta2 = delta3;

  002d0	8b 44 24 7c	 mov	 eax, DWORD PTR delta3$33448[rsp]
  002d4	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta2$33447[rsp], eax
$LN10@lzma_mf_bt@2:

; 754  : 	}
; 755  : 
; 756  : 	if (matches_count != 0) {

  002db	83 7c 24 64 00	 cmp	 DWORD PTR matches_count$33440[rsp], 0
  002e0	0f 84 7f 01 00
	00		 je	 $LN9@lzma_mf_bt@2

; 757  : 		len_best = lzma_memcmplen(
; 758  : 				cur, cur - delta2, len_best, len_limit);

  002e6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33450[rsp]
  002ed	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82143[rsp], eax
$LN24@lzma_mf_bt@2:
  002f4	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  002f8	39 84 24 94 00
	00 00		 cmp	 DWORD PTR $T82143[rsp], eax
  002ff	0f 83 bc 00 00
	00		 jae	 $LN23@lzma_mf_bt@2
  00305	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR $T82143[rsp]
  0030d	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR $T82143[rsp]
  00314	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta2$33447[rsp]
  0031b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$33438[rsp]
  00320	48 2b c8	 sub	 rcx, rax
  00323	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33438[rsp]
  00328	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0032c	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  00330	48 2b c1	 sub	 rax, rcx
  00333	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR x$82140[rsp], rax
  0033b	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR x$82140[rsp], 0
  00344	74 65		 je	 SHORT $LN22@lzma_mf_bt@2
  00346	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$82140[rsp]
  0034e	48 0f bc c0	 bsf	 rax, rax
  00352	89 84 24 90 00
	00 00		 mov	 DWORD PTR tmp$82142[rsp], eax
  00359	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tmp$82142[rsp]
  00360	c1 e9 03	 shr	 ecx, 3
  00363	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82143[rsp]
  0036a	03 c1		 add	 eax, ecx
  0036c	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82143[rsp], eax
  00373	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  00377	39 84 24 94 00
	00 00		 cmp	 DWORD PTR $T82143[rsp], eax
  0037e	73 10		 jae	 SHORT $LN27@lzma_mf_bt@2
  00380	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82143[rsp]
  00387	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv255[rsp], eax
  0038e	eb 0b		 jmp	 SHORT $LN28@lzma_mf_bt@2
$LN27@lzma_mf_bt@2:
  00390	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  00394	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv255[rsp], eax
$LN28@lzma_mf_bt@2:
  0039b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv255[rsp]
  003a2	89 84 24 84 00
	00 00		 mov	 DWORD PTR len_best$33450[rsp], eax
  003a9	eb 21		 jmp	 SHORT $LN25@lzma_mf_bt@2
$LN22@lzma_mf_bt@2:
  003ab	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82143[rsp]
  003b2	83 c0 08	 add	 eax, 8
  003b5	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82143[rsp], eax
  003bc	e9 33 ff ff ff	 jmp	 $LN24@lzma_mf_bt@2
$LN23@lzma_mf_bt@2:
  003c1	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  003c5	89 84 24 84 00
	00 00		 mov	 DWORD PTR len_best$33450[rsp], eax
$LN25@lzma_mf_bt@2:

; 759  : 
; 760  : 		matches[matches_count - 1].len = len_best;

  003cc	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33440[rsp]
  003d0	83 e8 01	 sub	 eax, 1
  003d3	8b d0		 mov	 edx, eax
  003d5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  003dd	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33450[rsp]
  003e4	89 04 d1	 mov	 DWORD PTR [rcx+rdx*8], eax

; 761  : 
; 762  : 		if (len_best == len_limit) {

  003e7	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33432[rsp]
  003eb	39 84 24 84 00
	00 00		 cmp	 DWORD PTR len_best$33450[rsp], eax
  003f2	75 71		 jne	 SHORT $LN8@lzma_mf_bt@2
$LN7@lzma_mf_bt@2:

; 763  : 			bt_skip();

  003f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  003fc	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  003ff	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00403	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0040b	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0040e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00412	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0041a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0041e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00423	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0042b	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0042e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00432	44 8b 4c 24 78	 mov	 r9d, DWORD PTR cur_match$33449[rsp]
  00437	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33438[rsp]
  0043c	8b 54 24 60	 mov	 edx, DWORD PTR pos$33439[rsp]
  00440	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33432[rsp]
  00444	e8 00 00 00 00	 call	 bt_skip_func
  00449	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00451	e8 00 00 00 00	 call	 move_pos
  00456	33 c0		 xor	 eax, eax
  00458	85 c0		 test	 eax, eax
  0045a	75 98		 jne	 SHORT $LN7@lzma_mf_bt@2

; 764  : 			return matches_count;

  0045c	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33440[rsp]
  00460	e9 b7 00 00 00	 jmp	 $LN16@lzma_mf_bt@2
$LN8@lzma_mf_bt@2:
$LN9@lzma_mf_bt@2:

; 765  : 		}
; 766  : 	}
; 767  : 
; 768  : 	if (len_best < 3)

  00465	83 bc 24 84 00
	00 00 03	 cmp	 DWORD PTR len_best$33450[rsp], 3
  0046d	73 0b		 jae	 SHORT $LN4@lzma_mf_bt@2

; 769  : 		len_best = 3;

  0046f	c7 84 24 84 00
	00 00 03 00 00
	00		 mov	 DWORD PTR len_best$33450[rsp], 3
$LN4@lzma_mf_bt@2:
$LN3@lzma_mf_bt@2:

; 770  : 
; 771  : 	bt_find(len_best);

  0047a	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33440[rsp]
  0047e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00486	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  0048a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33450[rsp]
  00491	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00495	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0049a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004a2	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  004a5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  004a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004b1	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  004b4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004c0	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  004c4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004d1	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  004d4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004d8	44 8b 4c 24 78	 mov	 r9d, DWORD PTR cur_match$33449[rsp]
  004dd	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33438[rsp]
  004e2	8b 54 24 60	 mov	 edx, DWORD PTR pos$33439[rsp]
  004e6	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33432[rsp]
  004ea	e8 00 00 00 00	 call	 bt_find_func
  004ef	48 2b 84 24 b8
	00 00 00	 sub	 rax, QWORD PTR matches$[rsp]
  004f7	48 c1 f8 03	 sar	 rax, 3
  004fb	89 44 24 64	 mov	 DWORD PTR matches_count$33440[rsp], eax
  004ff	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00507	e8 00 00 00 00	 call	 move_pos
  0050c	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33440[rsp]
  00510	eb 0a		 jmp	 SHORT $LN16@lzma_mf_bt@2
  00512	33 c0		 xor	 eax, eax
  00514	85 c0		 test	 eax, eax
  00516	0f 85 5e ff ff
	ff		 jne	 $LN3@lzma_mf_bt@2
$LN16@lzma_mf_bt@2:

; 772  :   }}}
; 773  :   }}}  //MiSt: header_find()
; 774  : }

  0051c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00523	c3		 ret	 0
lzma_mf_bt4_find ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_bt3_skip
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_bt3_skip DD imagerel $LN17
	DD	imagerel $LN17+478
	DD	imagerel $unwind$lzma_mf_bt3_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt3_skip DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt3_skip
_TEXT	SEGMENT
len_limit$33411 = 64
cur$33417 = 72
pos$33418 = 80
temp$33419 = 84
hash_value$33421 = 88
hash_2_value$33420 = 92
cur_match$33423 = 96
mf$ = 128
amount$ = 136
lzma_mf_bt3_skip PROC					; COMDAT

; 697  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN10@lzma_mf_bt@3:

; 698  : 	do {
; 699  : 		header_skip(true, 3);

  0000d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00015	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00020	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00023	2b c1		 sub	 eax, ecx
  00025	89 44 24 40	 mov	 DWORD PTR len_limit$33411[rsp], eax
  00029	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00031	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$33411[rsp]
  00035	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00038	77 11		 ja	 SHORT $LN7@lzma_mf_bt@3
  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00042	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00045	89 44 24 40	 mov	 DWORD PTR len_limit$33411[rsp], eax
  00049	eb 2e		 jmp	 SHORT $LN6@lzma_mf_bt@3
$LN7@lzma_mf_bt@3:
  0004b	83 7c 24 40 03	 cmp	 DWORD PTR len_limit$33411[rsp], 3
  00050	72 15		 jb	 SHORT $LN4@lzma_mf_bt@3
  00052	33 c0		 xor	 eax, eax
  00054	83 f8 01	 cmp	 eax, 1
  00057	74 20		 je	 SHORT $LN5@lzma_mf_bt@3
  00059	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00061	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00065	75 12		 jne	 SHORT $LN5@lzma_mf_bt@3
$LN4@lzma_mf_bt@3:
  00067	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0006f	e8 00 00 00 00	 call	 move_pending
  00074	e9 41 01 00 00	 jmp	 $LN9@lzma_mf_bt@3
$LN5@lzma_mf_bt@3:
$LN6@lzma_mf_bt@3:
  00079	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00081	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00084	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0008c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0008f	48 89 44 24 48	 mov	 QWORD PTR cur$33417[rsp], rax
  00094	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0009c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0009f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000a7	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000aa	89 44 24 50	 mov	 DWORD PTR pos$33418[rsp], eax

; 700  : 
; 701  : 	  {
; 702  : 		hash_3_calc();

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33417[rsp]
  000b3	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33417[rsp]
  000c3	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c7	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000cb	33 c1		 xor	 eax, ecx
  000cd	89 44 24 54	 mov	 DWORD PTR temp$33419[rsp], eax
  000d1	8b 44 24 54	 mov	 eax, DWORD PTR temp$33419[rsp]
  000d5	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000da	89 44 24 5c	 mov	 DWORD PTR hash_2_value$33420[rsp], eax
  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33417[rsp]
  000e3	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000e7	c1 e1 08	 shl	 ecx, 8
  000ea	8b 44 24 54	 mov	 eax, DWORD PTR temp$33419[rsp]
  000ee	33 c1		 xor	 eax, ecx
  000f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000f8	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  000fb	89 44 24 58	 mov	 DWORD PTR hash_value$33421[rsp], eax

; 703  : 
; 704  : 	  {
; 705  : 		const uint32_t cur_match
; 706  : 				= mf->hash[FIX_3_HASH_SIZE + hash_value];

  000ff	8b 44 24 58	 mov	 eax, DWORD PTR hash_value$33421[rsp]
  00103	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00108	8b c8		 mov	 ecx, eax
  0010a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00112	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00116	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00119	89 44 24 60	 mov	 DWORD PTR cur_match$33423[rsp], eax

; 707  : 
; 708  : 		mf->hash[hash_2_value] = pos;

  0011d	8b 54 24 5c	 mov	 edx, DWORD PTR hash_2_value$33420[rsp]
  00121	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00129	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0012d	8b 44 24 50	 mov	 eax, DWORD PTR pos$33418[rsp]
  00131	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 709  : 		mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  00134	8b 44 24 58	 mov	 eax, DWORD PTR hash_value$33421[rsp]
  00138	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0013d	8b d0		 mov	 edx, eax
  0013f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00147	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0014b	8b 44 24 50	 mov	 eax, DWORD PTR pos$33418[rsp]
  0014f	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_bt@3:

; 710  : 
; 711  : 		bt_skip();

  00152	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0015a	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0015d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00161	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00169	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0016c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00170	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00178	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0017c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00181	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00189	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0018c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00190	44 8b 4c 24 60	 mov	 r9d, DWORD PTR cur_match$33423[rsp]
  00195	4c 8b 44 24 48	 mov	 r8, QWORD PTR cur$33417[rsp]
  0019a	8b 54 24 50	 mov	 edx, DWORD PTR pos$33418[rsp]
  0019e	8b 4c 24 40	 mov	 ecx, DWORD PTR len_limit$33411[rsp]
  001a2	e8 00 00 00 00	 call	 bt_skip_func
  001a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001af	e8 00 00 00 00	 call	 move_pos
  001b4	33 c0		 xor	 eax, eax
  001b6	85 c0		 test	 eax, eax
  001b8	75 98		 jne	 SHORT $LN3@lzma_mf_bt@3
$LN9@lzma_mf_bt@3:

; 712  : 	  }}
; 713  : 
; 714  :     }}  //MiSt: header_skip()
; 715  : 	} while (--amount != 0);

  001ba	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR amount$[rsp]
  001c1	83 e8 01	 sub	 eax, 1
  001c4	89 84 24 88 00
	00 00		 mov	 DWORD PTR amount$[rsp], eax
  001cb	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR amount$[rsp], 0
  001d3	0f 85 34 fe ff
	ff		 jne	 $LN10@lzma_mf_bt@3

; 716  : }

  001d9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001dd	c3		 ret	 0
lzma_mf_bt3_skip ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_bt3_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_mf_bt3_find DD imagerel $LN26
	DD	imagerel $LN26+990
	DD	imagerel $unwind$lzma_mf_bt3_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt3_find DD 021101H
	DD	0150111H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt3_find
_TEXT	SEGMENT
len_limit$33377 = 80
cur$33383 = 88
pos$33384 = 96
matches_count$33385 = 100
temp$33386 = 104
hash_value$33388 = 108
hash_2_value$33387 = 112
cur_match$33391 = 116
delta2$33390 = 120
len_best$33392 = 124
x$82177 = 128
tmp$82179 = 136
$T82180 = 140
tv213 = 144
mf$ = 176
matches$ = 184
lzma_mf_bt3_find PROC					; COMDAT

; 659  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 660  : 	header_find(true, 3);

  00011	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00019	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00024	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00027	2b c1		 sub	 eax, ecx
  00029	89 44 24 50	 mov	 DWORD PTR len_limit$33377[rsp], eax
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00035	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  00039	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0003c	77 11		 ja	 SHORT $LN12@lzma_mf_bt@4
  0003e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00046	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00049	89 44 24 50	 mov	 DWORD PTR len_limit$33377[rsp], eax
  0004d	eb 30		 jmp	 SHORT $LN11@lzma_mf_bt@4
$LN12@lzma_mf_bt@4:
  0004f	83 7c 24 50 03	 cmp	 DWORD PTR len_limit$33377[rsp], 3
  00054	72 15		 jb	 SHORT $LN9@lzma_mf_bt@4
  00056	33 c0		 xor	 eax, eax
  00058	83 f8 01	 cmp	 eax, 1
  0005b	74 22		 je	 SHORT $LN10@lzma_mf_bt@4
  0005d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00065	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00069	75 14		 jne	 SHORT $LN10@lzma_mf_bt@4
$LN9@lzma_mf_bt@4:
  0006b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00073	e8 00 00 00 00	 call	 move_pending
  00078	33 c0		 xor	 eax, eax
  0007a	e9 57 03 00 00	 jmp	 $LN13@lzma_mf_bt@4
$LN10@lzma_mf_bt@4:
$LN11@lzma_mf_bt@4:
  0007f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00087	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0008a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00092	48 03 01	 add	 rax, QWORD PTR [rcx]
  00095	48 89 44 24 58	 mov	 QWORD PTR cur$33383[rsp], rax
  0009a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000a2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000ad	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000b0	89 44 24 60	 mov	 DWORD PTR pos$33384[rsp], eax
  000b4	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR matches_count$33385[rsp], 0

; 661  : 
; 662  :   {
; 663  : 	hash_3_calc();

  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  000c1	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  000d1	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d5	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000d9	33 c1		 xor	 eax, ecx
  000db	89 44 24 68	 mov	 DWORD PTR temp$33386[rsp], eax
  000df	8b 44 24 68	 mov	 eax, DWORD PTR temp$33386[rsp]
  000e3	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000e8	89 44 24 70	 mov	 DWORD PTR hash_2_value$33387[rsp], eax
  000ec	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  000f1	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000f5	c1 e1 08	 shl	 ecx, 8
  000f8	8b 44 24 68	 mov	 eax, DWORD PTR temp$33386[rsp]
  000fc	33 c1		 xor	 eax, ecx
  000fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00106	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  00109	89 44 24 6c	 mov	 DWORD PTR hash_value$33388[rsp], eax

; 664  : 
; 665  :   {
; 666  : 	const uint32_t delta2 = pos - mf->hash[hash_2_value];

  0010d	8b 4c 24 70	 mov	 ecx, DWORD PTR hash_2_value$33387[rsp]
  00111	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00119	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0011d	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  00120	8b 44 24 60	 mov	 eax, DWORD PTR pos$33384[rsp]
  00124	2b c1		 sub	 eax, ecx
  00126	89 44 24 78	 mov	 DWORD PTR delta2$33390[rsp], eax

; 667  : 	const uint32_t cur_match = mf->hash[FIX_3_HASH_SIZE + hash_value];

  0012a	8b 44 24 6c	 mov	 eax, DWORD PTR hash_value$33388[rsp]
  0012e	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00133	8b c8		 mov	 ecx, eax
  00135	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0013d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00141	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00144	89 44 24 74	 mov	 DWORD PTR cur_match$33391[rsp], eax

; 668  : 
; 669  : 	mf->hash[hash_2_value] = pos;

  00148	8b 54 24 70	 mov	 edx, DWORD PTR hash_2_value$33387[rsp]
  0014c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00154	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00158	8b 44 24 60	 mov	 eax, DWORD PTR pos$33384[rsp]
  0015c	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 670  : 	mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  0015f	8b 44 24 6c	 mov	 eax, DWORD PTR hash_value$33388[rsp]
  00163	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00168	8b d0		 mov	 edx, eax
  0016a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00172	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00176	8b 44 24 60	 mov	 eax, DWORD PTR pos$33384[rsp]
  0017a	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 671  : 
; 672  :   {
; 673  : 	uint32_t len_best = 2;

  0017d	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR len_best$33392[rsp], 2

; 674  : 
; 675  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00185	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0018d	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00190	39 44 24 78	 cmp	 DWORD PTR delta2$33390[rsp], eax
  00194	0f 83 9d 01 00
	00		 jae	 $LN8@lzma_mf_bt@4
  0019a	8b 4c 24 78	 mov	 ecx, DWORD PTR delta2$33390[rsp]
  0019e	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  001a3	48 2b c1	 sub	 rax, rcx
  001a6	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001a9	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  001ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b1	3b c8		 cmp	 ecx, eax
  001b3	0f 85 7e 01 00
	00		 jne	 $LN8@lzma_mf_bt@4

; 676  : 		len_best = lzma_memcmplen(
; 677  : 				cur, cur - delta2, len_best, len_limit);

  001b9	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33392[rsp]
  001bd	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82180[rsp], eax
$LN21@lzma_mf_bt@4:
  001c4	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  001c8	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR $T82180[rsp], eax
  001cf	0f 83 b6 00 00
	00		 jae	 $LN20@lzma_mf_bt@4
  001d5	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR $T82180[rsp]
  001dd	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR $T82180[rsp]
  001e4	8b 44 24 78	 mov	 eax, DWORD PTR delta2$33390[rsp]
  001e8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$33383[rsp]
  001ed	48 2b c8	 sub	 rcx, rax
  001f0	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33383[rsp]
  001f5	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001f9	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  001fd	48 2b c1	 sub	 rax, rcx
  00200	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR x$82177[rsp], rax
  00208	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR x$82177[rsp], 0
  00211	74 62		 je	 SHORT $LN19@lzma_mf_bt@4
  00213	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR x$82177[rsp]
  0021b	48 0f bc c0	 bsf	 rax, rax
  0021f	89 84 24 88 00
	00 00		 mov	 DWORD PTR tmp$82179[rsp], eax
  00226	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tmp$82179[rsp]
  0022d	c1 e9 03	 shr	 ecx, 3
  00230	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82180[rsp]
  00237	03 c1		 add	 eax, ecx
  00239	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82180[rsp], eax
  00240	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  00244	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR $T82180[rsp], eax
  0024b	73 10		 jae	 SHORT $LN24@lzma_mf_bt@4
  0024d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82180[rsp]
  00254	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  0025b	eb 0b		 jmp	 SHORT $LN25@lzma_mf_bt@4
$LN24@lzma_mf_bt@4:
  0025d	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  00261	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
$LN25@lzma_mf_bt@4:
  00268	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  0026f	89 44 24 7c	 mov	 DWORD PTR len_best$33392[rsp], eax
  00273	eb 1e		 jmp	 SHORT $LN22@lzma_mf_bt@4
$LN19@lzma_mf_bt@4:
  00275	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82180[rsp]
  0027c	83 c0 08	 add	 eax, 8
  0027f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82180[rsp], eax
  00286	e9 39 ff ff ff	 jmp	 $LN21@lzma_mf_bt@4
$LN20@lzma_mf_bt@4:
  0028b	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  0028f	89 44 24 7c	 mov	 DWORD PTR len_best$33392[rsp], eax
$LN22@lzma_mf_bt@4:

; 678  : 
; 679  : 		matches[0].len = len_best;

  00293	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  0029b	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33392[rsp]
  0029f	89 01		 mov	 DWORD PTR [rcx], eax

; 680  : 		matches[0].dist = delta2 - 1;

  002a1	8b 4c 24 78	 mov	 ecx, DWORD PTR delta2$33390[rsp]
  002a5	83 e9 01	 sub	 ecx, 1
  002a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  002b0	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 681  : 		matches_count = 1;

  002b3	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR matches_count$33385[rsp], 1

; 682  : 
; 683  : 		if (len_best == len_limit) {

  002bb	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33377[rsp]
  002bf	39 44 24 7c	 cmp	 DWORD PTR len_best$33392[rsp], eax
  002c3	75 72		 jne	 SHORT $LN7@lzma_mf_bt@4
$LN6@lzma_mf_bt@4:

; 684  : 			bt_skip();

  002c5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002cd	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  002d0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002dc	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  002df	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002eb	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  002ef	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002fc	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  002ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00303	44 8b 4c 24 74	 mov	 r9d, DWORD PTR cur_match$33391[rsp]
  00308	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33383[rsp]
  0030d	8b 54 24 60	 mov	 edx, DWORD PTR pos$33384[rsp]
  00311	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33377[rsp]
  00315	e8 00 00 00 00	 call	 bt_skip_func
  0031a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00322	e8 00 00 00 00	 call	 move_pos
  00327	33 c0		 xor	 eax, eax
  00329	85 c0		 test	 eax, eax
  0032b	75 98		 jne	 SHORT $LN6@lzma_mf_bt@4

; 685  : 			return 1; // matches_count

  0032d	b8 01 00 00 00	 mov	 eax, 1
  00332	e9 9f 00 00 00	 jmp	 $LN13@lzma_mf_bt@4
$LN7@lzma_mf_bt@4:
$LN8@lzma_mf_bt@4:
$LN3@lzma_mf_bt@4:

; 686  : 		}
; 687  : 	}
; 688  : 
; 689  : 	bt_find(len_best);

  00337	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33385[rsp]
  0033b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00343	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  00347	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33392[rsp]
  0034b	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0034f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00354	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0035c	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0035f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00363	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0036b	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0036e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00372	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0037a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0037e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00383	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0038b	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0038e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00392	44 8b 4c 24 74	 mov	 r9d, DWORD PTR cur_match$33391[rsp]
  00397	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33383[rsp]
  0039c	8b 54 24 60	 mov	 edx, DWORD PTR pos$33384[rsp]
  003a0	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33377[rsp]
  003a4	e8 00 00 00 00	 call	 bt_find_func
  003a9	48 2b 84 24 b8
	00 00 00	 sub	 rax, QWORD PTR matches$[rsp]
  003b1	48 c1 f8 03	 sar	 rax, 3
  003b5	89 44 24 64	 mov	 DWORD PTR matches_count$33385[rsp], eax
  003b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  003c1	e8 00 00 00 00	 call	 move_pos
  003c6	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33385[rsp]
  003ca	eb 0a		 jmp	 SHORT $LN13@lzma_mf_bt@4
  003cc	33 c0		 xor	 eax, eax
  003ce	85 c0		 test	 eax, eax
  003d0	0f 85 61 ff ff
	ff		 jne	 $LN3@lzma_mf_bt@4
$LN13@lzma_mf_bt@4:

; 690  :   }}}
; 691  :   }}}  //MiSt: header_find()
; 692  : }

  003d6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003dd	c3		 ret	 0
lzma_mf_bt3_find ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_bt2_skip
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_bt2_skip DD imagerel $LN17
	DD	imagerel $LN17+312
	DD	imagerel $unwind$lzma_mf_bt2_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt2_skip DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt2_skip
_TEXT	SEGMENT
len_limit$33358 = 64
cur$33364 = 72
pos$33365 = 80
hash_value$33366 = 84
cur_match$33368 = 88
mf$ = 112
amount$ = 120
lzma_mf_bt2_skip PROC					; COMDAT

; 636  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN10@lzma_mf_bt@5:

; 637  : 	do {
; 638  : 		header_skip(true, 2);

  0000d	48 8b 54 24 70	 mov	 rdx, QWORD PTR mf$[rsp]
  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00017	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0001a	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  0001d	2b c1		 sub	 eax, ecx
  0001f	89 44 24 40	 mov	 DWORD PTR len_limit$33358[rsp], eax
  00023	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  00028	8b 44 24 40	 mov	 eax, DWORD PTR len_limit$33358[rsp]
  0002c	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0002f	77 0e		 ja	 SHORT $LN7@lzma_mf_bt@5
  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00036	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00039	89 44 24 40	 mov	 DWORD PTR len_limit$33358[rsp], eax
  0003d	eb 28		 jmp	 SHORT $LN6@lzma_mf_bt@5
$LN7@lzma_mf_bt@5:
  0003f	83 7c 24 40 02	 cmp	 DWORD PTR len_limit$33358[rsp], 2
  00044	72 12		 jb	 SHORT $LN4@lzma_mf_bt@5
  00046	33 c0		 xor	 eax, eax
  00048	83 f8 01	 cmp	 eax, 1
  0004b	74 1a		 je	 SHORT $LN5@lzma_mf_bt@5
  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00052	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00056	75 0f		 jne	 SHORT $LN5@lzma_mf_bt@5
$LN4@lzma_mf_bt@5:
  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  0005d	e8 00 00 00 00	 call	 move_pending
  00062	e9 b6 00 00 00	 jmp	 $LN9@lzma_mf_bt@5
$LN5@lzma_mf_bt@5:
$LN6@lzma_mf_bt@5:
  00067	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  0006c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0006f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  00074	48 03 01	 add	 rax, QWORD PTR [rcx]
  00077	48 89 44 24 48	 mov	 QWORD PTR cur$33364[rsp], rax
  0007c	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  00081	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00084	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  00089	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  0008c	89 44 24 50	 mov	 DWORD PTR pos$33365[rsp], eax

; 639  : 
; 640  : 	  {
; 641  : 		hash_2_calc();

  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR cur$33364[rsp]
  00095	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00098	89 44 24 54	 mov	 DWORD PTR hash_value$33366[rsp], eax

; 642  : 
; 643  : 	  {
; 644  : 		const uint32_t cur_match = mf->hash[hash_value];

  0009c	8b 4c 24 54	 mov	 ecx, DWORD PTR hash_value$33366[rsp]
  000a0	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000a5	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000a9	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000ac	89 44 24 58	 mov	 DWORD PTR cur_match$33368[rsp], eax

; 645  : 		mf->hash[hash_value] = pos;

  000b0	8b 54 24 54	 mov	 edx, DWORD PTR hash_value$33366[rsp]
  000b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  000b9	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000bd	8b 44 24 50	 mov	 eax, DWORD PTR pos$33365[rsp]
  000c1	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_bt@5:

; 646  : 
; 647  : 		bt_skip();

  000c4	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000c9	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  000cc	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000d0	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000d5	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  000d8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000e1	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000e5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR mf$[rsp]
  000ef	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  000f2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f6	44 8b 4c 24 58	 mov	 r9d, DWORD PTR cur_match$33368[rsp]
  000fb	4c 8b 44 24 48	 mov	 r8, QWORD PTR cur$33364[rsp]
  00100	8b 54 24 50	 mov	 edx, DWORD PTR pos$33365[rsp]
  00104	8b 4c 24 40	 mov	 ecx, DWORD PTR len_limit$33358[rsp]
  00108	e8 00 00 00 00	 call	 bt_skip_func
  0010d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR mf$[rsp]
  00112	e8 00 00 00 00	 call	 move_pos
  00117	33 c0		 xor	 eax, eax
  00119	85 c0		 test	 eax, eax
  0011b	75 a7		 jne	 SHORT $LN3@lzma_mf_bt@5
$LN9@lzma_mf_bt@5:

; 648  : 	  }}
; 649  : 
; 650  :     }}  //MiSt: header_skip()
; 651  : 	} while (--amount != 0);

  0011d	8b 44 24 78	 mov	 eax, DWORD PTR amount$[rsp]
  00121	83 e8 01	 sub	 eax, 1
  00124	89 44 24 78	 mov	 DWORD PTR amount$[rsp], eax
  00128	83 7c 24 78 00	 cmp	 DWORD PTR amount$[rsp], 0
  0012d	0f 85 da fe ff
	ff		 jne	 $LN10@lzma_mf_bt@5

; 652  : }

  00133	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00137	c3		 ret	 0
lzma_mf_bt2_skip ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_bt2_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_bt2_find DD imagerel $LN14
	DD	imagerel $LN14+407
	DD	imagerel $unwind$lzma_mf_bt2_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_bt2_find DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_bt2_find
_TEXT	SEGMENT
len_limit$33333 = 80
cur$33339 = 88
pos$33340 = 96
matches_count$33341 = 100
hash_value$33342 = 104
cur_match$33344 = 108
mf$ = 128
matches$ = 136
lzma_mf_bt2_find PROC					; COMDAT

; 618  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 619  : 	header_find(true, 2);

  0000e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0001e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00021	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00024	2b c1		 sub	 eax, ecx
  00026	89 44 24 50	 mov	 DWORD PTR len_limit$33333[rsp], eax
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00032	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33333[rsp]
  00036	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00039	77 11		 ja	 SHORT $LN7@lzma_mf_bt@6
  0003b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00043	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00046	89 44 24 50	 mov	 DWORD PTR len_limit$33333[rsp], eax
  0004a	eb 30		 jmp	 SHORT $LN6@lzma_mf_bt@6
$LN7@lzma_mf_bt@6:
  0004c	83 7c 24 50 02	 cmp	 DWORD PTR len_limit$33333[rsp], 2
  00051	72 15		 jb	 SHORT $LN4@lzma_mf_bt@6
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 01	 cmp	 eax, 1
  00058	74 22		 je	 SHORT $LN5@lzma_mf_bt@6
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00062	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00066	75 14		 jne	 SHORT $LN5@lzma_mf_bt@6
$LN4@lzma_mf_bt@6:
  00068	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00070	e8 00 00 00 00	 call	 move_pending
  00075	33 c0		 xor	 eax, eax
  00077	e9 16 01 00 00	 jmp	 $LN8@lzma_mf_bt@6
$LN5@lzma_mf_bt@6:
$LN6@lzma_mf_bt@6:
  0007c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00084	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00087	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0008f	48 03 01	 add	 rax, QWORD PTR [rcx]
  00092	48 89 44 24 58	 mov	 QWORD PTR cur$33339[rsp], rax
  00097	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0009f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000aa	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000ad	89 44 24 60	 mov	 DWORD PTR pos$33340[rsp], eax
  000b1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR matches_count$33341[rsp], 0

; 620  : 
; 621  :   {
; 622  : 	hash_2_calc();

  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33339[rsp]
  000be	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000c1	89 44 24 68	 mov	 DWORD PTR hash_value$33342[rsp], eax

; 623  : 
; 624  :   {
; 625  : 	const uint32_t cur_match = mf->hash[hash_value];

  000c5	8b 4c 24 68	 mov	 ecx, DWORD PTR hash_value$33342[rsp]
  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000d1	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000d5	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000d8	89 44 24 6c	 mov	 DWORD PTR cur_match$33344[rsp], eax

; 626  : 	mf->hash[hash_value] = pos;

  000dc	8b 54 24 68	 mov	 edx, DWORD PTR hash_value$33342[rsp]
  000e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000e8	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000ec	8b 44 24 60	 mov	 eax, DWORD PTR pos$33340[rsp]
  000f0	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_bt@6:

; 627  : 
; 628  : 	bt_find(1);

  000f3	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33341[rsp]
  000f7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  000ff	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00103	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR [rsp+72], 1
  0010b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00110	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00118	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0011b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0011f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00127	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0012a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0012e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00136	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0013a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00147	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0014a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0014e	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR cur_match$33344[rsp]
  00153	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33339[rsp]
  00158	8b 54 24 60	 mov	 edx, DWORD PTR pos$33340[rsp]
  0015c	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33333[rsp]
  00160	e8 00 00 00 00	 call	 bt_find_func
  00165	48 2b 84 24 88
	00 00 00	 sub	 rax, QWORD PTR matches$[rsp]
  0016d	48 c1 f8 03	 sar	 rax, 3
  00171	89 44 24 64	 mov	 DWORD PTR matches_count$33341[rsp], eax
  00175	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0017d	e8 00 00 00 00	 call	 move_pos
  00182	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33341[rsp]
  00186	eb 0a		 jmp	 SHORT $LN8@lzma_mf_bt@6
  00188	33 c0		 xor	 eax, eax
  0018a	85 c0		 test	 eax, eax
  0018c	0f 85 61 ff ff
	ff		 jne	 $LN3@lzma_mf_bt@6
$LN8@lzma_mf_bt@6:

; 629  :   }}
; 630  :   }}}  //MiSt: header_find()
; 631  : }

  00192	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00196	c3		 ret	 0
lzma_mf_bt2_find ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_hc4_skip
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_hc4_skip DD imagerel $LN14
	DD	imagerel $LN14+391
	DD	imagerel $unwind$lzma_mf_hc4_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_hc4_skip DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_hc4_skip
_TEXT	SEGMENT
cur_match$33249 = 32
cur$33241 = 40
temp$33243 = 48
hash_3_value$33245 = 52
hash_value$33247 = 56
hash_2_value$33244 = 60
pos$33242 = 64
mf$ = 96
amount$ = 104
lzma_mf_hc4_skip PROC					; COMDAT

; 442  : {

$LN14:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN7@lzma_mf_hc:

; 443  : 	do {
; 444  : 		if (mf_avail(mf) < 4) {

  0000d	48 8b 54 24 60	 mov	 rdx, QWORD PTR mf$[rsp]
  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00017	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0001a	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  0001d	2b c1		 sub	 eax, ecx
  0001f	83 f8 04	 cmp	 eax, 4
  00022	73 0f		 jae	 SHORT $LN4@lzma_mf_hc

; 445  : 			move_pending(mf);

  00024	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00029	e8 00 00 00 00	 call	 move_pending

; 446  : 			continue;

  0002e	e9 39 01 00 00	 jmp	 $LN6@lzma_mf_hc
$LN4@lzma_mf_hc:

; 447  : 		}
; 448  : 
; 449  : 	  {
; 450  : 		const uint8_t *cur = mf_ptr(mf);

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00038	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00040	48 03 01	 add	 rax, QWORD PTR [rcx]
  00043	48 89 44 24 28	 mov	 QWORD PTR cur$33241[rsp], rax

; 451  : 		const uint32_t pos = mf->read_pos + mf->offset;

  00048	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0004d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00055	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  00058	89 44 24 40	 mov	 DWORD PTR pos$33242[rsp], eax

; 452  : 
; 453  : 		hash_4_calc();

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33241[rsp]
  00061	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33241[rsp]
  00071	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00075	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  00079	33 c1		 xor	 eax, ecx
  0007b	89 44 24 30	 mov	 DWORD PTR temp$33243[rsp], eax
  0007f	8b 44 24 30	 mov	 eax, DWORD PTR temp$33243[rsp]
  00083	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00088	89 44 24 3c	 mov	 DWORD PTR hash_2_value$33244[rsp], eax
  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33241[rsp]
  00091	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00095	c1 e1 08	 shl	 ecx, 8
  00098	8b 44 24 30	 mov	 eax, DWORD PTR temp$33243[rsp]
  0009c	33 c1		 xor	 eax, ecx
  0009e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a3	89 44 24 34	 mov	 DWORD PTR hash_3_value$33245[rsp], eax
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33241[rsp]
  000ac	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000b0	c1 e0 08	 shl	 eax, 8
  000b3	8b 54 24 30	 mov	 edx, DWORD PTR temp$33243[rsp]
  000b7	33 d0		 xor	 edx, eax
  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33241[rsp]
  000be	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  000c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  000c9	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  000cc	c1 e1 05	 shl	 ecx, 5
  000cf	8b c2		 mov	 eax, edx
  000d1	33 c1		 xor	 eax, ecx
  000d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  000d8	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  000db	89 44 24 38	 mov	 DWORD PTR hash_value$33247[rsp], eax

; 454  : 
; 455  : 		const uint32_t cur_match
; 456  : 				= mf->hash[FIX_4_HASH_SIZE + hash_value];

  000df	8b 44 24 38	 mov	 eax, DWORD PTR hash_value$33247[rsp]
  000e3	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  000e8	8b c8		 mov	 ecx, eax
  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  000ef	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000f3	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000f6	89 44 24 20	 mov	 DWORD PTR cur_match$33249[rsp], eax

; 457  : 
; 458  : 		mf->hash[hash_2_value] = pos;

  000fa	8b 54 24 3c	 mov	 edx, DWORD PTR hash_2_value$33244[rsp]
  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00103	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00107	8b 44 24 40	 mov	 eax, DWORD PTR pos$33242[rsp]
  0010b	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 459  : 		mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  0010e	8b 44 24 34	 mov	 eax, DWORD PTR hash_3_value$33245[rsp]
  00112	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00117	8b d0		 mov	 edx, eax
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0011e	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00122	8b 44 24 40	 mov	 eax, DWORD PTR pos$33242[rsp]
  00126	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 460  : 		mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  00129	8b 44 24 38	 mov	 eax, DWORD PTR hash_value$33247[rsp]
  0012d	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  00132	8b d0		 mov	 edx, eax
  00134	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00139	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0013d	8b 44 24 40	 mov	 eax, DWORD PTR pos$33242[rsp]
  00141	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_hc:

; 461  : 
; 462  : 		hc_skip();

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00149	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00151	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00155	8b 44 24 20	 mov	 eax, DWORD PTR cur_match$33249[rsp]
  00159	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  0015c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00161	e8 00 00 00 00	 call	 move_pos
  00166	33 c0		 xor	 eax, eax
  00168	85 c0		 test	 eax, eax
  0016a	75 d8		 jne	 SHORT $LN3@lzma_mf_hc
$LN6@lzma_mf_hc:

; 463  : 	  }
; 464  : 
; 465  : 	} while (--amount != 0);

  0016c	8b 44 24 68	 mov	 eax, DWORD PTR amount$[rsp]
  00170	83 e8 01	 sub	 eax, 1
  00173	89 44 24 68	 mov	 DWORD PTR amount$[rsp], eax
  00177	83 7c 24 68 00	 cmp	 DWORD PTR amount$[rsp], 0
  0017c	0f 85 8b fe ff
	ff		 jne	 $LN7@lzma_mf_hc

; 466  : }

  00182	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00186	c3		 ret	 0
lzma_mf_hc4_skip ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_hc4_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_mf_hc4_find DD imagerel $LN29
	DD	imagerel $LN29+1246
	DD	imagerel $unwind$lzma_mf_hc4_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_hc4_find DD 021101H
	DD	0150111H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_hc4_find
_TEXT	SEGMENT
len_limit$33200 = 80
cur$33206 = 88
pos$33207 = 96
matches_count$33208 = 100
cur_match$33217 = 104
delta3$33216 = 108
temp$33209 = 112
hash_3_value$33211 = 116
hash_value$33213 = 120
hash_2_value$33210 = 124
delta2$33215 = 128
len_best$33218 = 132
x$82235 = 136
tmp$82237 = 144
$T82241 = 148
tv246 = 152
mf$ = 176
matches$ = 184
lzma_mf_hc4_find PROC					; COMDAT

; 387  : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 388  : 	header_find(false, 4);

  00011	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00019	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00024	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00027	2b c1		 sub	 eax, ecx
  00029	89 44 24 50	 mov	 DWORD PTR len_limit$33200[rsp], eax
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00035	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  00039	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0003c	77 11		 ja	 SHORT $LN15@lzma_mf_hc@2
  0003e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00046	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00049	89 44 24 50	 mov	 DWORD PTR len_limit$33200[rsp], eax
  0004d	eb 21		 jmp	 SHORT $LN14@lzma_mf_hc@2
$LN15@lzma_mf_hc@2:
  0004f	83 7c 24 50 04	 cmp	 DWORD PTR len_limit$33200[rsp], 4
  00054	72 06		 jb	 SHORT $LN12@lzma_mf_hc@2
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	74 14		 je	 SHORT $LN13@lzma_mf_hc@2
$LN12@lzma_mf_hc@2:
  0005c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00064	e8 00 00 00 00	 call	 move_pending
  00069	33 c0		 xor	 eax, eax
  0006b	e9 66 04 00 00	 jmp	 $LN16@lzma_mf_hc@2
$LN13@lzma_mf_hc@2:
$LN14@lzma_mf_hc@2:
  00070	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00078	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0007b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00083	48 03 01	 add	 rax, QWORD PTR [rcx]
  00086	48 89 44 24 58	 mov	 QWORD PTR cur$33206[rsp], rax
  0008b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00093	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00096	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0009e	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000a1	89 44 24 60	 mov	 DWORD PTR pos$33207[rsp], eax
  000a5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR matches_count$33208[rsp], 0

; 389  : 
; 390  :   {
; 391  : 	hash_4_calc();

  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  000b2	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000bd	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  000c2	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c6	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000ca	33 c1		 xor	 eax, ecx
  000cc	89 44 24 70	 mov	 DWORD PTR temp$33209[rsp], eax
  000d0	8b 44 24 70	 mov	 eax, DWORD PTR temp$33209[rsp]
  000d4	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000d9	89 44 24 7c	 mov	 DWORD PTR hash_2_value$33210[rsp], eax
  000dd	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  000e2	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000e6	c1 e1 08	 shl	 ecx, 8
  000e9	8b 44 24 70	 mov	 eax, DWORD PTR temp$33209[rsp]
  000ed	33 c1		 xor	 eax, ecx
  000ef	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000f4	89 44 24 74	 mov	 DWORD PTR hash_3_value$33211[rsp], eax
  000f8	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  000fd	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00101	c1 e0 08	 shl	 eax, 8
  00104	8b 54 24 70	 mov	 edx, DWORD PTR temp$33209[rsp]
  00108	33 d0		 xor	 edx, eax
  0010a	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  0010f	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  0011a	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0011d	c1 e1 05	 shl	 ecx, 5
  00120	8b c2		 mov	 eax, edx
  00122	33 c1		 xor	 eax, ecx
  00124	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0012c	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  0012f	89 44 24 78	 mov	 DWORD PTR hash_value$33213[rsp], eax

; 392  : 
; 393  : 	uint32_t delta2 = pos - mf->hash[hash_2_value];

  00133	8b 4c 24 7c	 mov	 ecx, DWORD PTR hash_2_value$33210[rsp]
  00137	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0013f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00143	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  00146	8b 44 24 60	 mov	 eax, DWORD PTR pos$33207[rsp]
  0014a	2b c1		 sub	 eax, ecx
  0014c	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta2$33215[rsp], eax

; 394  : 	const uint32_t delta3
; 395  : 			= pos - mf->hash[FIX_3_HASH_SIZE + hash_3_value];

  00153	8b 44 24 74	 mov	 eax, DWORD PTR hash_3_value$33211[rsp]
  00157	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0015c	8b c8		 mov	 ecx, eax
  0015e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00166	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0016a	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0016d	8b 44 24 60	 mov	 eax, DWORD PTR pos$33207[rsp]
  00171	2b c1		 sub	 eax, ecx
  00173	89 44 24 6c	 mov	 DWORD PTR delta3$33216[rsp], eax

; 396  : 	const uint32_t cur_match = mf->hash[FIX_4_HASH_SIZE + hash_value];

  00177	8b 44 24 78	 mov	 eax, DWORD PTR hash_value$33213[rsp]
  0017b	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  00180	8b c8		 mov	 ecx, eax
  00182	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0018a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0018e	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00191	89 44 24 68	 mov	 DWORD PTR cur_match$33217[rsp], eax

; 397  : 
; 398  : 	mf->hash[hash_2_value ] = pos;

  00195	8b 54 24 7c	 mov	 edx, DWORD PTR hash_2_value$33210[rsp]
  00199	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001a1	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001a5	8b 44 24 60	 mov	 eax, DWORD PTR pos$33207[rsp]
  001a9	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 399  : 	mf->hash[FIX_3_HASH_SIZE + hash_3_value] = pos;

  001ac	8b 44 24 74	 mov	 eax, DWORD PTR hash_3_value$33211[rsp]
  001b0	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  001b5	8b d0		 mov	 edx, eax
  001b7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001bf	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001c3	8b 44 24 60	 mov	 eax, DWORD PTR pos$33207[rsp]
  001c7	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 400  : 	mf->hash[FIX_4_HASH_SIZE + hash_value] = pos;

  001ca	8b 44 24 78	 mov	 eax, DWORD PTR hash_value$33213[rsp]
  001ce	05 00 04 01 00	 add	 eax, 66560		; 00010400H
  001d3	8b d0		 mov	 edx, eax
  001d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001dd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001e1	8b 44 24 60	 mov	 eax, DWORD PTR pos$33207[rsp]
  001e5	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 401  : 
; 402  :   {
; 403  : 	uint32_t len_best = 1;

  001e8	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR len_best$33218[rsp], 1

; 404  : 
; 405  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  001f3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001fb	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  001fe	39 84 24 80 00
	00 00		 cmp	 DWORD PTR delta2$33215[rsp], eax
  00205	73 54		 jae	 SHORT $LN11@lzma_mf_hc@2
  00207	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR delta2$33215[rsp]
  0020e	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  00213	48 2b c1	 sub	 rax, rcx
  00216	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00219	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  0021e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00221	3b c8		 cmp	 ecx, eax
  00223	75 36		 jne	 SHORT $LN11@lzma_mf_hc@2

; 406  : 		len_best = 2;

  00225	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR len_best$33218[rsp], 2

; 407  : 		matches[0].len = 2;

  00230	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00238	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 408  : 		matches[0].dist = delta2 - 1;

  0023e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR delta2$33215[rsp]
  00245	83 e9 01	 sub	 ecx, 1
  00248	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00250	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 409  : 		matches_count = 1;

  00253	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR matches_count$33208[rsp], 1
$LN11@lzma_mf_hc@2:

; 410  : 	}
; 411  : 
; 412  : 	if (delta2 != delta3 && delta3 < mf->cyclic_size
; 413  : 			&& *(cur - delta3) == *cur) {

  0025b	8b 44 24 6c	 mov	 eax, DWORD PTR delta3$33216[rsp]
  0025f	39 84 24 80 00
	00 00		 cmp	 DWORD PTR delta2$33215[rsp], eax
  00266	74 64		 je	 SHORT $LN10@lzma_mf_hc@2
  00268	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00270	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00273	39 44 24 6c	 cmp	 DWORD PTR delta3$33216[rsp], eax
  00277	73 53		 jae	 SHORT $LN10@lzma_mf_hc@2
  00279	8b 4c 24 6c	 mov	 ecx, DWORD PTR delta3$33216[rsp]
  0027d	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  00282	48 2b c1	 sub	 rax, rcx
  00285	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00288	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33206[rsp]
  0028d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00290	3b c8		 cmp	 ecx, eax
  00292	75 38		 jne	 SHORT $LN10@lzma_mf_hc@2

; 414  : 		len_best = 3;

  00294	c7 84 24 84 00
	00 00 03 00 00
	00		 mov	 DWORD PTR len_best$33218[rsp], 3

; 415  : 		matches[matches_count++].dist = delta3 - 1;

  0029f	8b 54 24 6c	 mov	 edx, DWORD PTR delta3$33216[rsp]
  002a3	83 ea 01	 sub	 edx, 1
  002a6	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33208[rsp]
  002aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  002b2	89 54 c8 04	 mov	 DWORD PTR [rax+rcx*8+4], edx
  002b6	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33208[rsp]
  002ba	83 c0 01	 add	 eax, 1
  002bd	89 44 24 64	 mov	 DWORD PTR matches_count$33208[rsp], eax

; 416  : 		delta2 = delta3;

  002c1	8b 44 24 6c	 mov	 eax, DWORD PTR delta3$33216[rsp]
  002c5	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta2$33215[rsp], eax
$LN10@lzma_mf_hc@2:

; 417  : 	}
; 418  : 
; 419  : 	if (matches_count != 0) {

  002cc	83 7c 24 64 00	 cmp	 DWORD PTR matches_count$33208[rsp], 0
  002d1	0f 84 48 01 00
	00		 je	 $LN9@lzma_mf_hc@2

; 420  : 		len_best = lzma_memcmplen(cur - delta2, cur,
; 421  : 				len_best, len_limit);

  002d7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33218[rsp]
  002de	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82241[rsp], eax
$LN24@lzma_mf_hc@2:
  002e5	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  002e9	39 84 24 94 00
	00 00		 cmp	 DWORD PTR $T82241[rsp], eax
  002f0	0f 83 bc 00 00
	00		 jae	 $LN23@lzma_mf_hc@2
  002f6	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR $T82241[rsp]
  002fe	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta2$33215[rsp]
  00305	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$33206[rsp]
  0030a	48 2b d0	 sub	 rdx, rax
  0030d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82241[rsp]
  00314	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$33206[rsp]
  00319	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0031d	4a 8b 04 02	 mov	 rax, QWORD PTR [rdx+r8]
  00321	48 2b c1	 sub	 rax, rcx
  00324	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR x$82235[rsp], rax
  0032c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR x$82235[rsp], 0
  00335	74 65		 je	 SHORT $LN22@lzma_mf_hc@2
  00337	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$82235[rsp]
  0033f	48 0f bc c0	 bsf	 rax, rax
  00343	89 84 24 90 00
	00 00		 mov	 DWORD PTR tmp$82237[rsp], eax
  0034a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tmp$82237[rsp]
  00351	c1 e9 03	 shr	 ecx, 3
  00354	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82241[rsp]
  0035b	03 c1		 add	 eax, ecx
  0035d	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82241[rsp], eax
  00364	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  00368	39 84 24 94 00
	00 00		 cmp	 DWORD PTR $T82241[rsp], eax
  0036f	73 10		 jae	 SHORT $LN27@lzma_mf_hc@2
  00371	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82241[rsp]
  00378	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv246[rsp], eax
  0037f	eb 0b		 jmp	 SHORT $LN28@lzma_mf_hc@2
$LN27@lzma_mf_hc@2:
  00381	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  00385	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv246[rsp], eax
$LN28@lzma_mf_hc@2:
  0038c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv246[rsp]
  00393	89 84 24 84 00
	00 00		 mov	 DWORD PTR len_best$33218[rsp], eax
  0039a	eb 21		 jmp	 SHORT $LN25@lzma_mf_hc@2
$LN22@lzma_mf_hc@2:
  0039c	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR $T82241[rsp]
  003a3	83 c0 08	 add	 eax, 8
  003a6	89 84 24 94 00
	00 00		 mov	 DWORD PTR $T82241[rsp], eax
  003ad	e9 33 ff ff ff	 jmp	 $LN24@lzma_mf_hc@2
$LN23@lzma_mf_hc@2:
  003b2	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  003b6	89 84 24 84 00
	00 00		 mov	 DWORD PTR len_best$33218[rsp], eax
$LN25@lzma_mf_hc@2:

; 422  : 
; 423  : 		matches[matches_count - 1].len = len_best;

  003bd	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33208[rsp]
  003c1	83 e8 01	 sub	 eax, 1
  003c4	8b d0		 mov	 edx, eax
  003c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  003ce	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33218[rsp]
  003d5	89 04 d1	 mov	 DWORD PTR [rcx+rdx*8], eax

; 424  : 
; 425  : 		if (len_best == len_limit) {

  003d8	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33200[rsp]
  003dc	39 84 24 84 00
	00 00		 cmp	 DWORD PTR len_best$33218[rsp], eax
  003e3	75 3a		 jne	 SHORT $LN8@lzma_mf_hc@2
$LN7@lzma_mf_hc@2:

; 426  : 			hc_skip();

  003e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  003ed	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  003f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  003f8	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  003fc	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$33217[rsp]
  00400	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  00403	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0040b	e8 00 00 00 00	 call	 move_pos
  00410	33 c0		 xor	 eax, eax
  00412	85 c0		 test	 eax, eax
  00414	75 cf		 jne	 SHORT $LN7@lzma_mf_hc@2

; 427  : 			return matches_count;

  00416	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33208[rsp]
  0041a	e9 b7 00 00 00	 jmp	 $LN16@lzma_mf_hc@2
$LN8@lzma_mf_hc@2:
$LN9@lzma_mf_hc@2:

; 428  : 		}
; 429  : 	}
; 430  : 
; 431  : 	if (len_best < 3)

  0041f	83 bc 24 84 00
	00 00 03	 cmp	 DWORD PTR len_best$33218[rsp], 3
  00427	73 0b		 jae	 SHORT $LN4@lzma_mf_hc@2

; 432  : 		len_best = 3;

  00429	c7 84 24 84 00
	00 00 03 00 00
	00		 mov	 DWORD PTR len_best$33218[rsp], 3
$LN4@lzma_mf_hc@2:
$LN3@lzma_mf_hc@2:

; 433  : 
; 434  : 	hc_find(len_best);

  00434	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33208[rsp]
  00438	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  00440	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  00444	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_best$33218[rsp]
  0044b	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0044f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00454	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0045c	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0045f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00463	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0046b	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0046e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00472	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0047a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0047e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00483	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0048b	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0048e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00492	44 8b 4c 24 68	 mov	 r9d, DWORD PTR cur_match$33217[rsp]
  00497	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33206[rsp]
  0049c	8b 54 24 60	 mov	 edx, DWORD PTR pos$33207[rsp]
  004a0	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33200[rsp]
  004a4	e8 00 00 00 00	 call	 hc_find_func
  004a9	48 2b 84 24 b8
	00 00 00	 sub	 rax, QWORD PTR matches$[rsp]
  004b1	48 c1 f8 03	 sar	 rax, 3
  004b5	89 44 24 64	 mov	 DWORD PTR matches_count$33208[rsp], eax
  004b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  004c1	e8 00 00 00 00	 call	 move_pos
  004c6	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33208[rsp]
  004ca	eb 0a		 jmp	 SHORT $LN16@lzma_mf_hc@2
  004cc	33 c0		 xor	 eax, eax
  004ce	85 c0		 test	 eax, eax
  004d0	0f 85 5e ff ff
	ff		 jne	 $LN3@lzma_mf_hc@2
$LN16@lzma_mf_hc@2:

; 435  :   }}
; 436  :   }}}  //MiSt: header_find()
; 437  : }

  004d6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004dd	c3		 ret	 0
lzma_mf_hc4_find ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_hc3_skip
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_mf_hc3_skip DD imagerel $LN14
	DD	imagerel $LN14+311
	DD	imagerel $unwind$lzma_mf_hc3_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_hc3_skip DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_hc3_skip
_TEXT	SEGMENT
cur_match$33191 = 32
cur$33185 = 40
temp$33187 = 48
hash_value$33189 = 52
hash_2_value$33188 = 56
pos$33186 = 60
mf$ = 80
amount$ = 88
lzma_mf_hc3_skip PROC					; COMDAT

; 357  : {

$LN14:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN7@lzma_mf_hc@3:

; 358  : 	do {
; 359  : 		if (mf_avail(mf) < 3) {

  0000d	48 8b 54 24 50	 mov	 rdx, QWORD PTR mf$[rsp]
  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  00017	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0001a	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  0001d	2b c1		 sub	 eax, ecx
  0001f	83 f8 03	 cmp	 eax, 3
  00022	73 0f		 jae	 SHORT $LN4@lzma_mf_hc@3

; 360  : 			move_pending(mf);

  00024	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  00029	e8 00 00 00 00	 call	 move_pending

; 361  : 			continue;

  0002e	e9 e9 00 00 00	 jmp	 $LN6@lzma_mf_hc@3
$LN4@lzma_mf_hc@3:

; 362  : 		}
; 363  : 
; 364  : 	  {
; 365  : 		const uint8_t *cur = mf_ptr(mf);

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  00038	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  00040	48 03 01	 add	 rax, QWORD PTR [rcx]
  00043	48 89 44 24 28	 mov	 QWORD PTR cur$33185[rsp], rax

; 366  : 		const uint32_t pos = mf->read_pos + mf->offset;

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  0004d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  00055	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  00058	89 44 24 3c	 mov	 DWORD PTR pos$33186[rsp], eax

; 367  : 
; 368  : 		hash_3_calc();

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33185[rsp]
  00061	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33185[rsp]
  00071	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00075	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  00079	33 c1		 xor	 eax, ecx
  0007b	89 44 24 30	 mov	 DWORD PTR temp$33187[rsp], eax
  0007f	8b 44 24 30	 mov	 eax, DWORD PTR temp$33187[rsp]
  00083	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00088	89 44 24 38	 mov	 DWORD PTR hash_2_value$33188[rsp], eax
  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$33185[rsp]
  00091	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00095	c1 e1 08	 shl	 ecx, 8
  00098	8b 44 24 30	 mov	 eax, DWORD PTR temp$33187[rsp]
  0009c	33 c1		 xor	 eax, ecx
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  000a3	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  000a6	89 44 24 34	 mov	 DWORD PTR hash_value$33189[rsp], eax

; 369  : 
; 370  : 		const uint32_t cur_match
; 371  : 				= mf->hash[FIX_3_HASH_SIZE + hash_value];

  000aa	8b 44 24 34	 mov	 eax, DWORD PTR hash_value$33189[rsp]
  000ae	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  000b3	8b c8		 mov	 ecx, eax
  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  000ba	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000be	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000c1	89 44 24 20	 mov	 DWORD PTR cur_match$33191[rsp], eax

; 372  : 
; 373  : 		mf->hash[hash_2_value] = pos;

  000c5	8b 54 24 38	 mov	 edx, DWORD PTR hash_2_value$33188[rsp]
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  000ce	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d2	8b 44 24 3c	 mov	 eax, DWORD PTR pos$33186[rsp]
  000d6	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 374  : 		mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  000d9	8b 44 24 34	 mov	 eax, DWORD PTR hash_value$33189[rsp]
  000dd	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  000e9	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000ed	8b 44 24 3c	 mov	 eax, DWORD PTR pos$33186[rsp]
  000f1	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
$LN3@lzma_mf_hc@3:

; 375  : 
; 376  : 		hc_skip();

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  000f9	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  00101	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00105	8b 44 24 20	 mov	 eax, DWORD PTR cur_match$33191[rsp]
  00109	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mf$[rsp]
  00111	e8 00 00 00 00	 call	 move_pos
  00116	33 c0		 xor	 eax, eax
  00118	85 c0		 test	 eax, eax
  0011a	75 d8		 jne	 SHORT $LN3@lzma_mf_hc@3
$LN6@lzma_mf_hc@3:

; 377  : 	  }
; 378  : 
; 379  : 	} while (--amount != 0);

  0011c	8b 44 24 58	 mov	 eax, DWORD PTR amount$[rsp]
  00120	83 e8 01	 sub	 eax, 1
  00123	89 44 24 58	 mov	 DWORD PTR amount$[rsp], eax
  00127	83 7c 24 58 00	 cmp	 DWORD PTR amount$[rsp], 0
  0012c	0f 85 db fe ff
	ff		 jne	 $LN7@lzma_mf_hc@3

; 380  : }

  00132	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00136	c3		 ret	 0
lzma_mf_hc3_skip ENDP
_TEXT	ENDS
PUBLIC	lzma_mf_hc3_find
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_mf_hc3_find DD imagerel $LN26
	DD	imagerel $LN26+920
	DD	imagerel $unwind$lzma_mf_hc3_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mf_hc3_find DD 021101H
	DD	0150111H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder_mf.c
xdata	ENDS
;	COMDAT lzma_mf_hc3_find
_TEXT	SEGMENT
len_limit$33150 = 80
cur$33156 = 88
pos$33157 = 96
matches_count$33158 = 100
cur_match$33164 = 104
temp$33159 = 108
hash_value$33161 = 112
hash_2_value$33160 = 116
delta2$33163 = 120
len_best$33165 = 124
x$82272 = 128
tmp$82274 = 136
$T82278 = 140
tv204 = 144
mf$ = 176
matches$ = 184
lzma_mf_hc3_find PROC					; COMDAT

; 320  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 321  : 	header_find(false, 3);

  00011	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00019	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00024	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00027	2b c1		 sub	 eax, ecx
  00029	89 44 24 50	 mov	 DWORD PTR len_limit$33150[rsp], eax
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00035	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  00039	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0003c	77 11		 ja	 SHORT $LN12@lzma_mf_hc@4
  0003e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00046	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00049	89 44 24 50	 mov	 DWORD PTR len_limit$33150[rsp], eax
  0004d	eb 21		 jmp	 SHORT $LN11@lzma_mf_hc@4
$LN12@lzma_mf_hc@4:
  0004f	83 7c 24 50 03	 cmp	 DWORD PTR len_limit$33150[rsp], 3
  00054	72 06		 jb	 SHORT $LN9@lzma_mf_hc@4
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	74 14		 je	 SHORT $LN10@lzma_mf_hc@4
$LN9@lzma_mf_hc@4:
  0005c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00064	e8 00 00 00 00	 call	 move_pending
  00069	33 c0		 xor	 eax, eax
  0006b	e9 20 03 00 00	 jmp	 $LN13@lzma_mf_hc@4
$LN10@lzma_mf_hc@4:
$LN11@lzma_mf_hc@4:
  00070	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00078	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0007b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00083	48 03 01	 add	 rax, QWORD PTR [rcx]
  00086	48 89 44 24 58	 mov	 QWORD PTR cur$33156[rsp], rax
  0008b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00093	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00096	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0009e	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  000a1	89 44 24 60	 mov	 DWORD PTR pos$33157[rsp], eax
  000a5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR matches_count$33158[rsp], 0

; 322  : 
; 323  :   {
; 324  : 	hash_3_calc();

  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33156[rsp]
  000b2	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  000bd	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33156[rsp]
  000c2	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c6	42 8b 04 82	 mov	 eax, DWORD PTR [rdx+r8*4]
  000ca	33 c1		 xor	 eax, ecx
  000cc	89 44 24 6c	 mov	 DWORD PTR temp$33159[rsp], eax
  000d0	8b 44 24 6c	 mov	 eax, DWORD PTR temp$33159[rsp]
  000d4	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000d9	89 44 24 74	 mov	 DWORD PTR hash_2_value$33160[rsp], eax
  000dd	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33156[rsp]
  000e2	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000e6	c1 e1 08	 shl	 ecx, 8
  000e9	8b 44 24 6c	 mov	 eax, DWORD PTR temp$33159[rsp]
  000ed	33 c1		 xor	 eax, ecx
  000ef	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000f7	23 41 58	 and	 eax, DWORD PTR [rcx+88]
  000fa	89 44 24 70	 mov	 DWORD PTR hash_value$33161[rsp], eax

; 325  : 
; 326  : 	const uint32_t delta2 = pos - mf->hash[hash_2_value];

  000fe	8b 4c 24 74	 mov	 ecx, DWORD PTR hash_2_value$33160[rsp]
  00102	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0010a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0010e	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  00111	8b 44 24 60	 mov	 eax, DWORD PTR pos$33157[rsp]
  00115	2b c1		 sub	 eax, ecx
  00117	89 44 24 78	 mov	 DWORD PTR delta2$33163[rsp], eax

; 327  : 	const uint32_t cur_match = mf->hash[FIX_3_HASH_SIZE + hash_value];

  0011b	8b 44 24 70	 mov	 eax, DWORD PTR hash_value$33161[rsp]
  0011f	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00124	8b c8		 mov	 ecx, eax
  00126	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0012e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00132	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00135	89 44 24 68	 mov	 DWORD PTR cur_match$33164[rsp], eax

; 328  : 
; 329  : 	mf->hash[hash_2_value] = pos;

  00139	8b 54 24 74	 mov	 edx, DWORD PTR hash_2_value$33160[rsp]
  0013d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00145	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00149	8b 44 24 60	 mov	 eax, DWORD PTR pos$33157[rsp]
  0014d	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 330  : 	mf->hash[FIX_3_HASH_SIZE + hash_value] = pos;

  00150	8b 44 24 70	 mov	 eax, DWORD PTR hash_value$33161[rsp]
  00154	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00159	8b d0		 mov	 edx, eax
  0015b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00163	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00167	8b 44 24 60	 mov	 eax, DWORD PTR pos$33157[rsp]
  0016b	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 331  : 
; 332  :   {
; 333  : 	uint32_t len_best = 2;

  0016e	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR len_best$33165[rsp], 2

; 334  : 
; 335  : 	if (delta2 < mf->cyclic_size && *(cur - delta2) == *cur) {

  00176	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0017e	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00181	39 44 24 78	 cmp	 DWORD PTR delta2$33163[rsp], eax
  00185	0f 83 66 01 00
	00		 jae	 $LN8@lzma_mf_hc@4
  0018b	8b 4c 24 78	 mov	 ecx, DWORD PTR delta2$33163[rsp]
  0018f	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33156[rsp]
  00194	48 2b c1	 sub	 rax, rcx
  00197	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0019a	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$33156[rsp]
  0019f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a2	3b c8		 cmp	 ecx, eax
  001a4	0f 85 47 01 00
	00		 jne	 $LN8@lzma_mf_hc@4

; 336  : 		len_best = lzma_memcmplen(cur - delta2, cur,
; 337  : 				len_best, len_limit);

  001aa	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33165[rsp]
  001ae	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82278[rsp], eax
$LN21@lzma_mf_hc@4:
  001b5	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  001b9	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR $T82278[rsp], eax
  001c0	0f 83 b6 00 00
	00		 jae	 $LN20@lzma_mf_hc@4
  001c6	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR $T82278[rsp]
  001ce	8b 44 24 78	 mov	 eax, DWORD PTR delta2$33163[rsp]
  001d2	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$33156[rsp]
  001d7	48 2b d0	 sub	 rdx, rax
  001da	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82278[rsp]
  001e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$33156[rsp]
  001e6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001ea	4a 8b 04 02	 mov	 rax, QWORD PTR [rdx+r8]
  001ee	48 2b c1	 sub	 rax, rcx
  001f1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR x$82272[rsp], rax
  001f9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR x$82272[rsp], 0
  00202	74 62		 je	 SHORT $LN19@lzma_mf_hc@4
  00204	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR x$82272[rsp]
  0020c	48 0f bc c0	 bsf	 rax, rax
  00210	89 84 24 88 00
	00 00		 mov	 DWORD PTR tmp$82274[rsp], eax
  00217	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tmp$82274[rsp]
  0021e	c1 e9 03	 shr	 ecx, 3
  00221	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82278[rsp]
  00228	03 c1		 add	 eax, ecx
  0022a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82278[rsp], eax
  00231	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  00235	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR $T82278[rsp], eax
  0023c	73 10		 jae	 SHORT $LN24@lzma_mf_hc@4
  0023e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82278[rsp]
  00245	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv204[rsp], eax
  0024c	eb 0b		 jmp	 SHORT $LN25@lzma_mf_hc@4
$LN24@lzma_mf_hc@4:
  0024e	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  00252	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv204[rsp], eax
$LN25@lzma_mf_hc@4:
  00259	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv204[rsp]
  00260	89 44 24 7c	 mov	 DWORD PTR len_best$33165[rsp], eax
  00264	eb 1e		 jmp	 SHORT $LN22@lzma_mf_hc@4
$LN19@lzma_mf_hc@4:
  00266	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR $T82278[rsp]
  0026d	83 c0 08	 add	 eax, 8
  00270	89 84 24 8c 00
	00 00		 mov	 DWORD PTR $T82278[rsp], eax
  00277	e9 39 ff ff ff	 jmp	 $LN21@lzma_mf_hc@4
$LN20@lzma_mf_hc@4:
  0027c	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  00280	89 44 24 7c	 mov	 DWORD PTR len_best$33165[rsp], eax
$LN22@lzma_mf_hc@4:

; 338  : 
; 339  : 		matches[0].len = len_best;

  00284	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR matches$[rsp]
  0028c	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33165[rsp]
  00290	89 01		 mov	 DWORD PTR [rcx], eax

; 340  : 		matches[0].dist = delta2 - 1;

  00292	8b 4c 24 78	 mov	 ecx, DWORD PTR delta2$33163[rsp]
  00296	83 e9 01	 sub	 ecx, 1
  00299	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  002a1	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 341  : 		matches_count = 1;

  002a4	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR matches_count$33158[rsp], 1

; 342  : 
; 343  : 		if (len_best == len_limit) {

  002ac	8b 44 24 50	 mov	 eax, DWORD PTR len_limit$33150[rsp]
  002b0	39 44 24 7c	 cmp	 DWORD PTR len_best$33165[rsp], eax
  002b4	75 3b		 jne	 SHORT $LN7@lzma_mf_hc@4
$LN6@lzma_mf_hc@4:

; 344  : 			hc_skip();

  002b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002be	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  002c1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  002c9	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002cd	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$33164[rsp]
  002d1	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  002d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  002dc	e8 00 00 00 00	 call	 move_pos
  002e1	33 c0		 xor	 eax, eax
  002e3	85 c0		 test	 eax, eax
  002e5	75 cf		 jne	 SHORT $LN6@lzma_mf_hc@4

; 345  : 			return 1; // matches_count

  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	e9 9f 00 00 00	 jmp	 $LN13@lzma_mf_hc@4
$LN7@lzma_mf_hc@4:
$LN8@lzma_mf_hc@4:
$LN3@lzma_mf_hc@4:

; 346  : 		}
; 347  : 	}
; 348  : 
; 349  : 	hc_find(len_best);

  002f1	8b 4c 24 64	 mov	 ecx, DWORD PTR matches_count$33158[rsp]
  002f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR matches$[rsp]
  002fd	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  00301	8b 44 24 7c	 mov	 eax, DWORD PTR len_best$33165[rsp]
  00305	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00309	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0030e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00316	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00319	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0031d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00325	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00328	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0032c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00334	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00338	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0033d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00345	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  00348	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0034c	44 8b 4c 24 68	 mov	 r9d, DWORD PTR cur_match$33164[rsp]
  00351	4c 8b 44 24 58	 mov	 r8, QWORD PTR cur$33156[rsp]
  00356	8b 54 24 60	 mov	 edx, DWORD PTR pos$33157[rsp]
  0035a	8b 4c 24 50	 mov	 ecx, DWORD PTR len_limit$33150[rsp]
  0035e	e8 00 00 00 00	 call	 hc_find_func
  00363	48 2b 84 24 b8
	00 00 00	 sub	 rax, QWORD PTR matches$[rsp]
  0036b	48 c1 f8 03	 sar	 rax, 3
  0036f	89 44 24 64	 mov	 DWORD PTR matches_count$33158[rsp], eax
  00373	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0037b	e8 00 00 00 00	 call	 move_pos
  00380	8b 44 24 64	 mov	 eax, DWORD PTR matches_count$33158[rsp]
  00384	eb 0a		 jmp	 SHORT $LN13@lzma_mf_hc@4
  00386	33 c0		 xor	 eax, eax
  00388	85 c0		 test	 eax, eax
  0038a	0f 85 61 ff ff
	ff		 jne	 $LN3@lzma_mf_hc@4
$LN13@lzma_mf_hc@4:

; 350  :   }}
; 351  :   }}}  //MiSt: header_find()
; 352  : }

  00390	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00397	c3		 ret	 0
lzma_mf_hc3_find ENDP
END
