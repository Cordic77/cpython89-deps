; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_decoder.c
pdata	SEGMENT
$pdata$stream_decoder_memconfig DD imagerel stream_decoder_memconfig
	DD	imagerel stream_decoder_memconfig+127
	DD	imagerel $unwind$stream_decoder_memconfig
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_decoder_memconfig DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_decoder_memconfig
_TEXT	SEGMENT
coder$ = 0
coder_ptr$ = 32
memusage$ = 40
old_memlimit$ = 48
new_memlimit$ = 56
stream_decoder_memconfig PROC				; COMDAT

; 412  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 413  : 	lzma_stream_coder *coder = coder_ptr;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR coder$[rsp], rax

; 414  : 
; 415  : 	*memusage = coder->memusage;

  00021	48 8b 4c 24 28	 mov	 rcx, QWORD PTR memusage$[rsp]
  00026	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  0002a	48 8b 80 68 01
	00 00		 mov	 rax, QWORD PTR [rax+360]
  00031	48 89 01	 mov	 QWORD PTR [rcx], rax

; 416  : 	*old_memlimit = coder->memlimit;

  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_memlimit$[rsp]
  00039	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  0003d	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  00044	48 89 01	 mov	 QWORD PTR [rcx], rax

; 417  : 
; 418  : 	if (new_memlimit != 0) {

  00047	48 83 7c 24 38
	00		 cmp	 QWORD PTR new_memlimit$[rsp], 0
  0004d	74 29		 je	 SHORT $LN2@stream_dec

; 419  : 		if (new_memlimit < coder->memusage)

  0004f	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  00053	48 8b 80 68 01
	00 00		 mov	 rax, QWORD PTR [rax+360]
  0005a	48 39 44 24 38	 cmp	 QWORD PTR new_memlimit$[rsp], rax
  0005f	73 07		 jae	 SHORT $LN1@stream_dec

; 420  : 			return LZMA_MEMLIMIT_ERROR;

  00061	b8 06 00 00 00	 mov	 eax, 6
  00066	eb 12		 jmp	 SHORT $LN3@stream_dec
$LN1@stream_dec:

; 421  : 
; 422  : 		coder->memlimit = new_memlimit;

  00068	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  0006c	48 8b 44 24 38	 mov	 rax, QWORD PTR new_memlimit$[rsp]
  00071	48 89 81 60 01
	00 00		 mov	 QWORD PTR [rcx+352], rax
$LN2@stream_dec:

; 423  : 	}
; 424  : 
; 425  : 	return LZMA_OK;

  00078	33 c0		 xor	 eax, eax
$LN3@stream_dec:

; 426  : }

  0007a	48 83 c4 18	 add	 rsp, 24
  0007e	c3		 ret	 0
stream_decoder_memconfig ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_decoder_get_check DD imagerel stream_decoder_get_check
	DD	imagerel stream_decoder_get_check+33
	DD	imagerel $unwind$stream_decoder_get_check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_decoder_get_check DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_decoder_get_check
_TEXT	SEGMENT
coder$ = 0
coder_ptr$ = 32
stream_decoder_get_check PROC				; COMDAT

; 403  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 404  : 	const lzma_stream_coder *coder = coder_ptr;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR coder$[rsp], rax

; 405  : 	return coder->stream_flags.check;

  00012	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  00016	8b 80 30 01 00
	00		 mov	 eax, DWORD PTR [rax+304]

; 406  : }

  0001c	48 83 c4 18	 add	 rsp, 24
  00020	c3		 ret	 0
stream_decoder_get_check ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_decoder_reset DD imagerel stream_decoder_reset
	DD	imagerel stream_decoder_reset+107
	DD	imagerel $unwind$stream_decoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_decoder_reset DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_decoder_reset
_TEXT	SEGMENT
coder$ = 48
allocator$ = 56
stream_decoder_reset PROC				; COMDAT

; 88   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 89   : 	// Initialize the Index hash used to verify the Index.
; 90   : 	coder->index_hash = lzma_index_hash_init(coder->index_hash, allocator);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00018	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  0001f	e8 00 00 00 00	 call	 lzma_index_hash_init
  00024	4c 8b d8	 mov	 r11, rax
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0002c	4c 89 98 58 01
	00 00		 mov	 QWORD PTR [rax+344], r11

; 91   : 	if (coder->index_hash == NULL)

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00038	48 83 b8 58 01
	00 00 00	 cmp	 QWORD PTR [rax+344], 0
  00040	75 07		 jne	 SHORT $LN1@stream_dec@2

; 92   : 		return LZMA_MEM_ERROR;

  00042	b8 05 00 00 00	 mov	 eax, 5
  00047	eb 1d		 jmp	 SHORT $LN2@stream_dec@2
$LN1@stream_dec@2:

; 93   : 
; 94   : 	// Reset the rest of the variables.
; 95   : 	coder->sequence = SEQ_STREAM_HEADER;

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 96   : 	coder->pos = 0;

  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00059	48 c7 80 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+376], 0

; 97   : 
; 98   : 	return LZMA_OK;

  00064	33 c0		 xor	 eax, eax
$LN2@stream_dec@2:

; 99   : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
stream_decoder_reset ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_decoder_end DD imagerel stream_decoder_end
	DD	imagerel stream_decoder_end+85
	DD	imagerel $unwind$stream_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
stream_decoder_end PROC					; COMDAT

; 392  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 393  : 	lzma_stream_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 394  : 	lzma_next_end(&coder->block_decoder, allocator);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 83 c1 08	 add	 rcx, 8
  00021	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00026	e8 00 00 00 00	 call	 lzma_next_end

; 395  : 	lzma_index_hash_end(coder->index_hash, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  0003c	e8 00 00 00 00	 call	 lzma_index_hash_end

; 396  : 	lzma_free(coder, allocator);

  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0004b	e8 00 00 00 00	 call	 lzma_free

; 397  : 	return;
; 398  : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
stream_decoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_decode DD imagerel stream_decode
	DD	imagerel stream_decode+2084
	DD	imagerel $unwind$stream_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_decode DD 021b01H
	DD	027011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_decode
_TEXT	SEGMENT
coder$ = 80
ret$32885 = 88
filters$32896 = 96
ret_$32900 = 176
memusage$32902 = 184
ret$32903 = 192
i$32908 = 200
ret$32915 = 208
ret_$32920 = 212
ret$32924 = 216
ret$32929 = 220
footer_flags$32928 = 224
ret_$32935 = 280
ret_$32950 = 284
tv65 = 288
tv87 = 292
tv247 = 296
tv266 = 300
coder_ptr$ = 320
allocator$ = 328
in$ = 336
in_pos$ = 344
in_size$ = 352
out$ = 360
out_pos$ = 368
out_size$ = 376
action$ = 384
stream_decode PROC					; COMDAT

; 107  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 108  : 	lzma_stream_coder *coder = coder_ptr;

  0001b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax
$LN57@stream_dec@3:

; 109  : 
; 110  : 	// When decoding the actual Block, it may be able to produce more
; 111  : 	// output even if we don't give it any new input.
; 112  : 	while (true)

  00028	33 c0		 xor	 eax, eax
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	0f 84 d0 07 00
	00		 je	 $LN56@stream_dec@3

; 113  : 	switch (coder->sequence) {

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00038	8b 00		 mov	 eax, DWORD PTR [rax]
  0003a	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00041	83 bc 24 20 01
	00 00 05	 cmp	 DWORD PTR tv65[rsp], 5
  00049	0f 87 a8 07 00
	00		 ja	 $LN1@stream_dec@3
  0004f	48 63 84 24 20
	01 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stream_dec@3[rcx+rax*4]
  00065	48 03 c1	 add	 rax, rcx
  00068	ff e0		 jmp	 rax
$LN53@stream_dec@3:

; 114  : 	case SEQ_STREAM_HEADER: {
; 115  : 		// Copy the Stream Header to the internal buffer.
; 116  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 117  : 				LZMA_STREAM_HEADER_SIZE);

  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0006f	48 05 78 01 00
	00		 add	 rax, 376		; 00000178H
  00075	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  0007a	49 81 c1 80 01
	00 00		 add	 r9, 384			; 00000180H
  00081	48 c7 44 24 28
	0c 00 00 00	 mov	 QWORD PTR [rsp+40], 12
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  00097	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  0009f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  000a7	e8 00 00 00 00	 call	 lzma_bufcpy

; 118  : 
; 119  : 		// Return if we didn't get the whole Stream Header yet.
; 120  : 		if (coder->pos < LZMA_STREAM_HEADER_SIZE)

  000ac	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  000b1	49 83 bb 78 01
	00 00 0c	 cmp	 QWORD PTR [r11+376], 12
  000b9	73 07		 jae	 SHORT $LN52@stream_dec@3

; 121  : 			return LZMA_OK;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 41 07 00 00	 jmp	 $LN58@stream_dec@3
$LN52@stream_dec@3:

; 122  : 
; 123  : 		coder->pos = 0;

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000c7	48 c7 80 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+376], 0

; 124  : 
; 125  : 		// Decode the Stream Header.
; 126  : 	  {
; 127  : 		const lzma_ret ret = lzma_stream_header_decode(
; 128  : 				&coder->stream_flags, coder->buffer);

  000d2	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  000d7	48 81 c2 80 01
	00 00		 add	 rdx, 384		; 00000180H
  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000e3	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  000ea	e8 00 00 00 00	 call	 lzma_stream_header_decode
  000ef	89 44 24 58	 mov	 DWORD PTR ret$32885[rsp], eax

; 129  : 		if (ret != LZMA_OK)

  000f3	83 7c 24 58 00	 cmp	 DWORD PTR ret$32885[rsp], 0
  000f8	74 3b		 je	 SHORT $LN51@stream_dec@3

; 130  : 			return ret == LZMA_FORMAT_ERROR && !coder->first_stream
; 131  : 					? LZMA_DATA_ERROR : ret;

  000fa	83 7c 24 58 07	 cmp	 DWORD PTR ret$32885[rsp], 7
  000ff	75 1d		 jne	 SHORT $LN60@stream_dec@3
  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00106	0f b6 80 75 01
	00 00		 movzx	 eax, BYTE PTR [rax+373]
  0010d	85 c0		 test	 eax, eax
  0010f	75 0d		 jne	 SHORT $LN60@stream_dec@3
  00111	c7 84 24 24 01
	00 00 09 00 00
	00		 mov	 DWORD PTR tv87[rsp], 9
  0011c	eb 0b		 jmp	 SHORT $LN61@stream_dec@3
$LN60@stream_dec@3:
  0011e	8b 44 24 58	 mov	 eax, DWORD PTR ret$32885[rsp]
  00122	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv87[rsp], eax
$LN61@stream_dec@3:
  00129	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv87[rsp]
  00130	e9 ce 06 00 00	 jmp	 $LN58@stream_dec@3
$LN51@stream_dec@3:

; 132  : 
; 133  : 		// If we are decoding concatenated Streams, and the later
; 134  : 		// Streams have invalid Header Magic Bytes, we give
; 135  : 		// LZMA_DATA_ERROR instead of LZMA_FORMAT_ERROR.
; 136  : 		coder->first_stream = false;

  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0013a	c6 80 75 01 00
	00 00		 mov	 BYTE PTR [rax+373], 0

; 137  : 
; 138  : 		// Copy the type of the Check so that Block Header and Block
; 139  : 		// decoders see it.
; 140  : 		coder->block_options.check = coder->stream_flags.check;

  00141	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0014b	8b 80 30 01 00
	00		 mov	 eax, DWORD PTR [rax+304]
  00151	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 141  : 
; 142  : 		// Even if we return LZMA_*_CHECK below, we want
; 143  : 		// to continue from Block Header decoding.
; 144  : 		coder->sequence = SEQ_BLOCK_HEADER;

  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00159	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 145  : 
; 146  : 		// Detect if there's no integrity check or if it is
; 147  : 		// unsupported if those were requested by the application.
; 148  : 		if (coder->tell_no_check && coder->stream_flags.check
; 149  : 				== LZMA_CHECK_NONE)

  0015f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00164	0f b6 80 70 01
	00 00		 movzx	 eax, BYTE PTR [rax+368]
  0016b	85 c0		 test	 eax, eax
  0016d	74 18		 je	 SHORT $LN50@stream_dec@3
  0016f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00174	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [rax+304], 0
  0017b	75 0a		 jne	 SHORT $LN50@stream_dec@3

; 150  : 			return LZMA_NO_CHECK;

  0017d	b8 02 00 00 00	 mov	 eax, 2
  00182	e9 7c 06 00 00	 jmp	 $LN58@stream_dec@3
$LN50@stream_dec@3:

; 151  : 
; 152  : 		if (coder->tell_unsupported_check
; 153  : 				&& !lzma_check_is_supported(
; 154  : 					coder->stream_flags.check))

  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0018c	0f b6 80 71 01
	00 00		 movzx	 eax, BYTE PTR [rax+369]
  00193	85 c0		 test	 eax, eax
  00195	74 21		 je	 SHORT $LN49@stream_dec@3
  00197	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0019c	8b 88 30 01 00
	00		 mov	 ecx, DWORD PTR [rax+304]
  001a2	e8 00 00 00 00	 call	 lzma_check_is_supported
  001a7	0f b6 c0	 movzx	 eax, al
  001aa	85 c0		 test	 eax, eax
  001ac	75 0a		 jne	 SHORT $LN49@stream_dec@3

; 155  : 			return LZMA_UNSUPPORTED_CHECK;

  001ae	b8 03 00 00 00	 mov	 eax, 3
  001b3	e9 4b 06 00 00	 jmp	 $LN58@stream_dec@3
$LN49@stream_dec@3:

; 156  : 
; 157  : 		if (coder->tell_any_check)

  001b8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001bd	0f b6 80 72 01
	00 00		 movzx	 eax, BYTE PTR [rax+370]
  001c4	85 c0		 test	 eax, eax
  001c6	74 0a		 je	 SHORT $LN48@stream_dec@3

; 158  : 			return LZMA_GET_CHECK;

  001c8	b8 04 00 00 00	 mov	 eax, 4
  001cd	e9 31 06 00 00	 jmp	 $LN58@stream_dec@3
$LN48@stream_dec@3:
$LN47@stream_dec@3:

; 159  : 	  }
; 160  : 	}
; 161  : 
; 162  : 	// Fall through
; 163  : 
; 164  : 	case SEQ_BLOCK_HEADER: {
; 165  : 		if (*in_pos >= in_size)

  001d2	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  001da	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001e2	48 39 01	 cmp	 QWORD PTR [rcx], rax
  001e5	72 07		 jb	 SHORT $LN46@stream_dec@3

; 166  : 			return LZMA_OK;

  001e7	33 c0		 xor	 eax, eax
  001e9	e9 15 06 00 00	 jmp	 $LN58@stream_dec@3
$LN46@stream_dec@3:

; 167  : 
; 168  : 		if (coder->pos == 0) {

  001ee	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001f3	48 83 b8 78 01
	00 00 00	 cmp	 QWORD PTR [rax+376], 0
  001fb	75 51		 jne	 SHORT $LN45@stream_dec@3

; 169  : 			// Detect if it's Index.
; 170  : 			if (in[*in_pos] == 0x00) {

  001fd	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00205	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00208	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00210	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00214	85 c0		 test	 eax, eax
  00216	75 10		 jne	 SHORT $LN44@stream_dec@3

; 171  : 				coder->sequence = SEQ_INDEX;

  00218	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0021d	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 172  : 				break;

  00223	e9 d6 05 00 00	 jmp	 $LN54@stream_dec@3
$LN44@stream_dec@3:

; 173  : 			}
; 174  : 
; 175  : 			// Calculate the size of the Block Header. Note that
; 176  : 			// Block Header decoder wants to see this byte too
; 177  : 			// so don't advance *in_pos.
; 178  : 			coder->block_options.header_size
; 179  : 					= lzma_block_header_size_decode(
; 180  : 						in[*in_pos]);

  00228	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00230	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00233	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0023b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0023f	8d 0c 8d 04 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+4]
  00246	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0024b	89 48 54	 mov	 DWORD PTR [rax+84], ecx
$LN45@stream_dec@3:

; 181  : 		}
; 182  : 
; 183  : 		// Copy the Block Header to the internal buffer.
; 184  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 185  : 				coder->block_options.header_size);

  0024e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00253	8b 48 54	 mov	 ecx, DWORD PTR [rax+84]
  00256	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0025b	48 05 78 01 00
	00		 add	 rax, 376		; 00000178H
  00261	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  00266	49 81 c1 80 01
	00 00		 add	 r9, 384			; 00000180H
  0026d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00272	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00277	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  0027f	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00287	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  0028f	e8 00 00 00 00	 call	 lzma_bufcpy

; 186  : 
; 187  : 		// Return if we didn't get the whole Block Header yet.
; 188  : 		if (coder->pos < coder->block_options.header_size)

  00294	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  00299	41 8b 4b 54	 mov	 ecx, DWORD PTR [r11+84]
  0029d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002a2	48 39 88 78 01
	00 00		 cmp	 QWORD PTR [rax+376], rcx
  002a9	73 07		 jae	 SHORT $LN43@stream_dec@3

; 189  : 			return LZMA_OK;

  002ab	33 c0		 xor	 eax, eax
  002ad	e9 51 05 00 00	 jmp	 $LN58@stream_dec@3
$LN43@stream_dec@3:

; 190  : 
; 191  : 		coder->pos = 0;

  002b2	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002b7	48 c7 80 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+376], 0

; 192  : 
; 193  : 		// Version 1 is needed to support the .ignore_check option.
; 194  : 		coder->block_options.version = 1;

  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002c7	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1

; 195  : 
; 196  : 		// Set up a buffer to hold the filter chain. Block Header
; 197  : 		// decoder will initialize all members of this array so
; 198  : 		// we don't need to do it here.
; 199  : 	  {
; 200  : 		lzma_filter filters[LZMA_FILTERS_MAX + 1];
; 201  : 		coder->block_options.filters = filters;

  002ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002d3	48 8d 44 24 60	 lea	 rax, QWORD PTR filters$32896[rsp]
  002d8	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
$LN42@stream_dec@3:

; 202  : 
; 203  : 		// Decode the Block Header.
; 204  : 		return_if_error(lzma_block_header_decode(&coder->block_options,
; 205  : 				allocator, coder->buffer));

  002dc	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  002e1	49 81 c0 80 01
	00 00		 add	 r8, 384			; 00000180H
  002e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002ed	48 83 c1 50	 add	 rcx, 80			; 00000050H
  002f1	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002f9	e8 00 00 00 00	 call	 lzma_block_header_decode
  002fe	89 84 24 b0 00
	00 00		 mov	 DWORD PTR ret_$32900[rsp], eax
  00305	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR ret_$32900[rsp], 0
  0030d	74 0c		 je	 SHORT $LN39@stream_dec@3
  0030f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR ret_$32900[rsp]
  00316	e9 e8 04 00 00	 jmp	 $LN58@stream_dec@3
$LN39@stream_dec@3:
  0031b	33 c0		 xor	 eax, eax
  0031d	85 c0		 test	 eax, eax
  0031f	75 bb		 jne	 SHORT $LN42@stream_dec@3

; 206  : 
; 207  : 		// If LZMA_IGNORE_CHECK was used, this flag needs to be set.
; 208  : 		// It has to be set after lzma_block_header_decode() because
; 209  : 		// it always resets this to false.
; 210  : 		coder->block_options.ignore_check = coder->ignore_check;

  00321	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00326	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0032b	0f b6 80 73 01
	00 00		 movzx	 eax, BYTE PTR [rax+371]
  00332	88 81 18 01 00
	00		 mov	 BYTE PTR [rcx+280], al

; 211  : 
; 212  : 		// Check the memory usage limit.
; 213  : 	  {
; 214  : 		const uint64_t memusage = lzma_raw_decoder_memusage(filters);

  00338	48 8d 4c 24 60	 lea	 rcx, QWORD PTR filters$32896[rsp]
  0033d	e8 00 00 00 00	 call	 lzma_raw_decoder_memusage
  00342	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR memusage$32902[rsp], rax

; 215  : 		lzma_ret ret;
; 216  : 
; 217  : 		if (memusage == UINT64_MAX) {

  0034a	48 83 bc 24 b8
	00 00 00 ff	 cmp	 QWORD PTR memusage$32902[rsp], -1
  00353	75 0d		 jne	 SHORT $LN38@stream_dec@3

; 218  : 			// One or more unknown Filter IDs.
; 219  : 			ret = LZMA_OPTIONS_ERROR;

  00355	c7 84 24 c0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR ret$32903[rsp], 8

; 220  : 		} else {

  00360	eb 5d		 jmp	 SHORT $LN37@stream_dec@3
$LN38@stream_dec@3:

; 221  : 			// Now we can set coder->memusage since we know that
; 222  : 			// the filter chain is valid. We don't want
; 223  : 			// lzma_memusage() to return UINT64_MAX in case of
; 224  : 			// invalid filter chain.
; 225  : 			coder->memusage = memusage;

  00362	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00367	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR memusage$32902[rsp]
  0036f	48 89 81 68 01
	00 00		 mov	 QWORD PTR [rcx+360], rax

; 226  : 
; 227  : 			if (memusage > coder->memlimit) {

  00376	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0037b	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  00382	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR memusage$32902[rsp], rax
  0038a	76 0d		 jbe	 SHORT $LN36@stream_dec@3

; 228  : 				// The chain would need too much memory.
; 229  : 				ret = LZMA_MEMLIMIT_ERROR;

  0038c	c7 84 24 c0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR ret$32903[rsp], 6

; 230  : 			} else {

  00397	eb 26		 jmp	 SHORT $LN35@stream_dec@3
$LN36@stream_dec@3:

; 231  : 				// Memory usage is OK.
; 232  : 				// Initialize the Block decoder.
; 233  : 				ret = lzma_block_decoder_init(
; 234  : 						&coder->block_decoder,
; 235  : 						allocator,
; 236  : 						&coder->block_options);

  00399	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  0039e	49 83 c0 50	 add	 r8, 80			; 00000050H
  003a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003a7	48 83 c1 08	 add	 rcx, 8
  003ab	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003b3	e8 00 00 00 00	 call	 lzma_block_decoder_init
  003b8	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ret$32903[rsp], eax
$LN35@stream_dec@3:
$LN37@stream_dec@3:

; 237  : 			}
; 238  : 		}
; 239  : 
; 240  : 		// Free the allocated filter options since they are needed
; 241  : 		// only to initialize the Block decoder.
; 242  : 	  { size_t i;
; 243  : 		for (i = 0; i < LZMA_FILTERS_MAX; ++i)

  003bf	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$32908[rsp], 0
  003cb	eb 14		 jmp	 SHORT $LN34@stream_dec@3
$LN33@stream_dec@3:
  003cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR i$32908[rsp]
  003d5	48 83 c0 01	 add	 rax, 1
  003d9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR i$32908[rsp], rax
$LN34@stream_dec@3:
  003e1	48 83 bc 24 c8
	00 00 00 04	 cmp	 QWORD PTR i$32908[rsp], 4
  003ea	73 20		 jae	 SHORT $LN32@stream_dec@3

; 244  : 			lzma_free(filters[i].options, allocator);

  003ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR i$32908[rsp]
  003f4	48 6b c9 10	 imul	 rcx, 16
  003f8	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00400	48 8b 4c 0c 68	 mov	 rcx, QWORD PTR filters$32896[rsp+rcx+8]
  00405	e8 00 00 00 00	 call	 lzma_free
  0040a	eb c1		 jmp	 SHORT $LN33@stream_dec@3
$LN32@stream_dec@3:

; 245  : 	  }
; 246  : 
; 247  : 		coder->block_options.filters = NULL;

  0040c	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00411	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 248  : 
; 249  : 		// Check if memory usage calculation and Block enocoder
; 250  : 		// initialization succeeded.
; 251  : 		if (ret != LZMA_OK)

  00419	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR ret$32903[rsp], 0
  00421	74 0c		 je	 SHORT $LN31@stream_dec@3

; 252  : 			return ret;

  00423	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ret$32903[rsp]
  0042a	e9 d4 03 00 00	 jmp	 $LN58@stream_dec@3
$LN31@stream_dec@3:

; 253  : 
; 254  : 		coder->sequence = SEQ_BLOCK;

  0042f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00434	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN30@stream_dec@3:

; 255  : 	  }}
; 256  : 	}
; 257  : 
; 258  : 	// Fall through
; 259  : 
; 260  : 	case SEQ_BLOCK: {
; 261  : 		const lzma_ret ret = coder->block_decoder.code(
; 262  : 				coder->block_decoder.coder, allocator,
; 263  : 				in, in_pos, in_size, out, out_pos, out_size,
; 264  : 				action);

  0043a	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00441	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00445	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0044d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00452	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0045a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0045f	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00467	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0046c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00474	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00479	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00481	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00489	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00491	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00496	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0049a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0049f	ff 50 20	 call	 QWORD PTR [rax+32]
  004a2	89 84 24 d0 00
	00 00		 mov	 DWORD PTR ret$32915[rsp], eax

; 265  : 
; 266  : 		if (ret != LZMA_STREAM_END)

  004a9	83 bc 24 d0 00
	00 00 01	 cmp	 DWORD PTR ret$32915[rsp], 1
  004b1	74 0c		 je	 SHORT $LN29@stream_dec@3

; 267  : 			return ret;

  004b3	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR ret$32915[rsp]
  004ba	e9 44 03 00 00	 jmp	 $LN58@stream_dec@3
$LN29@stream_dec@3:
$LN28@stream_dec@3:

; 268  : 
; 269  : 		// Block decoded successfully. Add the new size pair to
; 270  : 		// the Index hash.
; 271  : 		return_if_error(lzma_index_hash_append(coder->index_hash,
; 272  : 				lzma_block_unpadded_size(
; 273  : 					&coder->block_options),
; 274  : 				coder->block_options.uncompressed_size));

  004bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  004c4	48 83 c1 50	 add	 rcx, 80			; 00000050H
  004c8	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  004cd	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  004d2	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  004d6	48 8b d0	 mov	 rdx, rax
  004d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  004de	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  004e5	e8 00 00 00 00	 call	 lzma_index_hash_append
  004ea	89 84 24 d4 00
	00 00		 mov	 DWORD PTR ret_$32920[rsp], eax
  004f1	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR ret_$32920[rsp], 0
  004f9	74 0c		 je	 SHORT $LN25@stream_dec@3
  004fb	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR ret_$32920[rsp]
  00502	e9 fc 02 00 00	 jmp	 $LN58@stream_dec@3
$LN25@stream_dec@3:
  00507	33 c0		 xor	 eax, eax
  00509	85 c0		 test	 eax, eax
  0050b	75 b2		 jne	 SHORT $LN28@stream_dec@3

; 275  : 
; 276  : 		coder->sequence = SEQ_BLOCK_HEADER;

  0050d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00512	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 277  : 		break;

  00518	e9 e1 02 00 00	 jmp	 $LN54@stream_dec@3
$LN24@stream_dec@3:

; 278  : 	}
; 279  : 
; 280  : 	case SEQ_INDEX: {
; 281  : 		// If we don't have any input, don't call
; 282  : 		// lzma_index_hash_decode() since it would return
; 283  : 		// LZMA_BUF_ERROR, which we must not do here.
; 284  : 		if (*in_pos >= in_size)

  0051d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00525	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0052d	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00530	72 07		 jb	 SHORT $LN23@stream_dec@3

; 285  : 			return LZMA_OK;

  00532	33 c0		 xor	 eax, eax
  00534	e9 ca 02 00 00	 jmp	 $LN58@stream_dec@3
$LN23@stream_dec@3:

; 286  : 
; 287  : 		// Decode the Index and compare it to the hash calculated
; 288  : 		// from the sizes of the Blocks (if any).
; 289  : 	  {
; 290  : 		const lzma_ret ret = lzma_index_hash_decode(coder->index_hash,
; 291  : 				in, in_pos, in_size);

  00539	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR in_size$[rsp]
  00541	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR in_pos$[rsp]
  00549	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR in$[rsp]
  00551	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00556	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  0055d	e8 00 00 00 00	 call	 lzma_index_hash_decode
  00562	89 84 24 d8 00
	00 00		 mov	 DWORD PTR ret$32924[rsp], eax

; 292  : 		if (ret != LZMA_STREAM_END)

  00569	83 bc 24 d8 00
	00 00 01	 cmp	 DWORD PTR ret$32924[rsp], 1
  00571	74 0c		 je	 SHORT $LN22@stream_dec@3

; 293  : 			return ret;

  00573	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR ret$32924[rsp]
  0057a	e9 84 02 00 00	 jmp	 $LN58@stream_dec@3
$LN22@stream_dec@3:

; 294  : 	  }
; 295  : 
; 296  : 		coder->sequence = SEQ_STREAM_FOOTER;

  0057f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00584	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN21@stream_dec@3:

; 297  : 	}
; 298  : 
; 299  : 	// Fall through
; 300  : 
; 301  : 	case SEQ_STREAM_FOOTER: {
; 302  : 		// Copy the Stream Footer to the internal buffer.
; 303  : 		lzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,
; 304  : 				LZMA_STREAM_HEADER_SIZE);

  0058a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0058f	48 05 78 01 00
	00		 add	 rax, 376		; 00000178H
  00595	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  0059a	49 81 c1 80 01
	00 00		 add	 r9, 384			; 00000180H
  005a1	48 c7 44 24 28
	0c 00 00 00	 mov	 QWORD PTR [rsp+40], 12
  005aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005af	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  005b7	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  005bf	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  005c7	e8 00 00 00 00	 call	 lzma_bufcpy

; 305  : 
; 306  : 		// Return if we didn't get the whole Stream Footer yet.
; 307  : 		if (coder->pos < LZMA_STREAM_HEADER_SIZE)

  005cc	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  005d1	49 83 bb 78 01
	00 00 0c	 cmp	 QWORD PTR [r11+376], 12
  005d9	73 07		 jae	 SHORT $LN20@stream_dec@3

; 308  : 			return LZMA_OK;

  005db	33 c0		 xor	 eax, eax
  005dd	e9 21 02 00 00	 jmp	 $LN58@stream_dec@3
$LN20@stream_dec@3:

; 309  : 
; 310  : 		coder->pos = 0;

  005e2	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  005e7	48 c7 80 78 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+376], 0

; 311  : 
; 312  : 		// Decode the Stream Footer. The decoder gives
; 313  : 		// LZMA_FORMAT_ERROR if the magic bytes don't match,
; 314  : 		// so convert that return code to LZMA_DATA_ERROR.
; 315  : 	  {
; 316  : 		lzma_stream_flags footer_flags;
; 317  : 		const lzma_ret ret = lzma_stream_footer_decode(
; 318  : 				&footer_flags, coder->buffer);

  005f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  005f7	48 81 c2 80 01
	00 00		 add	 rdx, 384		; 00000180H
  005fe	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR footer_flags$32928[rsp]
  00606	e8 00 00 00 00	 call	 lzma_stream_footer_decode
  0060b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR ret$32929[rsp], eax

; 319  : 		if (ret != LZMA_OK)

  00612	83 bc 24 dc 00
	00 00 00	 cmp	 DWORD PTR ret$32929[rsp], 0
  0061a	74 31		 je	 SHORT $LN19@stream_dec@3

; 320  : 			return ret == LZMA_FORMAT_ERROR
; 321  : 					? LZMA_DATA_ERROR : ret;

  0061c	83 bc 24 dc 00
	00 00 07	 cmp	 DWORD PTR ret$32929[rsp], 7
  00624	75 0d		 jne	 SHORT $LN62@stream_dec@3
  00626	c7 84 24 28 01
	00 00 09 00 00
	00		 mov	 DWORD PTR tv247[rsp], 9
  00631	eb 0e		 jmp	 SHORT $LN63@stream_dec@3
$LN62@stream_dec@3:
  00633	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR ret$32929[rsp]
  0063a	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv247[rsp], eax
$LN63@stream_dec@3:
  00641	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv247[rsp]
  00648	e9 b6 01 00 00	 jmp	 $LN58@stream_dec@3
$LN19@stream_dec@3:

; 322  : 
; 323  : 		// Check that Index Size stored in the Stream Footer matches
; 324  : 		// the real size of the Index field.
; 325  : 		if (lzma_index_hash_size(coder->index_hash)
; 326  : 				!= footer_flags.backward_size)

  0064d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00652	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  00659	e8 00 00 00 00	 call	 lzma_index_hash_size
  0065e	48 3b 84 24 e8
	00 00 00	 cmp	 rax, QWORD PTR footer_flags$32928[rsp+8]
  00666	74 0a		 je	 SHORT $LN18@stream_dec@3

; 327  : 			return LZMA_DATA_ERROR;

  00668	b8 09 00 00 00	 mov	 eax, 9
  0066d	e9 91 01 00 00	 jmp	 $LN58@stream_dec@3
$LN18@stream_dec@3:
$LN17@stream_dec@3:

; 328  : 
; 329  : 		// Compare that the Stream Flags fields are identical in
; 330  : 		// both Stream Header and Stream Footer.
; 331  : 		return_if_error(lzma_stream_flags_compare(
; 332  : 				&coder->stream_flags, &footer_flags));

  00672	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00677	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  0067e	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR footer_flags$32928[rsp]
  00686	e8 00 00 00 00	 call	 lzma_stream_flags_compare
  0068b	89 84 24 18 01
	00 00		 mov	 DWORD PTR ret_$32935[rsp], eax
  00692	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR ret_$32935[rsp], 0
  0069a	74 0c		 je	 SHORT $LN14@stream_dec@3
  0069c	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR ret_$32935[rsp]
  006a3	e9 5b 01 00 00	 jmp	 $LN58@stream_dec@3
$LN14@stream_dec@3:
  006a8	33 c0		 xor	 eax, eax
  006aa	85 c0		 test	 eax, eax
  006ac	75 c4		 jne	 SHORT $LN17@stream_dec@3

; 333  : 
; 334  : 		if (!coder->concatenated)

  006ae	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  006b3	0f b6 80 74 01
	00 00		 movzx	 eax, BYTE PTR [rax+372]
  006ba	85 c0		 test	 eax, eax
  006bc	75 0a		 jne	 SHORT $LN13@stream_dec@3

; 335  : 			return LZMA_STREAM_END;

  006be	b8 01 00 00 00	 mov	 eax, 1
  006c3	e9 3b 01 00 00	 jmp	 $LN58@stream_dec@3
$LN13@stream_dec@3:

; 336  : 
; 337  : 		coder->sequence = SEQ_STREAM_PADDING;

  006c8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  006cd	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN12@stream_dec@3:
$LN11@stream_dec@3:

; 338  : 	  }		
; 339  : 	}
; 340  : 
; 341  : 	// Fall through
; 342  : 
; 343  : 	case SEQ_STREAM_PADDING:
; 344  : 		assert(coder->concatenated);
; 345  : 
; 346  : 		// Skip over possible Stream Padding.
; 347  : 		while (true) {

  006d3	33 c0		 xor	 eax, eax
  006d5	83 f8 01	 cmp	 eax, 1
  006d8	0f 84 b5 00 00
	00		 je	 $LN10@stream_dec@3

; 348  : 			if (*in_pos >= in_size) {

  006de	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  006e6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  006ee	48 39 01	 cmp	 QWORD PTR [rcx], rax
  006f1	72 44		 jb	 SHORT $LN9@stream_dec@3

; 349  : 				// Unless LZMA_FINISH was used, we cannot
; 350  : 				// know if there's more input coming later.
; 351  : 				if (action != LZMA_FINISH)

  006f3	83 bc 24 80 01
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  006fb	74 07		 je	 SHORT $LN8@stream_dec@3

; 352  : 					return LZMA_OK;

  006fd	33 c0		 xor	 eax, eax
  006ff	e9 ff 00 00 00	 jmp	 $LN58@stream_dec@3
$LN8@stream_dec@3:

; 353  : 
; 354  : 				// Stream Padding must be a multiple of
; 355  : 				// four bytes.
; 356  : 				return coder->pos == 0
; 357  : 						? LZMA_STREAM_END
; 358  : 						: LZMA_DATA_ERROR;

  00704	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00709	48 83 b8 78 01
	00 00 00	 cmp	 QWORD PTR [rax+376], 0
  00711	75 0d		 jne	 SHORT $LN64@stream_dec@3
  00713	c7 84 24 2c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv266[rsp], 1
  0071e	eb 0b		 jmp	 SHORT $LN65@stream_dec@3
$LN64@stream_dec@3:
  00720	c7 84 24 2c 01
	00 00 09 00 00
	00		 mov	 DWORD PTR tv266[rsp], 9
$LN65@stream_dec@3:
  0072b	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv266[rsp]
  00732	e9 cc 00 00 00	 jmp	 $LN58@stream_dec@3
$LN9@stream_dec@3:

; 359  : 			}
; 360  : 
; 361  : 			// If the byte is not zero, it probably indicates
; 362  : 			// beginning of a new Stream (or the file is corrupt).
; 363  : 			if (in[*in_pos] != 0x00)

  00737	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0073f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00742	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0074a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0074e	85 c0		 test	 eax, eax
  00750	74 02		 je	 SHORT $LN7@stream_dec@3

; 364  : 				break;

  00752	eb 3f		 jmp	 SHORT $LN10@stream_dec@3
$LN7@stream_dec@3:

; 365  : 
; 366  : 			++*in_pos;

  00754	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0075c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0075f	48 83 c1 01	 add	 rcx, 1
  00763	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  0076b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 367  : 			coder->pos = (coder->pos + 1) & 3;

  0076e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00773	48 8b 89 78 01
	00 00		 mov	 rcx, QWORD PTR [rcx+376]
  0077a	48 83 c1 01	 add	 rcx, 1
  0077e	48 83 e1 03	 and	 rcx, 3
  00782	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00787	48 89 88 78 01
	00 00		 mov	 QWORD PTR [rax+376], rcx

; 368  : 		}

  0078e	e9 40 ff ff ff	 jmp	 $LN11@stream_dec@3
$LN10@stream_dec@3:

; 369  : 
; 370  : 		// Stream Padding must be a multiple of four bytes (empty
; 371  : 		// Stream Padding is OK).
; 372  : 		if (coder->pos != 0) {

  00793	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00798	48 83 b8 78 01
	00 00 00	 cmp	 QWORD PTR [rax+376], 0
  007a0	74 21		 je	 SHORT $LN6@stream_dec@3

; 373  : 			++*in_pos;

  007a2	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  007aa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007ad	48 83 c1 01	 add	 rcx, 1
  007b1	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  007b9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 374  : 			return LZMA_DATA_ERROR;

  007bc	b8 09 00 00 00	 mov	 eax, 9
  007c1	eb 40		 jmp	 SHORT $LN58@stream_dec@3
$LN6@stream_dec@3:
$LN5@stream_dec@3:

; 375  : 		}
; 376  : 
; 377  : 		// Prepare to decode the next Stream.
; 378  : 		return_if_error(stream_decoder_reset(coder, allocator));

  007c3	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  007cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  007d0	e8 00 00 00 00	 call	 stream_decoder_reset
  007d5	89 84 24 1c 01
	00 00		 mov	 DWORD PTR ret_$32950[rsp], eax
  007dc	83 bc 24 1c 01
	00 00 00	 cmp	 DWORD PTR ret_$32950[rsp], 0
  007e4	74 09		 je	 SHORT $LN2@stream_dec@3
  007e6	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR ret_$32950[rsp]
  007ed	eb 14		 jmp	 SHORT $LN58@stream_dec@3
$LN2@stream_dec@3:
  007ef	33 c0		 xor	 eax, eax
  007f1	85 c0		 test	 eax, eax
  007f3	75 ce		 jne	 SHORT $LN5@stream_dec@3

; 379  : 		break;

  007f5	eb 07		 jmp	 SHORT $LN54@stream_dec@3
$LN1@stream_dec@3:

; 380  : 
; 381  : 	default:
; 382  : 		assert(0);
; 383  : 		return LZMA_PROG_ERROR;

  007f7	b8 0b 00 00 00	 mov	 eax, 11
  007fc	eb 05		 jmp	 SHORT $LN58@stream_dec@3
$LN54@stream_dec@3:

; 384  : 	}

  007fe	e9 25 f8 ff ff	 jmp	 $LN57@stream_dec@3
$LN56@stream_dec@3:
$LN58@stream_dec@3:

; 385  : 
; 386  : 	// Never reached
; 387  : }

  00803	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  0080a	c3		 ret	 0
  0080b	90		 npad	 1
$LN66@stream_dec@3:
  0080c	00 00 00 00	 DD	 $LN53@stream_dec@3
  00810	00 00 00 00	 DD	 $LN47@stream_dec@3
  00814	00 00 00 00	 DD	 $LN30@stream_dec@3
  00818	00 00 00 00	 DD	 $LN24@stream_dec@3
  0081c	00 00 00 00	 DD	 $LN21@stream_dec@3
  00820	00 00 00 00	 DD	 $LN12@stream_dec@3
stream_decode ENDP
_TEXT	ENDS
PUBLIC	lzma_stream_decoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_decoder_init DD imagerel $LN22
	DD	imagerel $LN22+626
	DD	imagerel $unwind$lzma_stream_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_decoder_init DD 031a01H
	DD	07016a21aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_stream_decoder_init
_TEXT	SEGMENT
coder$32995 = 32
tv85 = 40
tv90 = 48
tv95 = 52
tv132 = 56
tv137 = 60
tv142 = 64
next$ = 112
allocator$ = 120
memlimit$ = 128
flags$ = 136
lzma_stream_decoder_init PROC				; COMDAT

; 433  : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN7@lzma_strea@4:

; 434  : 	lzma_next_coder_init(&lzma_stream_decoder_init, next, allocator);

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_stream_decoder_init
  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR next$[rsp]
  00026	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0002a	74 0f		 je	 SHORT $LN4@lzma_strea@4
  0002c	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  00031	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  00036	e8 00 00 00 00	 call	 lzma_next_end
$LN4@lzma_strea@4:
  0003b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_stream_decoder_init
  00047	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 c9		 jne	 SHORT $LN7@lzma_strea@4

; 435  : 
; 436  : 	if (flags & ~LZMA_SUPPORTED_FLAGS)

  00051	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00058	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $LN3@lzma_strea@4

; 437  : 		return LZMA_OPTIONS_ERROR;

  0005f	b8 08 00 00 00	 mov	 eax, 8
  00064	e9 02 02 00 00	 jmp	 $LN8@lzma_strea@4
$LN3@lzma_strea@4:

; 438  : 
; 439  :   {
; 440  : 	lzma_stream_coder *coder = next->coder;

  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR next$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 89 44 24 20	 mov	 QWORD PTR coder$32995[rsp], rax

; 441  : 	if (coder == NULL) {

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32995[rsp], 0
  0007c	0f 85 9a 00 00
	00		 jne	 $LN2@lzma_strea@4

; 442  : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  00082	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  00087	b9 80 05 00 00	 mov	 ecx, 1408		; 00000580H
  0008c	e8 00 00 00 00	 call	 lzma_alloc
  00091	48 89 44 24 20	 mov	 QWORD PTR coder$32995[rsp], rax

; 443  : 		if (coder == NULL)

  00096	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32995[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN1@lzma_strea@4

; 444  : 			return LZMA_MEM_ERROR;

  0009e	b8 05 00 00 00	 mov	 eax, 5
  000a3	e9 c3 01 00 00	 jmp	 $LN8@lzma_strea@4
$LN1@lzma_strea@4:

; 445  : 
; 446  : 		next->coder = coder;

  000a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32995[rsp]
  000b2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 447  : 		next->code = &stream_decode;

  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  000ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_decode
  000c1	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 448  : 		next->end = &stream_decoder_end;

  000c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_decoder_end
  000d1	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 449  : 		next->get_check = &stream_decoder_get_check;

  000d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  000da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_decoder_get_check
  000e1	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 450  : 		next->memconfig = &stream_decoder_memconfig;

  000e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next$[rsp]
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_decoder_memconfig
  000f1	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 451  : 
; 452  : 		coder->block_decoder = LZMA_NEXT_CODER_INIT;

  000f5	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32995[rsp]
  000fa	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  00101	48 83 c7 08	 add	 rdi, 8
  00105	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0010a	f3 a4		 rep movsb

; 453  : 		coder->index_hash = NULL;

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32995[rsp]
  00111	48 c7 80 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+344], 0
$LN2@lzma_strea@4:

; 454  : 	}
; 455  : 
; 456  : 	coder->memlimit = my_max(1, memlimit);

  0011c	48 83 bc 24 80
	00 00 00 01	 cmp	 QWORD PTR memlimit$[rsp], 1
  00125	73 0b		 jae	 SHORT $LN10@lzma_strea@4
  00127	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR tv85[rsp], 1
  00130	eb 0d		 jmp	 SHORT $LN11@lzma_strea@4
$LN10@lzma_strea@4:
  00132	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR memlimit$[rsp]
  0013a	48 89 44 24 28	 mov	 QWORD PTR tv85[rsp], rax
$LN11@lzma_strea@4:
  0013f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR tv85[rsp]
  00149	48 89 81 60 01
	00 00		 mov	 QWORD PTR [rcx+352], rax

; 457  : 	coder->memusage = LZMA_MEMUSAGE_BASE;

  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32995[rsp]
  00155	48 c7 80 68 01
	00 00 00 80 00
	00		 mov	 QWORD PTR [rax+360], 32768 ; 00008000H

; 458  : 	coder->tell_no_check = (flags & LZMA_TELL_NO_CHECK) != 0;

  00160	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00167	83 e0 01	 and	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	74 0a		 je	 SHORT $LN12@lzma_strea@4
  0016e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  00176	eb 08		 jmp	 SHORT $LN13@lzma_strea@4
$LN12@lzma_strea@4:
  00178	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN13@lzma_strea@4:
  00180	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  00185	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv90[rsp]
  0018a	88 81 70 01 00
	00		 mov	 BYTE PTR [rcx+368], al

; 459  : 	coder->tell_unsupported_check
; 460  : 			= (flags & LZMA_TELL_UNSUPPORTED_CHECK) != 0;

  00190	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00197	83 e0 02	 and	 eax, 2
  0019a	85 c0		 test	 eax, eax
  0019c	74 0a		 je	 SHORT $LN14@lzma_strea@4
  0019e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  001a6	eb 08		 jmp	 SHORT $LN15@lzma_strea@4
$LN14@lzma_strea@4:
  001a8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN15@lzma_strea@4:
  001b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  001b5	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv95[rsp]
  001ba	88 81 71 01 00
	00		 mov	 BYTE PTR [rcx+369], al

; 461  : 	coder->tell_any_check = (flags & LZMA_TELL_ANY_CHECK) != 0;

  001c0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001c7	83 e0 04	 and	 eax, 4
  001ca	85 c0		 test	 eax, eax
  001cc	74 0a		 je	 SHORT $LN16@lzma_strea@4
  001ce	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  001d6	eb 08		 jmp	 SHORT $LN17@lzma_strea@4
$LN16@lzma_strea@4:
  001d8	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN17@lzma_strea@4:
  001e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  001e5	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv132[rsp]
  001ea	88 81 72 01 00
	00		 mov	 BYTE PTR [rcx+370], al

; 462  : 	coder->ignore_check = (flags & LZMA_IGNORE_CHECK) != 0;

  001f0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001f7	83 e0 10	 and	 eax, 16
  001fa	85 c0		 test	 eax, eax
  001fc	74 0a		 je	 SHORT $LN18@lzma_strea@4
  001fe	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  00206	eb 08		 jmp	 SHORT $LN19@lzma_strea@4
$LN18@lzma_strea@4:
  00208	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN19@lzma_strea@4:
  00210	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  00215	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv137[rsp]
  0021a	88 81 73 01 00
	00		 mov	 BYTE PTR [rcx+371], al

; 463  : 	coder->concatenated = (flags & LZMA_CONCATENATED) != 0;

  00220	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00227	83 e0 08	 and	 eax, 8
  0022a	85 c0		 test	 eax, eax
  0022c	74 0a		 je	 SHORT $LN20@lzma_strea@4
  0022e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00236	eb 08		 jmp	 SHORT $LN21@lzma_strea@4
$LN20@lzma_strea@4:
  00238	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN21@lzma_strea@4:
  00240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  00245	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv142[rsp]
  0024a	88 81 74 01 00
	00		 mov	 BYTE PTR [rcx+372], al

; 464  : 	coder->first_stream = true;

  00250	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32995[rsp]
  00255	c6 80 75 01 00
	00 01		 mov	 BYTE PTR [rax+373], 1

; 465  : 
; 466  : 	return stream_decoder_reset(coder, allocator);

  0025c	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  00261	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32995[rsp]
  00266	e8 00 00 00 00	 call	 stream_decoder_reset
$LN8@lzma_strea@4:

; 467  :   }
; 468  : }

  0026b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0026f	5f		 pop	 rdi
  00270	5e		 pop	 rsi
  00271	c3		 ret	 0
lzma_stream_decoder_init ENDP
_TEXT	ENDS
PUBLIC	lzma_stream_decoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_decoder DD imagerel $LN11
	DD	imagerel $LN11+151
	DD	imagerel $unwind$lzma_stream_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_decoder DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_stream_decoder
_TEXT	SEGMENT
ret_$33015 = 32
ret_$33017 = 36
strm$ = 64
memlimit$ = 72
flags$ = 80
lzma_stream_decoder PROC				; COMDAT

; 473  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_strea@5:
$LN5@lzma_strea@5:

; 474  : 	lzma_next_strm_init(lzma_stream_decoder_init, strm, memlimit, flags);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_strm_init
  0001d	89 44 24 20	 mov	 DWORD PTR ret_$33015[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33015[rsp], 0
  00026	74 06		 je	 SHORT $LN2@lzma_strea@5
  00028	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33015[rsp]
  0002c	eb 64		 jmp	 SHORT $LN9@lzma_strea@5
$LN2@lzma_strea@5:
  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 df		 jne	 SHORT $LN5@lzma_strea@5
  00034	44 8b 4c 24 50	 mov	 r9d, DWORD PTR flags$[rsp]
  00039	4c 8b 44 24 48	 mov	 r8, QWORD PTR memlimit$[rsp]
  0003e	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00043	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0004c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00050	e8 00 00 00 00	 call	 lzma_stream_decoder_init
  00055	89 44 24 24	 mov	 DWORD PTR ret_$33017[rsp], eax
  00059	83 7c 24 24 00	 cmp	 DWORD PTR ret_$33017[rsp], 0
  0005e	74 10		 je	 SHORT $LN1@lzma_strea@5
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00065	e8 00 00 00 00	 call	 lzma_end
  0006a	8b 44 24 24	 mov	 eax, DWORD PTR ret_$33017[rsp]
  0006e	eb 22		 jmp	 SHORT $LN9@lzma_strea@5
$LN1@lzma_strea@5:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 9d		 jne	 SHORT $LN8@lzma_strea@5

; 475  : 
; 476  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0007f	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 477  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00088	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008c	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 478  : 
; 479  : 	return LZMA_OK;

  00090	33 c0		 xor	 eax, eax
$LN9@lzma_strea@5:

; 480  : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
lzma_stream_decoder ENDP
_TEXT	ENDS
END
