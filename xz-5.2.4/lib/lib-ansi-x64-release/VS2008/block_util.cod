; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_block_unpadded_size
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_util.c
pdata	SEGMENT
$pdata$lzma_block_unpadded_size DD imagerel $LN8
	DD	imagerel $LN8+227
	DD	imagerel $unwind$lzma_block_unpadded_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_unpadded_size DD 020a01H
	DD	03006520aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_unpadded_size
_TEXT	SEGMENT
unpadded_size$32858 = 32
block$ = 64
lzma_block_unpadded_size PROC				; COMDAT

; 50   : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 51   : 	// Validate the values that we are interested in i.e. all but
; 52   : 	// Uncompressed Size and the filters.
; 53   : 	//
; 54   : 	// NOTE: This function is used for validation too, so it is
; 55   : 	// essential that these checks are always done even if
; 56   : 	// Compressed Size is unknown.
; 57   : 	if (block == NULL || block->version > 1
; 58   : 			|| block->header_size < LZMA_BLOCK_HEADER_SIZE_MIN
; 59   : 			|| block->header_size > LZMA_BLOCK_HEADER_SIZE_MAX
; 60   : 			|| (block->header_size & 3)
; 61   : 			|| !lzma_vli_is_valid(block->compressed_size)
; 62   : 			|| block->compressed_size == 0
; 63   : 			|| (unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR block$[rsp], 0
  00010	74 6a		 je	 SHORT $LN4@lzma_block
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  00017	83 38 01	 cmp	 DWORD PTR [rax], 1
  0001a	77 60		 ja	 SHORT $LN4@lzma_block
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  00021	83 78 04 08	 cmp	 DWORD PTR [rax+4], 8
  00025	72 55		 jb	 SHORT $LN4@lzma_block
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0002c	81 78 04 00 04
	00 00		 cmp	 DWORD PTR [rax+4], 1024	; 00000400H
  00033	77 47		 ja	 SHORT $LN4@lzma_block
  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0003a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0003d	83 e0 03	 and	 eax, 3
  00040	85 c0		 test	 eax, eax
  00042	75 38		 jne	 SHORT $LN4@lzma_block
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR block$[rsp]
  00049	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00053	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00057	76 0c		 jbe	 SHORT $LN3@lzma_block
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0005e	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  00063	75 17		 jne	 SHORT $LN4@lzma_block
$LN3@lzma_block:
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0006a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006f	74 0b		 je	 SHORT $LN4@lzma_block
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  00076	83 78 08 0f	 cmp	 DWORD PTR [rax+8], 15
  0007a	76 04		 jbe	 SHORT $LN5@lzma_block
$LN4@lzma_block:

; 64   : 		return 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 5d		 jmp	 SHORT $LN6@lzma_block
$LN5@lzma_block:

; 65   : 
; 66   : 	// If Compressed Size is unknown, return that we cannot know
; 67   : 	// size of the Block either.
; 68   : 	if (block->compressed_size == LZMA_VLI_UNKNOWN)

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  00085	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  0008a	75 09		 jne	 SHORT $LN2@lzma_block

; 69   : 		return LZMA_VLI_UNKNOWN;

  0008c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00093	eb 48		 jmp	 SHORT $LN6@lzma_block
$LN2@lzma_block:

; 70   : 
; 71   : 	// Calculate Unpadded Size and validate it.
; 72   :   {
; 73   : 	const lzma_vli unpadded_size = block->compressed_size
; 74   : 				+ block->header_size
; 75   : 				+ lzma_check_size(block->check);

  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0009a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0009d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR block$[rsp]
  000a2	48 8b 5b 10	 mov	 rbx, QWORD PTR [rbx+16]
  000a6	48 03 d8	 add	 rbx, rax
  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  000ae	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000b1	e8 00 00 00 00	 call	 lzma_check_size
  000b6	8b c8		 mov	 ecx, eax
  000b8	48 8b c3	 mov	 rax, rbx
  000bb	48 03 c1	 add	 rax, rcx
  000be	48 89 44 24 20	 mov	 QWORD PTR unpadded_size$32858[rsp], rax

; 76   : 
; 77   : 	assert(unpadded_size >= UNPADDED_SIZE_MIN);
; 78   : 	if (unpadded_size > UNPADDED_SIZE_MAX)

  000c3	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  000cd	48 39 44 24 20	 cmp	 QWORD PTR unpadded_size$32858[rsp], rax
  000d2	76 04		 jbe	 SHORT $LN1@lzma_block

; 79   : 		return 0;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 05		 jmp	 SHORT $LN6@lzma_block
$LN1@lzma_block:

; 80   : 
; 81   : 	return unpadded_size;

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR unpadded_size$32858[rsp]
$LN6@lzma_block:

; 82   :   }
; 83   : }

  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5b		 pop	 rbx
  000e2	c3		 ret	 0
lzma_block_unpadded_size ENDP
END
