; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_memcmplen DD imagerel lzma_memcmplen
	DD	imagerel lzma_memcmplen+160
	DD	imagerel $unwind$lzma_memcmplen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_memcmplen DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_memcmplen
_TEXT	SEGMENT
x$33357 = 0
tmp$33361 = 8
tv76 = 12
buf1$ = 32
buf2$ = 40
len$ = 48
limit$ = 56
lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24
$LN3@lzma_memcm@2:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {

  00018	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0001c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00020	73 75		 jae	 SHORT $LN2@lzma_memcm@2

; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);

  00022	44 8b 44 24 30	 mov	 r8d, DWORD PTR len$[rsp]
  00027	8b 54 24 30	 mov	 edx, DWORD PTR len$[rsp]
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buf1$[rsp]
  00030	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf2$[rsp]
  00035	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00039	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	48 89 04 24	 mov	 QWORD PTR x$33357[rsp], rax

; 66   : 		if (x != 0) {

  00044	48 83 3c 24 00	 cmp	 QWORD PTR x$33357[rsp], 0
  00049	74 3f		 je	 SHORT $LN1@lzma_memcm@2

; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);

  0004b	48 8b 04 24	 mov	 rax, QWORD PTR x$33357[rsp]
  0004f	48 0f bc c0	 bsf	 rax, rax
  00053	89 44 24 08	 mov	 DWORD PTR tmp$33361[rsp], eax

; 70   : 			len += (uint32_t)tmp >> 3;

  00057	8b 4c 24 08	 mov	 ecx, DWORD PTR tmp$33361[rsp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00062	03 c1		 add	 eax, ecx
  00064	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);

  00068	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0006c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00070	73 0a		 jae	 SHORT $LN6@lzma_memcm@2
  00072	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00076	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
  0007a	eb 08		 jmp	 SHORT $LN7@lzma_memcm@2
$LN6@lzma_memcm@2:
  0007c	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00080	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
$LN7@lzma_memcm@2:
  00084	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
  00088	eb 11		 jmp	 SHORT $LN4@lzma_memcm@2
$LN1@lzma_memcm@2:

; 75   : 		}
; 76   : 
; 77   : 		len += 8;

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0008e	83 c0 08	 add	 eax, 8
  00091	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 78   : 	}

  00095	eb 81		 jmp	 SHORT $LN3@lzma_memcm@2
$LN2@lzma_memcm@2:

; 79   : 
; 80   : 	return limit;

  00097	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
$LN4@lzma_memcm@2:

; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {
; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);
; 125  : 		if (x != 0) {
; 126  : 			if ((x & 0xFFFF) == 0) {
; 127  : 				len += 2;
; 128  : 				x >>= 16;
; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)
; 132  : 				++len;
; 133  : 
; 134  : 			return my_min(len, limit);
; 135  : 		}
; 136  : 
; 137  : 		len += 4;
; 138  : 	}
; 139  : 
; 140  : 	return limit;
; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0009b	48 83 c4 18	 add	 rsp, 24
  0009f	c3		 ret	 0
lzma_memcmplen ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$mf_skip DD imagerel mf_skip
	DD	imagerel mf_skip+63
	DD	imagerel $unwind$mf_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mf_skip DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mf_skip
_TEXT	SEGMENT
mf$ = 48
amount$ = 56
mf_skip	PROC						; COMDAT

; 268  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  : 	if (amount != 0) {

  0000d	83 7c 24 38 00	 cmp	 DWORD PTR amount$[rsp], 0
  00012	74 26		 je	 SHORT $LN1@mf_skip

; 270  : 		mf->skip(mf, amount);

  00014	8b 54 24 38	 mov	 edx, DWORD PTR amount$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00022	ff 50 38	 call	 QWORD PTR [rax+56]

; 271  : 		mf->read_ahead += amount;

  00025	4c 8b 5c 24 30	 mov	 r11, QWORD PTR mf$[rsp]
  0002a	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  0002e	03 4c 24 38	 add	 ecx, DWORD PTR amount$[rsp]
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00037	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN1@mf_skip:

; 272  : 	}
; 273  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
mf_skip	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_avail
_TEXT	SEGMENT
mf$ = 8
mf_avail PROC						; COMDAT

; 230  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 231  : 	return mf->write_pos - mf->read_pos;

  00005	48 8b 54 24 08	 mov	 rdx, QWORD PTR mf$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00012	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00015	2b c1		 sub	 eax, ecx

; 232  : }

  00017	c3		 ret	 0
mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_ptr
_TEXT	SEGMENT
mf$ = 8
mf_ptr	PROC						; COMDAT

; 222  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 223  : 	return mf->buffer + mf->read_pos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR mf$[rsp]
  00012	48 03 01	 add	 rax, QWORD PTR [rcx]

; 224  : }

  00015	c3		 ret	 0
mf_ptr	ENDP
PUBLIC	lzma_lzma_optimum_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma_optimum_fast DD imagerel $LN62
	DD	imagerel $LN62+1850
	DD	imagerel $unwind$lzma_lzma_optimum_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_optimum_fast DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_fast.c
xdata	ENDS
;	COMDAT lzma_lzma_optimum_fast
_TEXT	SEGMENT
matches_count$ = 32
len_main$ = 36
nice_len$ = 40
buf$33378 = 48
buf_avail$33379 = 56
i$33383 = 60
rep_len$33381 = 64
rep_index$33382 = 68
buf_back$33387 = 72
len$33391 = 80
back_main$33395 = 84
new_dist$33409 = 88
limit$33414 = 92
x$80228 = 96
tmp$80230 = 104
$T80231 = 108
$T80236 = 112
$T80241 = 116
$T80246 = 120
$T80251 = 124
tv84 = 128
tv277 = 132
tv239 = 136
coder$ = 160
mf$ = 168
back_res$ = 176
len_res$ = 184
lzma_lzma_optimum_fast PROC				; COMDAT

; 24   : {

$LN62:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 25   : 	const uint32_t nice_len = mf->nice_len;

  0001b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00023	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00026	89 44 24 28	 mov	 DWORD PTR nice_len$[rsp], eax

; 26   : 
; 27   : 	uint32_t len_main;
; 28   : 	uint32_t matches_count;
; 29   : 	if (mf->read_ahead == 0) {

  0002a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00032	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00036	75 27		 jne	 SHORT $LN30@lzma_lzma_@3

; 30   : 		len_main = mf_find(mf, &matches_count, coder->matches);

  00038	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR coder$[rsp]
  00040	49 81 c0 f4 02
	00 00		 add	 r8, 756			; 000002f4H
  00047	48 8d 54 24 20	 lea	 rdx, QWORD PTR matches_count$[rsp]
  0004c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00054	e8 00 00 00 00	 call	 lzma_mf_find
  00059	89 44 24 24	 mov	 DWORD PTR len_main$[rsp], eax

; 31   : 	} else {

  0005d	eb 24		 jmp	 SHORT $LN29@lzma_lzma_@3
$LN30@lzma_lzma_@3:

; 32   : 		assert(mf->read_ahead == 1);
; 33   : 		len_main = coder->longest_match_length;

  0005f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00067	8b 80 88 0b 00
	00		 mov	 eax, DWORD PTR [rax+2952]
  0006d	89 44 24 24	 mov	 DWORD PTR len_main$[rsp], eax

; 34   : 		matches_count = coder->matches_count;

  00071	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00079	8b 80 84 0b 00
	00		 mov	 eax, DWORD PTR [rax+2948]
  0007f	89 44 24 20	 mov	 DWORD PTR matches_count$[rsp], eax
$LN29@lzma_lzma_@3:

; 35   : 	}
; 36   : 
; 37   :   {
; 38   : 	const uint8_t *buf = mf_ptr(mf) - 1;

  00083	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0008b	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0008e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  0009e	48 89 44 24 30	 mov	 QWORD PTR buf$33378[rsp], rax

; 39   : 	const uint32_t buf_avail = my_min(mf_avail(mf) + 1, MATCH_LEN_MAX);

  000a3	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  000ab	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000b3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000b6	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  000b9	2b c1		 sub	 eax, ecx
  000bb	83 c0 01	 add	 eax, 1
  000be	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  000c3	73 24		 jae	 SHORT $LN33@lzma_lzma_@3
  000c5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  000cd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000d5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000d8	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  000db	2b c1		 sub	 eax, ecx
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv84[rsp], eax
  000e7	eb 0b		 jmp	 SHORT $LN34@lzma_lzma_@3
$LN33@lzma_lzma_@3:
  000e9	c7 84 24 80 00
	00 00 11 01 00
	00		 mov	 DWORD PTR tv84[rsp], 273 ; 00000111H
$LN34@lzma_lzma_@3:
  000f4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv84[rsp]
  000fb	89 44 24 38	 mov	 DWORD PTR buf_avail$33379[rsp], eax

; 40   : 
; 41   : 	if (buf_avail < 2) {

  000ff	83 7c 24 38 02	 cmp	 DWORD PTR buf_avail$33379[rsp], 2
  00104	73 21		 jae	 SHORT $LN28@lzma_lzma_@3

; 42   : 		// There's not enough input left to encode a match.
; 43   : 		*back_res = UINT32_MAX;

  00106	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  0010e	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 44   : 		*len_res = 1;

  00114	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  0011c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 45   : 		return;

  00122	e9 0b 06 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN28@lzma_lzma_@3:

; 46   : 	}
; 47   : 
; 48   : 	// Look for repeated matches; scan the previous four match distances
; 49   :   {
; 50   : 	uint32_t rep_len = 0;

  00127	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rep_len$33381[rsp], 0

; 51   : 	uint32_t rep_index = 0;

  0012f	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rep_index$33382[rsp], 0

; 52   : 	uint32_t i;
; 53   : 
; 54   : 	for (i = 0; i < REPS; ++i) {

  00137	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$33383[rsp], 0
  0013f	eb 0b		 jmp	 SHORT $LN27@lzma_lzma_@3
$LN26@lzma_lzma_@3:
  00141	8b 44 24 3c	 mov	 eax, DWORD PTR i$33383[rsp]
  00145	83 c0 01	 add	 eax, 1
  00148	89 44 24 3c	 mov	 DWORD PTR i$33383[rsp], eax
$LN27@lzma_lzma_@3:
  0014c	83 7c 24 3c 04	 cmp	 DWORD PTR i$33383[rsp], 4
  00151	0f 83 6e 01 00
	00		 jae	 $LN25@lzma_lzma_@3

; 55   : 		// Pointer to the beginning of the match candidate
; 56   : 		const uint8_t *const buf_back = buf - coder->reps[i] - 1;

  00157	8b 4c 24 3c	 mov	 ecx, DWORD PTR i$33383[rsp]
  0015b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00163	8b 8c 88 e4 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*4+740]
  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$33378[rsp]
  0016f	48 2b c1	 sub	 rax, rcx
  00172	48 83 e8 01	 sub	 rax, 1
  00176	48 89 44 24 48	 mov	 QWORD PTR buf_back$33387[rsp], rax

; 57   : 
; 58   : 		// If the first two bytes (2 == MATCH_LEN_MIN) do not match,
; 59   : 		// this rep is not useful.
; 60   : 		if (not_equal_16(buf, buf_back))

  0017b	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$33378[rsp]
  00180	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00183	48 8b 44 24 48	 mov	 rax, QWORD PTR buf_back$33387[rsp]
  00188	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0018b	3b c8		 cmp	 ecx, eax
  0018d	74 02		 je	 SHORT $LN24@lzma_lzma_@3

; 61   : 			continue;

  0018f	eb b0		 jmp	 SHORT $LN26@lzma_lzma_@3
$LN24@lzma_lzma_@3:

; 62   : 
; 63   : 		// The first two bytes matched.
; 64   : 		// Calculate the length of the match.
; 65   : 	  { const uint32_t len = lzma_memcmplen(
; 66   : 				buf, buf_back, 2, buf_avail);

  00191	c7 44 24 6c 02
	00 00 00	 mov	 DWORD PTR $T80231[rsp], 2
$LN45@lzma_lzma_@3:
  00199	8b 44 24 38	 mov	 eax, DWORD PTR buf_avail$33379[rsp]
  0019d	39 44 24 6c	 cmp	 DWORD PTR $T80231[rsp], eax
  001a1	0f 83 88 00 00
	00		 jae	 $LN44@lzma_lzma_@3
  001a7	44 8b 44 24 6c	 mov	 r8d, DWORD PTR $T80231[rsp]
  001ac	8b 54 24 6c	 mov	 edx, DWORD PTR $T80231[rsp]
  001b0	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$33378[rsp]
  001b5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf_back$33387[rsp]
  001ba	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001be	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  001c2	48 2b c1	 sub	 rax, rcx
  001c5	48 89 44 24 60	 mov	 QWORD PTR x$80228[rsp], rax
  001ca	48 83 7c 24 60
	00		 cmp	 QWORD PTR x$80228[rsp], 0
  001d0	74 4d		 je	 SHORT $LN43@lzma_lzma_@3
  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR x$80228[rsp]
  001d7	48 0f bc c0	 bsf	 rax, rax
  001db	89 44 24 68	 mov	 DWORD PTR tmp$80230[rsp], eax
  001df	8b 4c 24 68	 mov	 ecx, DWORD PTR tmp$80230[rsp]
  001e3	c1 e9 03	 shr	 ecx, 3
  001e6	8b 44 24 6c	 mov	 eax, DWORD PTR $T80231[rsp]
  001ea	03 c1		 add	 eax, ecx
  001ec	89 44 24 6c	 mov	 DWORD PTR $T80231[rsp], eax
  001f0	8b 44 24 38	 mov	 eax, DWORD PTR buf_avail$33379[rsp]
  001f4	39 44 24 6c	 cmp	 DWORD PTR $T80231[rsp], eax
  001f8	73 0d		 jae	 SHORT $LN48@lzma_lzma_@3
  001fa	8b 44 24 6c	 mov	 eax, DWORD PTR $T80231[rsp]
  001fe	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv277[rsp], eax
  00205	eb 0b		 jmp	 SHORT $LN49@lzma_lzma_@3
$LN48@lzma_lzma_@3:
  00207	8b 44 24 38	 mov	 eax, DWORD PTR buf_avail$33379[rsp]
  0020b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv277[rsp], eax
$LN49@lzma_lzma_@3:
  00212	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv277[rsp]
  00219	89 44 24 50	 mov	 DWORD PTR len$33391[rsp], eax
  0021d	eb 18		 jmp	 SHORT $LN46@lzma_lzma_@3
$LN43@lzma_lzma_@3:
  0021f	8b 44 24 6c	 mov	 eax, DWORD PTR $T80231[rsp]
  00223	83 c0 08	 add	 eax, 8
  00226	89 44 24 6c	 mov	 DWORD PTR $T80231[rsp], eax
  0022a	e9 6a ff ff ff	 jmp	 $LN45@lzma_lzma_@3
$LN44@lzma_lzma_@3:
  0022f	8b 44 24 38	 mov	 eax, DWORD PTR buf_avail$33379[rsp]
  00233	89 44 24 50	 mov	 DWORD PTR len$33391[rsp], eax
$LN46@lzma_lzma_@3:

; 67   : 
; 68   : 		// If we have found a repeated match that is at least
; 69   : 		// nice_len long, return it immediately.
; 70   : 		if (len >= nice_len) {

  00237	8b 44 24 28	 mov	 eax, DWORD PTR nice_len$[rsp]
  0023b	39 44 24 50	 cmp	 DWORD PTR len$33391[rsp], eax
  0023f	72 65		 jb	 SHORT $LN23@lzma_lzma_@3

; 71   : 			*back_res = i;

  00241	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR back_res$[rsp]
  00249	8b 44 24 3c	 mov	 eax, DWORD PTR i$33383[rsp]
  0024d	89 01		 mov	 DWORD PTR [rcx], eax

; 72   : 			*len_res = len;

  0024f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  00257	8b 44 24 50	 mov	 eax, DWORD PTR len$33391[rsp]
  0025b	89 01		 mov	 DWORD PTR [rcx], eax

; 73   : 			mf_skip(mf, len - 1);

  0025d	8b 44 24 50	 mov	 eax, DWORD PTR len$33391[rsp]
  00261	83 e8 01	 sub	 eax, 1
  00264	89 44 24 70	 mov	 DWORD PTR $T80236[rsp], eax
  00268	83 7c 24 70 00	 cmp	 DWORD PTR $T80236[rsp], 0
  0026d	74 32		 je	 SHORT $LN50@lzma_lzma_@3
  0026f	8b 54 24 70	 mov	 edx, DWORD PTR $T80236[rsp]
  00273	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0027b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00283	ff 50 38	 call	 QWORD PTR [rax+56]
  00286	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  0028e	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  00292	03 4c 24 70	 add	 ecx, DWORD PTR $T80236[rsp]
  00296	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0029e	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN50@lzma_lzma_@3:

; 74   : 			return;

  002a1	e9 8c 04 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN23@lzma_lzma_@3:

; 75   : 		}
; 76   : 
; 77   : 		if (len > rep_len) {

  002a6	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  002aa	39 44 24 50	 cmp	 DWORD PTR len$33391[rsp], eax
  002ae	76 10		 jbe	 SHORT $LN22@lzma_lzma_@3

; 78   : 			rep_index = i;

  002b0	8b 44 24 3c	 mov	 eax, DWORD PTR i$33383[rsp]
  002b4	89 44 24 44	 mov	 DWORD PTR rep_index$33382[rsp], eax

; 79   : 			rep_len = len;

  002b8	8b 44 24 50	 mov	 eax, DWORD PTR len$33391[rsp]
  002bc	89 44 24 40	 mov	 DWORD PTR rep_len$33381[rsp], eax
$LN22@lzma_lzma_@3:

; 80   : 		}
; 81   : 	  }
; 82   : 	}

  002c0	e9 7c fe ff ff	 jmp	 $LN26@lzma_lzma_@3
$LN25@lzma_lzma_@3:

; 83   : 
; 84   : 	// We didn't find a long enough repeated match. Encode it as a normal
; 85   : 	// match if the match length is at least nice_len.
; 86   : 	if (len_main >= nice_len) {

  002c5	8b 44 24 28	 mov	 eax, DWORD PTR nice_len$[rsp]
  002c9	39 44 24 24	 cmp	 DWORD PTR len_main$[rsp], eax
  002cd	72 7c		 jb	 SHORT $LN21@lzma_lzma_@3

; 87   : 		*back_res = coder->matches[matches_count - 1].dist + REPS;

  002cf	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  002d3	83 e8 01	 sub	 eax, 1
  002d6	8b c8		 mov	 ecx, eax
  002d8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002e0	8b 8c c8 f8 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*8+760]
  002e7	83 c1 04	 add	 ecx, 4
  002ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  002f2	89 08		 mov	 DWORD PTR [rax], ecx

; 88   : 		*len_res = len_main;

  002f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  002fc	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  00300	89 01		 mov	 DWORD PTR [rcx], eax

; 89   : 		mf_skip(mf, len_main - 1);

  00302	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  00306	83 e8 01	 sub	 eax, 1
  00309	89 44 24 74	 mov	 DWORD PTR $T80241[rsp], eax
  0030d	83 7c 24 74 00	 cmp	 DWORD PTR $T80241[rsp], 0
  00312	74 32		 je	 SHORT $LN53@lzma_lzma_@3
  00314	8b 54 24 74	 mov	 edx, DWORD PTR $T80241[rsp]
  00318	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00320	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00328	ff 50 38	 call	 QWORD PTR [rax+56]
  0032b	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  00333	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  00337	03 4c 24 74	 add	 ecx, DWORD PTR $T80241[rsp]
  0033b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00343	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN53@lzma_lzma_@3:

; 90   : 		return;

  00346	e9 e7 03 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN21@lzma_lzma_@3:

; 91   : 	}
; 92   : 
; 93   :   { uint32_t back_main = 0;

  0034b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR back_main$33395[rsp], 0

; 94   : 	if (len_main >= 2) {

  00353	83 7c 24 24 02	 cmp	 DWORD PTR len_main$[rsp], 2
  00358	0f 82 cc 00 00
	00		 jb	 $LN20@lzma_lzma_@3

; 95   : 		back_main = coder->matches[matches_count - 1].dist;

  0035e	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  00362	83 e8 01	 sub	 eax, 1
  00365	8b c8		 mov	 ecx, eax
  00367	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0036f	8b 84 c8 f8 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+760]
  00376	89 44 24 54	 mov	 DWORD PTR back_main$33395[rsp], eax
$LN19@lzma_lzma_@3:

; 96   : 
; 97   : 		while (matches_count > 1 && len_main ==
; 98   : 				coder->matches[matches_count - 2].len + 1) {

  0037a	83 7c 24 20 01	 cmp	 DWORD PTR matches_count$[rsp], 1
  0037f	0f 86 8c 00 00
	00		 jbe	 $LN18@lzma_lzma_@3
  00385	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  00389	83 e8 02	 sub	 eax, 2
  0038c	8b c8		 mov	 ecx, eax
  0038e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00396	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  0039d	83 c0 01	 add	 eax, 1
  003a0	39 44 24 24	 cmp	 DWORD PTR len_main$[rsp], eax
  003a4	75 6b		 jne	 SHORT $LN18@lzma_lzma_@3

; 99   : 			if (!change_pair(coder->matches[
; 100  : 						matches_count - 2].dist,
; 101  : 					back_main))

  003a6	8b 54 24 54	 mov	 edx, DWORD PTR back_main$33395[rsp]
  003aa	c1 ea 07	 shr	 edx, 7
  003ad	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  003b1	83 e8 02	 sub	 eax, 2
  003b4	8b c8		 mov	 ecx, eax
  003b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003be	3b 94 c8 f8 02
	00 00		 cmp	 edx, DWORD PTR [rax+rcx*8+760]
  003c5	77 02		 ja	 SHORT $LN17@lzma_lzma_@3

; 102  : 				break;

  003c7	eb 48		 jmp	 SHORT $LN18@lzma_lzma_@3
$LN17@lzma_lzma_@3:

; 103  : 
; 104  : 			--matches_count;

  003c9	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  003cd	83 e8 01	 sub	 eax, 1
  003d0	89 44 24 20	 mov	 DWORD PTR matches_count$[rsp], eax

; 105  : 			len_main = coder->matches[matches_count - 1].len;

  003d4	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  003d8	83 e8 01	 sub	 eax, 1
  003db	8b c8		 mov	 ecx, eax
  003dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003e5	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  003ec	89 44 24 24	 mov	 DWORD PTR len_main$[rsp], eax

; 106  : 			back_main = coder->matches[matches_count - 1].dist;

  003f0	8b 44 24 20	 mov	 eax, DWORD PTR matches_count$[rsp]
  003f4	83 e8 01	 sub	 eax, 1
  003f7	8b c8		 mov	 ecx, eax
  003f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00401	8b 84 c8 f8 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+760]
  00408	89 44 24 54	 mov	 DWORD PTR back_main$33395[rsp], eax

; 107  : 		}

  0040c	e9 69 ff ff ff	 jmp	 $LN19@lzma_lzma_@3
$LN18@lzma_lzma_@3:

; 108  : 
; 109  : 		if (len_main == 2 && back_main >= 0x80)

  00411	83 7c 24 24 02	 cmp	 DWORD PTR len_main$[rsp], 2
  00416	75 12		 jne	 SHORT $LN16@lzma_lzma_@3
  00418	81 7c 24 54 80
	00 00 00	 cmp	 DWORD PTR back_main$33395[rsp], 128 ; 00000080H
  00420	72 08		 jb	 SHORT $LN16@lzma_lzma_@3

; 110  : 			len_main = 1;

  00422	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR len_main$[rsp], 1
$LN16@lzma_lzma_@3:
$LN20@lzma_lzma_@3:

; 111  : 	}
; 112  : 
; 113  : 	if (rep_len >= 2) {

  0042a	83 7c 24 40 02	 cmp	 DWORD PTR rep_len$33381[rsp], 2
  0042f	0f 82 a0 00 00
	00		 jb	 $LN15@lzma_lzma_@3

; 114  : 		if (rep_len + 1 >= len_main
; 115  : 				|| (rep_len + 2 >= len_main
; 116  : 					&& back_main > (UINT32_C(1) << 9))
; 117  : 				|| (rep_len + 3 >= len_main
; 118  : 					&& back_main > (UINT32_C(1) << 15))) {

  00435	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  00439	83 c0 01	 add	 eax, 1
  0043c	3b 44 24 24	 cmp	 eax, DWORD PTR len_main$[rsp]
  00440	73 2e		 jae	 SHORT $LN13@lzma_lzma_@3
  00442	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  00446	83 c0 02	 add	 eax, 2
  00449	3b 44 24 24	 cmp	 eax, DWORD PTR len_main$[rsp]
  0044d	72 0a		 jb	 SHORT $LN12@lzma_lzma_@3
  0044f	81 7c 24 54 00
	02 00 00	 cmp	 DWORD PTR back_main$33395[rsp], 512 ; 00000200H
  00457	77 17		 ja	 SHORT $LN13@lzma_lzma_@3
$LN12@lzma_lzma_@3:
  00459	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  0045d	83 c0 03	 add	 eax, 3
  00460	3b 44 24 24	 cmp	 eax, DWORD PTR len_main$[rsp]
  00464	72 6f		 jb	 SHORT $LN14@lzma_lzma_@3
  00466	81 7c 24 54 00
	80 00 00	 cmp	 DWORD PTR back_main$33395[rsp], 32768 ; 00008000H
  0046e	76 65		 jbe	 SHORT $LN14@lzma_lzma_@3
$LN13@lzma_lzma_@3:

; 119  : 			*back_res = rep_index;

  00470	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR back_res$[rsp]
  00478	8b 44 24 44	 mov	 eax, DWORD PTR rep_index$33382[rsp]
  0047c	89 01		 mov	 DWORD PTR [rcx], eax

; 120  : 			*len_res = rep_len;

  0047e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  00486	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  0048a	89 01		 mov	 DWORD PTR [rcx], eax

; 121  : 			mf_skip(mf, rep_len - 1);

  0048c	8b 44 24 40	 mov	 eax, DWORD PTR rep_len$33381[rsp]
  00490	83 e8 01	 sub	 eax, 1
  00493	89 44 24 78	 mov	 DWORD PTR $T80246[rsp], eax
  00497	83 7c 24 78 00	 cmp	 DWORD PTR $T80246[rsp], 0
  0049c	74 32		 je	 SHORT $LN56@lzma_lzma_@3
  0049e	8b 54 24 78	 mov	 edx, DWORD PTR $T80246[rsp]
  004a2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  004aa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004b2	ff 50 38	 call	 QWORD PTR [rax+56]
  004b5	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  004bd	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  004c1	03 4c 24 78	 add	 ecx, DWORD PTR $T80246[rsp]
  004c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  004cd	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN56@lzma_lzma_@3:

; 122  : 			return;

  004d0	e9 5d 02 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN14@lzma_lzma_@3:
$LN15@lzma_lzma_@3:

; 123  : 		}
; 124  : 	}
; 125  : 
; 126  : 	if (len_main < 2 || buf_avail <= 2) {

  004d5	83 7c 24 24 02	 cmp	 DWORD PTR len_main$[rsp], 2
  004da	72 07		 jb	 SHORT $LN10@lzma_lzma_@3
  004dc	83 7c 24 38 02	 cmp	 DWORD PTR buf_avail$33379[rsp], 2
  004e1	77 21		 ja	 SHORT $LN11@lzma_lzma_@3
$LN10@lzma_lzma_@3:

; 127  : 		*back_res = UINT32_MAX;

  004e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  004eb	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 128  : 		*len_res = 1;

  004f1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  004f9	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 129  : 		return;

  004ff	e9 2e 02 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN11@lzma_lzma_@3:

; 130  : 	}
; 131  : 
; 132  : 	// Get the matches for the next byte. If we find a better match,
; 133  : 	// the current byte is encoded as a literal.
; 134  : 	coder->longest_match_length = mf_find(mf,
; 135  : 			&coder->matches_count, coder->matches);

  00504	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR coder$[rsp]
  0050c	49 81 c0 f4 02
	00 00		 add	 r8, 756			; 000002f4H
  00513	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  0051b	48 81 c2 84 0b
	00 00		 add	 rdx, 2948		; 00000b84H
  00522	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0052a	e8 00 00 00 00	 call	 lzma_mf_find
  0052f	44 8b d8	 mov	 r11d, eax
  00532	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0053a	44 89 98 88 0b
	00 00		 mov	 DWORD PTR [rax+2952], r11d

; 136  : 
; 137  : 	if (coder->longest_match_length >= 2) {

  00541	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00549	83 b8 88 0b 00
	00 02		 cmp	 DWORD PTR [rax+2952], 2
  00550	0f 82 cb 00 00
	00		 jb	 $LN9@lzma_lzma_@3

; 138  : 		const uint32_t new_dist = coder->matches[
; 139  : 				coder->matches_count - 1].dist;

  00556	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0055e	8b 80 84 0b 00
	00		 mov	 eax, DWORD PTR [rax+2948]
  00564	83 e8 01	 sub	 eax, 1
  00567	8b c8		 mov	 ecx, eax
  00569	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00571	8b 84 c8 f8 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+760]
  00578	89 44 24 58	 mov	 DWORD PTR new_dist$33409[rsp], eax

; 140  : 
; 141  : 		if ((coder->longest_match_length >= len_main
; 142  : 					&& new_dist < back_main)
; 143  : 				|| (coder->longest_match_length == len_main + 1
; 144  : 					&& !change_pair(back_main, new_dist))
; 145  : 				|| (coder->longest_match_length > len_main + 1)
; 146  : 				|| (coder->longest_match_length + 1 >= len_main
; 147  : 					&& len_main >= 3
; 148  : 					&& change_pair(new_dist, back_main))) {

  0057c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00584	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  00588	39 81 88 0b 00
	00		 cmp	 DWORD PTR [rcx+2952], eax
  0058e	72 0a		 jb	 SHORT $LN6@lzma_lzma_@3
  00590	8b 44 24 54	 mov	 eax, DWORD PTR back_main$33395[rsp]
  00594	39 44 24 58	 cmp	 DWORD PTR new_dist$33409[rsp], eax
  00598	72 66		 jb	 SHORT $LN7@lzma_lzma_@3
$LN6@lzma_lzma_@3:
  0059a	8b 4c 24 24	 mov	 ecx, DWORD PTR len_main$[rsp]
  0059e	83 c1 01	 add	 ecx, 1
  005a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005a9	39 88 88 0b 00
	00		 cmp	 DWORD PTR [rax+2952], ecx
  005af	75 0d		 jne	 SHORT $LN5@lzma_lzma_@3
  005b1	8b 44 24 58	 mov	 eax, DWORD PTR new_dist$33409[rsp]
  005b5	c1 e8 07	 shr	 eax, 7
  005b8	3b 44 24 54	 cmp	 eax, DWORD PTR back_main$33395[rsp]
  005bc	76 42		 jbe	 SHORT $LN7@lzma_lzma_@3
$LN5@lzma_lzma_@3:
  005be	8b 4c 24 24	 mov	 ecx, DWORD PTR len_main$[rsp]
  005c2	83 c1 01	 add	 ecx, 1
  005c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005cd	39 88 88 0b 00
	00		 cmp	 DWORD PTR [rax+2952], ecx
  005d3	77 2b		 ja	 SHORT $LN7@lzma_lzma_@3
  005d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005dd	8b 80 88 0b 00
	00		 mov	 eax, DWORD PTR [rax+2952]
  005e3	83 c0 01	 add	 eax, 1
  005e6	3b 44 24 24	 cmp	 eax, DWORD PTR len_main$[rsp]
  005ea	72 35		 jb	 SHORT $LN8@lzma_lzma_@3
  005ec	83 7c 24 24 03	 cmp	 DWORD PTR len_main$[rsp], 3
  005f1	72 2e		 jb	 SHORT $LN8@lzma_lzma_@3
  005f3	8b 44 24 54	 mov	 eax, DWORD PTR back_main$33395[rsp]
  005f7	c1 e8 07	 shr	 eax, 7
  005fa	3b 44 24 58	 cmp	 eax, DWORD PTR new_dist$33409[rsp]
  005fe	76 21		 jbe	 SHORT $LN8@lzma_lzma_@3
$LN7@lzma_lzma_@3:

; 149  : 			*back_res = UINT32_MAX;

  00600	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  00608	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 150  : 			*len_res = 1;

  0060e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  00616	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 151  : 			return;

  0061c	e9 11 01 00 00	 jmp	 $LN31@lzma_lzma_@3
$LN8@lzma_lzma_@3:
$LN9@lzma_lzma_@3:

; 152  : 		}
; 153  : 	}
; 154  : 
; 155  : 	// In contrast to LZMA SDK, dictionary could not have been moved
; 156  : 	// between mf_find() calls, thus it is safe to just increment
; 157  : 	// the old buf pointer instead of recalculating it with mf_ptr().
; 158  : 	++buf;

  00621	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$33378[rsp]
  00626	48 83 c0 01	 add	 rax, 1
  0062a	48 89 44 24 30	 mov	 QWORD PTR buf$33378[rsp], rax

; 159  : 
; 160  :   {
; 161  : 	const uint32_t limit = my_max(2, len_main - 1);

  0062f	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  00633	83 e8 01	 sub	 eax, 1
  00636	83 f8 02	 cmp	 eax, 2
  00639	73 0d		 jae	 SHORT $LN35@lzma_lzma_@3
  0063b	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv239[rsp], 2
  00646	eb 0e		 jmp	 SHORT $LN36@lzma_lzma_@3
$LN35@lzma_lzma_@3:
  00648	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  0064c	83 e8 01	 sub	 eax, 1
  0064f	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv239[rsp], eax
$LN36@lzma_lzma_@3:
  00656	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv239[rsp]
  0065d	89 44 24 5c	 mov	 DWORD PTR limit$33414[rsp], eax

; 162  : 
; 163  : 	for (i = 0; i < REPS; ++i) {

  00661	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$33383[rsp], 0
  00669	eb 0b		 jmp	 SHORT $LN4@lzma_lzma_@3
$LN3@lzma_lzma_@3:
  0066b	8b 44 24 3c	 mov	 eax, DWORD PTR i$33383[rsp]
  0066f	83 c0 01	 add	 eax, 1
  00672	89 44 24 3c	 mov	 DWORD PTR i$33383[rsp], eax
$LN4@lzma_lzma_@3:
  00676	83 7c 24 3c 04	 cmp	 DWORD PTR i$33383[rsp], 4
  0067b	73 52		 jae	 SHORT $LN2@lzma_lzma_@3

; 164  : 		if (memcmp(buf, buf - coder->reps[i] - 1, limit) == 0) {

  0067d	44 8b 44 24 5c	 mov	 r8d, DWORD PTR limit$33414[rsp]
  00682	8b 4c 24 3c	 mov	 ecx, DWORD PTR i$33383[rsp]
  00686	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0068e	8b 84 88 e4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+740]
  00695	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$33378[rsp]
  0069a	48 2b d0	 sub	 rdx, rax
  0069d	48 83 ea 01	 sub	 rdx, 1
  006a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$33378[rsp]
  006a6	e8 00 00 00 00	 call	 memcmp
  006ab	85 c0		 test	 eax, eax
  006ad	75 1e		 jne	 SHORT $LN1@lzma_lzma_@3

; 165  : 			*back_res = UINT32_MAX;

  006af	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  006b7	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 166  : 			*len_res = 1;

  006bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  006c5	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 167  : 			return;

  006cb	eb 65		 jmp	 SHORT $LN31@lzma_lzma_@3
$LN1@lzma_lzma_@3:

; 168  : 		}
; 169  : 	}

  006cd	eb 9c		 jmp	 SHORT $LN3@lzma_lzma_@3
$LN2@lzma_lzma_@3:

; 170  :   }
; 171  : 
; 172  : 	*back_res = back_main + REPS;

  006cf	8b 4c 24 54	 mov	 ecx, DWORD PTR back_main$33395[rsp]
  006d3	83 c1 04	 add	 ecx, 4
  006d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  006de	89 08		 mov	 DWORD PTR [rax], ecx

; 173  :   }}}
; 174  : 	*len_res = len_main;

  006e0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  006e8	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  006ec	89 01		 mov	 DWORD PTR [rcx], eax

; 175  : 	mf_skip(mf, len_main - 2);

  006ee	8b 44 24 24	 mov	 eax, DWORD PTR len_main$[rsp]
  006f2	83 e8 02	 sub	 eax, 2
  006f5	89 44 24 7c	 mov	 DWORD PTR $T80251[rsp], eax
  006f9	83 7c 24 7c 00	 cmp	 DWORD PTR $T80251[rsp], 0
  006fe	74 32		 je	 SHORT $LN59@lzma_lzma_@3
  00700	8b 54 24 7c	 mov	 edx, DWORD PTR $T80251[rsp]
  00704	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0070c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00714	ff 50 38	 call	 QWORD PTR [rax+56]
  00717	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  0071f	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  00723	03 4c 24 7c	 add	 ecx, DWORD PTR $T80251[rsp]
  00727	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0072f	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN59@lzma_lzma_@3:
$LN31@lzma_lzma_@3:

; 176  : 	return;
; 177  : }

  00732	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00739	c3		 ret	 0
lzma_lzma_optimum_fast ENDP
END
