; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_decoder.c
pdata	SEGMENT
$pdata$index_decoder_memconfig DD imagerel index_decoder_memconfig
	DD	imagerel index_decoder_memconfig+132
	DD	imagerel $unwind$index_decoder_memconfig
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_decoder_memconfig DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_decoder_memconfig
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
memusage$ = 72
old_memlimit$ = 80
new_memlimit$ = 88
index_decoder_memconfig PROC				; COMDAT

; 224  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 225  : 	lzma_index_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 226  : 
; 227  : 	*memusage = lzma_index_memusage(1, coder->count);

  00022	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$[rsp]
  00027	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0002b	b9 01 00 00 00	 mov	 ecx, 1
  00030	e8 00 00 00 00	 call	 lzma_index_memusage
  00035	4c 8b d8	 mov	 r11, rax
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR memusage$[rsp]
  0003d	4c 89 18	 mov	 QWORD PTR [rax], r11

; 228  : 	*old_memlimit = coder->memlimit;

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR old_memlimit$[rsp]
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0004a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 229  : 
; 230  : 	if (new_memlimit != 0) {

  00051	48 83 7c 24 58
	00		 cmp	 QWORD PTR new_memlimit$[rsp], 0
  00057	74 24		 je	 SHORT $LN2@index_deco

; 231  : 		if (new_memlimit < *memusage)

  00059	48 8b 44 24 48	 mov	 rax, QWORD PTR memusage$[rsp]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 39 44 24 58	 cmp	 QWORD PTR new_memlimit$[rsp], rax
  00066	73 07		 jae	 SHORT $LN1@index_deco

; 232  : 			return LZMA_MEMLIMIT_ERROR;

  00068	b8 06 00 00 00	 mov	 eax, 6
  0006d	eb 10		 jmp	 SHORT $LN3@index_deco
$LN1@index_deco:

; 233  : 
; 234  : 		coder->memlimit = new_memlimit;

  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00074	48 8b 44 24 58	 mov	 rax, QWORD PTR new_memlimit$[rsp]
  00079	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN2@index_deco:

; 235  : 	}
; 236  : 
; 237  : 	return LZMA_OK;

  0007d	33 c0		 xor	 eax, eax
$LN3@index_deco:

; 238  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
index_decoder_memconfig ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_decoder_reset DD imagerel index_decoder_reset
	DD	imagerel index_decoder_reset+190
	DD	imagerel $unwind$index_decoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_decoder_reset DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_decoder_reset
_TEXT	SEGMENT
tv72 = 32
coder$ = 64
allocator$ = 72
i$ = 80
memlimit$ = 88
index_decoder_reset PROC				; COMDAT

; 244  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 245  : 	// Remember the pointer given by the application. We will set it
; 246  : 	// to point to the decoded Index only if decoding is successful.
; 247  : 	// Before that, keep it NULL so that applications can always safely
; 248  : 	// pass it to lzma_index_end() no matter did decoding succeed or not.
; 249  : 	coder->index_ptr = i;

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00022	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 250  : 	*i = NULL;

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0002b	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 251  : 
; 252  : 	// We always allocate a new lzma_index.
; 253  : 	coder->index = lzma_index_init(allocator);

  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR allocator$[rsp]
  00037	e8 00 00 00 00	 call	 lzma_index_init
  0003c	4c 8b d8	 mov	 r11, rax
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00044	4c 89 58 10	 mov	 QWORD PTR [rax+16], r11

; 254  : 	if (coder->index == NULL)

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0004d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00052	75 07		 jne	 SHORT $LN1@index_deco@2

; 255  : 		return LZMA_MEM_ERROR;

  00054	b8 05 00 00 00	 mov	 eax, 5
  00059	eb 5e		 jmp	 SHORT $LN2@index_deco@2
$LN1@index_deco@2:

; 256  : 
; 257  : 	// Initialize the rest.
; 258  : 	coder->sequence = SEQ_INDICATOR;

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00060	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 259  : 	coder->memlimit = my_max(1, memlimit);

  00066	48 83 7c 24 58
	01		 cmp	 QWORD PTR memlimit$[rsp], 1
  0006c	73 0b		 jae	 SHORT $LN4@index_deco@2
  0006e	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR tv72[rsp], 1
  00077	eb 0a		 jmp	 SHORT $LN5@index_deco@2
$LN4@index_deco@2:
  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR memlimit$[rsp]
  0007e	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
$LN5@index_deco@2:
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR tv72[rsp]
  0008d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 260  : 	coder->count = 0; // Needs to be initialized due to _memconfig().

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00096	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 261  : 	coder->pos = 0;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000a3	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 262  : 	coder->crc32 = 0;

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000b0	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 263  : 
; 264  : 	return LZMA_OK;

  000b7	33 c0		 xor	 eax, eax
$LN2@index_deco@2:

; 265  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
index_decoder_reset ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_decoder_end DD imagerel index_decoder_end
	DD	imagerel index_decoder_end+63
	DD	imagerel $unwind$index_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
index_decoder_end PROC					; COMDAT

; 213  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 214  : 	lzma_index_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 215  : 	lzma_index_end(coder->index, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00026	e8 00 00 00 00	 call	 lzma_index_end

; 216  : 	lzma_free(coder, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_free

; 217  : 	return;
; 218  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
index_decoder_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_decode DD imagerel index_decode
	DD	imagerel index_decode+1292
	DD	imagerel $unwind$index_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_decode DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_decode
_TEXT	SEGMENT
ret$ = 48
in_start$ = 56
coder$ = 64
size$32948 = 72
ret_$32957 = 80
tv65 = 84
tv92 = 88
tv128 = 96
tv158 = 104
coder_ptr$ = 128
allocator$ = 136
in$ = 144
in_pos$ = 152
in_size$ = 160
out$ = 168
out_pos$ = 176
out_size$ = 184
action$ = 192
index_decode PROC					; COMDAT

; 64   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 65   : 	lzma_index_coder *coder = coder_ptr;

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00020	48 89 44 24 40	 mov	 QWORD PTR coder$[rsp], rax

; 66   : 
; 67   : 	// Similar optimization as in index_encoder.c
; 68   : 	const size_t in_start = *in_pos;

  00025	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 38	 mov	 QWORD PTR in_start$[rsp], rax

; 69   : 	lzma_ret ret = LZMA_OK;

  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN31@index_deco@3:

; 70   : 
; 71   : 	while (*in_pos < in_size)

  0003d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00045	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0004d	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00050	0f 83 4f 04 00
	00		 jae	 $LN30@index_deco@3

; 72   : 	switch (coder->sequence) {

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0005b	8b 00		 mov	 eax, DWORD PTR [rax]
  0005d	89 44 24 54	 mov	 DWORD PTR tv65[rsp], eax
  00061	83 7c 24 54 07	 cmp	 DWORD PTR tv65[rsp], 7
  00066	0f 87 2d 04 00
	00		 ja	 $LN1@index_deco@3
  0006c	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv65[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00078	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN40@index_deco@3[rcx+rax*4]
  0007f	48 03 c1	 add	 rax, rcx
  00082	ff e0		 jmp	 rax
$LN27@index_deco@3:

; 73   : 	case SEQ_INDICATOR:
; 74   : 		// Return LZMA_DATA_ERROR instead of e.g. LZMA_PROG_ERROR or
; 75   : 		// LZMA_FORMAT_ERROR, because a typical usage case for Index
; 76   : 		// decoder is when parsing the Stream backwards. If seeking
; 77   : 		// backward from the Stream Footer gives us something that
; 78   : 		// doesn't begin with Index Indicator, the file is considered
; 79   : 		// corrupt, not "programming error" or "unrecognized file
; 80   : 		// format". One could argue that the application should
; 81   : 		// verify the Index Indicator before trying to decode the
; 82   : 		// Index, but well, I suppose it is simpler this way.
; 83   : 		if (in[(*in_pos)++] != 0x00)

  00084	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0008c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00097	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0009b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a6	48 83 c1 01	 add	 rcx, 1
  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000b2	48 89 08	 mov	 QWORD PTR [rax], rcx
  000b5	85 d2		 test	 edx, edx
  000b7	74 0a		 je	 SHORT $LN26@index_deco@3

; 84   : 			return LZMA_DATA_ERROR;

  000b9	b8 09 00 00 00	 mov	 eax, 9
  000be	e9 23 04 00 00	 jmp	 $LN32@index_deco@3
$LN26@index_deco@3:

; 85   : 
; 86   : 		coder->sequence = SEQ_COUNT;

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000c8	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 87   : 		break;

  000ce	e9 cd 03 00 00	 jmp	 $LN28@index_deco@3
$LN25@index_deco@3:

; 88   : 
; 89   : 	case SEQ_COUNT:
; 90   : 		ret = lzma_vli_decode(&coder->count, &coder->pos,
; 91   : 				in, in_pos, in_size);

  000d3	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  000d8	48 83 c2 38	 add	 rdx, 56			; 00000038H
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  000e1	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000e5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f2	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  000fa	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00102	e8 00 00 00 00	 call	 lzma_vli_decode
  00107	89 44 24 30	 mov	 DWORD PTR ret$[rsp], eax

; 92   : 		if (ret != LZMA_STREAM_END)

  0010b	83 7c 24 30 01	 cmp	 DWORD PTR ret$[rsp], 1
  00110	74 05		 je	 SHORT $LN24@index_deco@3

; 93   : 			goto out;

  00112	e9 8e 03 00 00	 jmp	 $out$32944
$LN24@index_deco@3:

; 94   : 
; 95   : 		coder->pos = 0;

  00117	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0011c	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 96   : 		coder->sequence = SEQ_MEMUSAGE;

  00124	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00129	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN23@index_deco@3:

; 97   : 
; 98   : 	// Fall through
; 99   : 
; 100  : 	case SEQ_MEMUSAGE:
; 101  : 		if (lzma_index_memusage(1, coder->count) > coder->memlimit) {

  0012f	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  00134	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	e8 00 00 00 00	 call	 lzma_index_memusage
  00142	4c 8b d8	 mov	 r11, rax
  00145	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0014a	4c 3b 58 08	 cmp	 r11, QWORD PTR [rax+8]
  0014e	76 0d		 jbe	 SHORT $LN22@index_deco@3

; 102  : 			ret = LZMA_MEMLIMIT_ERROR;

  00150	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR ret$[rsp], 6

; 103  : 			goto out;

  00158	e9 48 03 00 00	 jmp	 $out$32944
$LN22@index_deco@3:

; 104  : 		}
; 105  : 
; 106  : 		// Tell the Index handling code how many Records this
; 107  : 		// Index has to allow it to allocate memory more efficiently.
; 108  : 		lzma_index_prealloc(coder->index, coder->count);

  0015d	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  00162	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00166	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0016b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0016f	e8 00 00 00 00	 call	 lzma_index_prealloc

; 109  : 
; 110  : 		ret = LZMA_OK;

  00174	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 111  : 		coder->sequence = coder->count == 0
; 112  : 				? SEQ_PADDING_INIT : SEQ_UNPADDED;

  0017c	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00181	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00186	75 0a		 jne	 SHORT $LN34@index_deco@3
  00188	c7 44 24 58 05
	00 00 00	 mov	 DWORD PTR tv92[rsp], 5
  00190	eb 08		 jmp	 SHORT $LN35@index_deco@3
$LN34@index_deco@3:
  00192	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR tv92[rsp], 3
$LN35@index_deco@3:
  0019a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0019f	8b 44 24 58	 mov	 eax, DWORD PTR tv92[rsp]
  001a3	89 01		 mov	 DWORD PTR [rcx], eax

; 113  : 		break;

  001a5	e9 f6 02 00 00	 jmp	 $LN28@index_deco@3
$LN21@index_deco@3:

; 114  : 
; 115  : 	case SEQ_UNPADDED:
; 116  : 	case SEQ_UNCOMPRESSED: {
; 117  : 		lzma_vli *size = coder->sequence == SEQ_UNPADDED
; 118  : 				? &coder->unpadded_size
; 119  : 				: &coder->uncompressed_size;

  001aa	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001af	83 38 03	 cmp	 DWORD PTR [rax], 3
  001b2	75 10		 jne	 SHORT $LN36@index_deco@3
  001b4	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001b9	48 83 c0 28	 add	 rax, 40			; 00000028H
  001bd	48 89 44 24 60	 mov	 QWORD PTR tv128[rsp], rax
  001c2	eb 0e		 jmp	 SHORT $LN37@index_deco@3
$LN36@index_deco@3:
  001c4	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001c9	48 83 c0 30	 add	 rax, 48			; 00000030H
  001cd	48 89 44 24 60	 mov	 QWORD PTR tv128[rsp], rax
$LN37@index_deco@3:
  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR tv128[rsp]
  001d7	48 89 44 24 48	 mov	 QWORD PTR size$32948[rsp], rax

; 120  : 
; 121  : 		ret = lzma_vli_decode(size, &coder->pos,
; 122  : 				in, in_pos, in_size);

  001dc	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  001e1	48 83 c2 38	 add	 rdx, 56			; 00000038H
  001e5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f2	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  001fa	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00202	48 8b 4c 24 48	 mov	 rcx, QWORD PTR size$32948[rsp]
  00207	e8 00 00 00 00	 call	 lzma_vli_decode
  0020c	89 44 24 30	 mov	 DWORD PTR ret$[rsp], eax

; 123  : 		if (ret != LZMA_STREAM_END)

  00210	83 7c 24 30 01	 cmp	 DWORD PTR ret$[rsp], 1
  00215	74 05		 je	 SHORT $LN20@index_deco@3

; 124  : 			goto out;

  00217	e9 89 02 00 00	 jmp	 $out$32944
$LN20@index_deco@3:

; 125  : 
; 126  : 		ret = LZMA_OK;

  0021c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 127  : 		coder->pos = 0;

  00224	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00229	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 128  : 
; 129  : 		if (coder->sequence == SEQ_UNPADDED) {

  00231	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00236	83 38 03	 cmp	 DWORD PTR [rax], 3
  00239	75 3b		 jne	 SHORT $LN19@index_deco@3

; 130  : 			// Validate that encoded Unpadded Size isn't too small
; 131  : 			// or too big.
; 132  : 			if (coder->unpadded_size < UNPADDED_SIZE_MIN
; 133  : 					|| coder->unpadded_size
; 134  : 						> UNPADDED_SIZE_MAX)

  0023b	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00240	48 83 78 28 05	 cmp	 QWORD PTR [rax+40], 5
  00245	72 15		 jb	 SHORT $LN17@index_deco@3
  00247	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0024c	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  00256	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0025a	76 0a		 jbe	 SHORT $LN18@index_deco@3
$LN17@index_deco@3:

; 135  : 				return LZMA_DATA_ERROR;

  0025c	b8 09 00 00 00	 mov	 eax, 9
  00261	e9 80 02 00 00	 jmp	 $LN32@index_deco@3
$LN18@index_deco@3:

; 136  : 
; 137  : 			coder->sequence = SEQ_UNCOMPRESSED;

  00266	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0026b	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 138  : 		} else {

  00271	e9 81 00 00 00	 jmp	 $LN16@index_deco@3
$LN19@index_deco@3:
$LN15@index_deco@3:

; 139  : 			// Add the decoded Record to the Index.
; 140  : 			return_if_error(lzma_index_append(
; 141  : 					coder->index, allocator,
; 142  : 					coder->unpadded_size,
; 143  : 					coder->uncompressed_size));

  00276	4c 8b 4c 24 40	 mov	 r9, QWORD PTR coder$[rsp]
  0027b	4d 8b 49 30	 mov	 r9, QWORD PTR [r9+48]
  0027f	4c 8b 44 24 40	 mov	 r8, QWORD PTR coder$[rsp]
  00284	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  00288	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00290	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00295	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00299	e8 00 00 00 00	 call	 lzma_index_append
  0029e	89 44 24 50	 mov	 DWORD PTR ret_$32957[rsp], eax
  002a2	83 7c 24 50 00	 cmp	 DWORD PTR ret_$32957[rsp], 0
  002a7	74 09		 je	 SHORT $LN12@index_deco@3
  002a9	8b 44 24 50	 mov	 eax, DWORD PTR ret_$32957[rsp]
  002ad	e9 34 02 00 00	 jmp	 $LN32@index_deco@3
$LN12@index_deco@3:
  002b2	33 c0		 xor	 eax, eax
  002b4	85 c0		 test	 eax, eax
  002b6	75 be		 jne	 SHORT $LN15@index_deco@3

; 144  : 
; 145  : 			// Check if this was the last Record.
; 146  : 			coder->sequence = --coder->count == 0
; 147  : 					? SEQ_PADDING_INIT
; 148  : 					: SEQ_UNPADDED;

  002b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  002bd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002c1	48 83 e9 01	 sub	 rcx, 1
  002c5	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  002ca	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  002ce	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  002d3	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  002d8	75 0a		 jne	 SHORT $LN38@index_deco@3
  002da	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR tv158[rsp], 5
  002e2	eb 08		 jmp	 SHORT $LN39@index_deco@3
$LN38@index_deco@3:
  002e4	c7 44 24 68 03
	00 00 00	 mov	 DWORD PTR tv158[rsp], 3
$LN39@index_deco@3:
  002ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  002f1	8b 44 24 68	 mov	 eax, DWORD PTR tv158[rsp]
  002f5	89 01		 mov	 DWORD PTR [rcx], eax
$LN16@index_deco@3:

; 149  : 		}
; 150  : 
; 151  : 		break;

  002f7	e9 a4 01 00 00	 jmp	 $LN28@index_deco@3
$LN11@index_deco@3:

; 152  : 	}
; 153  : 
; 154  : 	case SEQ_PADDING_INIT:
; 155  : 		coder->pos = lzma_index_padding_size(coder->index);

  002fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00301	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00305	e8 00 00 00 00	 call	 lzma_index_padding_size
  0030a	8b c8		 mov	 ecx, eax
  0030c	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00311	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 156  : 		coder->sequence = SEQ_PADDING;

  00315	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0031a	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN10@index_deco@3:

; 157  : 
; 158  : 	// Fall through
; 159  : 
; 160  : 	case SEQ_PADDING:
; 161  : 		if (coder->pos > 0) {

  00320	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00325	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0032a	76 5a		 jbe	 SHORT $LN9@index_deco@3

; 162  : 			--coder->pos;

  0032c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00331	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00335	48 83 e9 01	 sub	 rcx, 1
  00339	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0033e	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 163  : 			if (in[(*in_pos)++] != 0x00)

  00342	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0034a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0034d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00355	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00359	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00361	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00364	48 83 c1 01	 add	 rcx, 1
  00368	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00370	48 89 08	 mov	 QWORD PTR [rax], rcx
  00373	85 d2		 test	 edx, edx
  00375	74 0a		 je	 SHORT $LN8@index_deco@3

; 164  : 				return LZMA_DATA_ERROR;

  00377	b8 09 00 00 00	 mov	 eax, 9
  0037c	e9 65 01 00 00	 jmp	 $LN32@index_deco@3
$LN8@index_deco@3:

; 165  : 
; 166  : 			break;

  00381	e9 1a 01 00 00	 jmp	 $LN28@index_deco@3
$LN9@index_deco@3:

; 167  : 		}
; 168  : 
; 169  : 		// Finish the CRC32 calculation.
; 170  : 		coder->crc32 = lzma_crc32(in + in_start,
; 171  : 				*in_pos - in_start, coder->crc32);

  00386	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  0038e	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$[rsp]
  00393	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00396	48 2b d0	 sub	 rdx, rax
  00399	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$[rsp]
  0039e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  003a6	48 03 c8	 add	 rcx, rax
  003a9	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  003ae	44 8b 40 40	 mov	 r8d, DWORD PTR [rax+64]
  003b2	e8 00 00 00 00	 call	 lzma_crc32
  003b7	44 8b d8	 mov	 r11d, eax
  003ba	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  003bf	44 89 58 40	 mov	 DWORD PTR [rax+64], r11d

; 172  : 
; 173  : 		coder->sequence = SEQ_CRC32;

  003c3	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  003c8	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
$LN7@index_deco@3:
$LN6@index_deco@3:

; 174  : 
; 175  : 	// Fall through
; 176  : 
; 177  : 	case SEQ_CRC32:
; 178  : 		do {
; 179  : 			if (*in_pos == in_size)

  003ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  003d6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  003de	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003e1	75 07		 jne	 SHORT $LN3@index_deco@3

; 180  : 				return LZMA_OK;

  003e3	33 c0		 xor	 eax, eax
  003e5	e9 fc 00 00 00	 jmp	 $LN32@index_deco@3
$LN3@index_deco@3:

; 181  : 
; 182  : 			if (((coder->crc32 >> (coder->pos * 8)) & 0xFF)
; 183  : 					!= in[(*in_pos)++])

  003ea	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  003f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  003fd	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00401	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00406	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0040a	48 c1 e1 03	 shl	 rcx, 3
  0040e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00413	44 8b 40 40	 mov	 r8d, DWORD PTR [rax+64]
  00417	41 d3 e8	 shr	 r8d, cl
  0041a	41 81 e0 ff 00
	00 00		 and	 r8d, 255		; 000000ffH
  00421	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00429	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0042c	48 83 c1 01	 add	 rcx, 1
  00430	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00438	48 89 08	 mov	 QWORD PTR [rax], rcx
  0043b	44 3b c2	 cmp	 r8d, edx
  0043e	74 0a		 je	 SHORT $LN2@index_deco@3

; 184  : 				return LZMA_DATA_ERROR;

  00440	b8 09 00 00 00	 mov	 eax, 9
  00445	e9 9c 00 00 00	 jmp	 $LN32@index_deco@3
$LN2@index_deco@3:

; 185  : 
; 186  : 		} while (++coder->pos < 4);

  0044a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0044f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00453	48 83 c1 01	 add	 rcx, 1
  00457	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0045c	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
  00460	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00465	48 83 78 38 04	 cmp	 QWORD PTR [rax+56], 4
  0046a	0f 82 5e ff ff
	ff		 jb	 $LN6@index_deco@3

; 187  : 
; 188  : 		// Decoding was successful, now we can let the application
; 189  : 		// see the decoded Index.
; 190  : 		*coder->index_ptr = coder->index;

  00470	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00475	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00479	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0047e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00482	48 89 01	 mov	 QWORD PTR [rcx], rax

; 191  : 
; 192  : 		// Make index NULL so we don't free it unintentionally.
; 193  : 		coder->index = NULL;

  00485	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0048a	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 194  : 
; 195  : 		return LZMA_STREAM_END;

  00492	b8 01 00 00 00	 mov	 eax, 1
  00497	eb 4d		 jmp	 SHORT $LN32@index_deco@3
$LN1@index_deco@3:

; 196  : 
; 197  : 	default:
; 198  : 		assert(0);
; 199  : 		return LZMA_PROG_ERROR;

  00499	b8 0b 00 00 00	 mov	 eax, 11
  0049e	eb 46		 jmp	 SHORT $LN32@index_deco@3
$LN28@index_deco@3:

; 200  : 	}

  004a0	e9 98 fb ff ff	 jmp	 $LN31@index_deco@3
$LN30@index_deco@3:
$out$32944:

; 201  : 
; 202  : out:
; 203  : 	// Update the CRC32,
; 204  : 	coder->crc32 = lzma_crc32(in + in_start,
; 205  : 			*in_pos - in_start, coder->crc32);

  004a5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  004ad	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$[rsp]
  004b2	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  004b5	48 2b d0	 sub	 rdx, rax
  004b8	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$[rsp]
  004bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  004c5	48 03 c8	 add	 rcx, rax
  004c8	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  004cd	44 8b 40 40	 mov	 r8d, DWORD PTR [rax+64]
  004d1	e8 00 00 00 00	 call	 lzma_crc32
  004d6	44 8b d8	 mov	 r11d, eax
  004d9	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  004de	44 89 58 40	 mov	 DWORD PTR [rax+64], r11d

; 206  : 
; 207  : 	return ret;

  004e2	8b 44 24 30	 mov	 eax, DWORD PTR ret$[rsp]
$LN32@index_deco@3:

; 208  : }

  004e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004ea	c3		 ret	 0
  004eb	90		 npad	 1
$LN40@index_deco@3:
  004ec	00 00 00 00	 DD	 $LN27@index_deco@3
  004f0	00 00 00 00	 DD	 $LN25@index_deco@3
  004f4	00 00 00 00	 DD	 $LN23@index_deco@3
  004f8	00 00 00 00	 DD	 $LN21@index_deco@3
  004fc	00 00 00 00	 DD	 $LN21@index_deco@3
  00500	00 00 00 00	 DD	 $LN11@index_deco@3
  00504	00 00 00 00	 DD	 $LN10@index_deco@3
  00508	00 00 00 00	 DD	 $LN7@index_deco@3
index_decode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_decoder_init DD imagerel index_decoder_init
	DD	imagerel index_decoder_init+278
	DD	imagerel $unwind$index_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_decoder_init DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_decoder_init
_TEXT	SEGMENT
coder$33023 = 32
next$ = 64
allocator$ = 72
i$ = 80
memlimit$ = 88
index_decoder_init PROC					; COMDAT

; 271  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@index_deco@4:

; 272  : 	lzma_next_coder_init(&index_decoder_init, next, allocator);

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:index_decoder_init
  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  00024	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00028	74 0f		 je	 SHORT $LN5@index_deco@4
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  00034	e8 00 00 00 00	 call	 lzma_next_end
$LN5@index_deco@4:
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_decoder_init
  00045	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 c9		 jne	 SHORT $LN8@index_deco@4

; 273  : 
; 274  : 	if (i == NULL)

  0004f	48 83 7c 24 50
	00		 cmp	 QWORD PTR i$[rsp], 0
  00055	75 0a		 jne	 SHORT $LN4@index_deco@4

; 275  : 		return LZMA_PROG_ERROR;

  00057	b8 0b 00 00 00	 mov	 eax, 11
  0005c	e9 b0 00 00 00	 jmp	 $LN9@index_deco@4
$LN4@index_deco@4:

; 276  : 
; 277  :   {
; 278  : 	lzma_index_coder *coder = next->coder;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR next$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 44 24 20	 mov	 QWORD PTR coder$33023[rsp], rax

; 279  : 	if (coder == NULL) {

  0006e	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33023[rsp], 0
  00074	75 6f		 jne	 SHORT $LN3@index_deco@4

; 280  : 		coder = lzma_alloc(sizeof(lzma_index_coder), allocator);

  00076	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0007b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00080	e8 00 00 00 00	 call	 lzma_alloc
  00085	48 89 44 24 20	 mov	 QWORD PTR coder$33023[rsp], rax

; 281  : 		if (coder == NULL)

  0008a	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33023[rsp], 0
  00090	75 07		 jne	 SHORT $LN2@index_deco@4

; 282  : 			return LZMA_MEM_ERROR;

  00092	b8 05 00 00 00	 mov	 eax, 5
  00097	eb 78		 jmp	 SHORT $LN9@index_deco@4
$LN2@index_deco@4:

; 283  : 
; 284  : 		next->coder = coder;

  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33023[rsp]
  000a3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 285  : 		next->code = &index_decode;

  000a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_decode
  000b2	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 286  : 		next->end = &index_decoder_end;

  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_decoder_end
  000c2	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 287  : 		next->memconfig = &index_decoder_memconfig;

  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  000cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_decoder_memconfig
  000d2	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 288  : 		coder->index = NULL;

  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33023[rsp]
  000db	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 289  : 	} else {

  000e3	eb 13		 jmp	 SHORT $LN1@index_deco@4
$LN3@index_deco@4:

; 290  : 		lzma_index_end(coder->index, allocator);

  000e5	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33023[rsp]
  000ef	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000f3	e8 00 00 00 00	 call	 lzma_index_end
$LN1@index_deco@4:

; 291  : 	}
; 292  : 
; 293  : 	return index_decoder_reset(coder, allocator, i, memlimit);

  000f8	4c 8b 4c 24 58	 mov	 r9, QWORD PTR memlimit$[rsp]
  000fd	4c 8b 44 24 50	 mov	 r8, QWORD PTR i$[rsp]
  00102	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00107	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33023[rsp]
  0010c	e8 00 00 00 00	 call	 index_decoder_reset
$LN9@index_deco@4:

; 294  :   }
; 295  : }

  00111	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00115	c3		 ret	 0
index_decoder_init ENDP
PUBLIC	lzma_index_decoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_decoder DD imagerel $LN11
	DD	imagerel $LN11+151
	DD	imagerel $unwind$lzma_index_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_decoder DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_decoder
_TEXT	SEGMENT
ret_$33044 = 32
ret_$33046 = 36
strm$ = 64
i$ = 72
memlimit$ = 80
lzma_index_decoder PROC					; COMDAT

; 300  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_index@16:
$LN5@lzma_index@16:

; 301  : 	lzma_next_strm_init(index_decoder_init, strm, i, memlimit);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_strm_init
  0001d	89 44 24 20	 mov	 DWORD PTR ret_$33044[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33044[rsp], 0
  00026	74 06		 je	 SHORT $LN2@lzma_index@16
  00028	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33044[rsp]
  0002c	eb 64		 jmp	 SHORT $LN9@lzma_index@16
$LN2@lzma_index@16:
  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 df		 jne	 SHORT $LN5@lzma_index@16
  00034	4c 8b 4c 24 50	 mov	 r9, QWORD PTR memlimit$[rsp]
  00039	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$[rsp]
  0003e	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00043	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0004c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00050	e8 00 00 00 00	 call	 index_decoder_init
  00055	89 44 24 24	 mov	 DWORD PTR ret_$33046[rsp], eax
  00059	83 7c 24 24 00	 cmp	 DWORD PTR ret_$33046[rsp], 0
  0005e	74 10		 je	 SHORT $LN1@lzma_index@16
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00065	e8 00 00 00 00	 call	 lzma_end
  0006a	8b 44 24 24	 mov	 eax, DWORD PTR ret_$33046[rsp]
  0006e	eb 22		 jmp	 SHORT $LN9@lzma_index@16
$LN1@lzma_index@16:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 9d		 jne	 SHORT $LN8@lzma_index@16

; 302  : 
; 303  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0007f	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 304  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00088	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008c	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 305  : 
; 306  : 	return LZMA_OK;

  00090	33 c0		 xor	 eax, eax
$LN9@lzma_index@16:

; 307  : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
lzma_index_decoder ENDP
END
