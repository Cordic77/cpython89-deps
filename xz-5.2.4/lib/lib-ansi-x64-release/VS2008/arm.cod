; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_arm_decoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\arm.c
pdata	SEGMENT
$pdata$arm_code DD imagerel arm_code
	DD	imagerel arm_code+306
	DD	imagerel $unwind$arm_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arm_code DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT arm_code
_TEXT	SEGMENT
i$ = 0
src$32958 = 8
dest$32959 = 12
simple$ = 32
now_pos$ = 40
is_encoder$ = 48
buffer$ = 56
size$ = 64
arm_code PROC						; COMDAT

; 21   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 4) {

  00017	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001f	eb 0c		 jmp	 SHORT $LN6@arm_code
$LN5@arm_code:
  00021	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00025	48 83 c0 04	 add	 rax, 4
  00029	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN6@arm_code:
  0002d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00031	48 83 c0 04	 add	 rax, 4
  00035	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0003a	0f 87 e9 00 00
	00		 ja	 $LN4@arm_code

; 24   : 		if (buffer[i + 3] == 0xEB) {

  00040	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00044	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00049	48 03 c1	 add	 rax, rcx
  0004c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00050	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00055	0f 85 c9 00 00
	00		 jne	 $LN3@arm_code

; 25   : 			uint32_t src = (buffer[i + 2] << 16)
; 26   : 					| (buffer[i + 1] << 8)
; 27   : 					| (buffer[i + 0]);

  0005b	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0005f	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00064	48 03 c1	 add	 rax, rcx
  00067	0f b6 50 02	 movzx	 edx, BYTE PTR [rax+2]
  0006b	c1 e2 10	 shl	 edx, 16
  0006e	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00072	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00077	48 03 c1	 add	 rax, rcx
  0007a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0007e	c1 e0 08	 shl	 eax, 8
  00081	0b d0		 or	 edx, eax
  00083	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00087	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0008c	48 03 c1	 add	 rax, rcx
  0008f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00092	8b c2		 mov	 eax, edx
  00094	0b c1		 or	 eax, ecx
  00096	89 44 24 08	 mov	 DWORD PTR src$32958[rsp], eax

; 28   : 			src <<= 2;

  0009a	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  0009e	c1 e0 02	 shl	 eax, 2
  000a1	89 44 24 08	 mov	 DWORD PTR src$32958[rsp], eax

; 29   : 
; 30   :           { uint32_t dest;
; 31   : 			if (is_encoder)

  000a5	0f b6 44 24 30	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  000aa	85 c0		 test	 eax, eax
  000ac	74 17		 je	 SHORT $LN2@arm_code

; 32   : 				dest = now_pos + (uint32_t)(i) + 8 + src;

  000ae	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000b1	8b 4c 24 28	 mov	 ecx, DWORD PTR now_pos$[rsp]
  000b5	03 c8		 add	 ecx, eax
  000b7	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  000bb	8d 44 01 08	 lea	 eax, DWORD PTR [rcx+rax+8]
  000bf	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax

; 33   : 			else

  000c3	eb 15		 jmp	 SHORT $LN1@arm_code
$LN2@arm_code:

; 34   : 				dest = src - (now_pos + (uint32_t)(i) + 8);

  000c5	8b 4c 24 28	 mov	 ecx, DWORD PTR now_pos$[rsp]
  000c9	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000cc	8d 4c 01 08	 lea	 ecx, DWORD PTR [rcx+rax+8]
  000d0	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  000d4	2b c1		 sub	 eax, ecx
  000d6	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax
$LN1@arm_code:

; 35   : 
; 36   : 			dest >>= 2;

  000da	8b 44 24 0c	 mov	 eax, DWORD PTR dest$32959[rsp]
  000de	c1 e8 02	 shr	 eax, 2
  000e1	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax

; 37   : 			buffer[i + 2] = (dest >> 16);

  000e5	8b 54 24 0c	 mov	 edx, DWORD PTR dest$32959[rsp]
  000e9	c1 ea 10	 shr	 edx, 16
  000ec	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000f5	48 03 c1	 add	 rax, rcx
  000f8	88 50 02	 mov	 BYTE PTR [rax+2], dl

; 38   : 			buffer[i + 1] = (dest >> 8);

  000fb	8b 54 24 0c	 mov	 edx, DWORD PTR dest$32959[rsp]
  000ff	c1 ea 08	 shr	 edx, 8
  00102	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00106	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0010b	48 03 c1	 add	 rax, rcx
  0010e	88 50 01	 mov	 BYTE PTR [rax+1], dl

; 39   : 			buffer[i + 0] = dest;

  00111	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00115	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buffer$[rsp]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	0f b6 44 24 0c	 movzx	 eax, BYTE PTR dest$32959[rsp]
  00122	88 01		 mov	 BYTE PTR [rcx], al
$LN3@arm_code:

; 40   : 		  }
; 41   : 		}
; 42   : 	}

  00124	e9 f8 fe ff ff	 jmp	 $LN5@arm_code
$LN4@arm_code:

; 43   : 
; 44   : 	return i;

  00129	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]

; 45   : }

  0012d	48 83 c4 18	 add	 rsp, 24
  00131	c3		 ret	 0
arm_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$arm_coder_init DD imagerel arm_coder_init
	DD	imagerel arm_coder_init+91
	DD	imagerel $unwind$arm_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arm_coder_init DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT arm_coder_init
_TEXT	SEGMENT
next$ = 80
allocator$ = 88
filters$ = 96
is_encoder$ = 104
arm_coder_init PROC					; COMDAT

; 51   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 52   : 	return lzma_simple_coder_init(next, allocator, filters,
; 53   : 			&arm_code, 0, 4, 4, is_encoder);

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0001d	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00021	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR [rsp+48], 4
  00029	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR [rsp+40], 4
  00032	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:arm_code
  00042	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  00047	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00051	e8 00 00 00 00	 call	 lzma_simple_coder_init

; 54   : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
arm_coder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_arm_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$lzma_simple_arm_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_arm_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_arm_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_simple_arm_decoder_init PROC			; COMDAT

; 70   : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 71   : 	return arm_coder_init(next, allocator, filters, false);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00025	e8 00 00 00 00	 call	 arm_coder_init

; 72   : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
lzma_simple_arm_decoder_init ENDP
END
