; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_header_magic
PUBLIC	lzma_footer_magic
lzma_header_magic DB 0fdH
	DB	037H
	DB	07aH
	DB	058H
	DB	05aH
	DB	00H
lzma_footer_magic DB 059H
	DB	05aH
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_common.h
pdata	SEGMENT
$pdata$is_backward_size_valid DD imagerel is_backward_size_valid
	DD	imagerel is_backward_size_valid+84
	DD	imagerel $unwind$is_backward_size_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_backward_size_valid DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_backward_size_valid
_TEXT	SEGMENT
tv71 = 0
options$ = 32
is_backward_size_valid PROC				; COMDAT

; 27   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 28   : 	return options->backward_size >= LZMA_BACKWARD_SIZE_MIN
; 29   : 			&& options->backward_size <= LZMA_BACKWARD_SIZE_MAX
; 30   : 			&& (options->backward_size & 3) == 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  00013	72 30		 jb	 SHORT $LN3@is_backwar
  00015	48 8b 4c 24 20	 mov	 rcx, QWORD PTR options$[rsp]
  0001a	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  00024	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00028	77 1b		 ja	 SHORT $LN3@is_backwar
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00033	48 83 e0 03	 and	 rax, 3
  00037	48 85 c0	 test	 rax, rax
  0003a	75 09		 jne	 SHORT $LN3@is_backwar
  0003c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv71[rsp], 1
  00043	eb 07		 jmp	 SHORT $LN4@is_backwar
$LN3@is_backwar:
  00045	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv71[rsp], 0
$LN4@is_backwar:
  0004c	8a 04 24	 mov	 al, BYTE PTR tv71[rsp]

; 31   : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
is_backward_size_valid ENDP
PUBLIC	lzma_stream_flags_compare
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_flags_compare DD imagerel $LN20
	DD	imagerel $LN20+330
	DD	imagerel $unwind$lzma_stream_flags_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_flags_compare DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_common.c
xdata	ENDS
;	COMDAT lzma_stream_flags_compare
_TEXT	SEGMENT
tv95 = 0
tv135 = 4
a$ = 32
b$ = 40
lzma_stream_flags_compare PROC				; COMDAT

; 23   : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 24   : 	// We can compare only version 0 structures.
; 25   : 	if (a->version != 0 || b->version != 0)

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	75 0a		 jne	 SHORT $LN8@lzma_strea@3
  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0001d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00020	74 0a		 je	 SHORT $LN9@lzma_strea@3
$LN8@lzma_strea@3:

; 26   : 		return LZMA_OPTIONS_ERROR;

  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	e9 19 01 00 00	 jmp	 $LN10@lzma_strea@3
$LN9@lzma_strea@3:

; 27   : 
; 28   : 	// Check type
; 29   : 	if ((unsigned int)(a->check) > LZMA_CHECK_ID_MAX
; 30   : 			|| (unsigned int)(b->check) > LZMA_CHECK_ID_MAX)

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00031	83 78 10 0f	 cmp	 DWORD PTR [rax+16], 15
  00035	77 0b		 ja	 SHORT $LN6@lzma_strea@3
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0003c	83 78 10 0f	 cmp	 DWORD PTR [rax+16], 15
  00040	76 0a		 jbe	 SHORT $LN7@lzma_strea@3
$LN6@lzma_strea@3:

; 31   : 		return LZMA_PROG_ERROR;

  00042	b8 0b 00 00 00	 mov	 eax, 11
  00047	e9 f9 00 00 00	 jmp	 $LN10@lzma_strea@3
$LN7@lzma_strea@3:

; 32   : 
; 33   : 	if (a->check != b->check)

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00056	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00059	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  0005c	74 0a		 je	 SHORT $LN5@lzma_strea@3

; 34   : 		return LZMA_DATA_ERROR;

  0005e	b8 09 00 00 00	 mov	 eax, 9
  00063	e9 dd 00 00 00	 jmp	 $LN10@lzma_strea@3
$LN5@lzma_strea@3:

; 35   : 
; 36   : 	// Backward Sizes are compared only if they are known in both.
; 37   : 	if (a->backward_size != LZMA_VLI_UNKNOWN
; 38   : 			&& b->backward_size != LZMA_VLI_UNKNOWN) {

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 83 78 08 ff	 cmp	 QWORD PTR [rax+8], -1
  00072	0f 84 cb 00 00
	00		 je	 $LN4@lzma_strea@3
  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0007d	48 83 78 08 ff	 cmp	 QWORD PTR [rax+8], -1
  00082	0f 84 bb 00 00
	00		 je	 $LN4@lzma_strea@3

; 39   : 		if (!is_backward_size_valid(a) || !is_backward_size_valid(b))

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0008d	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  00092	72 30		 jb	 SHORT $LN14@lzma_strea@3
  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00099	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  000a3	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000a7	77 1b		 ja	 SHORT $LN14@lzma_strea@3
  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  000ae	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b2	48 83 e0 03	 and	 rax, 3
  000b6	48 85 c0	 test	 rax, rax
  000b9	75 09		 jne	 SHORT $LN14@lzma_strea@3
  000bb	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv95[rsp], 1
  000c2	eb 07		 jmp	 SHORT $LN15@lzma_strea@3
$LN14@lzma_strea@3:
  000c4	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv95[rsp], 0
$LN15@lzma_strea@3:
  000cb	0f b6 04 24	 movzx	 eax, BYTE PTR tv95[rsp]
  000cf	85 c0		 test	 eax, eax
  000d1	74 4e		 je	 SHORT $LN2@lzma_strea@3
  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  000d8	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  000dd	72 31		 jb	 SHORT $LN18@lzma_strea@3
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  000e4	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  000ee	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000f2	77 1c		 ja	 SHORT $LN18@lzma_strea@3
  000f4	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  000f9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fd	48 83 e0 03	 and	 rax, 3
  00101	48 85 c0	 test	 rax, rax
  00104	75 0a		 jne	 SHORT $LN18@lzma_strea@3
  00106	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0010e	eb 08		 jmp	 SHORT $LN19@lzma_strea@3
$LN18@lzma_strea@3:
  00110	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN19@lzma_strea@3:
  00118	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv135[rsp]
  0011d	85 c0		 test	 eax, eax
  0011f	75 07		 jne	 SHORT $LN3@lzma_strea@3
$LN2@lzma_strea@3:

; 40   : 			return LZMA_PROG_ERROR;

  00121	b8 0b 00 00 00	 mov	 eax, 11
  00126	eb 1d		 jmp	 SHORT $LN10@lzma_strea@3
$LN3@lzma_strea@3:

; 41   : 
; 42   : 		if (a->backward_size != b->backward_size)

  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  0012d	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00132	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00136	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0013a	74 07		 je	 SHORT $LN1@lzma_strea@3

; 43   : 			return LZMA_DATA_ERROR;

  0013c	b8 09 00 00 00	 mov	 eax, 9
  00141	eb 02		 jmp	 SHORT $LN10@lzma_strea@3
$LN1@lzma_strea@3:
$LN4@lzma_strea@3:

; 44   : 	}
; 45   : 
; 46   : 	return LZMA_OK;

  00143	33 c0		 xor	 eax, eax
$LN10@lzma_strea@3:

; 47   : }

  00145	48 83 c4 18	 add	 rsp, 24
  00149	c3		 ret	 0
lzma_stream_flags_compare ENDP
END
