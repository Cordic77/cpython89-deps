; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
;	COMDAT make_short_rep
_TEXT	SEGMENT
optimal$ = 8
make_short_rep PROC					; COMDAT

; 227  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 228  : 	optimal->back_prev = 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR optimal$[rsp]
  0000a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 229  : 	optimal->prev_1_is_literal = false;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR optimal$[rsp]
  00016	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 230  : }

  0001a	c3		 ret	 0
make_short_rep ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT make_literal
_TEXT	SEGMENT
optimal$ = 8
make_literal PROC					; COMDAT

; 219  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 220  : 	optimal->back_prev = UINT32_MAX;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR optimal$[rsp]
  0000a	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH

; 221  : 	optimal->prev_1_is_literal = false;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR optimal$[rsp]
  00016	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 222  : }

  0001a	c3		 ret	 0
make_literal ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT get_len_price
_TEXT	SEGMENT
lencoder$ = 8
len$ = 16
pos_state$ = 24
get_len_price PROC					; COMDAT

; 62   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 63   : 	// NOTE: Unlike the other price tables, length prices are updated
; 64   : 	// in lzma_encoder.c
; 65   : 	return lencoder->prices[pos_state][len - MATCH_LEN_MIN];

  0000e	8b 4c 24 18	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00012	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR lencoder$[rsp]
  0001e	48 8d 8c 08 04
	04 00 00	 lea	 rcx, QWORD PTR [rax+rcx+1028]
  00026	8b 44 24 10	 mov	 eax, DWORD PTR len$[rsp]
  0002a	83 e8 02	 sub	 eax, 2
  0002d	8b c0		 mov	 eax, eax
  0002f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 66   : }

  00032	c3		 ret	 0
get_len_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\memcmplen.h
pdata	SEGMENT
$pdata$lzma_memcmplen DD imagerel lzma_memcmplen
	DD	imagerel lzma_memcmplen+160
	DD	imagerel $unwind$lzma_memcmplen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_memcmplen DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_memcmplen
_TEXT	SEGMENT
x$33372 = 0
tmp$33376 = 8
tv76 = 12
buf1$ = 32
buf2$ = 40
len$ = 48
limit$ = 56
lzma_memcmplen PROC					; COMDAT

; 45   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24
$LN3@lzma_memcm@3:

; 46   : 	assert(len <= limit);
; 47   : 	assert(limit <= UINT32_MAX / 2);
; 48   : 
; 49   : #if defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 50   : 		&& ((TUKLIB_GNUC_REQ(3, 4) && defined(__x86_64__)) \
; 51   : 			|| (defined(__INTEL_COMPILER) && defined(__x86_64__)) \
; 52   : 			|| (defined(__INTEL_COMPILER) && defined(_M_X64)) \
; 53   : 			|| (defined(_MSC_VER) && defined(_M_X64)))
; 54   : 	// NOTE: This will use 64-bit unaligned access which
; 55   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
; 56   : 	// it's convenient here at least as long as it's x86-64 only.
; 57   : 	//
; 58   : 	// I keep this x86-64 only for now since that's where I know this
; 59   : 	// to be a good method. This may be fine on other 64-bit CPUs too.
; 60   : 	// On big endian one should use xor instead of subtraction and switch
; 61   : 	// to __builtin_clzll().
; 62   : #define LZMA_MEMCMPLEN_EXTRA 8
; 63   : 	while (len < limit) {

  00018	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0001c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00020	73 75		 jae	 SHORT $LN2@lzma_memcm@3

; 64   : 		const uint64_t x = *(const uint64_t *)(buf1 + len)
; 65   : 				- *(const uint64_t *)(buf2 + len);

  00022	44 8b 44 24 30	 mov	 r8d, DWORD PTR len$[rsp]
  00027	8b 54 24 30	 mov	 edx, DWORD PTR len$[rsp]
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buf1$[rsp]
  00030	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf2$[rsp]
  00035	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00039	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	48 89 04 24	 mov	 QWORD PTR x$33372[rsp], rax

; 66   : 		if (x != 0) {

  00044	48 83 3c 24 00	 cmp	 QWORD PTR x$33372[rsp], 0
  00049	74 3f		 je	 SHORT $LN1@lzma_memcm@3

; 67   : #	if defined(_M_X64) // MSVC or Intel C compiler on Windows
; 68   : 			unsigned long tmp;
; 69   : 			_BitScanForward64(&tmp, x);

  0004b	48 8b 04 24	 mov	 rax, QWORD PTR x$33372[rsp]
  0004f	48 0f bc c0	 bsf	 rax, rax
  00053	89 44 24 08	 mov	 DWORD PTR tmp$33376[rsp], eax

; 70   : 			len += (uint32_t)tmp >> 3;

  00057	8b 4c 24 08	 mov	 ecx, DWORD PTR tmp$33376[rsp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00062	03 c1		 add	 eax, ecx
  00064	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 71   : #	else // GCC, clang, or Intel C compiler
; 72   : 			len += (uint32_t)__builtin_ctzll(x) >> 3;
; 73   : #	endif
; 74   : 			return my_min(len, limit);

  00068	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  0006c	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00070	73 0a		 jae	 SHORT $LN6@lzma_memcm@3
  00072	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00076	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
  0007a	eb 08		 jmp	 SHORT $LN7@lzma_memcm@3
$LN6@lzma_memcm@3:
  0007c	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00080	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
$LN7@lzma_memcm@3:
  00084	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
  00088	eb 11		 jmp	 SHORT $LN4@lzma_memcm@3
$LN1@lzma_memcm@3:

; 75   : 		}
; 76   : 
; 77   : 		len += 8;

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0008e	83 c0 08	 add	 eax, 8
  00091	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 78   : 	}

  00095	eb 81		 jmp	 SHORT $LN3@lzma_memcm@3
$LN2@lzma_memcm@3:

; 79   : 
; 80   : 	return limit;

  00097	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
$LN4@lzma_memcm@3:

; 81   : 
; 82   : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) \
; 83   : 		&& defined(HAVE__MM_MOVEMASK_EPI8) \
; 84   : 		&& ((defined(__GNUC__) && defined(__SSE2_MATH__)) \
; 85   : 			|| (defined(__INTEL_COMPILER) && defined(__SSE2__)) \
; 86   : 			|| (defined(_MSC_VER) && defined(_M_IX86_FP) \
; 87   : 				&& _M_IX86_FP >= 2))
; 88   : 	// NOTE: Like above, this will use 128-bit unaligned access which
; 89   : 	// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
; 90   : 	//
; 91   : 	// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
; 92   : 	// version is sometimes significantly faster and sometimes
; 93   : 	// slightly slower than this SSE2 version, so this SSE2
; 94   : 	// version isn't used on x86-64.
; 95   : #	define LZMA_MEMCMPLEN_EXTRA 16
; 96   : 	while (len < limit) {
; 97   : 		const uint32_t x = 0xFFFF ^ _mm_movemask_epi8(_mm_cmpeq_epi8(
; 98   : 			_mm_loadu_si128((const __m128i *)(buf1 + len)),
; 99   : 			_mm_loadu_si128((const __m128i *)(buf2 + len))));
; 100  : 
; 101  : 		if (x != 0) {
; 102  : #	if defined(__INTEL_COMPILER)
; 103  : 			len += _bit_scan_forward(x);
; 104  : #	elif defined(_MSC_VER)
; 105  : 			unsigned long tmp;
; 106  : 			_BitScanForward(&tmp, x);
; 107  : 			len += tmp;
; 108  : #	else
; 109  : 			len += __builtin_ctz(x);
; 110  : #	endif
; 111  : 			return my_min(len, limit);
; 112  : 		}
; 113  : 
; 114  : 		len += 16;
; 115  : 	}
; 116  : 
; 117  : 	return limit;
; 118  : 
; 119  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && !defined(WORDS_BIGENDIAN)
; 120  : 	// Generic 32-bit little endian method
; 121  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 122  : 	while (len < limit) {
; 123  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 124  : 				- *(const uint32_t *)(buf2 + len);
; 125  : 		if (x != 0) {
; 126  : 			if ((x & 0xFFFF) == 0) {
; 127  : 				len += 2;
; 128  : 				x >>= 16;
; 129  : 			}
; 130  : 
; 131  : 			if ((x & 0xFF) == 0)
; 132  : 				++len;
; 133  : 
; 134  : 			return my_min(len, limit);
; 135  : 		}
; 136  : 
; 137  : 		len += 4;
; 138  : 	}
; 139  : 
; 140  : 	return limit;
; 141  : 
; 142  : #elif defined(TUKLIB_FAST_UNALIGNED_ACCESS) && defined(WORDS_BIGENDIAN)
; 143  : 	// Generic 32-bit big endian method
; 144  : #	define LZMA_MEMCMPLEN_EXTRA 4
; 145  : 	while (len < limit) {
; 146  : 		uint32_t x = *(const uint32_t *)(buf1 + len)
; 147  : 				^ *(const uint32_t *)(buf2 + len);
; 148  : 		if (x != 0) {
; 149  : 			if ((x & 0xFFFF0000) == 0) {
; 150  : 				len += 2;
; 151  : 				x <<= 16;
; 152  : 			}
; 153  : 
; 154  : 			if ((x & 0xFF000000) == 0)
; 155  : 				++len;
; 156  : 
; 157  : 			return my_min(len, limit);
; 158  : 		}
; 159  : 
; 160  : 		len += 4;
; 161  : 	}
; 162  : 
; 163  : 	return limit;
; 164  : 
; 165  : #else
; 166  : 	// Simple portable version that doesn't use unaligned access.
; 167  : #	define LZMA_MEMCMPLEN_EXTRA 0
; 168  : 	while (len < limit && buf1[len] == buf2[len])
; 169  : 		++len;
; 170  : 
; 171  : 	return len;
; 172  : #endif
; 173  : }

  0009b	48 83 c4 18	 add	 rsp, 24
  0009f	c3		 ret	 0
lzma_memcmplen ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT get_dist_slot_2
_TEXT	SEGMENT
dist$ = 8
get_dist_slot_2 PROC					; COMDAT

; 126  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 127  : 	assert(dist >= FULL_DISTANCES);
; 128  : 
; 129  : 	if (dist < fastpos_limit(FULL_DISTANCES_BITS - 1, 0))

  00004	81 7c 24 08 00
	00 08 00	 cmp	 DWORD PTR dist$[rsp], 524288 ; 00080000H
  0000c	73 19		 jae	 SHORT $LN2@get_dist_s

; 130  : 		return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 0);

  0000e	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  00012	c1 e8 06	 shr	 eax, 6
  00015	8b c8		 mov	 ecx, eax
  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  0001e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00022	83 c0 0c	 add	 eax, 12
  00025	eb 3a		 jmp	 SHORT $LN3@get_dist_s
$LN2@get_dist_s:

; 131  : 
; 132  : 	if (dist < fastpos_limit(FULL_DISTANCES_BITS - 1, 1))

  00027	81 7c 24 08 00
	00 00 80	 cmp	 DWORD PTR dist$[rsp], -2147483648 ; 80000000H
  0002f	73 19		 jae	 SHORT $LN1@get_dist_s

; 133  : 		return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 1);

  00031	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  00035	c1 e8 12	 shr	 eax, 18
  00038	8b c8		 mov	 ecx, eax
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00041	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00045	83 c0 24	 add	 eax, 36			; 00000024H
  00048	eb 17		 jmp	 SHORT $LN3@get_dist_s
$LN1@get_dist_s:

; 134  : 
; 135  : 	return fastpos_result(dist, FULL_DISTANCES_BITS - 1, 2);

  0004a	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  0004e	c1 e8 1e	 shr	 eax, 30
  00051	8b c8		 mov	 ecx, eax
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  0005a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0005e	83 c0 3c	 add	 eax, 60			; 0000003cH
$LN3@get_dist_s:

; 136  : }

  00061	f3 c3		 fatret	 0
get_dist_slot_2 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT get_dist_slot
_TEXT	SEGMENT
dist$ = 8
get_dist_slot PROC					; COMDAT

; 110  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00004	81 7c 24 08 00
	20 00 00	 cmp	 DWORD PTR dist$[rsp], 8192 ; 00002000H
  0000c	73 11		 jae	 SHORT $LN2@get_dist_s@2

; 114  : 		return lzma_fastpos[dist];

  0000e	8b 4c 24 08	 mov	 ecx, DWORD PTR dist$[rsp]
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00019	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0001d	eb 3a		 jmp	 SHORT $LN3@get_dist_s@2
$LN2@get_dist_s@2:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  0001f	81 7c 24 08 00
	00 00 02	 cmp	 DWORD PTR dist$[rsp], 33554432 ; 02000000H
  00027	73 19		 jae	 SHORT $LN1@get_dist_s@2

; 117  : 		return fastpos_result(dist, 0, 1);

  00029	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  0002d	c1 e8 0c	 shr	 eax, 12
  00030	8b c8		 mov	 ecx, eax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00039	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003d	83 c0 18	 add	 eax, 24
  00040	eb 17		 jmp	 SHORT $LN3@get_dist_s@2
$LN1@get_dist_s@2:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00042	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  00046	c1 e8 18	 shr	 eax, 24
  00049	8b c8		 mov	 ecx, eax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00052	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00056	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@2:

; 120  : }

  00059	f3 c3		 fatret	 0
get_dist_slot ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT rc_direct_price
_TEXT	SEGMENT
bits$ = 8
rc_direct_price PROC					; COMDAT

; 88   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 89   : 	 return bits << RC_BIT_PRICE_SHIFT_BITS;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR bits$[rsp]
  00008	c1 e0 04	 shl	 eax, 4

; 90   : }

  0000b	c3		 ret	 0
rc_direct_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit_1_price
_TEXT	SEGMENT
prob$ = 8
rc_bit_1_price PROC					; COMDAT

; 45   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 46   : 	return lzma_rc_prices[(prob ^ (RC_BIT_MODEL_TOTAL - 1))
; 47   : 			>> RC_MOVE_REDUCING_BITS];

  00005	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000a	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0000f	c1 e8 04	 shr	 eax, 4
  00012	8b c8		 mov	 ecx, eax
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0001b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 48   : }

  0001f	c3		 ret	 0
rc_bit_1_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit_0_price
_TEXT	SEGMENT
prob$ = 8
rc_bit_0_price PROC					; COMDAT

; 38   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 39   : 	return lzma_rc_prices[prob >> RC_MOVE_REDUCING_BITS];

  00005	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000a	c1 f8 04	 sar	 eax, 4
  0000d	48 63 c8	 movsxd	 rcx, eax
  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00017	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 40   : }

  0001b	c3		 ret	 0
rc_bit_0_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit_price
_TEXT	SEGMENT
prob$ = 8
bit$ = 16
rc_bit_price PROC					; COMDAT

; 30   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 31   : 	return lzma_rc_prices[(prob ^ ((UINT32_C(0) - bit)
; 32   : 			& (RC_BIT_MODEL_TOTAL - 1))) >> RC_MOVE_REDUCING_BITS];

  00009	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000e	33 c9		 xor	 ecx, ecx
  00010	2b 4c 24 10	 sub	 ecx, DWORD PTR bit$[rsp]
  00014	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  0001a	33 c1		 xor	 eax, ecx
  0001c	c1 e8 04	 shr	 eax, 4
  0001f	8b c8		 mov	 ecx, eax
  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00028	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 33   : }

  0002c	c3		 ret	 0
rc_bit_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$mf_skip DD imagerel mf_skip
	DD	imagerel mf_skip+63
	DD	imagerel $unwind$mf_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mf_skip DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mf_skip
_TEXT	SEGMENT
mf$ = 48
amount$ = 56
mf_skip	PROC						; COMDAT

; 268  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  : 	if (amount != 0) {

  0000d	83 7c 24 38 00	 cmp	 DWORD PTR amount$[rsp], 0
  00012	74 26		 je	 SHORT $LN1@mf_skip@2

; 270  : 		mf->skip(mf, amount);

  00014	8b 54 24 38	 mov	 edx, DWORD PTR amount$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00022	ff 50 38	 call	 QWORD PTR [rax+56]

; 271  : 		mf->read_ahead += amount;

  00025	4c 8b 5c 24 30	 mov	 r11, QWORD PTR mf$[rsp]
  0002a	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  0002e	03 4c 24 38	 add	 ecx, DWORD PTR amount$[rsp]
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00037	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN1@mf_skip@2:

; 272  : 	}
; 273  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
mf_skip	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_avail
_TEXT	SEGMENT
mf$ = 8
mf_avail PROC						; COMDAT

; 230  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 231  : 	return mf->write_pos - mf->read_pos;

  00005	48 8b 54 24 08	 mov	 rdx, QWORD PTR mf$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00012	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00015	2b c1		 sub	 eax, ecx

; 232  : }

  00017	c3		 ret	 0
mf_avail ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_ptr
_TEXT	SEGMENT
mf$ = 8
mf_ptr	PROC						; COMDAT

; 222  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 223  : 	return mf->buffer + mf->read_pos;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR mf$[rsp]
  00012	48 03 01	 add	 rax, QWORD PTR [rcx]

; 224  : }

  00015	c3		 ret	 0
mf_ptr	ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
pdata	SEGMENT
$pdata$backward DD imagerel backward
	DD	imagerel backward+526
	DD	imagerel $unwind$backward
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$backward DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT backward
_TEXT	SEGMENT
back_mem$33520 = 0
pos_mem$33519 = 4
pos_prev$33526 = 8
back_cur$33527 = 12
$T80261 = 16
coder$ = 48
len_res$ = 56
back_res$ = 64
cur$ = 72
backward PROC						; COMDAT

; 240  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 241  : 	coder->opts_end_index = cur;

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	8b 44 24 48	 mov	 eax, DWORD PTR cur$[rsp]
  00021	89 81 dc 0e 01
	00		 mov	 DWORD PTR [rcx+69340], eax

; 242  : 
; 243  :   {
; 244  : 	uint32_t pos_mem = coder->opts[cur].pos_prev;

  00027	8b 4c 24 48	 mov	 ecx, DWORD PTR cur$[rsp]
  0002b	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00034	8b 84 08 f8 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69368]
  0003b	89 44 24 04	 mov	 DWORD PTR pos_mem$33519[rsp], eax

; 245  : 	uint32_t back_mem = coder->opts[cur].back_prev;

  0003f	8b 4c 24 48	 mov	 ecx, DWORD PTR cur$[rsp]
  00043	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0004c	8b 84 08 fc 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69372]
  00053	89 04 24	 mov	 DWORD PTR back_mem$33520[rsp], eax
$LN5@backward:

; 246  : 
; 247  : 	do {
; 248  : 		if (coder->opts[cur].prev_1_is_literal) {

  00056	8b 4c 24 48	 mov	 ecx, DWORD PTR cur$[rsp]
  0005a	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00063	0f b6 84 08 e8
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69352]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 db 00 00
	00		 je	 $LN2@backward

; 249  : 			make_literal(&coder->opts[pos_mem]);

  00073	8b 4c 24 04	 mov	 ecx, DWORD PTR pos_mem$33519[rsp]
  00077	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00080	48 8d 84 08 e4
	0e 01 00	 lea	 rax, QWORD PTR [rax+rcx+69348]
  00088	48 89 44 24 10	 mov	 QWORD PTR $T80261[rsp], rax
  0008d	48 8b 44 24 10	 mov	 rax, QWORD PTR $T80261[rsp]
  00092	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH
  00099	48 8b 44 24 10	 mov	 rax, QWORD PTR $T80261[rsp]
  0009e	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 250  : 			coder->opts[pos_mem].pos_prev = pos_mem - 1;

  000a2	8b 54 24 04	 mov	 edx, DWORD PTR pos_mem$33519[rsp]
  000a6	83 ea 01	 sub	 edx, 1
  000a9	8b 4c 24 04	 mov	 ecx, DWORD PTR pos_mem$33519[rsp]
  000ad	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000b1	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000b6	89 94 08 f8 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69368], edx

; 251  : 
; 252  : 			if (coder->opts[cur].prev_2) {

  000bd	8b 4c 24 48	 mov	 ecx, DWORD PTR cur$[rsp]
  000c1	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000ca	0f b6 84 08 e9
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69353]
  000d2	85 c0		 test	 eax, eax
  000d4	74 78		 je	 SHORT $LN1@backward

; 253  : 				coder->opts[pos_mem - 1].prev_1_is_literal
; 254  : 						= false;

  000d6	8b 44 24 04	 mov	 eax, DWORD PTR pos_mem$33519[rsp]
  000da	83 e8 01	 sub	 eax, 1
  000dd	8b c8		 mov	 ecx, eax
  000df	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000e8	c6 84 08 e8 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69352], 0

; 255  : 				coder->opts[pos_mem - 1].pos_prev
; 256  : 						= coder->opts[cur].pos_prev_2;

  000f0	44 8b 44 24 48	 mov	 r8d, DWORD PTR cur$[rsp]
  000f5	4d 6b c0 2c	 imul	 r8, 44			; 0000002cH
  000f9	8b 44 24 04	 mov	 eax, DWORD PTR pos_mem$33519[rsp]
  000fd	83 e8 01	 sub	 eax, 1
  00100	8b d0		 mov	 edx, eax
  00102	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00110	42 8b 84 00 ec
	0e 01 00	 mov	 eax, DWORD PTR [rax+r8+69356]
  00118	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 257  : 				coder->opts[pos_mem - 1].back_prev
; 258  : 						= coder->opts[cur].back_prev_2;

  0011f	44 8b 44 24 48	 mov	 r8d, DWORD PTR cur$[rsp]
  00124	4d 6b c0 2c	 imul	 r8, 44			; 0000002cH
  00128	8b 44 24 04	 mov	 eax, DWORD PTR pos_mem$33519[rsp]
  0012c	83 e8 01	 sub	 eax, 1
  0012f	8b d0		 mov	 edx, eax
  00131	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00135	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0013f	42 8b 84 00 f0
	0e 01 00	 mov	 eax, DWORD PTR [rax+r8+69360]
  00147	89 84 11 fc 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69372], eax
$LN1@backward:
$LN2@backward:

; 259  : 			}
; 260  : 		}
; 261  : 
; 262  :       {
; 263  : 		const uint32_t pos_prev = pos_mem;

  0014e	8b 44 24 04	 mov	 eax, DWORD PTR pos_mem$33519[rsp]
  00152	89 44 24 08	 mov	 DWORD PTR pos_prev$33526[rsp], eax

; 264  : 		const uint32_t back_cur = back_mem;

  00156	8b 04 24	 mov	 eax, DWORD PTR back_mem$33520[rsp]
  00159	89 44 24 0c	 mov	 DWORD PTR back_cur$33527[rsp], eax

; 265  : 
; 266  : 		back_mem = coder->opts[pos_prev].back_prev;

  0015d	8b 4c 24 08	 mov	 ecx, DWORD PTR pos_prev$33526[rsp]
  00161	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00165	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0016a	8b 84 08 fc 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69372]
  00171	89 04 24	 mov	 DWORD PTR back_mem$33520[rsp], eax

; 267  : 		pos_mem = coder->opts[pos_prev].pos_prev;

  00174	8b 4c 24 08	 mov	 ecx, DWORD PTR pos_prev$33526[rsp]
  00178	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00181	8b 84 08 f8 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69368]
  00188	89 44 24 04	 mov	 DWORD PTR pos_mem$33519[rsp], eax

; 268  : 
; 269  : 		coder->opts[pos_prev].back_prev = back_cur;

  0018c	8b 54 24 08	 mov	 edx, DWORD PTR pos_prev$33526[rsp]
  00190	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00194	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00199	8b 44 24 0c	 mov	 eax, DWORD PTR back_cur$33527[rsp]
  0019d	89 84 11 fc 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69372], eax

; 270  : 		coder->opts[pos_prev].pos_prev = cur;

  001a4	8b 54 24 08	 mov	 edx, DWORD PTR pos_prev$33526[rsp]
  001a8	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  001ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  001b1	8b 44 24 48	 mov	 eax, DWORD PTR cur$[rsp]
  001b5	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 271  : 		cur = pos_prev;

  001bc	8b 44 24 08	 mov	 eax, DWORD PTR pos_prev$33526[rsp]
  001c0	89 44 24 48	 mov	 DWORD PTR cur$[rsp], eax

; 272  :       }
; 273  : 
; 274  : 	} while (cur != 0);

  001c4	83 7c 24 48 00	 cmp	 DWORD PTR cur$[rsp], 0
  001c9	0f 85 87 fe ff
	ff		 jne	 $LN5@backward

; 275  :   }
; 276  : 
; 277  : 	coder->opts_current_index = coder->opts[0].pos_prev;

  001cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  001d4	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001d9	8b 80 f8 0e 01
	00		 mov	 eax, DWORD PTR [rax+69368]
  001df	89 81 e0 0e 01
	00		 mov	 DWORD PTR [rcx+69344], eax

; 278  : 	*len_res = coder->opts[0].pos_prev;

  001e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR len_res$[rsp]
  001ea	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001ef	8b 80 f8 0e 01
	00		 mov	 eax, DWORD PTR [rax+69368]
  001f5	89 01		 mov	 DWORD PTR [rcx], eax

; 279  : 	*back_res = coder->opts[0].back_prev;

  001f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR back_res$[rsp]
  001fc	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00201	8b 80 fc 0e 01
	00		 mov	 eax, DWORD PTR [rax+69372]
  00207	89 01		 mov	 DWORD PTR [rcx], eax

; 280  : 
; 281  : 	return;
; 282  : }

  00209	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0020d	c3		 ret	 0
backward ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_dist_len_price DD imagerel get_dist_len_price
	DD	imagerel get_dist_len_price+239
	DD	imagerel $unwind$get_dist_len_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_dist_len_price DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_dist_len_price
_TEXT	SEGMENT
dist_state$ = 32
price$ = 36
dist_slot$33460 = 40
$T80273 = 44
tv66 = 48
coder$ = 80
dist$ = 88
len$ = 96
pos_state$ = 104
get_dist_len_price PROC					; COMDAT

; 116  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 117  : 	const uint32_t dist_state = get_dist_state(len);

  00017	83 7c 24 60 06	 cmp	 DWORD PTR len$[rsp], 6
  0001c	73 0d		 jae	 SHORT $LN5@get_dist_l
  0001e	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00022	83 e8 02	 sub	 eax, 2
  00025	89 44 24 30	 mov	 DWORD PTR tv66[rsp], eax
  00029	eb 08		 jmp	 SHORT $LN6@get_dist_l
$LN5@get_dist_l:
  0002b	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv66[rsp], 3
$LN6@get_dist_l:
  00033	8b 44 24 30	 mov	 eax, DWORD PTR tv66[rsp]
  00037	89 44 24 20	 mov	 DWORD PTR dist_state$[rsp], eax

; 118  : 	uint32_t price;
; 119  : 
; 120  : 	if (dist < FULL_DISTANCES) {

  0003b	81 7c 24 58 80
	00 00 00	 cmp	 DWORD PTR dist$[rsp], 128 ; 00000080H
  00043	73 25		 jae	 SHORT $LN2@get_dist_l

; 121  : 		price = coder->dist_prices[dist_state][dist];

  00045	8b 4c 24 20	 mov	 ecx, DWORD PTR dist_state$[rsp]
  00049	48 69 c9 00 02
	00 00		 imul	 rcx, 512		; 00000200H
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00055	48 8d 8c 08 90
	06 01 00	 lea	 rcx, QWORD PTR [rax+rcx+67216]
  0005d	8b 44 24 58	 mov	 eax, DWORD PTR dist$[rsp]
  00061	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00064	89 44 24 24	 mov	 DWORD PTR price$[rsp], eax

; 122  : 	} else {

  00068	eb 46		 jmp	 SHORT $LN1@get_dist_l
$LN2@get_dist_l:

; 123  : 		const uint32_t dist_slot = get_dist_slot_2(dist);

  0006a	8b 4c 24 58	 mov	 ecx, DWORD PTR dist$[rsp]
  0006e	e8 00 00 00 00	 call	 get_dist_slot_2
  00073	89 44 24 28	 mov	 DWORD PTR dist_slot$33460[rsp], eax

; 124  : 		price = coder->dist_slot_prices[dist_state][dist_slot]
; 125  : 				+ coder->align_prices[dist & ALIGN_MASK];

  00077	8b 4c 24 20	 mov	 ecx, DWORD PTR dist_state$[rsp]
  0007b	48 69 c9 00 01
	00 00		 imul	 rcx, 256		; 00000100H
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00087	4c 8d 84 08 90
	02 01 00	 lea	 r8, QWORD PTR [rax+rcx+66192]
  0008f	8b 4c 24 28	 mov	 ecx, DWORD PTR dist_slot$33460[rsp]
  00093	8b 44 24 58	 mov	 eax, DWORD PTR dist$[rsp]
  00097	83 e0 0f	 and	 eax, 15
  0009a	8b d0		 mov	 edx, eax
  0009c	41 8b 04 88	 mov	 eax, DWORD PTR [r8+rcx*4]
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000a5	03 84 91 98 0e
	01 00		 add	 eax, DWORD PTR [rcx+rdx*4+69272]
  000ac	89 44 24 24	 mov	 DWORD PTR price$[rsp], eax
$LN1@get_dist_l:

; 126  : 	}
; 127  : 
; 128  : 	price += get_len_price(&coder->match_len_encoder, len, pos_state);

  000b0	8b 4c 24 68	 mov	 ecx, DWORD PTR pos_state$[rsp]
  000b4	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000c0	48 8d 8c 08 04
	76 00 00	 lea	 rcx, QWORD PTR [rax+rcx+30212]
  000c8	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000cc	83 e8 02	 sub	 eax, 2
  000cf	8b c0		 mov	 eax, eax
  000d1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d4	89 44 24 2c	 mov	 DWORD PTR $T80273[rsp], eax
  000d8	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T80273[rsp]
  000dc	8b 44 24 24	 mov	 eax, DWORD PTR price$[rsp]
  000e0	03 c1		 add	 eax, ecx
  000e2	89 44 24 24	 mov	 DWORD PTR price$[rsp], eax

; 129  : 
; 130  : 	return price;

  000e6	8b 44 24 24	 mov	 eax, DWORD PTR price$[rsp]

; 131  : }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
get_dist_len_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$get_pure_rep_price DD imagerel get_pure_rep_price
	DD	imagerel get_pure_rep_price+342
	DD	imagerel $unwind$get_pure_rep_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pure_rep_price DD 011701H
	DD	02217H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT get_pure_rep_price
_TEXT	SEGMENT
price$ = 0
coder$ = 32
rep_index$ = 40
state$ = 48
pos_state$ = 56
get_pure_rep_price PROC					; COMDAT

; 81   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 82   : 	uint32_t price;
; 83   : 
; 84   : 	if (rep_index == 0) {

  00017	83 7c 24 28 00	 cmp	 DWORD PTR rep_index$[rsp], 0
  0001c	75 66		 jne	 SHORT $LN4@get_pure_r

; 85   : 		price = rc_bit_0_price(coder->is_rep0[state]);

  0001e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00028	0f b7 84 48 34
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27956]
  00030	c1 f8 04	 sar	 eax, 4
  00033	48 63 c8	 movsxd	 rcx, eax
  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0003d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00041	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 86   : 		price += rc_bit_1_price(coder->is_rep0_long[state][pos_state]);

  00044	8b 54 24 38	 mov	 edx, DWORD PTR pos_state$[rsp]
  00048	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  0004d	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00056	48 8d 84 08 7c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx+28028]
  0005e	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  00062	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00067	c1 e8 04	 shr	 eax, 4
  0006a	8b c8		 mov	 ecx, eax
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00073	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00077	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  0007a	03 c1		 add	 eax, ecx
  0007c	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 87   : 	} else {

  0007f	e9 ca 00 00 00	 jmp	 $LN3@get_pure_r
$LN4@get_pure_r:

; 88   : 		price = rc_bit_1_price(coder->is_rep0[state]);

  00084	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0008e	0f b7 84 48 34
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27956]
  00096	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0009b	c1 e8 04	 shr	 eax, 4
  0009e	8b c8		 mov	 ecx, eax
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  000a7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ab	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 89   : 
; 90   : 		if (rep_index == 1) {

  000ae	83 7c 24 28 01	 cmp	 DWORD PTR rep_index$[rsp], 1
  000b3	75 2d		 jne	 SHORT $LN2@get_pure_r

; 91   : 			price += rc_bit_0_price(coder->is_rep1[state]);

  000b5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000bf	0f b7 84 48 4c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27980]
  000c7	c1 f8 04	 sar	 eax, 4
  000ca	48 63 c8	 movsxd	 rcx, eax
  000cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  000d4	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  000d8	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  000db	03 c1		 add	 eax, ecx
  000dd	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 92   : 		} else {

  000e0	eb 6c		 jmp	 SHORT $LN1@get_pure_r
$LN2@get_pure_r:

; 93   : 			price += rc_bit_1_price(coder->is_rep1[state]);

  000e2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000ec	0f b7 84 48 4c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27980]
  000f4	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  000f9	c1 e8 04	 shr	 eax, 4
  000fc	8b c8		 mov	 ecx, eax
  000fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00105	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00109	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  0010c	03 c1		 add	 eax, ecx
  0010e	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 94   : 			price += rc_bit_price(coder->is_rep2[state],
; 95   : 					rep_index - 2);

  00111	8b 44 24 28	 mov	 eax, DWORD PTR rep_index$[rsp]
  00115	83 e8 02	 sub	 eax, 2
  00118	33 d2		 xor	 edx, edx
  0011a	2b d0		 sub	 edx, eax
  0011c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00122	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR state$[rsp]
  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0012c	0f b7 84 48 64
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+28004]
  00134	33 c2		 xor	 eax, edx
  00136	c1 e8 04	 shr	 eax, 4
  00139	8b c8		 mov	 ecx, eax
  0013b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00142	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00146	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  00149	03 c1		 add	 eax, ecx
  0014b	89 04 24	 mov	 DWORD PTR price$[rsp], eax
$LN1@get_pure_r:
$LN3@get_pure_r:

; 96   : 		}
; 97   : 	}
; 98   : 
; 99   : 	return price;

  0014e	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]

; 100  : }

  00151	48 83 c4 18	 add	 rsp, 24
  00155	c3		 ret	 0
get_pure_rep_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$get_short_rep_price DD imagerel get_short_rep_price
	DD	imagerel get_short_rep_price+113
	DD	imagerel $unwind$get_short_rep_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_short_rep_price DD 011201H
	DD	02212H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT get_short_rep_price
_TEXT	SEGMENT
$T80305 = 0
coder$ = 32
state$ = 40
pos_state$ = 48
get_short_rep_price PROC				; COMDAT

; 72   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 73   : 	return rc_bit_0_price(coder->is_rep0[state])
; 74   : 		+ rc_bit_0_price(coder->is_rep0_long[state][pos_state]);

  00012	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR state$[rsp]
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0001c	0f b7 84 48 34
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27956]
  00024	c1 f8 04	 sar	 eax, 4
  00027	48 63 c8	 movsxd	 rcx, eax
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00031	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00035	89 04 24	 mov	 DWORD PTR $T80305[rsp], eax
  00038	8b 54 24 30	 mov	 edx, DWORD PTR pos_state$[rsp]
  0003c	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR state$[rsp]
  00041	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0004a	48 8d 84 08 7c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx+28028]
  00052	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  00056	c1 f8 04	 sar	 eax, 4
  00059	48 63 c8	 movsxd	 rcx, eax
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00063	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00067	8b 04 24	 mov	 eax, DWORD PTR $T80305[rsp]
  0006a	03 c1		 add	 eax, ecx

; 75   : }

  0006c	48 83 c4 18	 add	 rsp, 24
  00070	c3		 ret	 0
get_short_rep_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$rc_bittree_reverse_price DD imagerel rc_bittree_reverse_price
	DD	imagerel rc_bittree_reverse_price+146
	DD	imagerel $unwind$rc_bittree_reverse_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_bittree_reverse_price DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_bittree_reverse_price
_TEXT	SEGMENT
price$ = 0
model_index$ = 4
bit$33040 = 8
probs$ = 32
bit_levels$ = 40
symbol$ = 48
rc_bittree_reverse_price PROC				; COMDAT

; 71   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 72   : 	uint32_t price = 0;

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR price$[rsp], 0

; 73   : 	uint32_t model_index = 1;

  00019	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR model_index$[rsp], 1
$LN3@rc_bittree:

; 74   : 
; 75   : 	do {
; 76   : 		const uint32_t bit = symbol & 1;

  00021	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  00025	83 e0 01	 and	 eax, 1
  00028	89 44 24 08	 mov	 DWORD PTR bit$33040[rsp], eax

; 77   : 		symbol >>= 1;

  0002c	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  00030	d1 e8		 shr	 eax, 1
  00032	89 44 24 30	 mov	 DWORD PTR symbol$[rsp], eax

; 78   : 		price += rc_bit_price(probs[model_index], bit);

  00036	33 d2		 xor	 edx, edx
  00038	2b 54 24 08	 sub	 edx, DWORD PTR bit$33040[rsp]
  0003c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00042	8b 4c 24 04	 mov	 ecx, DWORD PTR model_index$[rsp]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR probs$[rsp]
  0004b	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0004f	33 c2		 xor	 eax, edx
  00051	c1 e8 04	 shr	 eax, 4
  00054	8b c8		 mov	 ecx, eax
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0005d	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00061	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  00064	03 c1		 add	 eax, ecx
  00066	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 79   : 		model_index = (model_index << 1) + bit;

  00069	8b 4c 24 08	 mov	 ecx, DWORD PTR bit$33040[rsp]
  0006d	8b 44 24 04	 mov	 eax, DWORD PTR model_index$[rsp]
  00071	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  00074	89 44 24 04	 mov	 DWORD PTR model_index$[rsp], eax

; 80   : 	} while (--bit_levels != 0);

  00078	8b 44 24 28	 mov	 eax, DWORD PTR bit_levels$[rsp]
  0007c	83 e8 01	 sub	 eax, 1
  0007f	89 44 24 28	 mov	 DWORD PTR bit_levels$[rsp], eax
  00083	83 7c 24 28 00	 cmp	 DWORD PTR bit_levels$[rsp], 0
  00088	75 97		 jne	 SHORT $LN3@rc_bittree

; 81   : 
; 82   : 	return price;

  0008a	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]

; 83   : }

  0008d	48 83 c4 18	 add	 rsp, 24
  00091	c3		 ret	 0
rc_bittree_reverse_price ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rc_bittree_price DD imagerel rc_bittree_price
	DD	imagerel rc_bittree_price+135
	DD	imagerel $unwind$rc_bittree_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_bittree_price DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_bittree_price
_TEXT	SEGMENT
price$ = 0
bit$33026 = 4
probs$ = 32
bit_levels$ = 40
symbol$ = 48
rc_bittree_price PROC					; COMDAT

; 54   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 55   : 	uint32_t price = 0;

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR price$[rsp], 0

; 56   : 	symbol += UINT32_C(1) << bit_levels;

  00019	8b 4c 24 28	 mov	 ecx, DWORD PTR bit_levels$[rsp]
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	d3 e0		 shl	 eax, cl
  00024	8b c8		 mov	 ecx, eax
  00026	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  0002a	03 c1		 add	 eax, ecx
  0002c	89 44 24 30	 mov	 DWORD PTR symbol$[rsp], eax
$LN3@rc_bittree@2:

; 57   : 
; 58   : 	do {
; 59   : 		const uint32_t bit = symbol & 1;

  00030	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  00034	83 e0 01	 and	 eax, 1
  00037	89 44 24 04	 mov	 DWORD PTR bit$33026[rsp], eax

; 60   : 		symbol >>= 1;

  0003b	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  0003f	d1 e8		 shr	 eax, 1
  00041	89 44 24 30	 mov	 DWORD PTR symbol$[rsp], eax

; 61   : 		price += rc_bit_price(probs[symbol], bit);

  00045	33 d2		 xor	 edx, edx
  00047	2b 54 24 04	 sub	 edx, DWORD PTR bit$33026[rsp]
  0004b	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00051	8b 4c 24 30	 mov	 ecx, DWORD PTR symbol$[rsp]
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR probs$[rsp]
  0005a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0005e	33 c2		 xor	 eax, edx
  00060	c1 e8 04	 shr	 eax, 4
  00063	8b c8		 mov	 ecx, eax
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0006c	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00070	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  00073	03 c1		 add	 eax, ecx
  00075	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 62   : 	} while (symbol != 1);

  00078	83 7c 24 30 01	 cmp	 DWORD PTR symbol$[rsp], 1
  0007d	75 b1		 jne	 SHORT $LN3@rc_bittree@2

; 63   : 
; 64   : 	return price;

  0007f	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]

; 65   : }

  00082	48 83 c4 18	 add	 rsp, 24
  00086	c3		 ret	 0
rc_bittree_price ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_align_prices DD imagerel fill_align_prices
	DD	imagerel fill_align_prices+106
	DD	imagerel $unwind$fill_align_prices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_align_prices DD 010901H
	DD	06209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT fill_align_prices
_TEXT	SEGMENT
i$ = 32
coder$ = 64
fill_align_prices PROC					; COMDAT

; 202  : {	uint32_t i;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 203  : 
; 204  : 	for (i = 0; i < ALIGN_SIZE; ++i)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0b		 jmp	 SHORT $LN3@fill_align
$LN2@fill_align:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@fill_align:
  0001e	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00023	73 31		 jae	 SHORT $LN1@fill_align

; 205  : 		coder->align_prices[i] = rc_bittree_reverse_price(
; 206  : 				coder->dist_align, ALIGN_BITS, i);

  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0002a	48 81 c1 e0 71
	00 00		 add	 rcx, 29152		; 000071e0H
  00031	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	e8 00 00 00 00	 call	 rc_bittree_reverse_price
  00040	44 8b d8	 mov	 r11d, eax
  00043	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0004c	44 89 9c 88 98
	0e 01 00	 mov	 DWORD PTR [rax+rcx*4+69272], r11d
  00054	eb bd		 jmp	 SHORT $LN2@fill_align
$LN1@fill_align:

; 207  : 
; 208  : 	coder->align_price_count = 0;

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0005b	c7 80 d8 0e 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+69336], 0

; 209  : 	return;
; 210  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
fill_align_prices ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$fill_dist_prices DD imagerel fill_dist_prices
	DD	imagerel fill_dist_prices+613
	DD	imagerel $unwind$fill_dist_prices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_dist_prices DD 010901H
	DD	0e209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT fill_dist_prices
_TEXT	SEGMENT
dist_state$ = 32
dist_slot_prices$33469 = 40
dist_slot$33470 = 48
i$33477 = 52
i$33481 = 56
dist_state$33482 = 60
footer_bits$33487 = 64
base$33488 = 68
dist_slot$33486 = 72
price$33489 = 76
coder$ = 128
fill_dist_prices PROC					; COMDAT

; 136  : {	uint32_t dist_state;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 137  : 
; 138  : 	for (dist_state = 0; dist_state < DIST_STATES; ++dist_state) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR dist_state$[rsp], 0
  00011	eb 0b		 jmp	 SHORT $LN18@fill_dist_
$LN17@fill_dist_:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR dist_state$[rsp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 44 24 20	 mov	 DWORD PTR dist_state$[rsp], eax
$LN18@fill_dist_:
  0001e	83 7c 24 20 04	 cmp	 DWORD PTR dist_state$[rsp], 4
  00023	0f 83 27 01 00
	00		 jae	 $LN16@fill_dist_

; 139  : 
; 140  : 		uint32_t *const dist_slot_prices
; 141  : 				= coder->dist_slot_prices[dist_state];

  00029	8b 4c 24 20	 mov	 ecx, DWORD PTR dist_state$[rsp]
  0002d	48 69 c9 00 01
	00 00		 imul	 rcx, 256		; 00000100H
  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0003c	48 8d 84 08 90
	02 01 00	 lea	 rax, QWORD PTR [rax+rcx+66192]
  00044	48 89 44 24 28	 mov	 QWORD PTR dist_slot_prices$33469[rsp], rax

; 142  : 
; 143  : 		// Price to encode the dist_slot.
; 144  : 	  { uint32_t dist_slot;
; 145  : 
; 146  : 		for (dist_slot = 0;
; 147  : 				dist_slot < coder->dist_table_size; ++dist_slot)

  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR dist_slot$33470[rsp], 0
  00051	eb 0b		 jmp	 SHORT $LN15@fill_dist_
$LN14@fill_dist_:
  00053	8b 44 24 30	 mov	 eax, DWORD PTR dist_slot$33470[rsp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 44 24 30	 mov	 DWORD PTR dist_slot$33470[rsp], eax
$LN15@fill_dist_:
  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00066	8b 80 90 0e 01
	00		 mov	 eax, DWORD PTR [rax+69264]
  0006c	39 44 24 30	 cmp	 DWORD PTR dist_slot$33470[rsp], eax
  00070	73 3c		 jae	 SHORT $LN13@fill_dist_

; 148  : 			dist_slot_prices[dist_slot] = rc_bittree_price(
; 149  : 					coder->dist_slot[dist_state],
; 150  : 					DIST_SLOT_BITS, dist_slot);

  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR dist_state$[rsp]
  00076	48 69 c9 80 00
	00 00		 imul	 rcx, 128		; 00000080H
  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00085	48 8d 8c 08 fc
	6e 00 00	 lea	 rcx, QWORD PTR [rax+rcx+28412]
  0008d	44 8b 44 24 30	 mov	 r8d, DWORD PTR dist_slot$33470[rsp]
  00092	ba 06 00 00 00	 mov	 edx, 6
  00097	e8 00 00 00 00	 call	 rc_bittree_price
  0009c	44 8b d8	 mov	 r11d, eax
  0009f	8b 4c 24 30	 mov	 ecx, DWORD PTR dist_slot$33470[rsp]
  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR dist_slot_prices$33469[rsp]
  000a8	44 89 1c 88	 mov	 DWORD PTR [rax+rcx*4], r11d
  000ac	eb a5		 jmp	 SHORT $LN14@fill_dist_
$LN13@fill_dist_:

; 151  : 
; 152  : 		// For matches with distance >= FULL_DISTANCES, add the price
; 153  : 		// of the direct bits part of the match distance. (Align bits
; 154  : 		// are handled by fill_align_prices()).
; 155  : 		for (dist_slot = DIST_MODEL_END;
; 156  : 				dist_slot < coder->dist_table_size;
; 157  : 				++dist_slot)

  000ae	c7 44 24 30 0e
	00 00 00	 mov	 DWORD PTR dist_slot$33470[rsp], 14
  000b6	eb 0b		 jmp	 SHORT $LN12@fill_dist_
$LN11@fill_dist_:
  000b8	8b 44 24 30	 mov	 eax, DWORD PTR dist_slot$33470[rsp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 44 24 30	 mov	 DWORD PTR dist_slot$33470[rsp], eax
$LN12@fill_dist_:
  000c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000cb	8b 80 90 0e 01
	00		 mov	 eax, DWORD PTR [rax+69264]
  000d1	39 44 24 30	 cmp	 DWORD PTR dist_slot$33470[rsp], eax
  000d5	73 26		 jae	 SHORT $LN10@fill_dist_

; 158  : 			dist_slot_prices[dist_slot] += rc_direct_price(
; 159  : 					((dist_slot >> 1) - 1) - ALIGN_BITS);

  000d7	8b 4c 24 30	 mov	 ecx, DWORD PTR dist_slot$33470[rsp]
  000db	8b 54 24 30	 mov	 edx, DWORD PTR dist_slot$33470[rsp]
  000df	d1 ea		 shr	 edx, 1
  000e1	83 ea 05	 sub	 edx, 5
  000e4	c1 e2 04	 shl	 edx, 4
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR dist_slot_prices$33469[rsp]
  000ec	03 14 88	 add	 edx, DWORD PTR [rax+rcx*4]
  000ef	8b 4c 24 30	 mov	 ecx, DWORD PTR dist_slot$33470[rsp]
  000f3	48 8b 44 24 28	 mov	 rax, QWORD PTR dist_slot_prices$33469[rsp]
  000f8	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
  000fb	eb bb		 jmp	 SHORT $LN11@fill_dist_
$LN10@fill_dist_:

; 160  : 
; 161  : 		// Distances in the range [0, 3] are fully encoded with
; 162  : 		// dist_slot, so they are used for coder->dist_prices
; 163  : 		// as is.
; 164  : 	  { uint32_t i;
; 165  : 
; 166  : 		for (i = 0; i < DIST_MODEL_START; ++i)

  000fd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$33477[rsp], 0
  00105	eb 0b		 jmp	 SHORT $LN9@fill_dist_
$LN8@fill_dist_:
  00107	8b 44 24 34	 mov	 eax, DWORD PTR i$33477[rsp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 44 24 34	 mov	 DWORD PTR i$33477[rsp], eax
$LN9@fill_dist_:
  00112	83 7c 24 34 04	 cmp	 DWORD PTR i$33477[rsp], 4
  00117	73 32		 jae	 SHORT $LN7@fill_dist_

; 167  : 			coder->dist_prices[dist_state][i]
; 168  : 					= dist_slot_prices[i];

  00119	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$33477[rsp]
  0011e	8b 4c 24 20	 mov	 ecx, DWORD PTR dist_state$[rsp]
  00122	48 69 c9 00 02
	00 00		 imul	 rcx, 512		; 00000200H
  00129	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00131	48 8d 94 08 90
	06 01 00	 lea	 rdx, QWORD PTR [rax+rcx+67216]
  00139	8b 4c 24 34	 mov	 ecx, DWORD PTR i$33477[rsp]
  0013d	48 8b 44 24 28	 mov	 rax, QWORD PTR dist_slot_prices$33469[rsp]
  00142	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00146	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00149	eb bc		 jmp	 SHORT $LN8@fill_dist_
$LN7@fill_dist_:

; 169  : 	  }}
; 170  : 	}

  0014b	e9 c3 fe ff ff	 jmp	 $LN17@fill_dist_
$LN16@fill_dist_:

; 171  : 
; 172  : 	// Distances in the range [4, 127] depend on dist_slot and
; 173  : 	// dist_special. We do this in a loop separate from the above
; 174  : 	// loop to avoid redundant calls to get_dist_slot().
; 175  :   {
; 176  : 	uint32_t i;
; 177  : 	uint32_t dist_state;
; 178  : 
; 179  : 	for (i = DIST_MODEL_START; i < FULL_DISTANCES; ++i) {

  00150	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR i$33481[rsp], 4
  00158	eb 0b		 jmp	 SHORT $LN6@fill_dist_
$LN5@fill_dist_:
  0015a	8b 44 24 38	 mov	 eax, DWORD PTR i$33481[rsp]
  0015e	83 c0 01	 add	 eax, 1
  00161	89 44 24 38	 mov	 DWORD PTR i$33481[rsp], eax
$LN6@fill_dist_:
  00165	81 7c 24 38 80
	00 00 00	 cmp	 DWORD PTR i$33481[rsp], 128 ; 00000080H
  0016d	0f 83 db 00 00
	00		 jae	 $LN4@fill_dist_

; 180  : 		const uint32_t dist_slot = get_dist_slot(i);

  00173	8b 4c 24 38	 mov	 ecx, DWORD PTR i$33481[rsp]
  00177	e8 00 00 00 00	 call	 get_dist_slot
  0017c	89 44 24 48	 mov	 DWORD PTR dist_slot$33486[rsp], eax

; 181  : 		const uint32_t footer_bits = ((dist_slot >> 1) - 1);

  00180	8b 44 24 48	 mov	 eax, DWORD PTR dist_slot$33486[rsp]
  00184	d1 e8		 shr	 eax, 1
  00186	83 e8 01	 sub	 eax, 1
  00189	89 44 24 40	 mov	 DWORD PTR footer_bits$33487[rsp], eax

; 182  : 		const uint32_t base = (2 | (dist_slot & 1)) << footer_bits;

  0018d	8b 54 24 48	 mov	 edx, DWORD PTR dist_slot$33486[rsp]
  00191	83 e2 01	 and	 edx, 1
  00194	83 ca 02	 or	 edx, 2
  00197	8b 44 24 40	 mov	 eax, DWORD PTR footer_bits$33487[rsp]
  0019b	0f b6 c8	 movzx	 ecx, al
  0019e	8b c2		 mov	 eax, edx
  001a0	d3 e0		 shl	 eax, cl
  001a2	89 44 24 44	 mov	 DWORD PTR base$33488[rsp], eax

; 183  : 		const uint32_t price = rc_bittree_reverse_price(
; 184  : 				coder->dist_special + base - dist_slot - 1,
; 185  : 				footer_bits, i - base);

  001a6	8b 44 24 44	 mov	 eax, DWORD PTR base$33488[rsp]
  001aa	44 8b 44 24 38	 mov	 r8d, DWORD PTR i$33481[rsp]
  001af	44 2b c0	 sub	 r8d, eax
  001b2	8b 4c 24 44	 mov	 ecx, DWORD PTR base$33488[rsp]
  001b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001be	48 8d 8c 48 fc
	70 00 00	 lea	 rcx, QWORD PTR [rax+rcx*2+28924]
  001c6	8b 44 24 48	 mov	 eax, DWORD PTR dist_slot$33486[rsp]
  001ca	48 d1 e0	 shl	 rax, 1
  001cd	48 2b c8	 sub	 rcx, rax
  001d0	48 83 e9 02	 sub	 rcx, 2
  001d4	8b 54 24 40	 mov	 edx, DWORD PTR footer_bits$33487[rsp]
  001d8	e8 00 00 00 00	 call	 rc_bittree_reverse_price
  001dd	89 44 24 4c	 mov	 DWORD PTR price$33489[rsp], eax

; 186  : 
; 187  : 		for (dist_state = 0; dist_state < DIST_STATES;
; 188  : 				++dist_state)

  001e1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR dist_state$33482[rsp], 0
  001e9	eb 0b		 jmp	 SHORT $LN3@fill_dist_
$LN2@fill_dist_:
  001eb	8b 44 24 3c	 mov	 eax, DWORD PTR dist_state$33482[rsp]
  001ef	83 c0 01	 add	 eax, 1
  001f2	89 44 24 3c	 mov	 DWORD PTR dist_state$33482[rsp], eax
$LN3@fill_dist_:
  001f6	83 7c 24 3c 04	 cmp	 DWORD PTR dist_state$33482[rsp], 4
  001fb	73 4c		 jae	 SHORT $LN1@fill_dist_

; 189  : 			coder->dist_prices[dist_state][i]
; 190  : 					= price + coder->dist_slot_prices[
; 191  : 						dist_state][dist_slot];

  001fd	8b 4c 24 3c	 mov	 ecx, DWORD PTR dist_state$33482[rsp]
  00201	48 69 c9 00 01
	00 00		 imul	 rcx, 256		; 00000100H
  00208	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00210	48 8d 8c 08 90
	02 01 00	 lea	 rcx, QWORD PTR [rax+rcx+66192]
  00218	8b 44 24 48	 mov	 eax, DWORD PTR dist_slot$33486[rsp]
  0021c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0021f	8b 54 24 4c	 mov	 edx, DWORD PTR price$33489[rsp]
  00223	03 d0		 add	 edx, eax
  00225	8b 4c 24 3c	 mov	 ecx, DWORD PTR dist_state$33482[rsp]
  00229	48 69 c9 00 02
	00 00		 imul	 rcx, 512		; 00000200H
  00230	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00238	48 8d 8c 08 90
	06 01 00	 lea	 rcx, QWORD PTR [rax+rcx+67216]
  00240	8b 44 24 38	 mov	 eax, DWORD PTR i$33481[rsp]
  00244	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00247	eb a2		 jmp	 SHORT $LN2@fill_dist_
$LN1@fill_dist_:

; 192  : 	}

  00249	e9 0c ff ff ff	 jmp	 $LN5@fill_dist_
$LN4@fill_dist_:

; 193  :   }
; 194  : 
; 195  : 	coder->match_price_count = 0;

  0024e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00256	c7 80 94 0e 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+69268], 0

; 196  : 	return;
; 197  : }

  00260	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00264	c3		 ret	 0
fill_dist_prices ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$get_rep_price DD imagerel get_rep_price
	DD	imagerel get_rep_price+102
	DD	imagerel $unwind$get_rep_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_rep_price DD 011701H
	DD	06217H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT get_rep_price
_TEXT	SEGMENT
$T82324 = 32
coder$ = 64
rep_index$ = 72
len$ = 80
state$ = 88
pos_state$ = 96
get_rep_price PROC					; COMDAT

; 107  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 108  : 	return get_len_price(&coder->rep_len_encoder, len, pos_state)
; 109  : 		+ get_pure_rep_price(coder, rep_index, state, pos_state);

  00017	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  0001b	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00027	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  0002f	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00033	83 e8 02	 sub	 eax, 2
  00036	8b c0		 mov	 eax, eax
  00038	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003b	89 44 24 20	 mov	 DWORD PTR $T82324[rsp], eax
  0003f	44 8b 4c 24 60	 mov	 r9d, DWORD PTR pos_state$[rsp]
  00044	44 8b 44 24 58	 mov	 r8d, DWORD PTR state$[rsp]
  00049	8b 54 24 48	 mov	 edx, DWORD PTR rep_index$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00052	e8 00 00 00 00	 call	 get_pure_rep_price
  00057	44 8b d8	 mov	 r11d, eax
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR $T82324[rsp]
  0005e	41 03 c3	 add	 eax, r11d

; 110  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
get_rep_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$get_literal_price DD imagerel get_literal_price
	DD	imagerel get_literal_price+389
	DD	imagerel $unwind$get_literal_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_literal_price DD 011701H
	DD	0a217H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT get_literal_price
_TEXT	SEGMENT
subcoder$ = 32
price$ = 40
offset$33396 = 44
subcoder_index$33401 = 48
match_bit$33400 = 52
bit$33402 = 56
coder$ = 96
pos$ = 104
prev_byte$ = 112
match_mode$ = 120
match_byte$ = 128
symbol$ = 136
get_literal_price PROC					; COMDAT

; 25   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 26   : 	const probability *const subcoder = literal_subcoder(coder->literal,
; 27   : 			coder->literal_context_bits, coder->literal_pos_mask,
; 28   : 			pos, prev_byte);

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0001c	8b 80 98 0b 00
	00		 mov	 eax, DWORD PTR [rax+2968]
  00022	8b 54 24 68	 mov	 edx, DWORD PTR pos$[rsp]
  00026	23 d0		 and	 edx, eax
  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	8b 80 94 0b 00
	00		 mov	 eax, DWORD PTR [rax+2964]
  00033	0f b6 c8	 movzx	 ecx, al
  00036	d3 e2		 shl	 edx, cl
  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  0003d	b8 08 00 00 00	 mov	 eax, 8
  00042	2b 81 94 0b 00
	00		 sub	 eax, DWORD PTR [rcx+2964]
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	8b 44 24 70	 mov	 eax, DWORD PTR prev_byte$[rsp]
  0004f	d3 e8		 shr	 eax, cl
  00051	8b c8		 mov	 ecx, eax
  00053	8b c2		 mov	 eax, edx
  00055	03 c1		 add	 eax, ecx
  00057	8b c8		 mov	 ecx, eax
  00059	48 69 c9 00 06
	00 00		 imul	 rcx, 1536		; 00000600H
  00060	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00065	48 8d 84 08 9c
	0b 00 00	 lea	 rax, QWORD PTR [rax+rcx+2972]
  0006d	48 89 44 24 20	 mov	 QWORD PTR subcoder$[rsp], rax

; 29   : 
; 30   : 	uint32_t price = 0;

  00072	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR price$[rsp], 0

; 31   : 
; 32   : 	if (!match_mode) {

  0007a	0f b6 44 24 78	 movzx	 eax, BYTE PTR match_mode$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	75 20		 jne	 SHORT $LN5@get_litera

; 33   : 		price = rc_bittree_price(subcoder, 8, symbol);

  00083	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR symbol$[rsp]
  0008b	ba 08 00 00 00	 mov	 edx, 8
  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR subcoder$[rsp]
  00095	e8 00 00 00 00	 call	 rc_bittree_price
  0009a	89 44 24 28	 mov	 DWORD PTR price$[rsp], eax

; 34   : 	} else {

  0009e	e9 d9 00 00 00	 jmp	 $LN4@get_litera
$LN5@get_litera:

; 35   : 		uint32_t offset = 0x100;

  000a3	c7 44 24 2c 00
	01 00 00	 mov	 DWORD PTR offset$33396[rsp], 256 ; 00000100H

; 36   : 		symbol += UINT32_C(1) << 8;

  000ab	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR symbol$[rsp]
  000b2	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000b7	89 84 24 88 00
	00 00		 mov	 DWORD PTR symbol$[rsp], eax
$LN3@get_litera:

; 37   : 
; 38   : 		do {
; 39   : 			match_byte <<= 1;

  000be	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR match_byte$[rsp]
  000c5	d1 e0		 shl	 eax, 1
  000c7	89 84 24 80 00
	00 00		 mov	 DWORD PTR match_byte$[rsp], eax

; 40   : 
; 41   :           {
; 42   : 			const uint32_t match_bit = match_byte & offset;

  000ce	8b 4c 24 2c	 mov	 ecx, DWORD PTR offset$33396[rsp]
  000d2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR match_byte$[rsp]
  000d9	23 c1		 and	 eax, ecx
  000db	89 44 24 34	 mov	 DWORD PTR match_bit$33400[rsp], eax

; 43   : 			const uint32_t subcoder_index
; 44   : 					= offset + match_bit + (symbol >> 8);

  000df	8b 4c 24 34	 mov	 ecx, DWORD PTR match_bit$33400[rsp]
  000e3	8b 44 24 2c	 mov	 eax, DWORD PTR offset$33396[rsp]
  000e7	03 c1		 add	 eax, ecx
  000e9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR symbol$[rsp]
  000f0	c1 e9 08	 shr	 ecx, 8
  000f3	03 c1		 add	 eax, ecx
  000f5	89 44 24 30	 mov	 DWORD PTR subcoder_index$33401[rsp], eax

; 45   : 			const uint32_t bit = (symbol >> 7) & 1;

  000f9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR symbol$[rsp]
  00100	c1 e8 07	 shr	 eax, 7
  00103	83 e0 01	 and	 eax, 1
  00106	89 44 24 38	 mov	 DWORD PTR bit$33402[rsp], eax

; 46   : 			price += rc_bit_price(subcoder[subcoder_index], bit);

  0010a	33 d2		 xor	 edx, edx
  0010c	2b 54 24 38	 sub	 edx, DWORD PTR bit$33402[rsp]
  00110	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00116	8b 4c 24 30	 mov	 ecx, DWORD PTR subcoder_index$33401[rsp]
  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR subcoder$[rsp]
  0011f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00123	33 c2		 xor	 eax, edx
  00125	c1 e8 04	 shr	 eax, 4
  00128	8b c8		 mov	 ecx, eax
  0012a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00131	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00135	8b 44 24 28	 mov	 eax, DWORD PTR price$[rsp]
  00139	03 c1		 add	 eax, ecx
  0013b	89 44 24 28	 mov	 DWORD PTR price$[rsp], eax

; 47   : 
; 48   : 			symbol <<= 1;

  0013f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR symbol$[rsp]
  00146	d1 e0		 shl	 eax, 1
  00148	89 84 24 88 00
	00 00		 mov	 DWORD PTR symbol$[rsp], eax

; 49   : 			offset &= ~(match_byte ^ symbol);

  0014f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR symbol$[rsp]
  00156	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR match_byte$[rsp]
  0015d	33 c8		 xor	 ecx, eax
  0015f	f7 d1		 not	 ecx
  00161	8b 44 24 2c	 mov	 eax, DWORD PTR offset$33396[rsp]
  00165	23 c1		 and	 eax, ecx
  00167	89 44 24 2c	 mov	 DWORD PTR offset$33396[rsp], eax

; 50   :           }
; 51   : 
; 52   : 		} while (symbol < (UINT32_C(1) << 16));

  0016b	81 bc 24 88 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR symbol$[rsp], 65536 ; 00010000H
  00176	0f 82 42 ff ff
	ff		 jb	 $LN3@get_litera
$LN4@get_litera:

; 53   : 	}
; 54   : 
; 55   : 	return price;

  0017c	8b 44 24 28	 mov	 eax, DWORD PTR price$[rsp]

; 56   : }

  00180	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00184	c3		 ret	 0
get_literal_price ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$helper2 DD imagerel helper2
	DD	imagerel helper2+7582
	DD	imagerel $unwind$helper2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$helper2 DD 031c01H
	DD	042011cH
	DD	03015H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT helper2
_TEXT	SEGMENT
matches_count$ = 48
pos_prev$ = 52
new_len$ = 56
state$ = 60
pos$33638 = 64
i$33643 = 68
i$33655 = 72
current_byte$33660 = 76
pos_state$33662 = 80
match_byte$33661 = 84
cur_price$33659 = 88
cur_and_1_price$33663 = 92
next_is_literal$33664 = 96
match_price$33666 = 100
rep_match_price$33667 = 104
short_rep_price$33670 = 108
buf_avail$33673 = 112
buf_back$33675 = 120
limit$33676 = 128
len_test$33677 = 132
state_2$33679 = 136
pos_state_next$33680 = 140
offset$33682 = 144
next_rep_match_price$33681 = 148
cur_and_len_price$33686 = 152
rep_index$33689 = 156
start_len$33688 = 160
buf_back$33693 = 168
len_test$33697 = 176
len_test_temp$33701 = 180
price$33702 = 184
cur_and_len_price$33706 = 188
len_test_2$33709 = 192
limit$33710 = 196
state_2$33715 = 200
cur_and_len_literal_price$33717 = 204
pos_state_next$33716 = 208
offset$33719 = 212
next_rep_match_price$33718 = 216
cur_and_len_price$33723 = 220
normal_match_price$33730 = 224
i$33734 = 228
len_test$33738 = 232
cur_and_len_price$33743 = 236
cur_back$33742 = 240
len_test_2$33747 = 244
buf_back$33746 = 248
limit$33748 = 256
state_2$33753 = 260
cur_and_len_literal_price$33755 = 264
pos_state_next$33754 = 268
offset$33757 = 272
next_rep_match_price$33756 = 276
$T82945 = 280
$T82949 = 288
$T82967 = 304
x$82977 = 312
tmp$82979 = 320
$T82980 = 324
$T82981 = 328
$T82985 = 332
$T82993 = 336
x$83026 = 344
tmp$83028 = 352
$T83029 = 356
$T83052 = 364
$T83056 = 368
$T83060 = 372
$T83064 = 376
$T83072 = 380
$T83110 = 404
$T83114 = 408
$T83122 = 412
tv134 = 420
tv136 = 424
tv146 = 428
tv145 = 432
tv160 = 436
tv166 = 440
tv165 = 444
tv192 = 448
tv200 = 452
tv202 = 456
tv297 = 460
tv397 = 464
tv409 = 468
tv1031 = 472
tv422 = 476
tv421 = 480
tv1094 = 484
tv598 = 488
tv612 = 492
tv656 = 496
tv655 = 500
tv828 = 504
tv842 = 508
tv880 = 512
tv879 = 516
coder$ = 544
reps$ = 552
buf$ = 560
len_end$ = 568
position$ = 576
cur$ = 584
nice_len$ = 592
buf_avail_full$ = 600
helper2	PROC						; COMDAT

; 479  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H

; 480  : 	uint32_t matches_count = coder->matches_count;

  0001c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00024	8b 80 84 0b 00
	00		 mov	 eax, DWORD PTR [rax+2948]
  0002a	89 44 24 30	 mov	 DWORD PTR matches_count$[rsp], eax

; 481  : 	uint32_t new_len = coder->longest_match_length;

  0002e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00036	8b 80 88 0b 00
	00		 mov	 eax, DWORD PTR [rax+2952]
  0003c	89 44 24 38	 mov	 DWORD PTR new_len$[rsp], eax

; 482  : 	uint32_t pos_prev = coder->opts[cur].pos_prev;

  00040	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00047	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0004b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00053	8b 84 08 f8 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69368]
  0005a	89 44 24 34	 mov	 DWORD PTR pos_prev$[rsp], eax

; 483  : 	lzma_lzma_state state;
; 484  : 
; 485  : 	if (coder->opts[cur].prev_1_is_literal) {

  0005e	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00065	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00069	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00071	0f b6 84 08 e8
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69352]
  00079	85 c0		 test	 eax, eax
  0007b	0f 84 43 01 00
	00		 je	 $LN77@helper2

; 486  : 		--pos_prev;

  00081	8b 44 24 34	 mov	 eax, DWORD PTR pos_prev$[rsp]
  00085	83 e8 01	 sub	 eax, 1
  00088	89 44 24 34	 mov	 DWORD PTR pos_prev$[rsp], eax

; 487  : 
; 488  : 		if (coder->opts[cur].prev_2) {

  0008c	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00093	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00097	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0009f	0f b6 84 08 e9
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69353]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 84 a6 00 00
	00		 je	 $LN76@helper2

; 489  : 			state = coder->opts[coder->opts[cur].pos_prev_2].state;

  000af	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  000b6	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000ba	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000c2	8b 8c 08 ec 0e
	01 00		 mov	 ecx, DWORD PTR [rax+rcx+69356]
  000c9	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000cd	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000d5	8b 84 08 e4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69348]
  000dc	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 490  : 
; 491  : 			if (coder->opts[cur].back_prev_2 < REPS)

  000e0	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  000e7	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  000eb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000f3	83 bc 08 f0 0e
	01 00 04	 cmp	 DWORD PTR [rax+rcx+69360], 4
  000fb	73 2c		 jae	 SHORT $LN75@helper2

; 492  : 				update_long_rep(state);

  000fd	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  00102	7d 0d		 jge	 SHORT $LN80@helper2
  00104	c7 84 24 a4 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv134[rsp], 8
  0010f	eb 0b		 jmp	 SHORT $LN81@helper2
$LN80@helper2:
  00111	c7 84 24 a4 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv134[rsp], 11
$LN81@helper2:
  0011c	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR tv134[rsp]
  00123	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 493  : 			else

  00127	eb 2a		 jmp	 SHORT $LN74@helper2
$LN75@helper2:

; 494  : 				update_match(state);

  00129	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  0012e	7d 0d		 jge	 SHORT $LN82@helper2
  00130	c7 84 24 a8 01
	00 00 07 00 00
	00		 mov	 DWORD PTR tv136[rsp], 7
  0013b	eb 0b		 jmp	 SHORT $LN83@helper2
$LN82@helper2:
  0013d	c7 84 24 a8 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv136[rsp], 10
$LN83@helper2:
  00148	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR tv136[rsp]
  0014f	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax
$LN74@helper2:

; 495  : 
; 496  : 		} else {

  00153	eb 1b		 jmp	 SHORT $LN73@helper2
$LN76@helper2:

; 497  : 			state = coder->opts[pos_prev].state;

  00155	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  00159	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0015d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00165	8b 84 08 e4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69348]
  0016c	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax
$LN73@helper2:

; 498  : 		}
; 499  : 
; 500  : 		update_literal(state);

  00170	83 7c 24 3c 03	 cmp	 DWORD PTR state$[rsp], 3
  00175	7f 0d		 jg	 SHORT $LN86@helper2
  00177	c7 84 24 ac 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
  00182	eb 33		 jmp	 SHORT $LN87@helper2
$LN86@helper2:
  00184	83 7c 24 3c 09	 cmp	 DWORD PTR state$[rsp], 9
  00189	7f 10		 jg	 SHORT $LN84@helper2
  0018b	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  0018f	83 e8 03	 sub	 eax, 3
  00192	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  00199	eb 0e		 jmp	 SHORT $LN85@helper2
$LN84@helper2:
  0019b	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  0019f	83 e8 06	 sub	 eax, 6
  001a2	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv145[rsp], eax
$LN85@helper2:
  001a9	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  001b0	89 84 24 ac 01
	00 00		 mov	 DWORD PTR tv146[rsp], eax
$LN87@helper2:
  001b7	8b 84 24 ac 01
	00 00		 mov	 eax, DWORD PTR tv146[rsp]
  001be	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 501  : 
; 502  : 	} else {

  001c2	eb 1b		 jmp	 SHORT $LN72@helper2
$LN77@helper2:

; 503  : 		state = coder->opts[pos_prev].state;

  001c4	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  001c8	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  001cc	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001d4	8b 84 08 e4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69348]
  001db	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax
$LN72@helper2:

; 504  : 	}
; 505  : 
; 506  : 	if (pos_prev == cur - 1) {

  001df	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  001e6	83 e8 01	 sub	 eax, 1
  001e9	39 44 24 34	 cmp	 DWORD PTR pos_prev$[rsp], eax
  001ed	0f 85 a0 00 00
	00		 jne	 $LN71@helper2

; 507  : 		if (is_short_rep(coder->opts[cur]))

  001f3	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  001fa	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  001fe	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00206	83 bc 08 fc 0e
	01 00 00	 cmp	 DWORD PTR [rax+rcx+69372], 0
  0020e	75 2c		 jne	 SHORT $LN70@helper2

; 508  : 			update_short_rep(state);

  00210	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  00215	7d 0d		 jge	 SHORT $LN88@helper2
  00217	c7 84 24 b4 01
	00 00 09 00 00
	00		 mov	 DWORD PTR tv160[rsp], 9
  00222	eb 0b		 jmp	 SHORT $LN89@helper2
$LN88@helper2:
  00224	c7 84 24 b4 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv160[rsp], 11
$LN89@helper2:
  0022f	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv160[rsp]
  00236	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 509  : 		else

  0023a	eb 52		 jmp	 SHORT $LN69@helper2
$LN70@helper2:

; 510  : 			update_literal(state);

  0023c	83 7c 24 3c 03	 cmp	 DWORD PTR state$[rsp], 3
  00241	7f 0d		 jg	 SHORT $LN92@helper2
  00243	c7 84 24 b8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv166[rsp], 0
  0024e	eb 33		 jmp	 SHORT $LN93@helper2
$LN92@helper2:
  00250	83 7c 24 3c 09	 cmp	 DWORD PTR state$[rsp], 9
  00255	7f 10		 jg	 SHORT $LN90@helper2
  00257	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  0025b	83 e8 03	 sub	 eax, 3
  0025e	89 84 24 bc 01
	00 00		 mov	 DWORD PTR tv165[rsp], eax
  00265	eb 0e		 jmp	 SHORT $LN91@helper2
$LN90@helper2:
  00267	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  0026b	83 e8 06	 sub	 eax, 6
  0026e	89 84 24 bc 01
	00 00		 mov	 DWORD PTR tv165[rsp], eax
$LN91@helper2:
  00275	8b 84 24 bc 01
	00 00		 mov	 eax, DWORD PTR tv165[rsp]
  0027c	89 84 24 b8 01
	00 00		 mov	 DWORD PTR tv166[rsp], eax
$LN93@helper2:
  00283	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR tv166[rsp]
  0028a	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax
$LN69@helper2:

; 511  : 	} else {

  0028e	e9 5c 02 00 00	 jmp	 $LN68@helper2
$LN71@helper2:

; 512  : 		uint32_t pos;
; 513  : 		if (coder->opts[cur].prev_1_is_literal
; 514  : 				&& coder->opts[cur].prev_2) {

  00293	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  0029a	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0029e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002a6	0f b6 84 08 e8
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69352]
  002ae	85 c0		 test	 eax, eax
  002b0	0f 84 87 00 00
	00		 je	 $LN67@helper2
  002b6	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  002bd	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  002c1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002c9	0f b6 84 08 e9
	0e 01 00	 movzx	 eax, BYTE PTR [rax+rcx+69353]
  002d1	85 c0		 test	 eax, eax
  002d3	74 68		 je	 SHORT $LN67@helper2

; 515  : 			pos_prev = coder->opts[cur].pos_prev_2;

  002d5	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  002dc	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  002e0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002e8	8b 84 08 ec 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69356]
  002ef	89 44 24 34	 mov	 DWORD PTR pos_prev$[rsp], eax

; 516  : 			pos = coder->opts[cur].back_prev_2;

  002f3	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  002fa	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  002fe	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00306	8b 84 08 f0 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69360]
  0030d	89 44 24 40	 mov	 DWORD PTR pos$33638[rsp], eax

; 517  : 			update_long_rep(state);

  00311	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  00316	7d 0d		 jge	 SHORT $LN94@helper2
  00318	c7 84 24 c0 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv192[rsp], 8
  00323	eb 0b		 jmp	 SHORT $LN95@helper2
$LN94@helper2:
  00325	c7 84 24 c0 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv192[rsp], 11
$LN95@helper2:
  00330	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR tv192[rsp]
  00337	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 518  : 		} else {

  0033b	eb 7b		 jmp	 SHORT $LN66@helper2
$LN67@helper2:

; 519  : 			pos = coder->opts[cur].back_prev;

  0033d	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00344	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00348	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00350	8b 84 08 fc 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69372]
  00357	89 44 24 40	 mov	 DWORD PTR pos$33638[rsp], eax

; 520  : 			if (pos < REPS)

  0035b	83 7c 24 40 04	 cmp	 DWORD PTR pos$33638[rsp], 4
  00360	73 2c		 jae	 SHORT $LN65@helper2

; 521  : 				update_long_rep(state);

  00362	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  00367	7d 0d		 jge	 SHORT $LN96@helper2
  00369	c7 84 24 c4 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv200[rsp], 8
  00374	eb 0b		 jmp	 SHORT $LN97@helper2
$LN96@helper2:
  00376	c7 84 24 c4 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv200[rsp], 11
$LN97@helper2:
  00381	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR tv200[rsp]
  00388	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax

; 522  : 			else

  0038c	eb 2a		 jmp	 SHORT $LN64@helper2
$LN65@helper2:

; 523  : 				update_match(state);

  0038e	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  00393	7d 0d		 jge	 SHORT $LN98@helper2
  00395	c7 84 24 c8 01
	00 00 07 00 00
	00		 mov	 DWORD PTR tv202[rsp], 7
  003a0	eb 0b		 jmp	 SHORT $LN99@helper2
$LN98@helper2:
  003a2	c7 84 24 c8 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv202[rsp], 10
$LN99@helper2:
  003ad	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR tv202[rsp]
  003b4	89 44 24 3c	 mov	 DWORD PTR state$[rsp], eax
$LN64@helper2:
$LN66@helper2:

; 524  : 		}
; 525  : 
; 526  :       { uint32_t i;
; 527  : 
; 528  : 		if (pos < REPS) {

  003b8	83 7c 24 40 04	 cmp	 DWORD PTR pos$33638[rsp], 4
  003bd	0f 83 c8 00 00
	00		 jae	 $LN63@helper2

; 529  : 			reps[0] = coder->opts[pos_prev].backs[pos];

  003c3	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  003c7	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  003cb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003d3	48 8d 94 08 e4
	0e 01 00	 lea	 rdx, QWORD PTR [rax+rcx+69348]
  003db	8b 44 24 40	 mov	 eax, DWORD PTR pos$33638[rsp]
  003df	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR reps$[rsp]
  003e7	8b 44 82 1c	 mov	 eax, DWORD PTR [rdx+rax*4+28]
  003eb	89 01		 mov	 DWORD PTR [rcx], eax

; 530  : 
; 531  : 			for (i = 1; i <= pos; ++i)

  003ed	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR i$33643[rsp], 1
  003f5	eb 0b		 jmp	 SHORT $LN62@helper2
$LN61@helper2:
  003f7	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  003fb	83 c0 01	 add	 eax, 1
  003fe	89 44 24 44	 mov	 DWORD PTR i$33643[rsp], eax
$LN62@helper2:
  00402	8b 44 24 40	 mov	 eax, DWORD PTR pos$33638[rsp]
  00406	39 44 24 44	 cmp	 DWORD PTR i$33643[rsp], eax
  0040a	77 37		 ja	 SHORT $LN60@helper2

; 532  : 				reps[i] = coder->opts[pos_prev].backs[i - 1];

  0040c	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  00410	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00414	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0041c	4c 8d 84 08 e4
	0e 01 00	 lea	 r8, QWORD PTR [rax+rcx+69348]
  00424	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  00428	83 e8 01	 sub	 eax, 1
  0042b	8b c0		 mov	 eax, eax
  0042d	8b 54 24 44	 mov	 edx, DWORD PTR i$33643[rsp]
  00431	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR reps$[rsp]
  00439	41 8b 44 80 1c	 mov	 eax, DWORD PTR [r8+rax*4+28]
  0043e	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  00441	eb b4		 jmp	 SHORT $LN61@helper2
$LN60@helper2:

; 533  : 
; 534  : 			for (; i < REPS; ++i)

  00443	eb 0b		 jmp	 SHORT $LN59@helper2
$LN58@helper2:
  00445	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  00449	83 c0 01	 add	 eax, 1
  0044c	89 44 24 44	 mov	 DWORD PTR i$33643[rsp], eax
$LN59@helper2:
  00450	83 7c 24 44 04	 cmp	 DWORD PTR i$33643[rsp], 4
  00455	73 32		 jae	 SHORT $LN57@helper2

; 535  : 				reps[i] = coder->opts[pos_prev].backs[i];

  00457	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  0045b	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0045f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00467	4c 8d 84 08 e4
	0e 01 00	 lea	 r8, QWORD PTR [rax+rcx+69348]
  0046f	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  00473	8b 54 24 44	 mov	 edx, DWORD PTR i$33643[rsp]
  00477	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR reps$[rsp]
  0047f	41 8b 44 80 1c	 mov	 eax, DWORD PTR [r8+rax*4+28]
  00484	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  00487	eb bc		 jmp	 SHORT $LN58@helper2
$LN57@helper2:

; 536  : 
; 537  : 		} else {

  00489	eb 64		 jmp	 SHORT $LN56@helper2
$LN63@helper2:

; 538  : 			reps[0] = pos - REPS;

  0048b	8b 4c 24 40	 mov	 ecx, DWORD PTR pos$33638[rsp]
  0048f	83 e9 04	 sub	 ecx, 4
  00492	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR reps$[rsp]
  0049a	89 08		 mov	 DWORD PTR [rax], ecx

; 539  : 
; 540  : 			for (i = 1; i < REPS; ++i)

  0049c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR i$33643[rsp], 1
  004a4	eb 0b		 jmp	 SHORT $LN55@helper2
$LN54@helper2:
  004a6	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  004aa	83 c0 01	 add	 eax, 1
  004ad	89 44 24 44	 mov	 DWORD PTR i$33643[rsp], eax
$LN55@helper2:
  004b1	83 7c 24 44 04	 cmp	 DWORD PTR i$33643[rsp], 4
  004b6	73 37		 jae	 SHORT $LN53@helper2

; 541  : 				reps[i] = coder->opts[pos_prev].backs[i - 1];

  004b8	8b 4c 24 34	 mov	 ecx, DWORD PTR pos_prev$[rsp]
  004bc	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  004c0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  004c8	4c 8d 84 08 e4
	0e 01 00	 lea	 r8, QWORD PTR [rax+rcx+69348]
  004d0	8b 44 24 44	 mov	 eax, DWORD PTR i$33643[rsp]
  004d4	83 e8 01	 sub	 eax, 1
  004d7	8b c0		 mov	 eax, eax
  004d9	8b 54 24 44	 mov	 edx, DWORD PTR i$33643[rsp]
  004dd	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR reps$[rsp]
  004e5	41 8b 44 80 1c	 mov	 eax, DWORD PTR [r8+rax*4+28]
  004ea	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  004ed	eb b7		 jmp	 SHORT $LN54@helper2
$LN53@helper2:
$LN56@helper2:
$LN68@helper2:

; 542  : 		}
; 543  : 	  }
; 544  : 	}
; 545  : 
; 546  : 	coder->opts[cur].state = state;

  004ef	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR cur$[rsp]
  004f6	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  004fa	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00502	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  00506	89 84 11 e4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69348], eax

; 547  : 
; 548  :   { uint32_t i;
; 549  : 	for (i = 0; i < REPS; ++i)

  0050d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$33655[rsp], 0
  00515	eb 0b		 jmp	 SHORT $LN52@helper2
$LN51@helper2:
  00517	8b 44 24 48	 mov	 eax, DWORD PTR i$33655[rsp]
  0051b	83 c0 01	 add	 eax, 1
  0051e	89 44 24 48	 mov	 DWORD PTR i$33655[rsp], eax
$LN52@helper2:
  00522	83 7c 24 48 04	 cmp	 DWORD PTR i$33655[rsp], 4
  00527	73 36		 jae	 SHORT $LN50@helper2

; 550  : 		coder->opts[cur].backs[i] = reps[i];

  00529	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$33655[rsp]
  0052e	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00535	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00539	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00541	48 8d 94 08 e4
	0e 01 00	 lea	 rdx, QWORD PTR [rax+rcx+69348]
  00549	8b 4c 24 48	 mov	 ecx, DWORD PTR i$33655[rsp]
  0054d	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR reps$[rsp]
  00555	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00559	89 44 8a 1c	 mov	 DWORD PTR [rdx+rcx*4+28], eax
  0055d	eb b8		 jmp	 SHORT $LN51@helper2
$LN50@helper2:

; 551  :   }
; 552  :   
; 553  :   {
; 554  : 	const uint32_t cur_price = coder->opts[cur].price;

  0055f	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00566	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0056a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00572	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00579	89 44 24 58	 mov	 DWORD PTR cur_price$33659[rsp], eax

; 555  : 
; 556  : 	const uint8_t current_byte = *buf;

  0057d	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00585	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00588	88 44 24 4c	 mov	 BYTE PTR current_byte$33660[rsp], al

; 557  : 	const uint8_t match_byte = *(buf - reps[0] - 1);

  0058c	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR reps$[rsp]
  00594	8b 08		 mov	 ecx, DWORD PTR [rax]
  00596	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0059e	48 2b c1	 sub	 rax, rcx
  005a1	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  005a5	88 44 24 54	 mov	 BYTE PTR match_byte$33661[rsp], al

; 558  : 
; 559  : 	const uint32_t pos_state = position & coder->pos_mask;

  005a9	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005b1	8b 88 90 0b 00
	00		 mov	 ecx, DWORD PTR [rax+2960]
  005b7	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  005be	23 c1		 and	 eax, ecx
  005c0	89 44 24 50	 mov	 DWORD PTR pos_state$33662[rsp], eax

; 560  : 
; 561  : 	const uint32_t cur_and_1_price = cur_price
; 562  : 			+ rc_bit_0_price(coder->is_match[state][pos_state])
; 563  : 			+ get_literal_price(coder, position, buf[-1],
; 564  : 			!is_literal_state(state), match_byte, current_byte);

  005c4	83 7c 24 3c 07	 cmp	 DWORD PTR state$[rsp], 7
  005c9	7c 0d		 jl	 SHORT $LN100@helper2
  005cb	c7 84 24 cc 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv297[rsp], 1
  005d6	eb 0b		 jmp	 SHORT $LN101@helper2
$LN100@helper2:
  005d8	c7 84 24 cc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv297[rsp], 0
$LN101@helper2:
  005e3	8b 54 24 50	 mov	 edx, DWORD PTR pos_state$33662[rsp]
  005e7	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR state$[rsp]
  005ec	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  005f0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005f8	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  00600	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  00604	c1 f8 04	 sar	 eax, 4
  00607	48 63 c8	 movsxd	 rcx, eax
  0060a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00611	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00615	89 84 24 18 01
	00 00		 mov	 DWORD PTR $T82945[rsp], eax
  0061c	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR $T82945[rsp]
  00623	8b 5c 24 58	 mov	 ebx, DWORD PTR cur_price$33659[rsp]
  00627	03 d8		 add	 ebx, eax
  00629	0f b6 54 24 4c	 movzx	 edx, BYTE PTR current_byte$33660[rsp]
  0062e	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR match_byte$33661[rsp]
  00633	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0063b	44 0f b6 40 ff	 movzx	 r8d, BYTE PTR [rax-1]
  00640	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00644	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00648	44 0f b6 8c 24
	cc 01 00 00	 movzx	 r9d, BYTE PTR tv297[rsp]
  00651	8b 94 24 40 02
	00 00		 mov	 edx, DWORD PTR position$[rsp]
  00658	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00660	e8 00 00 00 00	 call	 get_literal_price
  00665	44 8b d8	 mov	 r11d, eax
  00668	8b c3		 mov	 eax, ebx
  0066a	41 03 c3	 add	 eax, r11d
  0066d	89 44 24 5c	 mov	 DWORD PTR cur_and_1_price$33663[rsp], eax

; 565  : 
; 566  : 	bool next_is_literal = false;

  00671	c6 44 24 60 00	 mov	 BYTE PTR next_is_literal$33664[rsp], 0

; 567  : 
; 568  : 	if (cur_and_1_price < coder->opts[cur + 1].price) {

  00676	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  0067d	83 c0 01	 add	 eax, 1
  00680	8b c8		 mov	 ecx, eax
  00682	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00686	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0068e	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00695	39 44 24 5c	 cmp	 DWORD PTR cur_and_1_price$33663[rsp], eax
  00699	0f 83 91 00 00
	00		 jae	 $LN49@helper2

; 569  : 		coder->opts[cur + 1].price = cur_and_1_price;

  0069f	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  006a6	83 c0 01	 add	 eax, 1
  006a9	8b d0		 mov	 edx, eax
  006ab	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  006af	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  006b7	8b 44 24 5c	 mov	 eax, DWORD PTR cur_and_1_price$33663[rsp]
  006bb	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 570  : 		coder->opts[cur + 1].pos_prev = cur;

  006c2	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  006c9	83 c0 01	 add	 eax, 1
  006cc	8b d0		 mov	 edx, eax
  006ce	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  006d2	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  006da	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  006e1	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 571  : 		make_literal(&coder->opts[cur + 1]);

  006e8	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  006ef	83 c0 01	 add	 eax, 1
  006f2	8b c8		 mov	 ecx, eax
  006f4	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  006f8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00700	48 8d 84 08 e4
	0e 01 00	 lea	 rax, QWORD PTR [rax+rcx+69348]
  00708	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR $T82949[rsp], rax
  00710	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR $T82949[rsp]
  00718	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH
  0071f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR $T82949[rsp]
  00727	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 572  : 		next_is_literal = true;

  0072b	c6 44 24 60 01	 mov	 BYTE PTR next_is_literal$33664[rsp], 1
$LN49@helper2:

; 573  : 	}
; 574  : 
; 575  :   {
; 576  : 	const uint32_t match_price = cur_price
; 577  : 			+ rc_bit_1_price(coder->is_match[state][pos_state]);

  00730	8b 54 24 50	 mov	 edx, DWORD PTR pos_state$33662[rsp]
  00734	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR state$[rsp]
  00739	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0073d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00745	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  0074d	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  00751	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00756	c1 e8 04	 shr	 eax, 4
  00759	8b c8		 mov	 ecx, eax
  0075b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00762	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00766	8b 44 24 58	 mov	 eax, DWORD PTR cur_price$33659[rsp]
  0076a	03 c1		 add	 eax, ecx
  0076c	89 44 24 64	 mov	 DWORD PTR match_price$33666[rsp], eax

; 578  : 	const uint32_t rep_match_price = match_price
; 579  : 			+ rc_bit_1_price(coder->is_rep[state]);

  00770	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR state$[rsp]
  00775	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0077d	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  00785	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0078a	c1 e8 04	 shr	 eax, 4
  0078d	8b c8		 mov	 ecx, eax
  0078f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00796	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0079a	8b 44 24 64	 mov	 eax, DWORD PTR match_price$33666[rsp]
  0079e	03 c1		 add	 eax, ecx
  007a0	89 44 24 68	 mov	 DWORD PTR rep_match_price$33667[rsp], eax

; 580  : 
; 581  : 	if (match_byte == current_byte
; 582  : 			&& !(coder->opts[cur + 1].pos_prev < cur
; 583  : 				&& coder->opts[cur + 1].back_prev == 0)) {

  007a4	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR match_byte$33661[rsp]
  007a9	0f b6 44 24 4c	 movzx	 eax, BYTE PTR current_byte$33660[rsp]
  007ae	3b c8		 cmp	 ecx, eax
  007b0	0f 85 2c 01 00
	00		 jne	 $LN48@helper2
  007b6	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  007bd	83 c0 01	 add	 eax, 1
  007c0	8b d0		 mov	 edx, eax
  007c2	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  007c6	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  007ce	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  007d5	39 84 11 f8 0e
	01 00		 cmp	 DWORD PTR [rcx+rdx+69368], eax
  007dc	73 26		 jae	 SHORT $LN47@helper2
  007de	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  007e5	83 c0 01	 add	 eax, 1
  007e8	8b c8		 mov	 ecx, eax
  007ea	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  007ee	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  007f6	83 bc 08 fc 0e
	01 00 00	 cmp	 DWORD PTR [rax+rcx+69372], 0
  007fe	0f 84 de 00 00
	00		 je	 $LN48@helper2
$LN47@helper2:

; 584  : 
; 585  : 		const uint32_t short_rep_price = rep_match_price
; 586  : 				+ get_short_rep_price(coder, state, pos_state);

  00804	44 8b 44 24 50	 mov	 r8d, DWORD PTR pos_state$33662[rsp]
  00809	8b 54 24 3c	 mov	 edx, DWORD PTR state$[rsp]
  0080d	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00815	e8 00 00 00 00	 call	 get_short_rep_price
  0081a	44 8b d8	 mov	 r11d, eax
  0081d	8b 44 24 68	 mov	 eax, DWORD PTR rep_match_price$33667[rsp]
  00821	41 03 c3	 add	 eax, r11d
  00824	89 44 24 6c	 mov	 DWORD PTR short_rep_price$33670[rsp], eax

; 587  : 
; 588  : 		if (short_rep_price <= coder->opts[cur + 1].price) {

  00828	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  0082f	83 c0 01	 add	 eax, 1
  00832	8b c8		 mov	 ecx, eax
  00834	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00838	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00840	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00847	39 44 24 6c	 cmp	 DWORD PTR short_rep_price$33670[rsp], eax
  0084b	0f 87 91 00 00
	00		 ja	 $LN46@helper2

; 589  : 			coder->opts[cur + 1].price = short_rep_price;

  00851	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00858	83 c0 01	 add	 eax, 1
  0085b	8b d0		 mov	 edx, eax
  0085d	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00861	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00869	8b 44 24 6c	 mov	 eax, DWORD PTR short_rep_price$33670[rsp]
  0086d	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 590  : 			coder->opts[cur + 1].pos_prev = cur;

  00874	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  0087b	83 c0 01	 add	 eax, 1
  0087e	8b d0		 mov	 edx, eax
  00880	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00884	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0088c	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00893	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 591  : 			make_short_rep(&coder->opts[cur + 1]);

  0089a	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  008a1	83 c0 01	 add	 eax, 1
  008a4	8b c8		 mov	 ecx, eax
  008a6	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  008aa	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  008b2	48 8d 84 08 e4
	0e 01 00	 lea	 rax, QWORD PTR [rax+rcx+69348]
  008ba	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR $T82967[rsp], rax
  008c2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR $T82967[rsp]
  008ca	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  008d1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR $T82967[rsp]
  008d9	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 592  : 			next_is_literal = true;

  008dd	c6 44 24 60 01	 mov	 BYTE PTR next_is_literal$33664[rsp], 1
$LN46@helper2:
$LN48@helper2:

; 593  : 		}
; 594  : 	}
; 595  : 
; 596  : 	if (buf_avail_full < 2)

  008e2	83 bc 24 58 02
	00 00 02	 cmp	 DWORD PTR buf_avail_full$[rsp], 2
  008ea	73 0c		 jae	 SHORT $LN45@helper2

; 597  : 		return len_end;

  008ec	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  008f3	e9 9d 14 00 00	 jmp	 $LN78@helper2
$LN45@helper2:

; 598  : 
; 599  :   {
; 600  : 	const uint32_t buf_avail = my_min(buf_avail_full, nice_len);

  008f8	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR nice_len$[rsp]
  008ff	39 84 24 58 02
	00 00		 cmp	 DWORD PTR buf_avail_full$[rsp], eax
  00906	73 10		 jae	 SHORT $LN102@helper2
  00908	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR buf_avail_full$[rsp]
  0090f	89 84 24 d0 01
	00 00		 mov	 DWORD PTR tv397[rsp], eax
  00916	eb 0e		 jmp	 SHORT $LN103@helper2
$LN102@helper2:
  00918	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR nice_len$[rsp]
  0091f	89 84 24 d0 01
	00 00		 mov	 DWORD PTR tv397[rsp], eax
$LN103@helper2:
  00926	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR tv397[rsp]
  0092d	89 44 24 70	 mov	 DWORD PTR buf_avail$33673[rsp], eax

; 601  : 
; 602  : 	if (!next_is_literal && match_byte != current_byte) { // speed optimization

  00931	0f b6 44 24 60	 movzx	 eax, BYTE PTR next_is_literal$33664[rsp]
  00936	85 c0		 test	 eax, eax
  00938	0f 85 12 04 00
	00		 jne	 $LN44@helper2
  0093e	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR match_byte$33661[rsp]
  00943	0f b6 44 24 4c	 movzx	 eax, BYTE PTR current_byte$33660[rsp]
  00948	3b c8		 cmp	 ecx, eax
  0094a	0f 84 00 04 00
	00		 je	 $LN44@helper2

; 603  : 		// try literal + rep0
; 604  : 		const uint8_t *const buf_back = buf - reps[0] - 1;

  00950	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR reps$[rsp]
  00958	8b 08		 mov	 ecx, DWORD PTR [rax]
  0095a	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00962	48 2b c1	 sub	 rax, rcx
  00965	48 83 e8 01	 sub	 rax, 1
  00969	48 89 44 24 78	 mov	 QWORD PTR buf_back$33675[rsp], rax

; 605  : 		const uint32_t limit = my_min(buf_avail_full, nice_len + 1);

  0096e	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR nice_len$[rsp]
  00975	83 c0 01	 add	 eax, 1
  00978	39 84 24 58 02
	00 00		 cmp	 DWORD PTR buf_avail_full$[rsp], eax
  0097f	73 10		 jae	 SHORT $LN104@helper2
  00981	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR buf_avail_full$[rsp]
  00988	89 84 24 d4 01
	00 00		 mov	 DWORD PTR tv409[rsp], eax
  0098f	eb 11		 jmp	 SHORT $LN105@helper2
$LN104@helper2:
  00991	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR nice_len$[rsp]
  00998	83 c0 01	 add	 eax, 1
  0099b	89 84 24 d4 01
	00 00		 mov	 DWORD PTR tv409[rsp], eax
$LN105@helper2:
  009a2	8b 84 24 d4 01
	00 00		 mov	 eax, DWORD PTR tv409[rsp]
  009a9	89 84 24 80 00
	00 00		 mov	 DWORD PTR limit$33676[rsp], eax

; 606  : 
; 607  : 		const uint32_t len_test = lzma_memcmplen(buf, buf_back, 1, limit) - 1;

  009b0	c7 84 24 44 01
	00 00 01 00 00
	00		 mov	 DWORD PTR $T82980[rsp], 1
$LN144@helper2:
  009bb	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR limit$33676[rsp]
  009c2	39 84 24 44 01
	00 00		 cmp	 DWORD PTR $T82980[rsp], eax
  009c9	0f 83 bb 00 00
	00		 jae	 $LN143@helper2
  009cf	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR $T82980[rsp]
  009d7	8b 94 24 44 01
	00 00		 mov	 edx, DWORD PTR $T82980[rsp]
  009de	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  009e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buf_back$33675[rsp]
  009eb	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  009ef	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  009f3	48 2b c1	 sub	 rax, rcx
  009f6	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR x$82977[rsp], rax
  009fe	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR x$82977[rsp], 0
  00a07	74 6b		 je	 SHORT $LN142@helper2
  00a09	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR x$82977[rsp]
  00a11	48 0f bc c0	 bsf	 rax, rax
  00a15	89 84 24 40 01
	00 00		 mov	 DWORD PTR tmp$82979[rsp], eax
  00a1c	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tmp$82979[rsp]
  00a23	c1 e9 03	 shr	 ecx, 3
  00a26	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR $T82980[rsp]
  00a2d	03 c1		 add	 eax, ecx
  00a2f	89 84 24 44 01
	00 00		 mov	 DWORD PTR $T82980[rsp], eax
  00a36	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR limit$33676[rsp]
  00a3d	39 84 24 44 01
	00 00		 cmp	 DWORD PTR $T82980[rsp], eax
  00a44	73 10		 jae	 SHORT $LN147@helper2
  00a46	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR $T82980[rsp]
  00a4d	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv1031[rsp], eax
  00a54	eb 0e		 jmp	 SHORT $LN148@helper2
$LN147@helper2:
  00a56	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR limit$33676[rsp]
  00a5d	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv1031[rsp], eax
$LN148@helper2:
  00a64	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR tv1031[rsp]
  00a6b	89 84 24 48 01
	00 00		 mov	 DWORD PTR $T82981[rsp], eax
  00a72	eb 24		 jmp	 SHORT $LN145@helper2
$LN142@helper2:
  00a74	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR $T82980[rsp]
  00a7b	83 c0 08	 add	 eax, 8
  00a7e	89 84 24 44 01
	00 00		 mov	 DWORD PTR $T82980[rsp], eax
  00a85	e9 31 ff ff ff	 jmp	 $LN144@helper2
$LN143@helper2:
  00a8a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR limit$33676[rsp]
  00a91	89 84 24 48 01
	00 00		 mov	 DWORD PTR $T82981[rsp], eax
$LN145@helper2:
  00a98	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR $T82981[rsp]
  00a9f	83 e8 01	 sub	 eax, 1
  00aa2	89 84 24 84 00
	00 00		 mov	 DWORD PTR len_test$33677[rsp], eax

; 608  : 
; 609  : 		if (len_test >= 2) {

  00aa9	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR len_test$33677[rsp], 2
  00ab1	0f 82 99 02 00
	00		 jb	 $LN43@helper2

; 610  : 			lzma_lzma_state state_2 = state;

  00ab7	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  00abb	89 84 24 88 00
	00 00		 mov	 DWORD PTR state_2$33679[rsp], eax

; 611  : 			update_literal(state_2);

  00ac2	83 bc 24 88 00
	00 00 03	 cmp	 DWORD PTR state_2$33679[rsp], 3
  00aca	7f 0d		 jg	 SHORT $LN108@helper2
  00acc	c7 84 24 dc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv422[rsp], 0
  00ad7	eb 3c		 jmp	 SHORT $LN109@helper2
$LN108@helper2:
  00ad9	83 bc 24 88 00
	00 00 09	 cmp	 DWORD PTR state_2$33679[rsp], 9
  00ae1	7f 13		 jg	 SHORT $LN106@helper2
  00ae3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR state_2$33679[rsp]
  00aea	83 e8 03	 sub	 eax, 3
  00aed	89 84 24 e0 01
	00 00		 mov	 DWORD PTR tv421[rsp], eax
  00af4	eb 11		 jmp	 SHORT $LN107@helper2
$LN106@helper2:
  00af6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR state_2$33679[rsp]
  00afd	83 e8 06	 sub	 eax, 6
  00b00	89 84 24 e0 01
	00 00		 mov	 DWORD PTR tv421[rsp], eax
$LN107@helper2:
  00b07	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR tv421[rsp]
  00b0e	89 84 24 dc 01
	00 00		 mov	 DWORD PTR tv422[rsp], eax
$LN109@helper2:
  00b15	8b 84 24 dc 01
	00 00		 mov	 eax, DWORD PTR tv422[rsp]
  00b1c	89 84 24 88 00
	00 00		 mov	 DWORD PTR state_2$33679[rsp], eax

; 612  : 
; 613  :           {
; 614  : 			const uint32_t pos_state_next = (position + 1) & coder->pos_mask;

  00b23	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  00b2a	83 c0 01	 add	 eax, 1
  00b2d	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00b35	23 81 90 0b 00
	00		 and	 eax, DWORD PTR [rcx+2960]
  00b3b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR pos_state_next$33680[rsp], eax

; 615  : 			const uint32_t next_rep_match_price = cur_and_1_price
; 616  : 					+ rc_bit_1_price(coder->is_match[state_2][pos_state_next])
; 617  : 					+ rc_bit_1_price(coder->is_rep[state_2]);

  00b42	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR pos_state_next$33680[rsp]
  00b49	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR state_2$33679[rsp]
  00b51	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00b55	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00b5d	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  00b65	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  00b69	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00b6e	c1 e8 04	 shr	 eax, 4
  00b71	8b c8		 mov	 ecx, eax
  00b73	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00b7a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00b7e	89 84 24 4c 01
	00 00		 mov	 DWORD PTR $T82985[rsp], eax
  00b85	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR $T82985[rsp]
  00b8c	8b 54 24 5c	 mov	 edx, DWORD PTR cur_and_1_price$33663[rsp]
  00b90	03 d0		 add	 edx, eax
  00b92	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR state_2$33679[rsp]
  00b9a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00ba2	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  00baa	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00baf	c1 e8 04	 shr	 eax, 4
  00bb2	8b c8		 mov	 ecx, eax
  00bb4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00bbb	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00bbf	8b c2		 mov	 eax, edx
  00bc1	03 c1		 add	 eax, ecx
  00bc3	89 84 24 94 00
	00 00		 mov	 DWORD PTR next_rep_match_price$33681[rsp], eax

; 618  : 
; 619  : 			//for (; len_test >= 2; --len_test) {
; 620  : 			const uint32_t offset = cur + 1 + len_test;

  00bca	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  00bd1	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_test$33677[rsp]
  00bd8	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00bdc	89 84 24 90 00
	00 00		 mov	 DWORD PTR offset$33682[rsp], eax
$LN42@helper2:

; 621  : 
; 622  : 			while (len_end < offset)

  00be3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR offset$33682[rsp]
  00bea	39 84 24 38 02
	00 00		 cmp	 DWORD PTR len_end$[rsp], eax
  00bf1	73 31		 jae	 SHORT $LN41@helper2

; 623  : 				coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00bf3	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  00bfa	83 c0 01	 add	 eax, 1
  00bfd	89 84 24 38 02
	00 00		 mov	 DWORD PTR len_end$[rsp], eax
  00c04	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR len_end$[rsp]
  00c0b	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00c0f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00c17	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H
  00c22	eb bf		 jmp	 SHORT $LN42@helper2
$LN41@helper2:

; 624  : 
; 625  :           {
; 626  : 			const uint32_t cur_and_len_price = next_rep_match_price
; 627  : 					+ get_rep_price(coder, 0, len_test,
; 628  : 						state_2, pos_state_next);

  00c24	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR pos_state_next$33680[rsp]
  00c2b	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  00c32	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00c3a	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  00c42	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len_test$33677[rsp]
  00c49	83 e8 02	 sub	 eax, 2
  00c4c	8b c0		 mov	 eax, eax
  00c4e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00c51	89 84 24 50 01
	00 00		 mov	 DWORD PTR $T82993[rsp], eax
  00c58	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR pos_state_next$33680[rsp]
  00c60	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR state_2$33679[rsp]
  00c68	33 d2		 xor	 edx, edx
  00c6a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00c72	e8 00 00 00 00	 call	 get_pure_rep_price
  00c77	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR $T82993[rsp]
  00c7e	03 c8		 add	 ecx, eax
  00c80	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR next_rep_match_price$33681[rsp]
  00c87	03 c1		 add	 eax, ecx
  00c89	89 84 24 98 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33686[rsp], eax

; 629  : 
; 630  : 			if (cur_and_len_price < coder->opts[offset].price) {

  00c90	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR offset$33682[rsp]
  00c97	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00c9b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00ca3	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00caa	39 84 24 98 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33686[rsp], eax
  00cb1	0f 83 99 00 00
	00		 jae	 $LN40@helper2

; 631  : 				coder->opts[offset].price = cur_and_len_price;

  00cb7	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR offset$33682[rsp]
  00cbe	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00cc2	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00cca	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33686[rsp]
  00cd1	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 632  : 				coder->opts[offset].pos_prev = cur + 1;

  00cd8	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR cur$[rsp]
  00cdf	83 c2 01	 add	 edx, 1
  00ce2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR offset$33682[rsp]
  00ce9	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00ced	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00cf5	89 94 08 f8 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69368], edx

; 633  : 				coder->opts[offset].back_prev = 0;

  00cfc	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR offset$33682[rsp]
  00d03	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00d07	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00d0f	c7 84 08 fc 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx+69372], 0

; 634  : 				coder->opts[offset].prev_1_is_literal = true;

  00d1a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR offset$33682[rsp]
  00d21	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00d25	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00d2d	c6 84 08 e8 0e
	01 00 01	 mov	 BYTE PTR [rax+rcx+69352], 1

; 635  : 				coder->opts[offset].prev_2 = false;

  00d35	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR offset$33682[rsp]
  00d3c	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00d40	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00d48	c6 84 08 e9 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69353], 0
$LN40@helper2:
$LN43@helper2:
$LN44@helper2:

; 636  : 			}
; 637  : 			//}
; 638  : 		  }}
; 639  : 		}
; 640  : 	}
; 641  : 
; 642  : 
; 643  :    {
; 644  : 	uint32_t start_len = 2; // speed optimization

  00d50	c7 84 24 a0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR start_len$33688[rsp], 2

; 645  : 	uint32_t rep_index;
; 646  : 
; 647  : 	for (rep_index = 0; rep_index < REPS; ++rep_index) {

  00d5b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rep_index$33689[rsp], 0
  00d66	eb 11		 jmp	 SHORT $LN39@helper2
$LN38@helper2:
  00d68	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR rep_index$33689[rsp]
  00d6f	83 c0 01	 add	 eax, 1
  00d72	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rep_index$33689[rsp], eax
$LN39@helper2:
  00d79	83 bc 24 9c 00
	00 00 04	 cmp	 DWORD PTR rep_index$33689[rsp], 4
  00d81	0f 83 3f 08 00
	00		 jae	 $LN37@helper2

; 648  : 		const uint8_t *const buf_back = buf - reps[rep_index] - 1;

  00d87	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR rep_index$33689[rsp]
  00d8e	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR reps$[rsp]
  00d96	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  00d99	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00da1	48 2b c1	 sub	 rax, rcx
  00da4	48 83 e8 01	 sub	 rax, 1
  00da8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR buf_back$33693[rsp], rax

; 649  : 		if (not_equal_16(buf, buf_back))

  00db0	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00db8	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00dbb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf_back$33693[rsp]
  00dc3	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00dc6	3b c8		 cmp	 ecx, eax
  00dc8	74 02		 je	 SHORT $LN36@helper2

; 650  : 			continue;

  00dca	eb 9c		 jmp	 SHORT $LN38@helper2
$LN36@helper2:

; 651  : 
; 652  : 	  { uint32_t len_test = lzma_memcmplen(buf, buf_back, 2, buf_avail);

  00dcc	c7 84 24 64 01
	00 00 02 00 00
	00		 mov	 DWORD PTR $T83029[rsp], 2
$LN177@helper2:
  00dd7	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  00ddb	39 84 24 64 01
	00 00		 cmp	 DWORD PTR $T83029[rsp], eax
  00de2	0f 83 b8 00 00
	00		 jae	 $LN176@helper2
  00de8	44 8b 84 24 64
	01 00 00	 mov	 r8d, DWORD PTR $T83029[rsp]
  00df0	8b 94 24 64 01
	00 00		 mov	 edx, DWORD PTR $T83029[rsp]
  00df7	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00dff	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR buf_back$33693[rsp]
  00e07	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00e0b	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  00e0f	48 2b c1	 sub	 rax, rcx
  00e12	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR x$83026[rsp], rax
  00e1a	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR x$83026[rsp], 0
  00e23	74 65		 je	 SHORT $LN175@helper2
  00e25	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR x$83026[rsp]
  00e2d	48 0f bc c0	 bsf	 rax, rax
  00e31	89 84 24 60 01
	00 00		 mov	 DWORD PTR tmp$83028[rsp], eax
  00e38	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tmp$83028[rsp]
  00e3f	c1 e9 03	 shr	 ecx, 3
  00e42	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR $T83029[rsp]
  00e49	03 c1		 add	 eax, ecx
  00e4b	89 84 24 64 01
	00 00		 mov	 DWORD PTR $T83029[rsp], eax
  00e52	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  00e56	39 84 24 64 01
	00 00		 cmp	 DWORD PTR $T83029[rsp], eax
  00e5d	73 10		 jae	 SHORT $LN180@helper2
  00e5f	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR $T83029[rsp]
  00e66	89 84 24 e4 01
	00 00		 mov	 DWORD PTR tv1094[rsp], eax
  00e6d	eb 0b		 jmp	 SHORT $LN181@helper2
$LN180@helper2:
  00e6f	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  00e73	89 84 24 e4 01
	00 00		 mov	 DWORD PTR tv1094[rsp], eax
$LN181@helper2:
  00e7a	8b 84 24 e4 01
	00 00		 mov	 eax, DWORD PTR tv1094[rsp]
  00e81	89 84 24 b0 00
	00 00		 mov	 DWORD PTR len_test$33697[rsp], eax
  00e88	eb 21		 jmp	 SHORT $LN178@helper2
$LN175@helper2:
  00e8a	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR $T83029[rsp]
  00e91	83 c0 08	 add	 eax, 8
  00e94	89 84 24 64 01
	00 00		 mov	 DWORD PTR $T83029[rsp], eax
  00e9b	e9 37 ff ff ff	 jmp	 $LN177@helper2
$LN176@helper2:
  00ea0	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  00ea4	89 84 24 b0 00
	00 00		 mov	 DWORD PTR len_test$33697[rsp], eax
$LN178@helper2:
$LN35@helper2:

; 653  : 
; 654  : 		while (len_end < cur + len_test)

  00eab	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  00eb2	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00eb9	03 c1		 add	 eax, ecx
  00ebb	39 84 24 38 02
	00 00		 cmp	 DWORD PTR len_end$[rsp], eax
  00ec2	73 31		 jae	 SHORT $LN34@helper2

; 655  : 			coder->opts[++len_end].price = RC_INFINITY_PRICE;

  00ec4	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  00ecb	83 c0 01	 add	 eax, 1
  00ece	89 84 24 38 02
	00 00		 mov	 DWORD PTR len_end$[rsp], eax
  00ed5	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR len_end$[rsp]
  00edc	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00ee0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00ee8	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H
  00ef3	eb b6		 jmp	 SHORT $LN35@helper2
$LN34@helper2:

; 656  : 
; 657  :       {
; 658  : 		const uint32_t len_test_temp = len_test;

  00ef5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  00efc	89 84 24 b4 00
	00 00		 mov	 DWORD PTR len_test_temp$33701[rsp], eax

; 659  : 		const uint32_t price = rep_match_price + get_pure_rep_price(
; 660  : 				coder, rep_index, state, pos_state);

  00f03	44 8b 4c 24 50	 mov	 r9d, DWORD PTR pos_state$33662[rsp]
  00f08	44 8b 44 24 3c	 mov	 r8d, DWORD PTR state$[rsp]
  00f0d	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR rep_index$33689[rsp]
  00f14	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00f1c	e8 00 00 00 00	 call	 get_pure_rep_price
  00f21	44 8b d8	 mov	 r11d, eax
  00f24	8b 44 24 68	 mov	 eax, DWORD PTR rep_match_price$33667[rsp]
  00f28	41 03 c3	 add	 eax, r11d
  00f2b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR price$33702[rsp], eax
$LN33@helper2:

; 661  : 
; 662  : 		do {
; 663  : 			const uint32_t cur_and_len_price = price
; 664  : 					+ get_len_price(&coder->rep_len_encoder,
; 665  : 							len_test, pos_state);

  00f32	8b 4c 24 50	 mov	 ecx, DWORD PTR pos_state$33662[rsp]
  00f36	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  00f3d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00f45	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  00f4d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  00f54	83 e8 02	 sub	 eax, 2
  00f57	8b c0		 mov	 eax, eax
  00f59	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00f5c	89 84 24 6c 01
	00 00		 mov	 DWORD PTR $T83052[rsp], eax
  00f63	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR $T83052[rsp]
  00f6a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR price$33702[rsp]
  00f71	03 c1		 add	 eax, ecx
  00f73	89 84 24 bc 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33706[rsp], eax

; 666  : 
; 667  : 			if (cur_and_len_price < coder->opts[cur + len_test].price) {

  00f7a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  00f81	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00f88	03 c1		 add	 eax, ecx
  00f8a	8b c8		 mov	 ecx, eax
  00f8c	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00f90	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00f98	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00f9f	39 84 24 bc 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33706[rsp], eax
  00fa6	0f 83 aa 00 00
	00		 jae	 $LN30@helper2

; 668  : 				coder->opts[cur + len_test].price = cur_and_len_price;

  00fac	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  00fb3	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00fba	03 c1		 add	 eax, ecx
  00fbc	8b d0		 mov	 edx, eax
  00fbe	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00fc2	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00fca	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33706[rsp]
  00fd1	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 669  : 				coder->opts[cur + len_test].pos_prev = cur;

  00fd8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  00fdf	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00fe6	03 c1		 add	 eax, ecx
  00fe8	8b d0		 mov	 edx, eax
  00fea	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00fee	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00ff6	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  00ffd	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 670  : 				coder->opts[cur + len_test].back_prev = rep_index;

  01004	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  0100b	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01012	03 c1		 add	 eax, ecx
  01014	8b d0		 mov	 edx, eax
  01016	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0101a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01022	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR rep_index$33689[rsp]
  01029	89 84 11 fc 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69372], eax

; 671  : 				coder->opts[cur + len_test].prev_1_is_literal = false;

  01030	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  01037	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  0103e	03 c1		 add	 eax, ecx
  01040	8b c8		 mov	 ecx, eax
  01042	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01046	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0104e	c6 84 08 e8 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69352], 0
$LN30@helper2:

; 672  : 			}
; 673  : 		} while (--len_test >= 2);

  01056	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  0105d	83 e8 01	 sub	 eax, 1
  01060	89 84 24 b0 00
	00 00		 mov	 DWORD PTR len_test$33697[rsp], eax
  01067	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR len_test$33697[rsp], 2
  0106f	0f 83 bd fe ff
	ff		 jae	 $LN33@helper2

; 674  : 
; 675  : 		len_test = len_test_temp;

  01075	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR len_test_temp$33701[rsp]
  0107c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR len_test$33697[rsp], eax

; 676  : 
; 677  : 		if (rep_index == 0)

  01083	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rep_index$33689[rsp], 0
  0108b	75 11		 jne	 SHORT $LN29@helper2

; 678  : 			start_len = len_test + 1;

  0108d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  01094	83 c0 01	 add	 eax, 1
  01097	89 84 24 a0 00
	00 00		 mov	 DWORD PTR start_len$33688[rsp], eax
$LN29@helper2:

; 679  : 
; 680  :       {
; 681  : 		uint32_t len_test_2 = len_test + 1;

  0109e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  010a5	83 c0 01	 add	 eax, 1
  010a8	89 84 24 c0 00
	00 00		 mov	 DWORD PTR len_test_2$33709[rsp], eax

; 682  : 		const uint32_t limit = my_min(buf_avail_full,
; 683  : 				len_test_2 + nice_len);

  010af	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR nice_len$[rsp]
  010b6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  010bd	03 c1		 add	 eax, ecx
  010bf	39 84 24 58 02
	00 00		 cmp	 DWORD PTR buf_avail_full$[rsp], eax
  010c6	73 10		 jae	 SHORT $LN110@helper2
  010c8	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR buf_avail_full$[rsp]
  010cf	89 84 24 e8 01
	00 00		 mov	 DWORD PTR tv598[rsp], eax
  010d6	eb 17		 jmp	 SHORT $LN111@helper2
$LN110@helper2:
  010d8	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR nice_len$[rsp]
  010df	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  010e6	03 c1		 add	 eax, ecx
  010e8	89 84 24 e8 01
	00 00		 mov	 DWORD PTR tv598[rsp], eax
$LN111@helper2:
  010ef	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR tv598[rsp]
  010f6	89 84 24 c4 00
	00 00		 mov	 DWORD PTR limit$33710[rsp], eax
  010fd	eb 11		 jmp	 SHORT $LN28@helper2
$LN27@helper2:

; 684  : 		for (; len_test_2 < limit
; 685  : 				&& buf[len_test_2] == buf_back[len_test_2];
; 686  : 				++len_test_2) ;

  010ff	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  01106	83 c0 01	 add	 eax, 1
  01109	89 84 24 c0 00
	00 00		 mov	 DWORD PTR len_test_2$33709[rsp], eax
$LN28@helper2:
  01110	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR limit$33710[rsp]
  01117	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR len_test_2$33709[rsp], eax
  0111e	73 2c		 jae	 SHORT $LN26@helper2
  01120	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len_test_2$33709[rsp]
  01127	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0112f	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  01133	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len_test_2$33709[rsp]
  0113a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf_back$33693[rsp]
  01142	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01146	3b d0		 cmp	 edx, eax
  01148	75 02		 jne	 SHORT $LN26@helper2
  0114a	eb b3		 jmp	 SHORT $LN27@helper2
$LN26@helper2:

; 687  : 
; 688  : 		len_test_2 -= len_test + 1;

  0114c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  01153	83 c1 01	 add	 ecx, 1
  01156	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  0115d	2b c1		 sub	 eax, ecx
  0115f	89 84 24 c0 00
	00 00		 mov	 DWORD PTR len_test_2$33709[rsp], eax

; 689  : 
; 690  : 		if (len_test_2 >= 2) {

  01166	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR len_test_2$33709[rsp], 2
  0116e	0f 82 4d 04 00
	00		 jb	 $LN25@helper2

; 691  : 			lzma_lzma_state state_2 = state;

  01174	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  01178	89 84 24 c8 00
	00 00		 mov	 DWORD PTR state_2$33715[rsp], eax

; 692  : 			update_long_rep(state_2);

  0117f	83 bc 24 c8 00
	00 00 07	 cmp	 DWORD PTR state_2$33715[rsp], 7
  01187	7d 0d		 jge	 SHORT $LN112@helper2
  01189	c7 84 24 ec 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv612[rsp], 8
  01194	eb 0b		 jmp	 SHORT $LN113@helper2
$LN112@helper2:
  01196	c7 84 24 ec 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv612[rsp], 11
$LN113@helper2:
  011a1	8b 84 24 ec 01
	00 00		 mov	 eax, DWORD PTR tv612[rsp]
  011a8	89 84 24 c8 00
	00 00		 mov	 DWORD PTR state_2$33715[rsp], eax

; 693  : 
; 694  :           {
; 695  : 			uint32_t pos_state_next = (position + len_test) & coder->pos_mask;

  011af	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  011b6	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  011bd	03 c1		 add	 eax, ecx
  011bf	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  011c7	23 81 90 0b 00
	00		 and	 eax, DWORD PTR [rcx+2960]
  011cd	89 84 24 d0 00
	00 00		 mov	 DWORD PTR pos_state_next$33716[rsp], eax

; 696  : 
; 697  : 			const uint32_t cur_and_len_literal_price = price
; 698  : 					+ get_len_price(&coder->rep_len_encoder,
; 699  : 						len_test, pos_state)
; 700  : 					+ rc_bit_0_price(coder->is_match[state_2][pos_state_next])
; 701  : 					+ get_literal_price(coder, position + len_test,
; 702  : 						buf[len_test - 1], true,
; 703  : 						buf_back[len_test], buf[len_test]);

  011d4	8b 4c 24 50	 mov	 ecx, DWORD PTR pos_state$33662[rsp]
  011d8	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  011df	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  011e7	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  011ef	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  011f6	83 e8 02	 sub	 eax, 2
  011f9	8b c0		 mov	 eax, eax
  011fb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  011fe	89 84 24 70 01
	00 00		 mov	 DWORD PTR $T83056[rsp], eax
  01205	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR pos_state_next$33716[rsp]
  0120c	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR state_2$33715[rsp]
  01214	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  01218	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01220	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  01228	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  0122c	c1 f8 04	 sar	 eax, 4
  0122f	48 63 c8	 movsxd	 rcx, eax
  01232	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  01239	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0123d	89 84 24 74 01
	00 00		 mov	 DWORD PTR $T83060[rsp], eax
  01244	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR $T83056[rsp]
  0124b	8b 9c 24 b8 00
	00 00		 mov	 ebx, DWORD PTR price$33702[rsp]
  01252	03 d8		 add	 ebx, eax
  01254	03 9c 24 74 01
	00 00		 add	 ebx, DWORD PTR $T83060[rsp]
  0125b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  01262	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0126a	44 0f b6 14 08	 movzx	 r10d, BYTE PTR [rax+rcx]
  0126f	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len_test$33697[rsp]
  01276	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf_back$33693[rsp]
  0127e	44 0f b6 0c 08	 movzx	 r9d, BYTE PTR [rax+rcx]
  01283	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  0128a	83 e8 01	 sub	 eax, 1
  0128d	8b c8		 mov	 ecx, eax
  0128f	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01297	44 0f b6 04 08	 movzx	 r8d, BYTE PTR [rax+rcx]
  0129c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  012a3	8b 94 24 40 02
	00 00		 mov	 edx, DWORD PTR position$[rsp]
  012aa	03 d0		 add	 edx, eax
  012ac	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  012b1	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  012b6	41 b1 01	 mov	 r9b, 1
  012b9	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  012c1	e8 00 00 00 00	 call	 get_literal_price
  012c6	44 8b d8	 mov	 r11d, eax
  012c9	8b c3		 mov	 eax, ebx
  012cb	41 03 c3	 add	 eax, r11d
  012ce	89 84 24 cc 00
	00 00		 mov	 DWORD PTR cur_and_len_literal_price$33717[rsp], eax

; 704  : 
; 705  : 			update_literal(state_2);

  012d5	83 bc 24 c8 00
	00 00 03	 cmp	 DWORD PTR state_2$33715[rsp], 3
  012dd	7f 0d		 jg	 SHORT $LN116@helper2
  012df	c7 84 24 f0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv656[rsp], 0
  012ea	eb 3c		 jmp	 SHORT $LN117@helper2
$LN116@helper2:
  012ec	83 bc 24 c8 00
	00 00 09	 cmp	 DWORD PTR state_2$33715[rsp], 9
  012f4	7f 13		 jg	 SHORT $LN114@helper2
  012f6	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR state_2$33715[rsp]
  012fd	83 e8 03	 sub	 eax, 3
  01300	89 84 24 f4 01
	00 00		 mov	 DWORD PTR tv655[rsp], eax
  01307	eb 11		 jmp	 SHORT $LN115@helper2
$LN114@helper2:
  01309	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR state_2$33715[rsp]
  01310	83 e8 06	 sub	 eax, 6
  01313	89 84 24 f4 01
	00 00		 mov	 DWORD PTR tv655[rsp], eax
$LN115@helper2:
  0131a	8b 84 24 f4 01
	00 00		 mov	 eax, DWORD PTR tv655[rsp]
  01321	89 84 24 f0 01
	00 00		 mov	 DWORD PTR tv656[rsp], eax
$LN117@helper2:
  01328	8b 84 24 f0 01
	00 00		 mov	 eax, DWORD PTR tv656[rsp]
  0132f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR state_2$33715[rsp], eax

; 706  : 
; 707  : 			pos_state_next = (position + len_test + 1) & coder->pos_mask;

  01336	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR position$[rsp]
  0133d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  01344	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  01348	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01350	23 81 90 0b 00
	00		 and	 eax, DWORD PTR [rcx+2960]
  01356	89 84 24 d0 00
	00 00		 mov	 DWORD PTR pos_state_next$33716[rsp], eax

; 708  : 
; 709  :           {
; 710  : 			const uint32_t next_rep_match_price = cur_and_len_literal_price
; 711  : 					+ rc_bit_1_price(coder->is_match[state_2][pos_state_next])
; 712  : 					+ rc_bit_1_price(coder->is_rep[state_2]);

  0135d	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR pos_state_next$33716[rsp]
  01364	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR state_2$33715[rsp]
  0136c	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  01370	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01378	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  01380	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  01384	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  01389	c1 e8 04	 shr	 eax, 4
  0138c	8b c8		 mov	 ecx, eax
  0138e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  01395	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01399	89 84 24 78 01
	00 00		 mov	 DWORD PTR $T83064[rsp], eax
  013a0	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR $T83064[rsp]
  013a7	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR cur_and_len_literal_price$33717[rsp]
  013ae	03 d0		 add	 edx, eax
  013b0	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR state_2$33715[rsp]
  013b8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  013c0	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  013c8	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  013cd	c1 e8 04	 shr	 eax, 4
  013d0	8b c8		 mov	 ecx, eax
  013d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  013d9	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  013dd	8b c2		 mov	 eax, edx
  013df	03 c1		 add	 eax, ecx
  013e1	89 84 24 d8 00
	00 00		 mov	 DWORD PTR next_rep_match_price$33718[rsp], eax

; 713  : 
; 714  : 			//for(; len_test_2 >= 2; len_test_2--) {
; 715  : 			const uint32_t offset = cur + len_test + 1 + len_test_2;

  013e8	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  013ef	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  013f6	03 c8		 add	 ecx, eax
  013f8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  013ff	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  01403	89 84 24 d4 00
	00 00		 mov	 DWORD PTR offset$33719[rsp], eax
$LN24@helper2:

; 716  : 
; 717  : 			while (len_end < offset)

  0140a	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR offset$33719[rsp]
  01411	39 84 24 38 02
	00 00		 cmp	 DWORD PTR len_end$[rsp], eax
  01418	73 31		 jae	 SHORT $LN23@helper2

; 718  : 				coder->opts[++len_end].price = RC_INFINITY_PRICE;

  0141a	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  01421	83 c0 01	 add	 eax, 1
  01424	89 84 24 38 02
	00 00		 mov	 DWORD PTR len_end$[rsp], eax
  0142b	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR len_end$[rsp]
  01432	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01436	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0143e	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H
  01449	eb bf		 jmp	 SHORT $LN24@helper2
$LN23@helper2:

; 719  : 
; 720  :           {
; 721  : 			const uint32_t cur_and_len_price = next_rep_match_price
; 722  : 					+ get_rep_price(coder, 0, len_test_2,
; 723  : 						state_2, pos_state_next);

  0144b	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR pos_state_next$33716[rsp]
  01452	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  01459	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01461	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  01469	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33709[rsp]
  01470	83 e8 02	 sub	 eax, 2
  01473	8b c0		 mov	 eax, eax
  01475	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01478	89 84 24 7c 01
	00 00		 mov	 DWORD PTR $T83072[rsp], eax
  0147f	44 8b 8c 24 d0
	00 00 00	 mov	 r9d, DWORD PTR pos_state_next$33716[rsp]
  01487	44 8b 84 24 c8
	00 00 00	 mov	 r8d, DWORD PTR state_2$33715[rsp]
  0148f	33 d2		 xor	 edx, edx
  01491	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01499	e8 00 00 00 00	 call	 get_pure_rep_price
  0149e	8b 8c 24 7c 01
	00 00		 mov	 ecx, DWORD PTR $T83072[rsp]
  014a5	03 c8		 add	 ecx, eax
  014a7	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR next_rep_match_price$33718[rsp]
  014ae	03 c1		 add	 eax, ecx
  014b0	89 84 24 dc 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33723[rsp], eax

; 724  : 
; 725  : 			if (cur_and_len_price < coder->opts[offset].price) {

  014b7	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR offset$33719[rsp]
  014be	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  014c2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  014ca	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  014d1	39 84 24 dc 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33723[rsp], eax
  014d8	0f 83 e3 00 00
	00		 jae	 $LN22@helper2

; 726  : 				coder->opts[offset].price = cur_and_len_price;

  014de	8b 94 24 d4 00
	00 00		 mov	 edx, DWORD PTR offset$33719[rsp]
  014e5	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  014e9	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  014f1	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33723[rsp]
  014f8	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 727  : 				coder->opts[offset].pos_prev = cur + len_test + 1;

  014ff	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  01506	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len_test$33697[rsp]
  0150d	8d 54 01 01	 lea	 edx, DWORD PTR [rcx+rax+1]
  01511	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR offset$33719[rsp]
  01518	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0151c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01524	89 94 08 f8 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69368], edx

; 728  : 				coder->opts[offset].back_prev = 0;

  0152b	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR offset$33719[rsp]
  01532	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01536	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0153e	c7 84 08 fc 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx+69372], 0

; 729  : 				coder->opts[offset].prev_1_is_literal = true;

  01549	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR offset$33719[rsp]
  01550	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01554	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0155c	c6 84 08 e8 0e
	01 00 01	 mov	 BYTE PTR [rax+rcx+69352], 1

; 730  : 				coder->opts[offset].prev_2 = true;

  01564	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR offset$33719[rsp]
  0156b	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0156f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01577	c6 84 08 e9 0e
	01 00 01	 mov	 BYTE PTR [rax+rcx+69353], 1

; 731  : 				coder->opts[offset].pos_prev_2 = cur;

  0157f	8b 94 24 d4 00
	00 00		 mov	 edx, DWORD PTR offset$33719[rsp]
  01586	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0158a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01592	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01599	89 84 11 ec 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69356], eax

; 732  : 				coder->opts[offset].back_prev_2 = rep_index;

  015a0	8b 94 24 d4 00
	00 00		 mov	 edx, DWORD PTR offset$33719[rsp]
  015a7	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  015ab	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  015b3	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR rep_index$33689[rsp]
  015ba	89 84 11 f0 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69360], eax
$LN22@helper2:
$LN25@helper2:

; 733  : 			}
; 734  : 			//}
; 735  : 		  }}}
; 736  : 		} //if
; 737  : 	  }}}
; 738  : 	}//for

  015c1	e9 a2 f7 ff ff	 jmp	 $LN38@helper2
$LN37@helper2:

; 739  : 
; 740  : 
; 741  : 	//for (uint32_t len_test = 2; len_test <= new_len; ++len_test)
; 742  : 	if (new_len > buf_avail) {

  015c6	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  015ca	39 44 24 38	 cmp	 DWORD PTR new_len$[rsp], eax
  015ce	76 58		 jbe	 SHORT $LN21@helper2

; 743  : 		new_len = buf_avail;

  015d0	8b 44 24 70	 mov	 eax, DWORD PTR buf_avail$33673[rsp]
  015d4	89 44 24 38	 mov	 DWORD PTR new_len$[rsp], eax

; 744  : 
; 745  : 		matches_count = 0;

  015d8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR matches_count$[rsp], 0
$LN20@helper2:

; 746  : 		while (new_len > coder->matches[matches_count].len)

  015e0	8b 4c 24 30	 mov	 ecx, DWORD PTR matches_count$[rsp]
  015e4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  015ec	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  015f3	39 44 24 38	 cmp	 DWORD PTR new_len$[rsp], eax
  015f7	76 0d		 jbe	 SHORT $LN19@helper2

; 747  : 			++matches_count;

  015f9	8b 44 24 30	 mov	 eax, DWORD PTR matches_count$[rsp]
  015fd	83 c0 01	 add	 eax, 1
  01600	89 44 24 30	 mov	 DWORD PTR matches_count$[rsp], eax
  01604	eb da		 jmp	 SHORT $LN20@helper2
$LN19@helper2:

; 748  : 
; 749  : 		coder->matches[matches_count++].len = new_len;

  01606	8b 54 24 30	 mov	 edx, DWORD PTR matches_count$[rsp]
  0160a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01612	8b 44 24 38	 mov	 eax, DWORD PTR new_len$[rsp]
  01616	89 84 d1 f4 02
	00 00		 mov	 DWORD PTR [rcx+rdx*8+756], eax
  0161d	8b 44 24 30	 mov	 eax, DWORD PTR matches_count$[rsp]
  01621	83 c0 01	 add	 eax, 1
  01624	89 44 24 30	 mov	 DWORD PTR matches_count$[rsp], eax
$LN21@helper2:

; 750  : 	}
; 751  : 
; 752  : 
; 753  : 	if (new_len >= start_len) {

  01628	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR start_len$33688[rsp]
  0162f	39 44 24 38	 cmp	 DWORD PTR new_len$[rsp], eax
  01633	0f 82 55 07 00
	00		 jb	 $LN18@helper2

; 754  : 		const uint32_t normal_match_price = match_price
; 755  : 				+ rc_bit_0_price(coder->is_rep[state]);

  01639	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR state$[rsp]
  0163e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01646	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  0164e	c1 f8 04	 sar	 eax, 4
  01651	48 63 c8	 movsxd	 rcx, eax
  01654	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0165b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0165f	8b 44 24 64	 mov	 eax, DWORD PTR match_price$33666[rsp]
  01663	03 c1		 add	 eax, ecx
  01665	89 84 24 e0 00
	00 00		 mov	 DWORD PTR normal_match_price$33730[rsp], eax
$LN17@helper2:

; 756  : 
; 757  : 		while (len_end < cur + new_len)

  0166c	8b 4c 24 38	 mov	 ecx, DWORD PTR new_len$[rsp]
  01670	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01677	03 c1		 add	 eax, ecx
  01679	39 84 24 38 02
	00 00		 cmp	 DWORD PTR len_end$[rsp], eax
  01680	73 31		 jae	 SHORT $LN16@helper2

; 758  : 			coder->opts[++len_end].price = RC_INFINITY_PRICE;

  01682	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  01689	83 c0 01	 add	 eax, 1
  0168c	89 84 24 38 02
	00 00		 mov	 DWORD PTR len_end$[rsp], eax
  01693	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR len_end$[rsp]
  0169a	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0169e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  016a6	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H
  016b1	eb b9		 jmp	 SHORT $LN17@helper2
$LN16@helper2:

; 759  : 
; 760  : 	  { uint32_t i = 0;

  016b3	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$33734[rsp], 0
$LN15@helper2:

; 761  : 		while (start_len > coder->matches[i].len)

  016be	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR i$33734[rsp]
  016c5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  016cd	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  016d4	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR start_len$33688[rsp], eax
  016db	76 13		 jbe	 SHORT $LN14@helper2

; 762  : 			++i;

  016dd	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR i$33734[rsp]
  016e4	83 c0 01	 add	 eax, 1
  016e7	89 84 24 e4 00
	00 00		 mov	 DWORD PTR i$33734[rsp], eax
  016ee	eb ce		 jmp	 SHORT $LN15@helper2
$LN14@helper2:

; 763  : 
; 764  :       { uint32_t len_test;
; 765  : 		for (len_test = start_len; ; ++len_test) {

  016f0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR start_len$33688[rsp]
  016f7	89 84 24 e8 00
	00 00		 mov	 DWORD PTR len_test$33738[rsp], eax
  016fe	eb 11		 jmp	 SHORT $LN13@helper2
$LN12@helper2:
  01700	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  01707	83 c0 01	 add	 eax, 1
  0170a	89 84 24 e8 00
	00 00		 mov	 DWORD PTR len_test$33738[rsp], eax
$LN13@helper2:

; 766  : 			const uint32_t cur_back = coder->matches[i].dist;

  01711	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR i$33734[rsp]
  01718	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01720	8b 84 c8 f8 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+760]
  01727	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cur_back$33742[rsp], eax

; 767  : 			uint32_t cur_and_len_price = normal_match_price
; 768  : 					+ get_dist_len_price(coder,
; 769  : 						cur_back, len_test, pos_state);

  0172e	44 8b 4c 24 50	 mov	 r9d, DWORD PTR pos_state$33662[rsp]
  01733	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR len_test$33738[rsp]
  0173b	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR cur_back$33742[rsp]
  01742	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0174a	e8 00 00 00 00	 call	 get_dist_len_price
  0174f	44 8b d8	 mov	 r11d, eax
  01752	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR normal_match_price$33730[rsp]
  01759	41 03 c3	 add	 eax, r11d
  0175c	89 84 24 ec 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33743[rsp], eax

; 770  : 
; 771  : 			if (cur_and_len_price < coder->opts[cur + len_test].price) {

  01763	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  0176a	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01771	03 c1		 add	 eax, ecx
  01773	8b c8		 mov	 ecx, eax
  01775	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01779	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01781	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  01788	39 84 24 ec 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33743[rsp], eax
  0178f	0f 83 ad 00 00
	00		 jae	 $LN10@helper2

; 772  : 				coder->opts[cur + len_test].price = cur_and_len_price;

  01795	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  0179c	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  017a3	03 c1		 add	 eax, ecx
  017a5	8b d0		 mov	 edx, eax
  017a7	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  017ab	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  017b3	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33743[rsp]
  017ba	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 773  : 				coder->opts[cur + len_test].pos_prev = cur;

  017c1	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  017c8	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  017cf	03 c1		 add	 eax, ecx
  017d1	8b d0		 mov	 edx, eax
  017d3	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  017d7	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  017df	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  017e6	89 84 11 f8 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69368], eax

; 774  : 				coder->opts[cur + len_test].back_prev
; 775  : 						= cur_back + REPS;

  017ed	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR cur_back$33742[rsp]
  017f4	83 c2 04	 add	 edx, 4
  017f7	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  017fe	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01805	03 c1		 add	 eax, ecx
  01807	8b c8		 mov	 ecx, eax
  01809	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0180d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01815	89 94 08 fc 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69372], edx

; 776  : 				coder->opts[cur + len_test].prev_1_is_literal = false;

  0181c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  01823	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  0182a	03 c1		 add	 eax, ecx
  0182c	8b c8		 mov	 ecx, eax
  0182e	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01832	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0183a	c6 84 08 e8 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69352], 0
$LN10@helper2:

; 777  : 			}
; 778  : 
; 779  : 			if (len_test == coder->matches[i].len) {

  01842	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR i$33734[rsp]
  01849	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01851	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  01858	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR len_test$33738[rsp], eax
  0185f	0f 85 24 05 00
	00		 jne	 $LN9@helper2

; 780  : 				// Try Match + Literal + Rep0
; 781  : 				const uint8_t *const buf_back = buf - cur_back - 1;

  01865	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR cur_back$33742[rsp]
  0186c	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01874	48 2b c1	 sub	 rax, rcx
  01877	48 83 e8 01	 sub	 rax, 1
  0187b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR buf_back$33746[rsp], rax

; 782  : 				uint32_t len_test_2 = len_test + 1;

  01883	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  0188a	83 c0 01	 add	 eax, 1
  0188d	89 84 24 f4 00
	00 00		 mov	 DWORD PTR len_test_2$33747[rsp], eax

; 783  : 				const uint32_t limit = my_min(buf_avail_full,
; 784  : 						len_test_2 + nice_len);

  01894	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR nice_len$[rsp]
  0189b	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  018a2	03 c1		 add	 eax, ecx
  018a4	39 84 24 58 02
	00 00		 cmp	 DWORD PTR buf_avail_full$[rsp], eax
  018ab	73 10		 jae	 SHORT $LN118@helper2
  018ad	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR buf_avail_full$[rsp]
  018b4	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv828[rsp], eax
  018bb	eb 17		 jmp	 SHORT $LN119@helper2
$LN118@helper2:
  018bd	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR nice_len$[rsp]
  018c4	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  018cb	03 c1		 add	 eax, ecx
  018cd	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv828[rsp], eax
$LN119@helper2:
  018d4	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR tv828[rsp]
  018db	89 84 24 00 01
	00 00		 mov	 DWORD PTR limit$33748[rsp], eax
  018e2	eb 11		 jmp	 SHORT $LN8@helper2
$LN7@helper2:

; 785  : 
; 786  : 				for (; len_test_2 < limit &&
; 787  : 						buf[len_test_2] == buf_back[len_test_2];
; 788  : 						++len_test_2) ;

  018e4	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  018eb	83 c0 01	 add	 eax, 1
  018ee	89 84 24 f4 00
	00 00		 mov	 DWORD PTR len_test_2$33747[rsp], eax
$LN8@helper2:
  018f5	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR limit$33748[rsp]
  018fc	39 84 24 f4 00
	00 00		 cmp	 DWORD PTR len_test_2$33747[rsp], eax
  01903	73 2c		 jae	 SHORT $LN6@helper2
  01905	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR len_test_2$33747[rsp]
  0190c	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01914	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  01918	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR len_test_2$33747[rsp]
  0191f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR buf_back$33746[rsp]
  01927	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0192b	3b d0		 cmp	 edx, eax
  0192d	75 02		 jne	 SHORT $LN6@helper2
  0192f	eb b3		 jmp	 SHORT $LN7@helper2
$LN6@helper2:

; 789  : 
; 790  : 				len_test_2 -= len_test + 1;

  01931	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  01938	83 c1 01	 add	 ecx, 1
  0193b	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  01942	2b c1		 sub	 eax, ecx
  01944	89 84 24 f4 00
	00 00		 mov	 DWORD PTR len_test_2$33747[rsp], eax

; 791  : 
; 792  : 				if (len_test_2 >= 2) {

  0194b	83 bc 24 f4 00
	00 00 02	 cmp	 DWORD PTR len_test_2$33747[rsp], 2
  01953	0f 82 10 04 00
	00		 jb	 $LN5@helper2

; 793  : 					lzma_lzma_state state_2 = state;

  01959	8b 44 24 3c	 mov	 eax, DWORD PTR state$[rsp]
  0195d	89 84 24 04 01
	00 00		 mov	 DWORD PTR state_2$33753[rsp], eax

; 794  : 					update_match(state_2);

  01964	83 bc 24 04 01
	00 00 07	 cmp	 DWORD PTR state_2$33753[rsp], 7
  0196c	7d 0d		 jge	 SHORT $LN120@helper2
  0196e	c7 84 24 fc 01
	00 00 07 00 00
	00		 mov	 DWORD PTR tv842[rsp], 7
  01979	eb 0b		 jmp	 SHORT $LN121@helper2
$LN120@helper2:
  0197b	c7 84 24 fc 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv842[rsp], 10
$LN121@helper2:
  01986	8b 84 24 fc 01
	00 00		 mov	 eax, DWORD PTR tv842[rsp]
  0198d	89 84 24 04 01
	00 00		 mov	 DWORD PTR state_2$33753[rsp], eax

; 795  : 				  {
; 796  : 				    uint32_t pos_state_next
; 797  : 							= (position + len_test) & coder->pos_mask;

  01994	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  0199b	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  019a2	03 c1		 add	 eax, ecx
  019a4	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  019ac	23 81 90 0b 00
	00		 and	 eax, DWORD PTR [rcx+2960]
  019b2	89 84 24 0c 01
	00 00		 mov	 DWORD PTR pos_state_next$33754[rsp], eax

; 798  : 
; 799  : 					const uint32_t cur_and_len_literal_price = cur_and_len_price
; 800  : 							+ rc_bit_0_price(
; 801  : 								coder->is_match[state_2][pos_state_next])
; 802  : 							+ get_literal_price(coder,
; 803  : 								position + len_test,
; 804  : 								buf[len_test - 1],
; 805  : 								true,
; 806  : 								buf_back[len_test],
; 807  : 								buf[len_test]);

  019b9	8b 94 24 0c 01
	00 00		 mov	 edx, DWORD PTR pos_state_next$33754[rsp]
  019c0	48 63 8c 24 04
	01 00 00	 movsxd	 rcx, DWORD PTR state_2$33753[rsp]
  019c8	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  019cc	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  019d4	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  019dc	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  019e0	c1 f8 04	 sar	 eax, 4
  019e3	48 63 c8	 movsxd	 rcx, eax
  019e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  019ed	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  019f1	89 84 24 94 01
	00 00		 mov	 DWORD PTR $T83110[rsp], eax
  019f8	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR $T83110[rsp]
  019ff	8b 9c 24 ec 00
	00 00		 mov	 ebx, DWORD PTR cur_and_len_price$33743[rsp]
  01a06	03 d8		 add	 ebx, eax
  01a08	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  01a0f	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01a17	44 0f b6 14 08	 movzx	 r10d, BYTE PTR [rax+rcx]
  01a1c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR len_test$33738[rsp]
  01a23	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR buf_back$33746[rsp]
  01a2b	44 0f b6 0c 08	 movzx	 r9d, BYTE PTR [rax+rcx]
  01a30	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  01a37	83 e8 01	 sub	 eax, 1
  01a3a	8b c8		 mov	 ecx, eax
  01a3c	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01a44	44 0f b6 04 08	 movzx	 r8d, BYTE PTR [rax+rcx]
  01a49	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  01a50	8b 94 24 40 02
	00 00		 mov	 edx, DWORD PTR position$[rsp]
  01a57	03 d0		 add	 edx, eax
  01a59	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  01a5e	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  01a63	41 b1 01	 mov	 r9b, 1
  01a66	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01a6e	e8 00 00 00 00	 call	 get_literal_price
  01a73	44 8b d8	 mov	 r11d, eax
  01a76	8b c3		 mov	 eax, ebx
  01a78	41 03 c3	 add	 eax, r11d
  01a7b	89 84 24 08 01
	00 00		 mov	 DWORD PTR cur_and_len_literal_price$33755[rsp], eax

; 808  : 
; 809  : 					update_literal(state_2);

  01a82	83 bc 24 04 01
	00 00 03	 cmp	 DWORD PTR state_2$33753[rsp], 3
  01a8a	7f 0d		 jg	 SHORT $LN124@helper2
  01a8c	c7 84 24 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv880[rsp], 0
  01a97	eb 3c		 jmp	 SHORT $LN125@helper2
$LN124@helper2:
  01a99	83 bc 24 04 01
	00 00 09	 cmp	 DWORD PTR state_2$33753[rsp], 9
  01aa1	7f 13		 jg	 SHORT $LN122@helper2
  01aa3	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR state_2$33753[rsp]
  01aaa	83 e8 03	 sub	 eax, 3
  01aad	89 84 24 04 02
	00 00		 mov	 DWORD PTR tv879[rsp], eax
  01ab4	eb 11		 jmp	 SHORT $LN123@helper2
$LN122@helper2:
  01ab6	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR state_2$33753[rsp]
  01abd	83 e8 06	 sub	 eax, 6
  01ac0	89 84 24 04 02
	00 00		 mov	 DWORD PTR tv879[rsp], eax
$LN123@helper2:
  01ac7	8b 84 24 04 02
	00 00		 mov	 eax, DWORD PTR tv879[rsp]
  01ace	89 84 24 00 02
	00 00		 mov	 DWORD PTR tv880[rsp], eax
$LN125@helper2:
  01ad5	8b 84 24 00 02
	00 00		 mov	 eax, DWORD PTR tv880[rsp]
  01adc	89 84 24 04 01
	00 00		 mov	 DWORD PTR state_2$33753[rsp], eax

; 810  : 					pos_state_next = (pos_state_next + 1) & coder->pos_mask;

  01ae3	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR pos_state_next$33754[rsp]
  01aea	83 c0 01	 add	 eax, 1
  01aed	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01af5	23 81 90 0b 00
	00		 and	 eax, DWORD PTR [rcx+2960]
  01afb	89 84 24 0c 01
	00 00		 mov	 DWORD PTR pos_state_next$33754[rsp], eax

; 811  : 
; 812  :                   {
; 813  : 					const uint32_t next_rep_match_price
; 814  : 							= cur_and_len_literal_price
; 815  : 							+ rc_bit_1_price(
; 816  : 								coder->is_match[state_2][pos_state_next])
; 817  : 							+ rc_bit_1_price(coder->is_rep[state_2]);

  01b02	8b 94 24 0c 01
	00 00		 mov	 edx, DWORD PTR pos_state_next$33754[rsp]
  01b09	48 63 8c 24 04
	01 00 00	 movsxd	 rcx, DWORD PTR state_2$33753[rsp]
  01b11	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  01b15	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01b1d	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  01b25	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  01b29	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  01b2e	c1 e8 04	 shr	 eax, 4
  01b31	8b c8		 mov	 ecx, eax
  01b33	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  01b3a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01b3e	89 84 24 98 01
	00 00		 mov	 DWORD PTR $T83114[rsp], eax
  01b45	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR $T83114[rsp]
  01b4c	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR cur_and_len_literal_price$33755[rsp]
  01b53	03 d0		 add	 edx, eax
  01b55	48 63 8c 24 04
	01 00 00	 movsxd	 rcx, DWORD PTR state_2$33753[rsp]
  01b5d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01b65	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  01b6d	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  01b72	c1 e8 04	 shr	 eax, 4
  01b75	8b c8		 mov	 ecx, eax
  01b77	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  01b7e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  01b82	8b c2		 mov	 eax, edx
  01b84	03 c1		 add	 eax, ecx
  01b86	89 84 24 14 01
	00 00		 mov	 DWORD PTR next_rep_match_price$33756[rsp], eax

; 818  : 
; 819  : 					// for(; len_test_2 >= 2; --len_test_2) {
; 820  : 					const uint32_t offset = cur + len_test + 1 + len_test_2;

  01b8d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  01b94	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  01b9b	03 c8		 add	 ecx, eax
  01b9d	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  01ba4	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  01ba8	89 84 24 10 01
	00 00		 mov	 DWORD PTR offset$33757[rsp], eax
$LN4@helper2:

; 821  : 
; 822  : 					while (len_end < offset)

  01baf	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR offset$33757[rsp]
  01bb6	39 84 24 38 02
	00 00		 cmp	 DWORD PTR len_end$[rsp], eax
  01bbd	73 31		 jae	 SHORT $LN3@helper2

; 823  : 						coder->opts[++len_end].price = RC_INFINITY_PRICE;

  01bbf	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
  01bc6	83 c0 01	 add	 eax, 1
  01bc9	89 84 24 38 02
	00 00		 mov	 DWORD PTR len_end$[rsp], eax
  01bd0	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR len_end$[rsp]
  01bd7	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01bdb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01be3	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H
  01bee	eb bf		 jmp	 SHORT $LN4@helper2
$LN3@helper2:

; 824  : 
; 825  : 					cur_and_len_price = next_rep_match_price
; 826  : 							+ get_rep_price(coder, 0, len_test_2,
; 827  : 								state_2, pos_state_next);

  01bf0	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR pos_state_next$33754[rsp]
  01bf7	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  01bfe	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01c06	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  01c0e	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR len_test_2$33747[rsp]
  01c15	83 e8 02	 sub	 eax, 2
  01c18	8b c0		 mov	 eax, eax
  01c1a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01c1d	89 84 24 9c 01
	00 00		 mov	 DWORD PTR $T83122[rsp], eax
  01c24	44 8b 8c 24 0c
	01 00 00	 mov	 r9d, DWORD PTR pos_state_next$33754[rsp]
  01c2c	44 8b 84 24 04
	01 00 00	 mov	 r8d, DWORD PTR state_2$33753[rsp]
  01c34	33 d2		 xor	 edx, edx
  01c36	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01c3e	e8 00 00 00 00	 call	 get_pure_rep_price
  01c43	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR $T83122[rsp]
  01c4a	03 c8		 add	 ecx, eax
  01c4c	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR next_rep_match_price$33756[rsp]
  01c53	03 c1		 add	 eax, ecx
  01c55	89 84 24 ec 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33743[rsp], eax

; 828  : 
; 829  : 					if (cur_and_len_price < coder->opts[offset].price) {

  01c5c	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01c63	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01c67	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01c6f	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  01c76	39 84 24 ec 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33743[rsp], eax
  01c7d	0f 83 e6 00 00
	00		 jae	 $LN2@helper2

; 830  : 						coder->opts[offset].price = cur_and_len_price;

  01c83	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR offset$33757[rsp]
  01c8a	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  01c8e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01c96	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33743[rsp]
  01c9d	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 831  : 						coder->opts[offset].pos_prev = cur + len_test + 1;

  01ca4	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR cur$[rsp]
  01cab	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR len_test$33738[rsp]
  01cb2	8d 54 01 01	 lea	 edx, DWORD PTR [rcx+rax+1]
  01cb6	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01cbd	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01cc1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01cc9	89 94 08 f8 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69368], edx

; 832  : 						coder->opts[offset].back_prev = 0;

  01cd0	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01cd7	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01cdb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01ce3	c7 84 08 fc 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx+69372], 0

; 833  : 						coder->opts[offset].prev_1_is_literal = true;

  01cee	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01cf5	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01cf9	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01d01	c6 84 08 e8 0e
	01 00 01	 mov	 BYTE PTR [rax+rcx+69352], 1

; 834  : 						coder->opts[offset].prev_2 = true;

  01d09	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01d10	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01d14	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01d1c	c6 84 08 e9 0e
	01 00 01	 mov	 BYTE PTR [rax+rcx+69353], 1

; 835  : 						coder->opts[offset].pos_prev_2 = cur;

  01d24	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR offset$33757[rsp]
  01d2b	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  01d2f	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  01d37	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR cur$[rsp]
  01d3e	89 84 11 ec 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69356], eax

; 836  : 						coder->opts[offset].back_prev_2
; 837  : 								= cur_back + REPS;

  01d45	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR cur_back$33742[rsp]
  01d4c	83 c2 04	 add	 edx, 4
  01d4f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR offset$33757[rsp]
  01d56	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  01d5a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  01d62	89 94 08 f0 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69360], edx
$LN2@helper2:
$LN5@helper2:

; 838  : 					}
; 839  : 					//}
; 840  : 				  }}
; 841  : 				}
; 842  : 
; 843  : 				if (++i == matches_count)

  01d69	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR i$33734[rsp]
  01d70	83 c0 01	 add	 eax, 1
  01d73	89 84 24 e4 00
	00 00		 mov	 DWORD PTR i$33734[rsp], eax
  01d7a	8b 44 24 30	 mov	 eax, DWORD PTR matches_count$[rsp]
  01d7e	39 84 24 e4 00
	00 00		 cmp	 DWORD PTR i$33734[rsp], eax
  01d85	75 02		 jne	 SHORT $LN1@helper2

; 844  : 					break;

  01d87	eb 05		 jmp	 SHORT $LN11@helper2
$LN1@helper2:
$LN9@helper2:

; 845  : 			} //if
; 846  : 		} //for

  01d89	e9 72 f9 ff ff	 jmp	 $LN12@helper2
$LN11@helper2:
$LN18@helper2:

; 847  : 	  }}
; 848  : 	} //if
; 849  :   }
; 850  :   }}}
; 851  : 
; 852  : 	return len_end;

  01d8e	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR len_end$[rsp]
$LN78@helper2:

; 853  : }

  01d95	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  01d9c	5b		 pop	 rbx
  01d9d	c3		 ret	 0
helper2	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$helper1 DD imagerel helper1
	DD	imagerel helper1+2828
	DD	imagerel $unwind$helper1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$helper1 DD 021b01H
	DD	023011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT helper1
_TEXT	SEGMENT
matches_count$ = 48
len_main$ = 52
nice_len$ = 56
buf_avail$33546 = 60
i$33551 = 64
rep_max_index$33550 = 68
buf$33548 = 72
rep_lens$33549 = 80
buf_back$33555 = 96
current_byte$33562 = 104
match_byte$33563 = 105
pos_state$33565 = 108
match_price$33566 = 112
rep_match_price$33567 = 116
short_rep_price$33569 = 120
len_end$33571 = 124
len$33576 = 128
rep_len$33583 = 132
price$33585 = 136
cur_and_len_price$33589 = 140
len$33592 = 144
normal_match_price$33591 = 148
i$33594 = 152
cur_and_len_price$33602 = 156
dist$33601 = 160
x$83177 = 168
tmp$83179 = 176
$T83180 = 180
$T83181 = 184
$T83186 = 188
$T83191 = 192
$T83195 = 196
$T83199 = 200
$T83217 = 216
$T83240 = 228
tv81 = 248
tv452 = 252
tv208 = 256
tv264 = 260
tv348 = 264
coder$ = 288
mf$ = 296
back_res$ = 304
len_res$ = 312
position$ = 320
helper1	PROC						; COMDAT

; 293  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 294  : 	const uint32_t nice_len = mf->nice_len;

  0001b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00023	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00026	89 44 24 38	 mov	 DWORD PTR nice_len$[rsp], eax

; 295  : 
; 296  : 	uint32_t len_main;
; 297  : 	uint32_t matches_count;
; 298  : 
; 299  : 	if (mf->read_ahead == 0) {

  0002a	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00032	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00036	75 27		 jne	 SHORT $LN37@helper1

; 300  : 		len_main = mf_find(mf, &matches_count, coder->matches);

  00038	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR coder$[rsp]
  00040	49 81 c0 f4 02
	00 00		 add	 r8, 756			; 000002f4H
  00047	48 8d 54 24 30	 lea	 rdx, QWORD PTR matches_count$[rsp]
  0004c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00054	e8 00 00 00 00	 call	 lzma_mf_find
  00059	89 44 24 34	 mov	 DWORD PTR len_main$[rsp], eax

; 301  : 	} else {

  0005d	eb 24		 jmp	 SHORT $LN36@helper1
$LN37@helper1:

; 302  : 		assert(mf->read_ahead == 1);
; 303  : 		len_main = coder->longest_match_length;

  0005f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00067	8b 80 88 0b 00
	00		 mov	 eax, DWORD PTR [rax+2952]
  0006d	89 44 24 34	 mov	 DWORD PTR len_main$[rsp], eax

; 304  : 		matches_count = coder->matches_count;

  00071	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00079	8b 80 84 0b 00
	00		 mov	 eax, DWORD PTR [rax+2948]
  0007f	89 44 24 30	 mov	 DWORD PTR matches_count$[rsp], eax
$LN36@helper1:

; 305  : 	}
; 306  : 
; 307  :   {
; 308  : 	const uint32_t buf_avail = my_min(mf_avail(mf) + 1, MATCH_LEN_MAX);

  00083	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  0008b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00093	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00096	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00099	2b c1		 sub	 eax, ecx
  0009b	83 c0 01	 add	 eax, 1
  0009e	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  000a3	73 24		 jae	 SHORT $LN40@helper1
  000a5	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  000ad	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000b5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000b8	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  000bb	2b c1		 sub	 eax, ecx
  000bd	83 c0 01	 add	 eax, 1
  000c0	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  000c7	eb 0b		 jmp	 SHORT $LN41@helper1
$LN40@helper1:
  000c9	c7 84 24 f8 00
	00 00 11 01 00
	00		 mov	 DWORD PTR tv81[rsp], 273 ; 00000111H
$LN41@helper1:
  000d4	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  000db	89 44 24 3c	 mov	 DWORD PTR buf_avail$33546[rsp], eax

; 309  : 	if (buf_avail < 2) {

  000df	83 7c 24 3c 02	 cmp	 DWORD PTR buf_avail$33546[rsp], 2
  000e4	73 26		 jae	 SHORT $LN35@helper1

; 310  : 		*back_res = UINT32_MAX;

  000e6	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  000ee	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 311  : 		*len_res = 1;

  000f4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  000fc	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 312  : 		return UINT32_MAX;

  00102	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00107	e9 f8 09 00 00	 jmp	 $LN38@helper1
$LN35@helper1:

; 313  : 	}
; 314  : 
; 315  :   {
; 316  : 	const uint8_t *const buf = mf_ptr(mf) - 1;

  0010c	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00114	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00117	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0011f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00122	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00127	48 89 44 24 48	 mov	 QWORD PTR buf$33548[rsp], rax

; 317  : 
; 318  : 	uint32_t rep_lens[REPS];
; 319  : 	uint32_t rep_max_index = 0;

  0012c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rep_max_index$33550[rsp], 0

; 320  : 	uint32_t i;
; 321  : 
; 322  : 	for (i = 0; i < REPS; ++i) {

  00134	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$33551[rsp], 0
  0013c	eb 0b		 jmp	 SHORT $LN34@helper1
$LN33@helper1:
  0013e	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  00142	83 c0 01	 add	 eax, 1
  00145	89 44 24 40	 mov	 DWORD PTR i$33551[rsp], eax
$LN34@helper1:
  00149	83 7c 24 40 04	 cmp	 DWORD PTR i$33551[rsp], 4
  0014e	0f 83 4d 01 00
	00		 jae	 $LN32@helper1

; 323  : 		const uint8_t *const buf_back = buf - coder->reps[i] - 1;

  00154	8b 4c 24 40	 mov	 ecx, DWORD PTR i$33551[rsp]
  00158	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00160	8b 8c 88 e4 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*4+740]
  00167	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  0016c	48 2b c1	 sub	 rax, rcx
  0016f	48 83 e8 01	 sub	 rax, 1
  00173	48 89 44 24 60	 mov	 QWORD PTR buf_back$33555[rsp], rax

; 324  : 
; 325  : 		if (not_equal_16(buf, buf_back)) {

  00178	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  0017d	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR buf_back$33555[rsp]
  00185	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00188	3b c8		 cmp	 ecx, eax
  0018a	74 0e		 je	 SHORT $LN31@helper1

; 326  : 			rep_lens[i] = 0;

  0018c	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  00190	c7 44 84 50 00
	00 00 00	 mov	 DWORD PTR rep_lens$33549[rsp+rax*4], 0

; 327  : 			continue;

  00198	eb a4		 jmp	 SHORT $LN33@helper1
$LN31@helper1:

; 328  : 		}
; 329  : 
; 330  : 		rep_lens[i] = lzma_memcmplen(buf, buf_back, 2, buf_avail);

  0019a	c7 84 24 b4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR $T83180[rsp], 2
$LN56@helper1:
  001a5	8b 44 24 3c	 mov	 eax, DWORD PTR buf_avail$33546[rsp]
  001a9	39 84 24 b4 00
	00 00		 cmp	 DWORD PTR $T83180[rsp], eax
  001b0	0f 83 b2 00 00
	00		 jae	 $LN55@helper1
  001b6	44 8b 84 24 b4
	00 00 00	 mov	 r8d, DWORD PTR $T83180[rsp]
  001be	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR $T83180[rsp]
  001c5	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  001ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buf_back$33555[rsp]
  001cf	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001d3	4a 8b 04 00	 mov	 rax, QWORD PTR [rax+r8]
  001d7	48 2b c1	 sub	 rax, rcx
  001da	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR x$83177[rsp], rax
  001e2	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR x$83177[rsp], 0
  001eb	74 65		 je	 SHORT $LN54@helper1
  001ed	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR x$83177[rsp]
  001f5	48 0f bc c0	 bsf	 rax, rax
  001f9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tmp$83179[rsp], eax
  00200	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tmp$83179[rsp]
  00207	c1 e9 03	 shr	 ecx, 3
  0020a	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR $T83180[rsp]
  00211	03 c1		 add	 eax, ecx
  00213	89 84 24 b4 00
	00 00		 mov	 DWORD PTR $T83180[rsp], eax
  0021a	8b 44 24 3c	 mov	 eax, DWORD PTR buf_avail$33546[rsp]
  0021e	39 84 24 b4 00
	00 00		 cmp	 DWORD PTR $T83180[rsp], eax
  00225	73 10		 jae	 SHORT $LN59@helper1
  00227	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR $T83180[rsp]
  0022e	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv452[rsp], eax
  00235	eb 0b		 jmp	 SHORT $LN60@helper1
$LN59@helper1:
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR buf_avail$33546[rsp]
  0023b	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv452[rsp], eax
$LN60@helper1:
  00242	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv452[rsp]
  00249	89 84 24 b8 00
	00 00		 mov	 DWORD PTR $T83181[rsp], eax
  00250	eb 21		 jmp	 SHORT $LN57@helper1
$LN54@helper1:
  00252	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR $T83180[rsp]
  00259	83 c0 08	 add	 eax, 8
  0025c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR $T83180[rsp], eax
  00263	e9 3d ff ff ff	 jmp	 $LN56@helper1
$LN55@helper1:
  00268	8b 44 24 3c	 mov	 eax, DWORD PTR buf_avail$33546[rsp]
  0026c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR $T83181[rsp], eax
$LN57@helper1:
  00273	8b 4c 24 40	 mov	 ecx, DWORD PTR i$33551[rsp]
  00277	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR $T83181[rsp]
  0027e	89 44 8c 50	 mov	 DWORD PTR rep_lens$33549[rsp+rcx*4], eax

; 331  : 
; 332  : 		if (rep_lens[i] > rep_lens[rep_max_index])

  00282	8b 4c 24 40	 mov	 ecx, DWORD PTR i$33551[rsp]
  00286	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  0028a	8b 44 84 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp+rax*4]
  0028e	39 44 8c 50	 cmp	 DWORD PTR rep_lens$33549[rsp+rcx*4], eax
  00292	76 08		 jbe	 SHORT $LN30@helper1

; 333  : 			rep_max_index = i;

  00294	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  00298	89 44 24 44	 mov	 DWORD PTR rep_max_index$33550[rsp], eax
$LN30@helper1:

; 334  : 	}

  0029c	e9 9d fe ff ff	 jmp	 $LN33@helper1
$LN32@helper1:

; 335  : 
; 336  : 	if (rep_lens[rep_max_index] >= nice_len) {

  002a1	8b 4c 24 44	 mov	 ecx, DWORD PTR rep_max_index$33550[rsp]
  002a5	8b 44 24 38	 mov	 eax, DWORD PTR nice_len$[rsp]
  002a9	39 44 8c 50	 cmp	 DWORD PTR rep_lens$33549[rsp+rcx*4], eax
  002ad	0f 82 80 00 00
	00		 jb	 $LN29@helper1

; 337  : 		*back_res = rep_max_index;

  002b3	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR back_res$[rsp]
  002bb	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  002bf	89 01		 mov	 DWORD PTR [rcx], eax

; 338  : 		*len_res = rep_lens[rep_max_index];

  002c1	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  002c5	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  002cd	8b 44 84 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp+rax*4]
  002d1	89 01		 mov	 DWORD PTR [rcx], eax

; 339  : 		mf_skip(mf, *len_res - 1);

  002d3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  002db	8b 00		 mov	 eax, DWORD PTR [rax]
  002dd	83 e8 01	 sub	 eax, 1
  002e0	89 84 24 bc 00
	00 00		 mov	 DWORD PTR $T83186[rsp], eax
  002e7	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR $T83186[rsp], 0
  002ef	74 38		 je	 SHORT $LN61@helper1
  002f1	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR $T83186[rsp]
  002f8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00300	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00308	ff 50 38	 call	 QWORD PTR [rax+56]
  0030b	4c 8b 9c 24 28
	01 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  00313	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  00317	03 8c 24 bc 00
	00 00		 add	 ecx, DWORD PTR $T83186[rsp]
  0031e	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00326	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN61@helper1:

; 340  : 		return UINT32_MAX;

  00329	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0032e	e9 d1 07 00 00	 jmp	 $LN38@helper1
$LN29@helper1:

; 341  : 	}
; 342  : 
; 343  : 
; 344  : 	if (len_main >= nice_len) {

  00333	8b 44 24 38	 mov	 eax, DWORD PTR nice_len$[rsp]
  00337	39 44 24 34	 cmp	 DWORD PTR len_main$[rsp], eax
  0033b	0f 82 8d 00 00
	00		 jb	 $LN28@helper1

; 345  : 		*back_res = coder->matches[matches_count - 1].dist + REPS;

  00341	8b 44 24 30	 mov	 eax, DWORD PTR matches_count$[rsp]
  00345	83 e8 01	 sub	 eax, 1
  00348	8b c8		 mov	 ecx, eax
  0034a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00352	8b 8c c8 f8 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*8+760]
  00359	83 c1 04	 add	 ecx, 4
  0035c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  00364	89 08		 mov	 DWORD PTR [rax], ecx

; 346  : 		*len_res = len_main;

  00366	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR len_res$[rsp]
  0036e	8b 44 24 34	 mov	 eax, DWORD PTR len_main$[rsp]
  00372	89 01		 mov	 DWORD PTR [rcx], eax

; 347  : 		mf_skip(mf, len_main - 1);

  00374	8b 44 24 34	 mov	 eax, DWORD PTR len_main$[rsp]
  00378	83 e8 01	 sub	 eax, 1
  0037b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR $T83191[rsp], eax
  00382	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR $T83191[rsp], 0
  0038a	74 38		 je	 SHORT $LN64@helper1
  0038c	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR $T83191[rsp]
  00393	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  0039b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  003a3	ff 50 38	 call	 QWORD PTR [rax+56]
  003a6	4c 8b 9c 24 28
	01 00 00	 mov	 r11, QWORD PTR mf$[rsp]
  003ae	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  003b2	03 8c 24 c0 00
	00 00		 add	 ecx, DWORD PTR $T83191[rsp]
  003b9	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  003c1	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN64@helper1:

; 348  : 		return UINT32_MAX;

  003c4	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  003c9	e9 36 07 00 00	 jmp	 $LN38@helper1
$LN28@helper1:

; 349  : 	}
; 350  : 
; 351  :   {
; 352  : 	const uint8_t current_byte = *buf;

  003ce	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  003d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003d6	88 44 24 68	 mov	 BYTE PTR current_byte$33562[rsp], al

; 353  : 	const uint8_t match_byte = *(buf - coder->reps[0] - 1);

  003da	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003e2	8b 88 e4 02 00
	00		 mov	 ecx, DWORD PTR [rax+740]
  003e8	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  003ed	48 2b c1	 sub	 rax, rcx
  003f0	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  003f4	88 44 24 69	 mov	 BYTE PTR match_byte$33563[rsp], al

; 354  : 
; 355  : 	if (len_main < 2 && current_byte != match_byte
; 356  : 			&& rep_lens[rep_max_index] < 2) {

  003f8	83 7c 24 34 02	 cmp	 DWORD PTR len_main$[rsp], 2
  003fd	73 3f		 jae	 SHORT $LN27@helper1
  003ff	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR current_byte$33562[rsp]
  00404	0f b6 44 24 69	 movzx	 eax, BYTE PTR match_byte$33563[rsp]
  00409	3b c8		 cmp	 ecx, eax
  0040b	74 31		 je	 SHORT $LN27@helper1
  0040d	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  00411	83 7c 84 50 02	 cmp	 DWORD PTR rep_lens$33549[rsp+rax*4], 2
  00416	73 26		 jae	 SHORT $LN27@helper1

; 357  : 		*back_res = UINT32_MAX;

  00418	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR back_res$[rsp]
  00420	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 358  : 		*len_res = 1;

  00426	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  0042e	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 359  : 		return UINT32_MAX;

  00434	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00439	e9 c6 06 00 00	 jmp	 $LN38@helper1
$LN27@helper1:

; 360  : 	}
; 361  : 
; 362  : 	coder->opts[0].state = coder->state;

  0043e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00446	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0044e	8b 80 e0 02 00
	00		 mov	 eax, DWORD PTR [rax+736]
  00454	89 81 e4 0e 01
	00		 mov	 DWORD PTR [rcx+69348], eax

; 363  : 
; 364  :   {
; 365  : 	const uint32_t pos_state = position & coder->pos_mask;

  0045a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00462	8b 88 90 0b 00
	00		 mov	 ecx, DWORD PTR [rax+2960]
  00468	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  0046f	23 c1		 and	 eax, ecx
  00471	89 44 24 6c	 mov	 DWORD PTR pos_state$33565[rsp], eax

; 366  : 
; 367  : 	coder->opts[1].price = rc_bit_0_price(
; 368  : 				coder->is_match[coder->state][pos_state])
; 369  : 			+ get_literal_price(coder, position, buf[-1],
; 370  : 				!is_literal_state(coder->state),
; 371  : 				match_byte, current_byte);

  00475	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0047d	83 b8 e0 02 00
	00 07		 cmp	 DWORD PTR [rax+736], 7
  00484	7c 0d		 jl	 SHORT $LN42@helper1
  00486	c7 84 24 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv208[rsp], 1
  00491	eb 0b		 jmp	 SHORT $LN43@helper1
$LN42@helper1:
  00493	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv208[rsp], 0
$LN43@helper1:
  0049e	8b 54 24 6c	 mov	 edx, DWORD PTR pos_state$33565[rsp]
  004a2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  004aa	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  004b1	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  004b5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  004bd	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  004c5	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  004c9	c1 f8 04	 sar	 eax, 4
  004cc	48 63 c8	 movsxd	 rcx, eax
  004cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  004d6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004da	89 84 24 c4 00
	00 00		 mov	 DWORD PTR $T83195[rsp], eax
  004e1	0f b6 54 24 68	 movzx	 edx, BYTE PTR current_byte$33562[rsp]
  004e6	0f b6 4c 24 69	 movzx	 ecx, BYTE PTR match_byte$33563[rsp]
  004eb	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$33548[rsp]
  004f0	44 0f b6 40 ff	 movzx	 r8d, BYTE PTR [rax-1]
  004f5	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  004f9	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  004fd	44 0f b6 8c 24
	00 01 00 00	 movzx	 r9d, BYTE PTR tv208[rsp]
  00506	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR position$[rsp]
  0050d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00515	e8 00 00 00 00	 call	 get_literal_price
  0051a	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR $T83195[rsp]
  00521	03 c8		 add	 ecx, eax
  00523	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0052b	89 88 20 0f 01
	00		 mov	 DWORD PTR [rax+69408], ecx

; 372  : 
; 373  : 	make_literal(&coder->opts[1]);

  00531	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00539	48 05 10 0f 01
	00		 add	 rax, 69392		; 00010f10H
  0053f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR $T83199[rsp], rax
  00547	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR $T83199[rsp]
  0054f	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH
  00556	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR $T83199[rsp]
  0055e	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 374  : 
; 375  :   {
; 376  : 	const uint32_t match_price = rc_bit_1_price(
; 377  : 			coder->is_match[coder->state][pos_state]);

  00562	8b 54 24 6c	 mov	 edx, DWORD PTR pos_state$33565[rsp]
  00566	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0056e	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00575	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00579	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00581	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  00589	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  0058d	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  00592	c1 e8 04	 shr	 eax, 4
  00595	8b c8		 mov	 ecx, eax
  00597	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0059e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  005a2	89 44 24 70	 mov	 DWORD PTR match_price$33566[rsp], eax

; 378  : 	const uint32_t rep_match_price = match_price
; 379  : 			+ rc_bit_1_price(coder->is_rep[coder->state]);

  005a6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005ae	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  005b5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  005bd	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  005c5	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  005ca	c1 e8 04	 shr	 eax, 4
  005cd	8b c8		 mov	 ecx, eax
  005cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  005d6	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  005da	8b 44 24 70	 mov	 eax, DWORD PTR match_price$33566[rsp]
  005de	03 c1		 add	 eax, ecx
  005e0	89 44 24 74	 mov	 DWORD PTR rep_match_price$33567[rsp], eax

; 380  : 
; 381  : 	if (match_byte == current_byte) {

  005e4	0f b6 4c 24 69	 movzx	 ecx, BYTE PTR match_byte$33563[rsp]
  005e9	0f b6 44 24 68	 movzx	 eax, BYTE PTR current_byte$33562[rsp]
  005ee	3b c8		 cmp	 ecx, eax
  005f0	0f 85 85 00 00
	00		 jne	 $LN26@helper1

; 382  : 		const uint32_t short_rep_price = rep_match_price
; 383  : 				+ get_short_rep_price(
; 384  : 					coder, coder->state, pos_state);

  005f6	44 8b 44 24 6c	 mov	 r8d, DWORD PTR pos_state$33565[rsp]
  005fb	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00603	8b 90 e0 02 00
	00		 mov	 edx, DWORD PTR [rax+736]
  00609	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00611	e8 00 00 00 00	 call	 get_short_rep_price
  00616	44 8b d8	 mov	 r11d, eax
  00619	8b 44 24 74	 mov	 eax, DWORD PTR rep_match_price$33567[rsp]
  0061d	41 03 c3	 add	 eax, r11d
  00620	89 44 24 78	 mov	 DWORD PTR short_rep_price$33569[rsp], eax

; 385  : 
; 386  : 		if (short_rep_price < coder->opts[1].price) {

  00624	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0062c	8b 80 20 0f 01
	00		 mov	 eax, DWORD PTR [rax+69408]
  00632	39 44 24 78	 cmp	 DWORD PTR short_rep_price$33569[rsp], eax
  00636	73 43		 jae	 SHORT $LN25@helper1

; 387  : 			coder->opts[1].price = short_rep_price;

  00638	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00640	8b 44 24 78	 mov	 eax, DWORD PTR short_rep_price$33569[rsp]
  00644	89 81 20 0f 01
	00		 mov	 DWORD PTR [rcx+69408], eax

; 388  : 			make_short_rep(&coder->opts[1]);

  0064a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00652	48 05 10 0f 01
	00		 add	 rax, 69392		; 00010f10H
  00658	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR $T83217[rsp], rax
  00660	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR $T83217[rsp]
  00668	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  0066f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR $T83217[rsp]
  00677	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0
$LN25@helper1:
$LN26@helper1:

; 389  : 		}
; 390  : 	}
; 391  : 
; 392  :   {
; 393  : 	const uint32_t len_end = my_max(len_main, rep_lens[rep_max_index]);

  0067b	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  0067f	8b 44 84 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp+rax*4]
  00683	39 44 24 34	 cmp	 DWORD PTR len_main$[rsp], eax
  00687	76 0d		 jbe	 SHORT $LN44@helper1
  00689	8b 44 24 34	 mov	 eax, DWORD PTR len_main$[rsp]
  0068d	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv264[rsp], eax
  00694	eb 0f		 jmp	 SHORT $LN45@helper1
$LN44@helper1:
  00696	8b 44 24 44	 mov	 eax, DWORD PTR rep_max_index$33550[rsp]
  0069a	8b 44 84 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp+rax*4]
  0069e	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv264[rsp], eax
$LN45@helper1:
  006a5	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv264[rsp]
  006ac	89 44 24 7c	 mov	 DWORD PTR len_end$33571[rsp], eax

; 394  : 
; 395  : 	if (len_end < 2) {

  006b0	83 7c 24 7c 02	 cmp	 DWORD PTR len_end$33571[rsp], 2
  006b5	73 30		 jae	 SHORT $LN24@helper1

; 396  : 		*back_res = coder->opts[1].back_prev;

  006b7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR back_res$[rsp]
  006bf	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  006c7	8b 80 28 0f 01
	00		 mov	 eax, DWORD PTR [rax+69416]
  006cd	89 01		 mov	 DWORD PTR [rcx], eax

; 397  : 		*len_res = 1;

  006cf	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  006d7	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 398  : 		return UINT32_MAX;

  006dd	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  006e2	e9 1d 04 00 00	 jmp	 $LN38@helper1
$LN24@helper1:

; 399  : 	}
; 400  : 
; 401  : 	coder->opts[1].pos_prev = 0;

  006e7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  006ef	c7 80 24 0f 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+69412], 0

; 402  : 
; 403  : 	for (i = 0; i < REPS; ++i)

  006f9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$33551[rsp], 0
  00701	eb 0b		 jmp	 SHORT $LN23@helper1
$LN22@helper1:
  00703	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  00707	83 c0 01	 add	 eax, 1
  0070a	89 44 24 40	 mov	 DWORD PTR i$33551[rsp], eax
$LN23@helper1:
  0070e	83 7c 24 40 04	 cmp	 DWORD PTR i$33551[rsp], 4
  00713	73 2a		 jae	 SHORT $LN21@helper1

; 404  : 		coder->opts[0].backs[i] = coder->reps[i];

  00715	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$33551[rsp]
  0071a	8b 54 24 40	 mov	 edx, DWORD PTR i$33551[rsp]
  0071e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00726	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0072e	42 8b 84 80 e4
	02 00 00	 mov	 eax, DWORD PTR [rax+r8*4+740]
  00736	89 84 91 00 0f
	01 00		 mov	 DWORD PTR [rcx+rdx*4+69376], eax
  0073d	eb c4		 jmp	 SHORT $LN22@helper1
$LN21@helper1:

; 405  : 
; 406  :   {
; 407  : 	uint32_t len = len_end;

  0073f	8b 44 24 7c	 mov	 eax, DWORD PTR len_end$33571[rsp]
  00743	89 84 24 80 00
	00 00		 mov	 DWORD PTR len$33576[rsp], eax
$LN20@helper1:

; 408  : 	do {
; 409  : 		coder->opts[len].price = RC_INFINITY_PRICE;

  0074a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR len$33576[rsp]
  00751	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00755	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0075d	c7 84 08 f4 0e
	01 00 00 00 00
	40		 mov	 DWORD PTR [rax+rcx+69364], 1073741824 ; 40000000H

; 410  : 	} while (--len >= 2);

  00768	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$33576[rsp]
  0076f	83 e8 01	 sub	 eax, 1
  00772	89 84 24 80 00
	00 00		 mov	 DWORD PTR len$33576[rsp], eax
  00779	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR len$33576[rsp], 2
  00781	73 c7		 jae	 SHORT $LN20@helper1

; 411  : 
; 412  : 
; 413  : 	for (i = 0; i < REPS; ++i) {

  00783	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$33551[rsp], 0
  0078b	eb 0b		 jmp	 SHORT $LN17@helper1
$LN16@helper1:
  0078d	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  00791	83 c0 01	 add	 eax, 1
  00794	89 44 24 40	 mov	 DWORD PTR i$33551[rsp], eax
$LN17@helper1:
  00798	83 7c 24 40 04	 cmp	 DWORD PTR i$33551[rsp], 4
  0079d	0f 83 58 01 00
	00		 jae	 $LN15@helper1

; 414  : 		uint32_t rep_len = rep_lens[i];

  007a3	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  007a7	8b 44 84 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp+rax*4]
  007ab	89 84 24 84 00
	00 00		 mov	 DWORD PTR rep_len$33583[rsp], eax

; 415  : 		if (rep_len < 2)

  007b2	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR rep_len$33583[rsp], 2
  007ba	73 02		 jae	 SHORT $LN14@helper1

; 416  : 			continue;

  007bc	eb cf		 jmp	 SHORT $LN16@helper1
$LN14@helper1:

; 417  : 
; 418  :       {
; 419  : 		const uint32_t price = rep_match_price + get_pure_rep_price(
; 420  : 				coder, i, coder->state, pos_state);

  007be	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR pos_state$33565[rsp]
  007c3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  007cb	44 8b 80 e0 02
	00 00		 mov	 r8d, DWORD PTR [rax+736]
  007d2	8b 54 24 40	 mov	 edx, DWORD PTR i$33551[rsp]
  007d6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  007de	e8 00 00 00 00	 call	 get_pure_rep_price
  007e3	44 8b d8	 mov	 r11d, eax
  007e6	8b 44 24 74	 mov	 eax, DWORD PTR rep_match_price$33567[rsp]
  007ea	41 03 c3	 add	 eax, r11d
  007ed	89 84 24 88 00
	00 00		 mov	 DWORD PTR price$33585[rsp], eax
$LN13@helper1:

; 421  : 
; 422  : 		do {
; 423  : 			const uint32_t cur_and_len_price = price
; 424  : 					+ get_len_price(
; 425  : 						&coder->rep_len_encoder,
; 426  : 						rep_len, pos_state);

  007f4	8b 4c 24 6c	 mov	 ecx, DWORD PTR pos_state$33565[rsp]
  007f8	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  007ff	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00807	48 8d 8c 08 4c
	be 00 00	 lea	 rcx, QWORD PTR [rax+rcx+48716]
  0080f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR rep_len$33583[rsp]
  00816	83 e8 02	 sub	 eax, 2
  00819	8b c0		 mov	 eax, eax
  0081b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0081e	89 84 24 e4 00
	00 00		 mov	 DWORD PTR $T83240[rsp], eax
  00825	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR $T83240[rsp]
  0082c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR price$33585[rsp]
  00833	03 c1		 add	 eax, ecx
  00835	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33589[rsp], eax

; 427  : 
; 428  : 			if (cur_and_len_price < coder->opts[rep_len].price) {

  0083c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR rep_len$33583[rsp]
  00843	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00847	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0084f	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00856	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33589[rsp], eax
  0085d	73 78		 jae	 SHORT $LN10@helper1

; 429  : 				coder->opts[rep_len].price = cur_and_len_price;

  0085f	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR rep_len$33583[rsp]
  00866	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0086a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00872	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33589[rsp]
  00879	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 430  : 				coder->opts[rep_len].pos_prev = 0;

  00880	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR rep_len$33583[rsp]
  00887	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  0088b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00893	c7 84 08 f8 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx+69368], 0

; 431  : 				coder->opts[rep_len].back_prev = i;

  0089e	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR rep_len$33583[rsp]
  008a5	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  008a9	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  008b1	8b 44 24 40	 mov	 eax, DWORD PTR i$33551[rsp]
  008b5	89 84 11 fc 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69372], eax

; 432  : 				coder->opts[rep_len].prev_1_is_literal = false;

  008bc	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR rep_len$33583[rsp]
  008c3	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  008c7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  008cf	c6 84 08 e8 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69352], 0
$LN10@helper1:

; 433  : 			}
; 434  : 		} while (--rep_len >= 2);

  008d7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR rep_len$33583[rsp]
  008de	83 e8 01	 sub	 eax, 1
  008e1	89 84 24 84 00
	00 00		 mov	 DWORD PTR rep_len$33583[rsp], eax
  008e8	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR rep_len$33583[rsp], 2
  008f0	0f 83 fe fe ff
	ff		 jae	 $LN13@helper1

; 435  : 	  }
; 436  : 	}

  008f6	e9 92 fe ff ff	 jmp	 $LN16@helper1
$LN15@helper1:

; 437  :   }
; 438  : 
; 439  :   {
; 440  : 	const uint32_t normal_match_price = match_price
; 441  : 			+ rc_bit_0_price(coder->is_rep[coder->state]);

  008fb	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00903	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  0090a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00912	0f b7 84 48 1c
	6d 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+27932]
  0091a	c1 f8 04	 sar	 eax, 4
  0091d	48 63 c8	 movsxd	 rcx, eax
  00920	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00927	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0092b	8b 44 24 70	 mov	 eax, DWORD PTR match_price$33566[rsp]
  0092f	03 c1		 add	 eax, ecx
  00931	89 84 24 94 00
	00 00		 mov	 DWORD PTR normal_match_price$33591[rsp], eax

; 442  : 	uint32_t len;
; 443  : 
; 444  : 	len = rep_lens[0] >= 2 ? rep_lens[0] + 1 : 2;

  00938	83 7c 24 50 02	 cmp	 DWORD PTR rep_lens$33549[rsp], 2
  0093d	72 10		 jb	 SHORT $LN46@helper1
  0093f	8b 44 24 50	 mov	 eax, DWORD PTR rep_lens$33549[rsp]
  00943	83 c0 01	 add	 eax, 1
  00946	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv348[rsp], eax
  0094d	eb 0b		 jmp	 SHORT $LN47@helper1
$LN46@helper1:
  0094f	c7 84 24 08 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv348[rsp], 2
$LN47@helper1:
  0095a	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv348[rsp]
  00961	89 84 24 90 00
	00 00		 mov	 DWORD PTR len$33592[rsp], eax

; 445  : 	if (len <= len_main) {

  00968	8b 44 24 34	 mov	 eax, DWORD PTR len_main$[rsp]
  0096c	39 84 24 90 00
	00 00		 cmp	 DWORD PTR len$33592[rsp], eax
  00973	0f 87 87 01 00
	00		 ja	 $LN9@helper1

; 446  : 		uint32_t i = 0;

  00979	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$33594[rsp], 0
$LN8@helper1:

; 447  : 		while (len > coder->matches[i].len)

  00984	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$33594[rsp]
  0098b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00993	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  0099a	39 84 24 90 00
	00 00		 cmp	 DWORD PTR len$33592[rsp], eax
  009a1	76 13		 jbe	 SHORT $LN7@helper1

; 448  : 			++i;

  009a3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$33594[rsp]
  009aa	83 c0 01	 add	 eax, 1
  009ad	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$33594[rsp], eax
  009b4	eb ce		 jmp	 SHORT $LN8@helper1
$LN7@helper1:

; 449  : 
; 450  : 		for(; ; ++len) {

  009b6	eb 11		 jmp	 SHORT $LN6@helper1
$LN5@helper1:
  009b8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$33592[rsp]
  009bf	83 c0 01	 add	 eax, 1
  009c2	89 84 24 90 00
	00 00		 mov	 DWORD PTR len$33592[rsp], eax
$LN6@helper1:

; 451  : 			const uint32_t dist = coder->matches[i].dist;

  009c9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$33594[rsp]
  009d0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  009d8	8b 84 c8 f8 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+760]
  009df	89 84 24 a0 00
	00 00		 mov	 DWORD PTR dist$33601[rsp], eax

; 452  : 			const uint32_t cur_and_len_price = normal_match_price
; 453  : 					+ get_dist_len_price(coder,
; 454  : 						dist, len, pos_state);

  009e6	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR pos_state$33565[rsp]
  009eb	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR len$33592[rsp]
  009f3	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR dist$33601[rsp]
  009fa	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00a02	e8 00 00 00 00	 call	 get_dist_len_price
  00a07	44 8b d8	 mov	 r11d, eax
  00a0a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR normal_match_price$33591[rsp]
  00a11	41 03 c3	 add	 eax, r11d
  00a14	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cur_and_len_price$33602[rsp], eax

; 455  : 
; 456  : 			if (cur_and_len_price < coder->opts[len].price) {

  00a1b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR len$33592[rsp]
  00a22	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00a26	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00a2e	8b 84 08 f4 0e
	01 00		 mov	 eax, DWORD PTR [rax+rcx+69364]
  00a35	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR cur_and_len_price$33602[rsp], eax
  00a3c	73 7e		 jae	 SHORT $LN3@helper1

; 457  : 				coder->opts[len].price = cur_and_len_price;

  00a3e	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR len$33592[rsp]
  00a45	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00a49	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00a51	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cur_and_len_price$33602[rsp]
  00a58	89 84 11 f4 0e
	01 00		 mov	 DWORD PTR [rcx+rdx+69364], eax

; 458  : 				coder->opts[len].pos_prev = 0;

  00a5f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR len$33592[rsp]
  00a66	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00a6a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00a72	c7 84 08 f8 0e
	01 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx+69368], 0

; 459  : 				coder->opts[len].back_prev = dist + REPS;

  00a7d	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR dist$33601[rsp]
  00a84	83 c2 04	 add	 edx, 4
  00a87	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR len$33592[rsp]
  00a8e	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00a92	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00a9a	89 94 08 fc 0e
	01 00		 mov	 DWORD PTR [rax+rcx+69372], edx

; 460  : 				coder->opts[len].prev_1_is_literal = false;

  00aa1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR len$33592[rsp]
  00aa8	48 6b c9 2c	 imul	 rcx, 44			; 0000002cH
  00aac	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00ab4	c6 84 08 e8 0e
	01 00 00	 mov	 BYTE PTR [rax+rcx+69352], 0
$LN3@helper1:

; 461  : 			}
; 462  : 
; 463  : 			if (len == coder->matches[i].len)

  00abc	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$33594[rsp]
  00ac3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00acb	8b 84 c8 f4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*8+756]
  00ad2	39 84 24 90 00
	00 00		 cmp	 DWORD PTR len$33592[rsp], eax
  00ad9	75 20		 jne	 SHORT $LN2@helper1

; 464  : 				if (++i == matches_count)

  00adb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$33594[rsp]
  00ae2	83 c0 01	 add	 eax, 1
  00ae5	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$33594[rsp], eax
  00aec	8b 44 24 30	 mov	 eax, DWORD PTR matches_count$[rsp]
  00af0	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$33594[rsp], eax
  00af7	75 02		 jne	 SHORT $LN1@helper1

; 465  : 					break;

  00af9	eb 05		 jmp	 SHORT $LN4@helper1
$LN1@helper1:
$LN2@helper1:

; 466  : 		}

  00afb	e9 b8 fe ff ff	 jmp	 $LN5@helper1
$LN4@helper1:
$LN9@helper1:

; 467  : 	}
; 468  :   }
; 469  : 
; 470  : 	return len_end;

  00b00	8b 44 24 7c	 mov	 eax, DWORD PTR len_end$33571[rsp]
$LN38@helper1:

; 471  :   }}}}}}
; 472  : }

  00b04	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00b0b	c3		 ret	 0
helper1	ENDP
PUBLIC	lzma_lzma_optimum_normal
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma_lzma_optimum_normal DD imagerel $LN20
	DD	imagerel $LN20+753
	DD	imagerel $unwind$lzma_lzma_optimum_normal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_optimum_normal DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder_optimum_normal.c
xdata	ENDS
;	COMDAT lzma_lzma_optimum_normal
_TEXT	SEGMENT
len_end$33779 = 64
reps$33781 = 72
cur$33782 = 88
$T83510 = 96
tv161 = 104
coder$ = 128
mf$ = 136
back_res$ = 144
len_res$ = 152
position$ = 160
lzma_lzma_optimum_normal PROC				; COMDAT

; 861  : {

$LN20:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 862  : 	// If we have symbols pending, return the next pending symbol.
; 863  : 	if (coder->opts_end_index != coder->opts_current_index) {

  00018	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00020	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00028	8b 80 e0 0e 01
	00		 mov	 eax, DWORD PTR [rax+69344]
  0002e	39 81 dc 0e 01
	00		 cmp	 DWORD PTR [rcx+69340], eax
  00034	0f 84 9a 00 00
	00		 je	 $LN9@lzma_lzma_@10

; 864  : 		assert(mf->read_ahead > 0);
; 865  : 		*len_res = coder->opts[coder->opts_current_index].pos_prev
; 866  : 				- coder->opts_current_index;

  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00042	8b 90 e0 0e 01
	00		 mov	 edx, DWORD PTR [rax+69344]
  00048	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  0004c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00054	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0005c	8b 80 e0 0e 01
	00		 mov	 eax, DWORD PTR [rax+69344]
  00062	8b 8c 11 f8 0e
	01 00		 mov	 ecx, DWORD PTR [rcx+rdx+69368]
  00069	2b c8		 sub	 ecx, eax
  0006b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR len_res$[rsp]
  00073	89 08		 mov	 DWORD PTR [rax], ecx

; 867  : 		*back_res = coder->opts[coder->opts_current_index].back_prev;

  00075	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0007d	8b 90 e0 0e 01
	00		 mov	 edx, DWORD PTR [rax+69344]
  00083	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  00087	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR back_res$[rsp]
  0008f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00097	8b 84 10 fc 0e
	01 00		 mov	 eax, DWORD PTR [rax+rdx+69372]
  0009e	89 01		 mov	 DWORD PTR [rcx], eax

; 868  : 		coder->opts_current_index = coder->opts[
; 869  : 				coder->opts_current_index].pos_prev;

  000a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000a8	8b 90 e0 0e 01
	00		 mov	 edx, DWORD PTR [rax+69344]
  000ae	48 6b d2 2c	 imul	 rdx, 44			; 0000002cH
  000b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000c2	8b 84 10 f8 0e
	01 00		 mov	 eax, DWORD PTR [rax+rdx+69368]
  000c9	89 81 e0 0e 01
	00		 mov	 DWORD PTR [rcx+69344], eax

; 870  : 		return;

  000cf	e9 18 02 00 00	 jmp	 $LN10@lzma_lzma_@10
$LN9@lzma_lzma_@10:

; 871  : 	}
; 872  : 
; 873  : 	// Update the price tables. In LZMA SDK <= 4.60 (and possibly later)
; 874  : 	// this was done in both initialization function and in the main loop.
; 875  : 	// In liblzma they were moved into this single place.
; 876  : 	if (mf->read_ahead == 0) {

  000d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000dc	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  000e0	75 3f		 jne	 SHORT $LN8@lzma_lzma_@10

; 877  : 		if (coder->match_price_count >= (1 << 7))

  000e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000ea	81 b8 94 0e 01
	00 80 00 00 00	 cmp	 DWORD PTR [rax+69268], 128 ; 00000080H
  000f4	72 0d		 jb	 SHORT $LN7@lzma_lzma_@10

; 878  : 			fill_dist_prices(coder);

  000f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000fe	e8 00 00 00 00	 call	 fill_dist_prices
$LN7@lzma_lzma_@10:

; 879  : 
; 880  : 		if (coder->align_price_count >= ALIGN_SIZE)

  00103	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0010b	83 b8 d8 0e 01
	00 10		 cmp	 DWORD PTR [rax+69336], 16
  00112	72 0d		 jb	 SHORT $LN6@lzma_lzma_@10

; 881  : 			fill_align_prices(coder);

  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0011c	e8 00 00 00 00	 call	 fill_align_prices
$LN6@lzma_lzma_@10:
$LN8@lzma_lzma_@10:

; 882  : 	}
; 883  : 
; 884  : 	// TODO: This needs quite a bit of cleaning still. But splitting
; 885  : 	// the original function into two pieces makes it at least a little
; 886  : 	// more readable, since those two parts don't share many variables.
; 887  : 
; 888  :   { uint32_t len_end = helper1(coder, mf, back_res, len_res, position);

  00121	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  00128	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0012c	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR len_res$[rsp]
  00134	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR back_res$[rsp]
  0013c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00144	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0014c	e8 00 00 00 00	 call	 helper1
  00151	89 44 24 40	 mov	 DWORD PTR len_end$33779[rsp], eax

; 889  : 	if (len_end == UINT32_MAX)

  00155	83 7c 24 40 ff	 cmp	 DWORD PTR len_end$33779[rsp], -1 ; ffffffffH
  0015a	75 05		 jne	 SHORT $LN5@lzma_lzma_@10

; 890  : 		return;

  0015c	e9 8b 01 00 00	 jmp	 $LN10@lzma_lzma_@10
$LN5@lzma_lzma_@10:

; 891  : 
; 892  :   { uint32_t reps[REPS];
; 893  : 	memcpy(reps, coder->reps, sizeof(reps));

  00161	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00169	48 81 c2 e4 02
	00 00		 add	 rdx, 740		; 000002e4H
  00170	41 b8 10 00 00
	00		 mov	 r8d, 16
  00176	48 8d 4c 24 48	 lea	 rcx, QWORD PTR reps$33781[rsp]
  0017b	e8 00 00 00 00	 call	 memcpy

; 894  : 
; 895  :   { uint32_t cur;
; 896  : 	for (cur = 1; cur < len_end; ++cur) {

  00180	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR cur$33782[rsp], 1
  00188	eb 0b		 jmp	 SHORT $LN4@lzma_lzma_@10
$LN3@lzma_lzma_@10:
  0018a	8b 44 24 58	 mov	 eax, DWORD PTR cur$33782[rsp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 44 24 58	 mov	 DWORD PTR cur$33782[rsp], eax
$LN4@lzma_lzma_@10:
  00195	8b 44 24 40	 mov	 eax, DWORD PTR len_end$33779[rsp]
  00199	39 44 24 58	 cmp	 DWORD PTR cur$33782[rsp], eax
  0019d	0f 83 27 01 00
	00		 jae	 $LN2@lzma_lzma_@10

; 897  : 		assert(cur < OPTS);
; 898  : 
; 899  : 		coder->longest_match_length = mf_find(
; 900  : 				mf, &coder->matches_count, coder->matches);

  001a3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR coder$[rsp]
  001ab	49 81 c0 f4 02
	00 00		 add	 r8, 756			; 000002f4H
  001b2	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  001ba	48 81 c2 84 0b
	00 00		 add	 rdx, 2948		; 00000b84H
  001c1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001c9	e8 00 00 00 00	 call	 lzma_mf_find
  001ce	44 8b d8	 mov	 r11d, eax
  001d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001d9	44 89 98 88 0b
	00 00		 mov	 DWORD PTR [rax+2952], r11d

; 901  : 
; 902  : 		if (coder->longest_match_length >= mf->nice_len)

  001e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001f0	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  001f3	39 81 88 0b 00
	00		 cmp	 DWORD PTR [rcx+2952], eax
  001f9	72 05		 jb	 SHORT $LN1@lzma_lzma_@10

; 903  : 			break;

  001fb	e9 ca 00 00 00	 jmp	 $LN2@lzma_lzma_@10
$LN1@lzma_lzma_@10:

; 904  : 
; 905  : 		len_end = helper2(coder, reps, mf_ptr(mf) - 1, len_end,
; 906  : 				position + cur, cur, mf->nice_len,
; 907  : 				my_min(mf_avail(mf) + 1, OPTS - 1 - cur));

  00200	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00208	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00210	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00213	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  00216	2b c8		 sub	 ecx, eax
  00218	83 c1 01	 add	 ecx, 1
  0021b	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  00220	2b 44 24 58	 sub	 eax, DWORD PTR cur$33782[rsp]
  00224	3b c8		 cmp	 ecx, eax
  00226	73 21		 jae	 SHORT $LN12@lzma_lzma_@10
  00228	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00230	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00238	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0023b	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  0023e	2b c1		 sub	 eax, ecx
  00240	83 c0 01	 add	 eax, 1
  00243	89 44 24 68	 mov	 DWORD PTR tv161[rsp], eax
  00247	eb 0d		 jmp	 SHORT $LN13@lzma_lzma_@10
$LN12@lzma_lzma_@10:
  00249	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  0024e	2b 44 24 58	 sub	 eax, DWORD PTR cur$33782[rsp]
  00252	89 44 24 68	 mov	 DWORD PTR tv161[rsp], eax
$LN13@lzma_lzma_@10:
  00256	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0025e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00261	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  00269	48 03 01	 add	 rax, QWORD PTR [rcx]
  0026c	48 89 44 24 60	 mov	 QWORD PTR $T83510[rsp], rax
  00271	8b 44 24 58	 mov	 eax, DWORD PTR cur$33782[rsp]
  00275	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR position$[rsp]
  0027c	03 c8		 add	 ecx, eax
  0027e	4c 8b 44 24 60	 mov	 r8, QWORD PTR $T83510[rsp]
  00283	49 83 e8 01	 sub	 r8, 1
  00287	8b 44 24 68	 mov	 eax, DWORD PTR tv161[rsp]
  0028b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0028f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00297	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0029a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0029e	8b 44 24 58	 mov	 eax, DWORD PTR cur$33782[rsp]
  002a2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002a6	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  002aa	44 8b 4c 24 40	 mov	 r9d, DWORD PTR len_end$33779[rsp]
  002af	48 8d 54 24 48	 lea	 rdx, QWORD PTR reps$33781[rsp]
  002b4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002bc	e8 00 00 00 00	 call	 helper2
  002c1	89 44 24 40	 mov	 DWORD PTR len_end$33779[rsp], eax

; 908  : 	}

  002c5	e9 c0 fe ff ff	 jmp	 $LN3@lzma_lzma_@10
$LN2@lzma_lzma_@10:

; 909  : 
; 910  : 	backward(coder, len_res, back_res, cur);

  002ca	44 8b 4c 24 58	 mov	 r9d, DWORD PTR cur$33782[rsp]
  002cf	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR back_res$[rsp]
  002d7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR len_res$[rsp]
  002df	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002e7	e8 00 00 00 00	 call	 backward
$LN10@lzma_lzma_@10:

; 911  :   }}}
; 912  : 	return;
; 913  : }

  002ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002f0	c3		 ret	 0
lzma_lzma_optimum_normal ENDP
END
