; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_powerpc_decoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\powerpc.c
pdata	SEGMENT
$pdata$powerpc_code DD imagerel powerpc_code
	DD	imagerel powerpc_code+410
	DD	imagerel $unwind$powerpc_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$powerpc_code DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT powerpc_code
_TEXT	SEGMENT
i$ = 0
dest$32959 = 8
src$32958 = 12
simple$ = 32
now_pos$ = 40
is_encoder$ = 48
buffer$ = 56
size$ = 64
powerpc_code PROC					; COMDAT

; 21   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 4) {

  00017	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001f	eb 0c		 jmp	 SHORT $LN6@powerpc_co
$LN5@powerpc_co:
  00021	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00025	48 83 c0 04	 add	 rax, 4
  00029	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN6@powerpc_co:
  0002d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00031	48 83 c0 04	 add	 rax, 4
  00035	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0003a	0f 87 51 01 00
	00		 ja	 $LN4@powerpc_co

; 24   : 		// PowerPC branch 6(48) 24(Offset) 1(Abs) 1(Link)
; 25   : 		if ((buffer[i] >> 2) == 0x12
; 26   : 				&& ((buffer[i + 3] & 3) == 1)) {

  00040	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00044	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00049	48 03 c1	 add	 rax, rcx
  0004c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004f	c1 f8 02	 sar	 eax, 2
  00052	83 f8 12	 cmp	 eax, 18
  00055	0f 85 31 01 00
	00		 jne	 $LN3@powerpc_co
  0005b	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0005f	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00064	48 03 c1	 add	 rax, rcx
  00067	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0006b	83 e0 03	 and	 eax, 3
  0006e	83 f8 01	 cmp	 eax, 1
  00071	0f 85 15 01 00
	00		 jne	 $LN3@powerpc_co

; 27   : 
; 28   : 			const uint32_t src = ((buffer[i + 0] & 3) << 24)
; 29   : 					| (buffer[i + 1] << 16)
; 30   : 					| (buffer[i + 2] << 8)
; 31   : 					| (buffer[i + 3] & (~3));

  00077	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00080	48 03 c1	 add	 rax, rcx
  00083	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00086	83 e2 03	 and	 edx, 3
  00089	c1 e2 18	 shl	 edx, 24
  0008c	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00090	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00095	48 03 c1	 add	 rax, rcx
  00098	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009c	c1 e0 10	 shl	 eax, 16
  0009f	0b d0		 or	 edx, eax
  000a1	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000a5	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000aa	48 03 c1	 add	 rax, rcx
  000ad	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000b1	c1 e0 08	 shl	 eax, 8
  000b4	0b d0		 or	 edx, eax
  000b6	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000ba	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000bf	48 03 c1	 add	 rax, rcx
  000c2	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  000c6	83 e1 fc	 and	 ecx, -4
  000c9	8b c2		 mov	 eax, edx
  000cb	0b c1		 or	 eax, ecx
  000cd	89 44 24 0c	 mov	 DWORD PTR src$32958[rsp], eax

; 32   : 
; 33   : 			uint32_t dest;
; 34   : 			if (is_encoder)

  000d1	0f b6 44 24 30	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  000d6	85 c0		 test	 eax, eax
  000d8	74 13		 je	 SHORT $LN2@powerpc_co

; 35   : 				dest = now_pos + (uint32_t)(i) + src;

  000da	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  000dd	8b 44 24 28	 mov	 eax, DWORD PTR now_pos$[rsp]
  000e1	03 c1		 add	 eax, ecx
  000e3	03 44 24 0c	 add	 eax, DWORD PTR src$32958[rsp]
  000e7	89 44 24 08	 mov	 DWORD PTR dest$32959[rsp], eax

; 36   : 			else

  000eb	eb 13		 jmp	 SHORT $LN1@powerpc_co
$LN2@powerpc_co:

; 37   : 				dest = src - (now_pos + (uint32_t)(i));

  000ed	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000f0	8b 4c 24 28	 mov	 ecx, DWORD PTR now_pos$[rsp]
  000f4	03 c8		 add	 ecx, eax
  000f6	8b 44 24 0c	 mov	 eax, DWORD PTR src$32958[rsp]
  000fa	2b c1		 sub	 eax, ecx
  000fc	89 44 24 08	 mov	 DWORD PTR dest$32959[rsp], eax
$LN1@powerpc_co:

; 38   : 
; 39   : 			buffer[i + 0] = 0x48 | ((dest >> 24) &  0x03);

  00100	8b 54 24 08	 mov	 edx, DWORD PTR dest$32959[rsp]
  00104	c1 ea 18	 shr	 edx, 24
  00107	83 e2 03	 and	 edx, 3
  0010a	83 ca 48	 or	 edx, 72			; 00000048H
  0010d	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00111	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00116	48 03 c1	 add	 rax, rcx
  00119	88 10		 mov	 BYTE PTR [rax], dl

; 40   : 			buffer[i + 1] = (dest >> 16);

  0011b	8b 54 24 08	 mov	 edx, DWORD PTR dest$32959[rsp]
  0011f	c1 ea 10	 shr	 edx, 16
  00122	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00126	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0012b	48 03 c1	 add	 rax, rcx
  0012e	88 50 01	 mov	 BYTE PTR [rax+1], dl

; 41   : 			buffer[i + 2] = (dest >> 8);

  00131	8b 54 24 08	 mov	 edx, DWORD PTR dest$32959[rsp]
  00135	c1 ea 08	 shr	 edx, 8
  00138	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0013c	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00141	48 03 c1	 add	 rax, rcx
  00144	88 50 02	 mov	 BYTE PTR [rax+2], dl

; 42   : 			buffer[i + 3] &= 0x03;

  00147	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0014b	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00150	48 03 c1	 add	 rax, rcx
  00153	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00157	83 e2 03	 and	 edx, 3
  0015a	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0015e	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00163	48 03 c1	 add	 rax, rcx
  00166	88 50 03	 mov	 BYTE PTR [rax+3], dl

; 43   : 			buffer[i + 3] |= dest;

  00169	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0016d	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00172	48 03 c1	 add	 rax, rcx
  00175	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]
  00179	0b 54 24 08	 or	 edx, DWORD PTR dest$32959[rsp]
  0017d	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00181	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00186	48 03 c1	 add	 rax, rcx
  00189	88 50 03	 mov	 BYTE PTR [rax+3], dl
$LN3@powerpc_co:

; 44   : 		}
; 45   : 	}

  0018c	e9 90 fe ff ff	 jmp	 $LN5@powerpc_co
$LN4@powerpc_co:

; 46   : 
; 47   : 	return i;

  00191	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]

; 48   : }

  00195	48 83 c4 18	 add	 rsp, 24
  00199	c3		 ret	 0
powerpc_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$powerpc_coder_init DD imagerel powerpc_coder_init
	DD	imagerel powerpc_coder_init+91
	DD	imagerel $unwind$powerpc_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$powerpc_coder_init DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT powerpc_coder_init
_TEXT	SEGMENT
next$ = 80
allocator$ = 88
filters$ = 96
is_encoder$ = 104
powerpc_coder_init PROC					; COMDAT

; 54   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 55   : 	return lzma_simple_coder_init(next, allocator, filters,
; 56   : 			&powerpc_code, 0, 4, 4, is_encoder);

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0001d	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00021	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR [rsp+48], 4
  00029	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR [rsp+40], 4
  00032	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:powerpc_code
  00042	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  00047	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00051	e8 00 00 00 00	 call	 lzma_simple_coder_init

; 57   : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
powerpc_coder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_powerpc_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$lzma_simple_powerpc_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_powerpc_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_powerpc_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_simple_powerpc_decoder_init PROC			; COMDAT

; 73   : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 74   : 	return powerpc_coder_init(next, allocator, filters, false);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00025	e8 00 00 00 00	 call	 powerpc_coder_init

; 75   : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
lzma_simple_powerpc_decoder_init ENDP
END
