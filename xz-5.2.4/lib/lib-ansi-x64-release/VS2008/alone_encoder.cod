; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT write32ne
_TEXT	SEGMENT
buf$ = 8
num$ = 16
write32ne PROC						; COMDAT

; 266  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  : 	*(uint32_t *)buf = num;

  00009	48 8b 4c 24 08	 mov	 rcx, QWORD PTR buf$[rsp]
  0000e	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00012	89 01		 mov	 DWORD PTR [rcx], eax

; 268  : 	return;
; 269  : }

  00014	c3		 ret	 0
write32ne ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\alone_encoder.c
pdata	SEGMENT
$pdata$alone_encode DD imagerel alone_encode
	DD	imagerel alone_encode+307
	DD	imagerel $unwind$alone_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_encode DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT alone_encode
_TEXT	SEGMENT
coder$ = 80
tv66 = 88
coder_ptr$ = 112
allocator$ = 120
in$ = 128
in_pos$ = 136
in_size$ = 144
out$ = 152
out_pos$ = 160
out_size$ = 168
action$ = 176
alone_encode PROC					; COMDAT

; 40   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 41   : 	lzma_alone_coder *coder = coder_ptr;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax
$LN8@alone_enco:

; 42   : 
; 43   : 	while (*out_pos < out_size)

  00022	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0002a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00032	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00035	0f 83 f1 00 00
	00		 jae	 $LN7@alone_enco

; 44   : 	switch (coder->sequence) {

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00040	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00043	89 44 24 58	 mov	 DWORD PTR tv66[rsp], eax
  00047	83 7c 24 58 00	 cmp	 DWORD PTR tv66[rsp], 0
  0004c	74 0c		 je	 SHORT $LN4@alone_enco
  0004e	83 7c 24 58 01	 cmp	 DWORD PTR tv66[rsp], 1
  00053	74 65		 je	 SHORT $LN2@alone_enco
  00055	e9 c6 00 00 00	 jmp	 $LN1@alone_enco
$LN4@alone_enco:

; 45   : 	case SEQ_HEADER:
; 46   : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 47   : 				ALONE_HEADER_SIZE,
; 48   : 				out, out_pos, out_size);

  0005a	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  0005f	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00068	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0006c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00074	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00079	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00081	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00086	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  0008e	41 b8 0d 00 00
	00		 mov	 r8d, 13
  00094	e8 00 00 00 00	 call	 lzma_bufcpy

; 49   : 		if (coder->header_pos < ALONE_HEADER_SIZE)

  00099	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  0009e	49 83 7b 50 0d	 cmp	 QWORD PTR [r11+80], 13
  000a3	73 07		 jae	 SHORT $LN3@alone_enco

; 50   : 			return LZMA_OK;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 82 00 00 00	 jmp	 $LN9@alone_enco
$LN3@alone_enco:

; 51   : 
; 52   : 		coder->sequence = SEQ_CODE;

  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000b1	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 53   : 		break;

  000b8	eb 6d		 jmp	 SHORT $LN5@alone_enco
$LN2@alone_enco:

; 54   : 
; 55   : 	case SEQ_CODE:
; 56   : 		return coder->next.code(coder->next.coder,
; 57   : 				allocator, in, in_pos, in_size,
; 58   : 				out, out_pos, out_size, action);

  000ba	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  000c1	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000cd	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000da	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000df	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f9	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00101	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00109	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00113	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0011b	ff 50 18	 call	 QWORD PTR [rax+24]
  0011e	eb 0e		 jmp	 SHORT $LN9@alone_enco
$LN1@alone_enco:

; 59   : 
; 60   : 	default:
; 61   : 		assert(0);
; 62   : 		return LZMA_PROG_ERROR;

  00120	b8 0b 00 00 00	 mov	 eax, 11
  00125	eb 07		 jmp	 SHORT $LN9@alone_enco
$LN5@alone_enco:

; 63   : 	}

  00127	e9 f6 fe ff ff	 jmp	 $LN8@alone_enco
$LN7@alone_enco:

; 64   : 
; 65   : 	return LZMA_OK;

  0012c	33 c0		 xor	 eax, eax
$LN9@alone_enco:

; 66   : }

  0012e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00132	c3		 ret	 0
alone_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$alone_encoder_end DD imagerel alone_encoder_end
	DD	imagerel alone_encoder_end+59
	DD	imagerel $unwind$alone_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_encoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT alone_encoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
alone_encoder_end PROC					; COMDAT

; 71   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 72   : 	lzma_alone_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 73   : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 74   : 	lzma_free(coder, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_free

; 75   : 	return;
; 76   : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
alone_encoder_end ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$alone_encoder_init DD imagerel alone_encoder_init
	DD	imagerel alone_encoder_init+555
	DD	imagerel $unwind$alone_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_encoder_init DD 031501H
	DD	07011c215H
	DD	06010H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\alone_encoder.c
xdata	ENDS
;	COMDAT alone_encoder_init
_TEXT	SEGMENT
coder$32891 = 32
d$32899 = 40
filters$32902 = 48
next$ = 128
allocator$ = 136
options$ = 144
alone_encoder_init PROC					; COMDAT

; 83   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN9@alone_enco@2:

; 84   : 	lzma_next_coder_init(&alone_encoder_init, next, allocator);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:alone_encoder_init
  0001c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00024	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00028	74 15		 je	 SHORT $LN6@alone_enco@2
  0002a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00032	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0003a	e8 00 00 00 00	 call	 lzma_next_end
$LN6@alone_enco@2:
  0003f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_encoder_init
  0004e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 bd		 jne	 SHORT $LN9@alone_enco@2

; 85   : 
; 86   :   {
; 87   : 	lzma_alone_coder *coder = next->coder;

  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 89 44 24 20	 mov	 QWORD PTR coder$32891[rsp], rax

; 88   : 
; 89   : 	if (coder == NULL) {

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32891[rsp], 0
  0006e	75 72		 jne	 SHORT $LN5@alone_enco@2

; 90   : 		coder = lzma_alloc(sizeof(lzma_alone_coder), allocator);

  00070	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00078	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0007d	e8 00 00 00 00	 call	 lzma_alloc
  00082	48 89 44 24 20	 mov	 QWORD PTR coder$32891[rsp], rax

; 91   : 		if (coder == NULL)

  00087	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32891[rsp], 0
  0008d	75 0a		 jne	 SHORT $LN4@alone_enco@2

; 92   : 			return LZMA_MEM_ERROR;

  0008f	b8 05 00 00 00	 mov	 eax, 5
  00094	e9 8b 01 00 00	 jmp	 $LN10@alone_enco@2
$LN4@alone_enco@2:

; 93   : 
; 94   : 		next->coder = coder;

  00099	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32891[rsp]
  000a6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 95   : 		next->code = &alone_encode;

  000a9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_encode
  000b8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 96   : 		next->end = &alone_encoder_end;

  000bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_encoder_end
  000cb	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 97   : 		coder->next = LZMA_NEXT_CODER_INIT;

  000cf	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000d6	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32891[rsp]
  000db	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000e0	f3 a4		 rep movsb
$LN5@alone_enco@2:

; 98   : 	}
; 99   : 
; 100  : 	// Basic initializations
; 101  : 	coder->sequence = SEQ_HEADER;

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32891[rsp]
  000e7	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 102  : 	coder->header_pos = 0;

  000ee	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32891[rsp]
  000f3	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 103  : 
; 104  : 	// Encode the header:
; 105  : 	// - Properties (1 byte)
; 106  : 	if (lzma_lzma_lclppb_encode(options, coder->header))

  000fb	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$32891[rsp]
  00100	48 83 c2 58	 add	 rdx, 88			; 00000058H
  00104	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  0010c	e8 00 00 00 00	 call	 lzma_lzma_lclppb_encode
  00111	0f b6 c0	 movzx	 eax, al
  00114	85 c0		 test	 eax, eax
  00116	74 0a		 je	 SHORT $LN3@alone_enco@2

; 107  : 		return LZMA_OPTIONS_ERROR;

  00118	b8 08 00 00 00	 mov	 eax, 8
  0011d	e9 02 01 00 00	 jmp	 $LN10@alone_enco@2
$LN3@alone_enco@2:

; 108  : 
; 109  : 	// - Dictionary size (4 bytes)
; 110  : 	if (options->dict_size < LZMA_DICT_SIZE_MIN)

  00122	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR options$[rsp]
  0012a	81 38 00 10 00
	00		 cmp	 DWORD PTR [rax], 4096	; 00001000H
  00130	73 0a		 jae	 SHORT $LN2@alone_enco@2

; 111  : 		return LZMA_OPTIONS_ERROR;

  00132	b8 08 00 00 00	 mov	 eax, 8
  00137	e9 e8 00 00 00	 jmp	 $LN10@alone_enco@2
$LN2@alone_enco@2:

; 112  : 
; 113  : 	// Round up to the next 2^n or 2^n + 2^(n - 1) depending on which
; 114  : 	// one is the next unless it is UINT32_MAX. While the header would
; 115  : 	// allow any 32-bit integer, we do this to keep the decoder of liblzma
; 116  : 	// accepting the resulting files.
; 117  :   {
; 118  : 	uint32_t d = options->dict_size - 1;

  0013c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00144	8b 00		 mov	 eax, DWORD PTR [rax]
  00146	83 e8 01	 sub	 eax, 1
  00149	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 119  : 	d |= d >> 2;

  0014d	8b 4c 24 28	 mov	 ecx, DWORD PTR d$32899[rsp]
  00151	c1 e9 02	 shr	 ecx, 2
  00154	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  00158	0b c1		 or	 eax, ecx
  0015a	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 120  : 	d |= d >> 3;

  0015e	8b 4c 24 28	 mov	 ecx, DWORD PTR d$32899[rsp]
  00162	c1 e9 03	 shr	 ecx, 3
  00165	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  00169	0b c1		 or	 eax, ecx
  0016b	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 121  : 	d |= d >> 4;

  0016f	8b 4c 24 28	 mov	 ecx, DWORD PTR d$32899[rsp]
  00173	c1 e9 04	 shr	 ecx, 4
  00176	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  0017a	0b c1		 or	 eax, ecx
  0017c	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 122  : 	d |= d >> 8;

  00180	8b 4c 24 28	 mov	 ecx, DWORD PTR d$32899[rsp]
  00184	c1 e9 08	 shr	 ecx, 8
  00187	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  0018b	0b c1		 or	 eax, ecx
  0018d	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 123  : 	d |= d >> 16;

  00191	8b 4c 24 28	 mov	 ecx, DWORD PTR d$32899[rsp]
  00195	c1 e9 10	 shr	 ecx, 16
  00198	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  0019c	0b c1		 or	 eax, ecx
  0019e	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax

; 124  : 	if (d != UINT32_MAX)

  001a2	83 7c 24 28 ff	 cmp	 DWORD PTR d$32899[rsp], -1 ; ffffffffH
  001a7	74 0b		 je	 SHORT $LN1@alone_enco@2

; 125  : 		++d;

  001a9	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  001ad	83 c0 01	 add	 eax, 1
  001b0	89 44 24 28	 mov	 DWORD PTR d$32899[rsp], eax
$LN1@alone_enco@2:

; 126  : 
; 127  : 	unaligned_write32le(coder->header + 1, d);

  001b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32891[rsp]
  001b9	8b 44 24 28	 mov	 eax, DWORD PTR d$32899[rsp]
  001bd	89 41 59	 mov	 DWORD PTR [rcx+89], eax

; 128  :   }
; 129  : 
; 130  : 	// - Uncompressed size (always unknown and using EOPM)
; 131  : 	memset(coder->header + 1 + 4, 0xFF, 8);

  001c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32891[rsp]
  001c5	48 83 c1 5d	 add	 rcx, 93			; 0000005dH
  001c9	41 b8 08 00 00
	00		 mov	 r8d, 8
  001cf	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001d4	e8 00 00 00 00	 call	 memset

; 132  : 
; 133  : 	// Initialize the LZMA encoder.
; 134  : 	{
; 135  : 	/*
; 136  : 	const lzma_filter_info filters[2] = {
; 137  : 		{
; 138  : 			.init = &lzma_lzma_encoder_init,
; 139  : 			.options = (void *)(options),
; 140  : 		}, {
; 141  : 			.init = NULL,
; 142  : 		}
; 143  : 	};
; 144  : 	*/
; 145  : 	/*
; 146  : 	struct lzma_filter_info_s {
; 147  : 		lzma_vli id;
; 148  : 		lzma_init_function init;
; 149  : 		void *options;
; 150  : 	};
; 151  : 	*/
; 152  : 	lzma_filter_info filters[2];
; 153  : 	memset (filters, 0, sizeof(filters));

  001d9	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  001df	33 d2		 xor	 edx, edx
  001e1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR filters$32902[rsp]
  001e6	e8 00 00 00 00	 call	 memset

; 154  : 
; 155  : 	filters[0].init    = &lzma_lzma_encoder_init;

  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_lzma_encoder_init
  001f2	48 89 54 24 38	 mov	 QWORD PTR filters$32902[rsp+8], rdx

; 156  : 	filters[0].options = (void *)(options);

  001f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR options$[rsp]
  001ff	48 89 44 24 40	 mov	 QWORD PTR filters$32902[rsp+16], rax

; 157  : 
; 158  : 	filters[1].init    = NULL;

  00204	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR filters$32902[rsp+32], 0

; 159  : 
; 160  : 	return lzma_next_filter_init(&coder->next, allocator, filters);

  0020d	4c 8d 44 24 30	 lea	 r8, QWORD PTR filters$32902[rsp]
  00212	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0021a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32891[rsp]
  0021f	e8 00 00 00 00	 call	 lzma_next_filter_init
$LN10@alone_enco@2:

; 161  :   }}
; 162  : }

  00224	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00228	5f		 pop	 rdi
  00229	5e		 pop	 rsi
  0022a	c3		 ret	 0
alone_encoder_init ENDP
PUBLIC	lzma_alone_encoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_alone_encoder DD imagerel $LN11
	DD	imagerel $LN11+141
	DD	imagerel $unwind$lzma_alone_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_alone_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_alone_encoder
_TEXT	SEGMENT
ret_$32916 = 32
ret_$32918 = 36
strm$ = 64
options$ = 72
lzma_alone_encoder PROC					; COMDAT

; 177  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_alone@3:
$LN5@lzma_alone@3:

; 178  : 	lzma_next_strm_init(alone_encoder_init, strm, options);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_strm_init
  00018	89 44 24 20	 mov	 DWORD PTR ret_$32916[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR ret_$32916[rsp], 0
  00021	74 06		 je	 SHORT $LN2@lzma_alone@3
  00023	8b 44 24 20	 mov	 eax, DWORD PTR ret_$32916[rsp]
  00027	eb 5f		 jmp	 SHORT $LN9@lzma_alone@3
$LN2@lzma_alone@3:
  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 df		 jne	 SHORT $LN5@lzma_alone@3
  0002f	4c 8b 44 24 48	 mov	 r8, QWORD PTR options$[rsp]
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00039	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00042	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00046	e8 00 00 00 00	 call	 alone_encoder_init
  0004b	89 44 24 24	 mov	 DWORD PTR ret_$32918[rsp], eax
  0004f	83 7c 24 24 00	 cmp	 DWORD PTR ret_$32918[rsp], 0
  00054	74 10		 je	 SHORT $LN1@lzma_alone@3
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0005b	e8 00 00 00 00	 call	 lzma_end
  00060	8b 44 24 24	 mov	 eax, DWORD PTR ret_$32918[rsp]
  00064	eb 22		 jmp	 SHORT $LN9@lzma_alone@3
$LN1@lzma_alone@3:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 a2		 jne	 SHORT $LN8@lzma_alone@3

; 179  : 
; 180  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00075	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 181  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00082	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 182  : 
; 183  : 	return LZMA_OK;

  00086	33 c0		 xor	 eax, eax
$LN9@lzma_alone@3:

; 184  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
lzma_alone_encoder ENDP
END
