; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\alone_decoder.c
pdata	SEGMENT
$pdata$alone_decoder_memconfig DD imagerel alone_decoder_memconfig
	DD	imagerel alone_decoder_memconfig+115
	DD	imagerel $unwind$alone_decoder_memconfig
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_decoder_memconfig DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT alone_decoder_memconfig
_TEXT	SEGMENT
coder$ = 0
coder_ptr$ = 32
memusage$ = 40
old_memlimit$ = 48
new_memlimit$ = 56
alone_decoder_memconfig PROC				; COMDAT

; 198  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 199  : 	lzma_alone_coder *coder = coder_ptr;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR coder$[rsp], rax

; 200  : 
; 201  : 	*memusage = coder->memusage;

  00021	48 8b 4c 24 28	 mov	 rcx, QWORD PTR memusage$[rsp]
  00026	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  0002a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 202  : 	*old_memlimit = coder->memlimit;

  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_memlimit$[rsp]
  00036	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  0003a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 203  : 
; 204  : 	if (new_memlimit != 0) {

  00041	48 83 7c 24 38
	00		 cmp	 QWORD PTR new_memlimit$[rsp], 0
  00047	74 23		 je	 SHORT $LN2@alone_deco

; 205  : 		if (new_memlimit < coder->memusage)

  00049	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  0004d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00051	48 39 44 24 38	 cmp	 QWORD PTR new_memlimit$[rsp], rax
  00056	73 07		 jae	 SHORT $LN1@alone_deco

; 206  : 			return LZMA_MEMLIMIT_ERROR;

  00058	b8 06 00 00 00	 mov	 eax, 6
  0005d	eb 0f		 jmp	 SHORT $LN3@alone_deco
$LN1@alone_deco:

; 207  : 
; 208  : 		coder->memlimit = new_memlimit;

  0005f	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  00063	48 8b 44 24 38	 mov	 rax, QWORD PTR new_memlimit$[rsp]
  00068	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN2@alone_deco:

; 209  : 	}
; 210  : 
; 211  : 	return LZMA_OK;

  0006c	33 c0		 xor	 eax, eax
$LN3@alone_deco:

; 212  : }

  0006e	48 83 c4 18	 add	 rsp, 24
  00072	c3		 ret	 0
alone_decoder_memconfig ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$alone_decoder_end DD imagerel alone_decoder_end
	DD	imagerel alone_decoder_end+59
	DD	imagerel $unwind$alone_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT alone_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
alone_decoder_end PROC					; COMDAT

; 187  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 188  : 	lzma_alone_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 189  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 190  : 	lzma_free(coder, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_free

; 191  : 	return;
; 192  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
alone_decoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$alone_decode DD imagerel alone_decode
	DD	imagerel alone_decode+1165
	DD	imagerel $unwind$alone_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alone_decode DD 021b01H
	DD	015011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT alone_decode
_TEXT	SEGMENT
coder$ = 80
d$33028 = 88
filters$33036 = 96
ret$33039 = 144
tv69 = 148
coder_ptr$ = 176
allocator$ = 184
in$ = 192
in_pos$ = 200
in_size$ = 208
out$ = 216
out_pos$ = 224
out_size$ = 232
action$ = 240
alone_decode PROC					; COMDAT

; 59   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 60   : 	lzma_alone_coder *coder = coder_ptr;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax
$LN19@alone_deco@2:

; 61   : 
; 62   : 	while (*out_pos < out_size
; 63   : 			&& (coder->sequence == SEQ_CODE || *in_pos < in_size))

  00028	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00030	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00038	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003b	0f 83 42 04 00
	00		 jae	 $LN18@alone_deco@2
  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00046	83 78 48 04	 cmp	 DWORD PTR [rax+72], 4
  0004a	74 19		 je	 SHORT $LN17@alone_deco@2
  0004c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00054	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0005c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0005f	0f 83 1e 04 00
	00		 jae	 $LN18@alone_deco@2
$LN17@alone_deco@2:

; 64   : 	switch (coder->sequence) {

  00065	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0006a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0006d	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv69[rsp], eax
  00074	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv69[rsp], 0
  0007c	74 3d		 je	 SHORT $LN14@alone_deco@2
  0007e	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv69[rsp], 1
  00086	0f 84 90 00 00
	00		 je	 $LN12@alone_deco@2
  0008c	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv69[rsp], 2
  00094	0f 84 c4 01 00
	00		 je	 $LN8@alone_deco@2
  0009a	83 bc 24 94 00
	00 00 03	 cmp	 DWORD PTR tv69[rsp], 3
  000a2	0f 84 ab 02 00
	00		 je	 $LN5@alone_deco@2
  000a8	83 bc 24 94 00
	00 00 04	 cmp	 DWORD PTR tv69[rsp], 4
  000b0	0f 84 58 03 00
	00		 je	 $LN2@alone_deco@2
  000b6	e9 bc 03 00 00	 jmp	 $LN1@alone_deco@2
$LN14@alone_deco@2:

; 65   : 	case SEQ_PROPERTIES:
; 66   : 		if (lzma_lzma_lclppb_decode(&coder->options, in[*in_pos]))

  000bb	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  000c3	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000cb	48 83 c1 70	 add	 rcx, 112		; 00000070H
  000cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  000d7	0f b6 14 10	 movzx	 edx, BYTE PTR [rax+rdx]
  000db	e8 00 00 00 00	 call	 lzma_lzma_lclppb_decode
  000e0	0f b6 c0	 movzx	 eax, al
  000e3	85 c0		 test	 eax, eax
  000e5	74 0a		 je	 SHORT $LN13@alone_deco@2

; 67   : 			return LZMA_FORMAT_ERROR;

  000e7	b8 07 00 00 00	 mov	 eax, 7
  000ec	e9 94 03 00 00	 jmp	 $LN20@alone_deco@2
$LN13@alone_deco@2:

; 68   : 
; 69   : 		coder->sequence = SEQ_DICTIONARY_SIZE;

  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000f6	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 70   : 		++*in_pos;

  000fd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 83 c1 01	 add	 rcx, 1
  0010c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00114	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   : 		break;

  00117	e9 62 03 00 00	 jmp	 $LN15@alone_deco@2
$LN12@alone_deco@2:

; 72   : 
; 73   : 	case SEQ_DICTIONARY_SIZE:
; 74   : 		coder->options.dict_size
; 75   : 				|= (size_t)(in[*in_pos]) << (coder->pos * 8);

  0011c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00124	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00127	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0012f	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00133	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00138	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0013c	48 c1 e0 03	 shl	 rax, 3
  00140	0f b6 c8	 movzx	 ecx, al
  00143	48 d3 e2	 shl	 rdx, cl
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0014b	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0014e	48 0b ca	 or	 rcx, rdx
  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00156	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 76   : 
; 77   : 		if (++coder->pos == 4) {

  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0015e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00162	48 83 c1 01	 add	 rcx, 1
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0016b	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0016f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00174	48 83 78 50 04	 cmp	 QWORD PTR [rax+80], 4
  00179	0f 85 c0 00 00
	00		 jne	 $LN11@alone_deco@2

; 78   : 			if (coder->picky && coder->options.dict_size
; 79   : 					!= UINT32_MAX) {

  0017f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00184	0f b6 40 4c	 movzx	 eax, BYTE PTR [rax+76]
  00188	85 c0		 test	 eax, eax
  0018a	0f 84 96 00 00
	00		 je	 $LN10@alone_deco@2
  00190	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00195	83 78 70 ff	 cmp	 DWORD PTR [rax+112], -1	; ffffffffH
  00199	0f 84 87 00 00
	00		 je	 $LN10@alone_deco@2

; 80   : 				// A hack to ditch tons of false positives:
; 81   : 				// We allow only dictionary sizes that are
; 82   : 				// 2^n or 2^n + 2^(n-1). LZMA_Alone created
; 83   : 				// only files with 2^n, but accepts any
; 84   : 				// dictionary size.
; 85   : 				uint32_t d = coder->options.dict_size - 1;

  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001a4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001a7	83 e8 01	 sub	 eax, 1
  001aa	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 86   : 				d |= d >> 2;

  001ae	8b 4c 24 58	 mov	 ecx, DWORD PTR d$33028[rsp]
  001b2	c1 e9 02	 shr	 ecx, 2
  001b5	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  001b9	0b c1		 or	 eax, ecx
  001bb	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 87   : 				d |= d >> 3;

  001bf	8b 4c 24 58	 mov	 ecx, DWORD PTR d$33028[rsp]
  001c3	c1 e9 03	 shr	 ecx, 3
  001c6	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  001ca	0b c1		 or	 eax, ecx
  001cc	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 88   : 				d |= d >> 4;

  001d0	8b 4c 24 58	 mov	 ecx, DWORD PTR d$33028[rsp]
  001d4	c1 e9 04	 shr	 ecx, 4
  001d7	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  001db	0b c1		 or	 eax, ecx
  001dd	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 89   : 				d |= d >> 8;

  001e1	8b 4c 24 58	 mov	 ecx, DWORD PTR d$33028[rsp]
  001e5	c1 e9 08	 shr	 ecx, 8
  001e8	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  001ec	0b c1		 or	 eax, ecx
  001ee	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 90   : 				d |= d >> 16;

  001f2	8b 4c 24 58	 mov	 ecx, DWORD PTR d$33028[rsp]
  001f6	c1 e9 10	 shr	 ecx, 16
  001f9	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  001fd	0b c1		 or	 eax, ecx
  001ff	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 91   : 				++d;

  00203	8b 44 24 58	 mov	 eax, DWORD PTR d$33028[rsp]
  00207	83 c0 01	 add	 eax, 1
  0020a	89 44 24 58	 mov	 DWORD PTR d$33028[rsp], eax

; 92   : 
; 93   : 				if (d != coder->options.dict_size)

  0020e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00213	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00216	39 44 24 58	 cmp	 DWORD PTR d$33028[rsp], eax
  0021a	74 0a		 je	 SHORT $LN9@alone_deco@2

; 94   : 					return LZMA_FORMAT_ERROR;

  0021c	b8 07 00 00 00	 mov	 eax, 7
  00221	e9 5f 02 00 00	 jmp	 $LN20@alone_deco@2
$LN9@alone_deco@2:
$LN10@alone_deco@2:

; 95   : 			}
; 96   : 
; 97   : 			coder->pos = 0;

  00226	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0022b	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 98   : 			coder->sequence = SEQ_UNCOMPRESSED_SIZE;

  00233	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00238	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2
$LN11@alone_deco@2:

; 99   : 		}
; 100  : 
; 101  : 		++*in_pos;

  0023f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00247	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024a	48 83 c1 01	 add	 rcx, 1
  0024e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00256	48 89 08	 mov	 QWORD PTR [rax], rcx

; 102  : 		break;

  00259	e9 20 02 00 00	 jmp	 $LN15@alone_deco@2
$LN8@alone_deco@2:

; 103  : 
; 104  : 	case SEQ_UNCOMPRESSED_SIZE:
; 105  : 		coder->uncompressed_size
; 106  : 				|= (lzma_vli)(in[*in_pos]) << (coder->pos * 8);

  0025e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00266	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00269	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00271	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00275	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0027a	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0027e	48 c1 e0 03	 shl	 rax, 3
  00282	0f b6 c8	 movzx	 ecx, al
  00285	48 8b c2	 mov	 rax, rdx
  00288	48 d3 e0	 shl	 rax, cl
  0028b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00290	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00294	48 0b c8	 or	 rcx, rax
  00297	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0029c	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 107  : 		++*in_pos;

  002a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  002a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002ab	48 83 c1 01	 add	 rcx, 1
  002af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  002b7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 108  : 		if (++coder->pos < 8)

  002ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002bf	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002c3	48 83 c1 01	 add	 rcx, 1
  002c7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002cc	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  002d0	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002d5	48 83 78 50 08	 cmp	 QWORD PTR [rax+80], 8
  002da	73 05		 jae	 SHORT $LN7@alone_deco@2

; 109  : 			break;

  002dc	e9 9d 01 00 00	 jmp	 $LN15@alone_deco@2
$LN7@alone_deco@2:

; 110  : 
; 111  : 		// Another hack to ditch false positives: Assume that
; 112  : 		// if the uncompressed size is known, it must be less
; 113  : 		// than 256 GiB.
; 114  : 		if (coder->picky
; 115  : 				&& coder->uncompressed_size != LZMA_VLI_UNKNOWN
; 116  : 				&& coder->uncompressed_size
; 117  : 					>= (LZMA_VLI_C(1) << 38))

  002e1	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002e6	0f b6 40 4c	 movzx	 eax, BYTE PTR [rax+76]
  002ea	85 c0		 test	 eax, eax
  002ec	74 2b		 je	 SHORT $LN6@alone_deco@2
  002ee	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002f3	48 83 78 58 ff	 cmp	 QWORD PTR [rax+88], -1
  002f8	74 1f		 je	 SHORT $LN6@alone_deco@2
  002fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002ff	48 b8 00 00 00
	00 40 00 00 00	 mov	 rax, 274877906944	; 0000004000000000H
  00309	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0030d	72 0a		 jb	 SHORT $LN6@alone_deco@2

; 118  : 			return LZMA_FORMAT_ERROR;

  0030f	b8 07 00 00 00	 mov	 eax, 7
  00314	e9 6c 01 00 00	 jmp	 $LN20@alone_deco@2
$LN6@alone_deco@2:

; 119  : 
; 120  : 		// Calculate the memory usage so that it is ready
; 121  : 		// for SEQ_CODER_INIT.
; 122  : 		coder->memusage = lzma_lzma_decoder_memusage(&coder->options)
; 123  : 				+ LZMA_MEMUSAGE_BASE;

  00319	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0031e	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00322	e8 00 00 00 00	 call	 lzma_lzma_decoder_memusage
  00327	48 8b c8	 mov	 rcx, rax
  0032a	48 81 c1 00 80
	00 00		 add	 rcx, 32768		; 00008000H
  00331	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00336	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 124  : 
; 125  : 		coder->pos = 0;

  0033a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0033f	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 126  : 		coder->sequence = SEQ_CODER_INIT;

  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0034c	c7 40 48 03 00
	00 00		 mov	 DWORD PTR [rax+72], 3
$LN5@alone_deco@2:

; 127  : 
; 128  : 	// Fall through
; 129  : 
; 130  : 	case SEQ_CODER_INIT: {
; 131  : 		if (coder->memusage > coder->memlimit)

  00353	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00358	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0035d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00361	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00365	76 0a		 jbe	 SHORT $LN4@alone_deco@2

; 132  : 			return LZMA_MEMLIMIT_ERROR;

  00367	b8 06 00 00 00	 mov	 eax, 6
  0036c	e9 14 01 00 00	 jmp	 $LN20@alone_deco@2
$LN4@alone_deco@2:

; 133  : 
; 134  :       {
; 135  : 	    /* //MiSt
; 136  : 		lzma_filter_info filters[2] = {
; 137  : 			{
; 138  : 				.init = &lzma_lzma_decoder_init,
; 139  : 				.options = &coder->options,
; 140  : 			}, {
; 141  : 				.init = NULL,
; 142  : 			}
; 143  : 		};
; 144  : 		*/
; 145  : 		lzma_filter_info filters[2] = {
; 146  : 			{
; 147  : 				0,                          // lzma_vli id;

  00371	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR filters$33036[rsp], 0

; 148  : 				&lzma_lzma_decoder_init,    // lzma_init_function init;

  0037a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_lzma_decoder_init
  00381	48 89 44 24 68	 mov	 QWORD PTR filters$33036[rsp+8], rax

; 149  : 				&coder->options,            // void *options;

  00386	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0038b	48 83 c0 70	 add	 rax, 112		; 00000070H
  0038f	48 89 44 24 70	 mov	 QWORD PTR filters$33036[rsp+16], rax

; 150  : 			}, {
; 151  : 				0,

  00394	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR filters$33036[rsp+24], 0

; 152  : 				NULL,

  0039d	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR filters$33036[rsp+32], 0

; 153  : 				NULL,

  003a9	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR filters$33036[rsp+40], 0

; 154  : 			}
; 155  : 		};
; 156  : 
; 157  : 		const lzma_ret ret = lzma_next_filter_init(&coder->next,
; 158  : 				allocator, filters);

  003b5	4c 8d 44 24 60	 lea	 r8, QWORD PTR filters$33036[rsp]
  003ba	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003c7	e8 00 00 00 00	 call	 lzma_next_filter_init
  003cc	89 84 24 90 00
	00 00		 mov	 DWORD PTR ret$33039[rsp], eax

; 159  : 		if (ret != LZMA_OK)

  003d3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR ret$33039[rsp], 0
  003db	74 0c		 je	 SHORT $LN3@alone_deco@2

; 160  : 			return ret;

  003dd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ret$33039[rsp]
  003e4	e9 9c 00 00 00	 jmp	 $LN20@alone_deco@2
$LN3@alone_deco@2:

; 161  : 
; 162  : 		// Use a hack to set the uncompressed size.
; 163  : 		lzma_lz_decoder_uncompressed(coder->next.coder,
; 164  : 				coder->uncompressed_size);

  003e9	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  003ee	48 8b 52 58	 mov	 rdx, QWORD PTR [rdx+88]
  003f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003f7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003fa	e8 00 00 00 00	 call	 lzma_lz_decoder_uncompressed

; 165  : 
; 166  : 		coder->sequence = SEQ_CODE;

  003ff	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  00404	41 c7 43 48 04
	00 00 00	 mov	 DWORD PTR [r11+72], 4

; 167  : 	  }
; 168  : 		break;

  0040c	eb 70		 jmp	 SHORT $LN15@alone_deco@2
$LN2@alone_deco@2:

; 169  : 	}
; 170  : 
; 171  : 	case SEQ_CODE: {
; 172  : 		return coder->next.code(coder->next.coder,
; 173  : 				allocator, in, in_pos, in_size,
; 174  : 				out, out_pos, out_size, action);

  0040e	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00415	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00419	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00421	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00426	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0042e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00433	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0043b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00440	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00448	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00455	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0045d	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00465	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0046a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0046d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00472	ff 50 18	 call	 QWORD PTR [rax+24]
  00475	eb 0e		 jmp	 SHORT $LN20@alone_deco@2
$LN1@alone_deco@2:

; 175  : 	}
; 176  : 
; 177  : 	default:
; 178  : 		return LZMA_PROG_ERROR;

  00477	b8 0b 00 00 00	 mov	 eax, 11
  0047c	eb 07		 jmp	 SHORT $LN20@alone_deco@2
$LN15@alone_deco@2:

; 179  : 	}

  0047e	e9 a5 fb ff ff	 jmp	 $LN19@alone_deco@2
$LN18@alone_deco@2:

; 180  : 
; 181  : 	return LZMA_OK;

  00483	33 c0		 xor	 eax, eax
$LN20@alone_deco@2:

; 182  : }

  00485	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0048c	c3		 ret	 0
alone_decode ENDP
PUBLIC	lzma_alone_decoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_alone_decoder_init DD imagerel $LN11
	DD	imagerel $LN11+376
	DD	imagerel $unwind$lzma_alone_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_alone_decoder_init DD 031a01H
	DD	07016621aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_alone_decoder_init
_TEXT	SEGMENT
coder$33078 = 32
tv87 = 40
next$ = 80
allocator$ = 88
memlimit$ = 96
picky$ = 104
lzma_alone_decoder_init PROC				; COMDAT

; 218  : {

$LN11:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@lzma_alone:

; 219  : 	lzma_next_coder_init(&lzma_alone_decoder_init, next, allocator);

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_alone_decoder_init
  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00026	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0002a	74 0f		 je	 SHORT $LN3@lzma_alone
  0002c	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00036	e8 00 00 00 00	 call	 lzma_next_end
$LN3@lzma_alone:
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_alone_decoder_init
  00047	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 c9		 jne	 SHORT $LN6@lzma_alone

; 220  : 
; 221  :   {
; 222  : 	lzma_alone_coder *coder = next->coder;

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 89 44 24 20	 mov	 QWORD PTR coder$33078[rsp], rax

; 223  : 
; 224  : 	if (coder == NULL) {

  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33078[rsp], 0
  00064	75 76		 jne	 SHORT $LN2@lzma_alone

; 225  : 		coder = lzma_alloc(sizeof(lzma_alone_coder), allocator);

  00066	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0006b	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00070	e8 00 00 00 00	 call	 lzma_alloc
  00075	48 89 44 24 20	 mov	 QWORD PTR coder$33078[rsp], rax

; 226  : 		if (coder == NULL)

  0007a	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33078[rsp], 0
  00080	75 0a		 jne	 SHORT $LN1@lzma_alone

; 227  : 			return LZMA_MEM_ERROR;

  00082	b8 05 00 00 00	 mov	 eax, 5
  00087	e9 e5 00 00 00	 jmp	 $LN7@lzma_alone
$LN1@lzma_alone:

; 228  : 
; 229  : 		next->coder = coder;

  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  00096	48 89 01	 mov	 QWORD PTR [rcx], rax

; 230  : 		next->code = &alone_decode;

  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_decode
  000a5	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 231  : 		next->end = &alone_decoder_end;

  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_decoder_end
  000b5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 232  : 		next->memconfig = &alone_decoder_memconfig;

  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:alone_decoder_memconfig
  000c5	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 233  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000c9	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000d0	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$33078[rsp]
  000d5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000da	f3 a4		 rep movsb
$LN2@lzma_alone:

; 234  : 	}
; 235  : 
; 236  : 	coder->sequence = SEQ_PROPERTIES;

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  000e1	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 237  : 	coder->picky = picky;

  000e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33078[rsp]
  000ed	0f b6 44 24 68	 movzx	 eax, BYTE PTR picky$[rsp]
  000f2	88 41 4c	 mov	 BYTE PTR [rcx+76], al

; 238  : 	coder->pos = 0;

  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  000fa	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 239  : 	coder->options.dict_size = 0;

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  00107	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 240  : 	coder->options.preset_dict = NULL;

  0010e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  00113	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 241  : 	coder->options.preset_dict_size = 0;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  00120	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 242  : 	coder->uncompressed_size = 0;

  0012a	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  0012f	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 243  : 	coder->memlimit = my_max(1, memlimit);

  00137	48 83 7c 24 60
	01		 cmp	 QWORD PTR memlimit$[rsp], 1
  0013d	73 0b		 jae	 SHORT $LN9@lzma_alone
  0013f	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR tv87[rsp], 1
  00148	eb 0a		 jmp	 SHORT $LN10@lzma_alone
$LN9@lzma_alone:
  0014a	48 8b 44 24 60	 mov	 rax, QWORD PTR memlimit$[rsp]
  0014f	48 89 44 24 28	 mov	 QWORD PTR tv87[rsp], rax
$LN10@lzma_alone:
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33078[rsp]
  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR tv87[rsp]
  0015e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 244  : 	coder->memusage = LZMA_MEMUSAGE_BASE;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33078[rsp]
  00167	48 c7 40 68 00
	80 00 00	 mov	 QWORD PTR [rax+104], 32768 ; 00008000H

; 245  :   }
; 246  : 
; 247  : 	return LZMA_OK;

  0016f	33 c0		 xor	 eax, eax
$LN7@lzma_alone:

; 248  : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	5f		 pop	 rdi
  00176	5e		 pop	 rsi
  00177	c3		 ret	 0
lzma_alone_decoder_init ENDP
PUBLIC	lzma_alone_decoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_alone_decoder DD imagerel $LN11
	DD	imagerel $LN11+144
	DD	imagerel $unwind$lzma_alone_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_alone_decoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_alone_decoder
_TEXT	SEGMENT
ret_$33096 = 32
ret_$33098 = 36
strm$ = 64
memlimit$ = 72
lzma_alone_decoder PROC					; COMDAT

; 253  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_alone@2:
$LN5@lzma_alone@2:

; 254  : 	lzma_next_strm_init(lzma_alone_decoder_init, strm, memlimit, false);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_strm_init
  00018	89 44 24 20	 mov	 DWORD PTR ret_$33096[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33096[rsp], 0
  00021	74 06		 je	 SHORT $LN2@lzma_alone@2
  00023	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33096[rsp]
  00027	eb 62		 jmp	 SHORT $LN9@lzma_alone@2
$LN2@lzma_alone@2:
  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 df		 jne	 SHORT $LN5@lzma_alone@2
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	4c 8b 44 24 48	 mov	 r8, QWORD PTR memlimit$[rsp]
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0003c	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00045	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00049	e8 00 00 00 00	 call	 lzma_alone_decoder_init
  0004e	89 44 24 24	 mov	 DWORD PTR ret_$33098[rsp], eax
  00052	83 7c 24 24 00	 cmp	 DWORD PTR ret_$33098[rsp], 0
  00057	74 10		 je	 SHORT $LN1@lzma_alone@2
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0005e	e8 00 00 00 00	 call	 lzma_end
  00063	8b 44 24 24	 mov	 eax, DWORD PTR ret_$33098[rsp]
  00067	eb 22		 jmp	 SHORT $LN9@lzma_alone@2
$LN1@lzma_alone@2:
  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 9f		 jne	 SHORT $LN8@lzma_alone@2

; 255  : 
; 256  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00074	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00078	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 257  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00081	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00085	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 258  : 
; 259  : 	return LZMA_OK;

  00089	33 c0		 xor	 eax, eax
$LN9@lzma_alone@2:

; 260  : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
lzma_alone_decoder ENDP
END
