; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_lzma_props_encode
PUBLIC	lzma_lzma_encoder_memusage
PUBLIC	lzma_lzma_encoder_init
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
;	COMDAT set_lz_options
_TEXT	SEGMENT
lz_options$ = 8
options$ = 16
set_lz_options PROC					; COMDAT

; 444  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 445  : 	// LZ encoder initialization does the validation for these so we
; 446  : 	// don't need to validate here.
; 447  : 	lz_options->before_size = OPTS;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR lz_options$[rsp]
  0000f	48 c7 00 00 10
	00 00		 mov	 QWORD PTR [rax], 4096	; 00001000H

; 448  : 	lz_options->dict_size = options->dict_size;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR lz_options$[rsp]
  00022	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 449  : 	lz_options->after_size = LOOP_INPUT_MAX;

  00026	48 8b 44 24 08	 mov	 rax, QWORD PTR lz_options$[rsp]
  0002b	48 c7 40 10 01
	10 00 00	 mov	 QWORD PTR [rax+16], 4097 ; 00001001H

; 450  : 	lz_options->match_len_max = MATCH_LEN_MAX;

  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR lz_options$[rsp]
  00038	48 c7 40 18 11
	01 00 00	 mov	 QWORD PTR [rax+24], 273	; 00000111H

; 451  : 	lz_options->nice_len = options->nice_len;

  00040	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  00045	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00048	48 8b 44 24 08	 mov	 rax, QWORD PTR lz_options$[rsp]
  0004d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 452  : 	lz_options->match_finder = options->mf;

  00051	48 8b 4c 24 08	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00056	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  0005b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0005e	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 453  : 	lz_options->depth = options->depth;

  00061	48 8b 4c 24 08	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00066	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  0006b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0006e	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 454  : 	lz_options->preset_dict = options->preset_dict;

  00071	48 8b 4c 24 08	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  0007b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007f	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 455  : 	lz_options->preset_dict_size = options->preset_dict_size;

  00083	48 8b 4c 24 08	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00088	48 8b 44 24 10	 mov	 rax, QWORD PTR options$[rsp]
  0008d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00090	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 456  : 	return;
; 457  : }

  00093	c3		 ret	 0
set_lz_options ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT get_dist_slot
_TEXT	SEGMENT
dist$ = 8
get_dist_slot PROC					; COMDAT

; 110  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00004	81 7c 24 08 00
	20 00 00	 cmp	 DWORD PTR dist$[rsp], 8192 ; 00002000H
  0000c	73 11		 jae	 SHORT $LN2@get_dist_s@4

; 114  : 		return lzma_fastpos[dist];

  0000e	8b 4c 24 08	 mov	 ecx, DWORD PTR dist$[rsp]
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00019	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0001d	eb 3a		 jmp	 SHORT $LN3@get_dist_s@4
$LN2@get_dist_s@4:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  0001f	81 7c 24 08 00
	00 00 02	 cmp	 DWORD PTR dist$[rsp], 33554432 ; 02000000H
  00027	73 19		 jae	 SHORT $LN1@get_dist_s@4

; 117  : 		return fastpos_result(dist, 0, 1);

  00029	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  0002d	c1 e8 0c	 shr	 eax, 12
  00030	8b c8		 mov	 ecx, eax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00039	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003d	83 c0 18	 add	 eax, 24
  00040	eb 17		 jmp	 SHORT $LN3@get_dist_s@4
$LN1@get_dist_s@4:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00042	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  00046	c1 e8 18	 shr	 eax, 24
  00049	8b c8		 mov	 ecx, eax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00052	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00056	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@4:

; 120  : }

  00059	f3 c3		 fatret	 0
get_dist_slot ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_common.h
pdata	SEGMENT
$pdata$literal_init DD imagerel literal_init
	DD	imagerel literal_init+137
	DD	imagerel $unwind$literal_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$literal_init DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT literal_init
_TEXT	SEGMENT
i$33228 = 0
coders$33227 = 4
j$33229 = 8
probs$ = 32
lc$ = 40
lp$ = 48
literal_init PROC					; COMDAT

; 131  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 132  : 	assert(lc + lp <= LZMA_LCLP_MAX);
; 133  : 
; 134  :   {
; 135  : 	const uint32_t coders = 1U << (lc + lp);

  00012	8b 44 24 30	 mov	 eax, DWORD PTR lp$[rsp]
  00016	8b 4c 24 28	 mov	 ecx, DWORD PTR lc$[rsp]
  0001a	03 c8		 add	 ecx, eax
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	d3 e0		 shl	 eax, cl
  00023	89 44 24 04	 mov	 DWORD PTR coders$33227[rsp], eax

; 136  : 	uint32_t i, j;
; 137  : 
; 138  : 	for (i = 0; i < coders; ++i)

  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$33228[rsp], 0
  0002e	eb 09		 jmp	 SHORT $LN6@literal_in
$LN5@literal_in:
  00030	8b 04 24	 mov	 eax, DWORD PTR i$33228[rsp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 04 24	 mov	 DWORD PTR i$33228[rsp], eax
$LN6@literal_in:
  00039	8b 44 24 04	 mov	 eax, DWORD PTR coders$33227[rsp]
  0003d	39 04 24	 cmp	 DWORD PTR i$33228[rsp], eax
  00040	73 42		 jae	 SHORT $LN4@literal_in

; 139  : 		for (j = 0; j < LITERAL_CODER_SIZE; ++j)

  00042	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR j$33229[rsp], 0
  0004a	eb 0b		 jmp	 SHORT $LN3@literal_in
$LN2@literal_in:
  0004c	8b 44 24 08	 mov	 eax, DWORD PTR j$33229[rsp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 44 24 08	 mov	 DWORD PTR j$33229[rsp], eax
$LN3@literal_in:
  00057	81 7c 24 08 00
	03 00 00	 cmp	 DWORD PTR j$33229[rsp], 768 ; 00000300H
  0005f	73 21		 jae	 SHORT $LN1@literal_in

; 140  : 			bit_reset(probs[i][j]);

  00061	8b 04 24	 mov	 eax, DWORD PTR i$33228[rsp]
  00064	48 69 c0 00 06
	00 00		 imul	 rax, 1536		; 00000600H
  0006b	48 8b 54 24 20	 mov	 rdx, QWORD PTR probs$[rsp]
  00070	48 03 d0	 add	 rdx, rax
  00073	8b 4c 24 08	 mov	 ecx, DWORD PTR j$33229[rsp]
  00077	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  0007c	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  00080	eb ca		 jmp	 SHORT $LN2@literal_in
$LN1@literal_in:
  00082	eb ac		 jmp	 SHORT $LN5@literal_in
$LN4@literal_in:

; 141  :   }
; 142  : 
; 143  : 	return;
; 144  : }

  00084	48 83 c4 18	 add	 rsp, 24
  00088	c3		 ret	 0
literal_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_lclppb_valid DD imagerel is_lclppb_valid
	DD	imagerel is_lclppb_valid+87
	DD	imagerel $unwind$is_lclppb_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_lclppb_valid DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_lclppb_valid
_TEXT	SEGMENT
tv74 = 0
options$ = 32
is_lclppb_valid PROC					; COMDAT

; 34   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 35   : 	return options->lc <= LZMA_LCLP_MAX && options->lp <= LZMA_LCLP_MAX
; 36   : 			&& options->lc + options->lp <= LZMA_LCLP_MAX
; 37   : 			&& options->pb <= LZMA_PB_MAX;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	83 78 14 04	 cmp	 DWORD PTR [rax+20], 4
  00012	77 34		 ja	 SHORT $LN3@is_lclppb_
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00019	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  0001d	77 29		 ja	 SHORT $LN3@is_lclppb_
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00024	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR options$[rsp]
  0002c	03 41 18	 add	 eax, DWORD PTR [rcx+24]
  0002f	83 f8 04	 cmp	 eax, 4
  00032	77 14		 ja	 SHORT $LN3@is_lclppb_
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00039	83 78 1c 04	 cmp	 DWORD PTR [rax+28], 4
  0003d	77 09		 ja	 SHORT $LN3@is_lclppb_
  0003f	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv74[rsp], 1
  00046	eb 07		 jmp	 SHORT $LN4@is_lclppb_
$LN3@is_lclppb_:
  00048	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN4@is_lclppb_:
  0004f	8a 04 24	 mov	 al, BYTE PTR tv74[rsp]

; 38   : }

  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
is_lclppb_valid ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
_TEXT	ENDS
;	COMDAT rc_pending
_TEXT	SEGMENT
rc$ = 8
rc_pending PROC						; COMDAT

; 227  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 228  : 	return rc->cache_size + 5 - 1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	48 83 c0 04	 add	 rax, 4

; 229  : }

  00012	c3		 ret	 0
rc_pending ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_shift_low
_TEXT	SEGMENT
rc$ = 8
out$ = 16
out_pos$ = 24
out_size$ = 32
rc_shift_low PROC					; COMDAT

; 126  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 127  : 	if ((uint32_t)(rc->low) < (uint32_t)(0xFF000000)
; 128  : 			|| (uint32_t)(rc->low >> 32) != 0) {

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00019	81 38 00 00 00
	ff		 cmp	 DWORD PTR [rax], -16777216 ; ff000000H
  0001f	72 14		 jb	 SHORT $LN5@rc_shift_l
  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 9a 00 00
	00		 je	 $LN6@rc_shift_l
$LN5@rc_shift_l:
$LN4@rc_shift_l:

; 129  : 		do {
; 130  : 			if (*out_pos == out_size)

  00035	48 8b 4c 24 18	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR out_size$[rsp]
  0003f	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00042	75 07		 jne	 SHORT $LN1@rc_shift_l

; 131  : 				return true;

  00044	b0 01		 mov	 al, 1
  00046	e9 b7 00 00 00	 jmp	 $LN7@rc_shift_l
$LN1@rc_shift_l:

; 132  : 
; 133  : 			out[*out_pos] = rc->cache + (uint8_t)(rc->low >> 32);

  0004b	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00050	0f b6 50 14	 movzx	 edx, BYTE PTR [rax+20]
  00054	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00060	0f b6 c0	 movzx	 eax, al
  00063	03 d0		 add	 edx, eax
  00065	48 8b 4c 24 18	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0006a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006d	48 8b 44 24 10	 mov	 rax, QWORD PTR out$[rsp]
  00072	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 134  : 			++*out_pos;

  00075	48 8b 4c 24 18	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0007a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007d	48 83 c1 01	 add	 rcx, 1
  00081	48 8b 44 24 18	 mov	 rax, QWORD PTR out_pos$[rsp]
  00086	48 89 08	 mov	 QWORD PTR [rax], rcx

; 135  : 			rc->cache = 0xFF;

  00089	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  0008e	c6 40 14 ff	 mov	 BYTE PTR [rax+20], 255	; 000000ffH

; 136  : 
; 137  : 		} while (--rc->cache_size != 0);

  00092	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  00097	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009b	48 83 e9 01	 sub	 rcx, 1
  0009f	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  000a4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000a8	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  000ad	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b2	75 81		 jne	 SHORT $LN4@rc_shift_l

; 138  : 
; 139  : 		rc->cache = (rc->low >> 24) & 0xFF;

  000b4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  000b9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000bc	48 c1 e9 18	 shr	 rcx, 24
  000c0	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  000c7	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  000cc	88 48 14	 mov	 BYTE PTR [rax+20], cl
$LN6@rc_shift_l:

; 140  : 	}
; 141  : 
; 142  : 	++rc->cache_size;

  000cf	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  000d4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d8	48 83 c1 01	 add	 rcx, 1
  000dc	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  000e1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 143  : 	rc->low = (rc->low & 0x00FFFFFF) << RC_SHIFT_BITS;

  000e5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  000ea	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ed	48 81 e1 ff ff
	ff 00		 and	 rcx, 16777215		; 00ffffffH
  000f4	48 c1 e1 08	 shl	 rcx, 8
  000f8	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  000fd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 144  : 
; 145  : 	return false;

  00100	32 c0		 xor	 al, al
$LN7@rc_shift_l:

; 146  : }

  00102	f3 c3		 fatret	 0
rc_shift_low ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rc_flush DD imagerel rc_flush
	DD	imagerel rc_flush+89
	DD	imagerel $unwind$rc_flush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_flush DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_flush
_TEXT	SEGMENT
i$ = 0
rc$ = 32
rc_flush PROC						; COMDAT

; 117  : {   size_t i;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 118  : 	for (i = 0; i < 5; ++i)

  00009	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00011	eb 0c		 jmp	 SHORT $LN3@rc_flush
$LN2@rc_flush:
  00013	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00017	48 83 c0 01	 add	 rax, 1
  0001b	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@rc_flush:
  0001f	48 83 3c 24 05	 cmp	 QWORD PTR i$[rsp], 5
  00024	73 2e		 jae	 SHORT $LN1@rc_flush

; 119  : 		rc->symbols[rc->count++] = RC_FLUSH;

  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  0002b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  00034	c7 44 88 28 04
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 4
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  00041	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00045	48 83 c1 01	 add	 rcx, 1
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  0004e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  00052	eb bf		 jmp	 SHORT $LN2@rc_flush
$LN1@rc_flush:

; 120  : }

  00054	48 83 c4 18	 add	 rsp, 24
  00058	c3		 ret	 0
rc_flush ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_direct
_TEXT	SEGMENT
rc$ = 8
value$ = 16
bit_count$ = 24
rc_direct PROC						; COMDAT

; 107  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN3@rc_direct:

; 108  : 	do {
; 109  : 		rc->symbols[rc->count++]
; 110  : 				= RC_DIRECT_0 + ((value >> --bit_count) & 1);

  0000e	8b 44 24 18	 mov	 eax, DWORD PTR bit_count$[rsp]
  00012	83 e8 01	 sub	 eax, 1
  00015	89 44 24 18	 mov	 DWORD PTR bit_count$[rsp], eax
  00019	8b 44 24 18	 mov	 eax, DWORD PTR bit_count$[rsp]
  0001d	0f b6 c8	 movzx	 ecx, al
  00020	8b 54 24 10	 mov	 edx, DWORD PTR value$[rsp]
  00024	d3 ea		 shr	 edx, cl
  00026	83 e2 01	 and	 edx, 1
  00029	83 c2 02	 add	 edx, 2
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  00031	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  0003a	89 54 88 28	 mov	 DWORD PTR [rax+rcx*4+40], edx
  0003e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  00043	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00047	48 83 c1 01	 add	 rcx, 1
  0004b	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00050	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 111  : 	} while (bit_count != 0);

  00054	83 7c 24 18 00	 cmp	 DWORD PTR bit_count$[rsp], 0
  00059	75 b3		 jne	 SHORT $LN3@rc_direct

; 112  : }

  0005b	f3 c3		 fatret	 0
rc_direct ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit
_TEXT	SEGMENT
rc$ = 8
prob$ = 16
bit$ = 24
rc_bit	PROC						; COMDAT

; 68   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 69   : 	rc->symbols[rc->count] = bit;

  0000f	48 8b 54 24 08	 mov	 rdx, QWORD PTR rc$[rsp]
  00014	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00018	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  0001d	8b 44 24 18	 mov	 eax, DWORD PTR bit$[rsp]
  00021	89 44 91 28	 mov	 DWORD PTR [rcx+rdx*4+40], eax

; 70   : 	rc->probs[rc->count] = prob;

  00025	48 8b 54 24 08	 mov	 rdx, QWORD PTR rc$[rsp]
  0002a	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0002e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  00033	48 8b 44 24 10	 mov	 rax, QWORD PTR prob$[rsp]
  00038	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax

; 71   : 	++rc->count;

  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR rc$[rsp]
  00045	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00049	48 83 c1 01	 add	 rcx, 1
  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00052	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 72   : }

  00056	c3		 ret	 0
rc_bit	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_reset
_TEXT	SEGMENT
rc$ = 8
rc_reset PROC						; COMDAT

; 56   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 57   : 	rc->low = 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 58   : 	rc->cache_size = 1;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00016	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 59   : 	rc->range = UINT32_MAX;

  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00023	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [rax+16], -1	; ffffffffH

; 60   : 	rc->cache = 0;

  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  0002f	c6 40 14 00	 mov	 BYTE PTR [rax+20], 0

; 61   : 	rc->count = 0;

  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00038	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 62   : 	rc->pos = 0;

  00040	48 8b 44 24 08	 mov	 rax, QWORD PTR rc$[rsp]
  00045	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 63   : }

  0004d	c3		 ret	 0
rc_reset ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
_TEXT	ENDS
;	COMDAT rc_bit_1_price
_TEXT	SEGMENT
prob$ = 8
rc_bit_1_price PROC					; COMDAT

; 45   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 46   : 	return lzma_rc_prices[(prob ^ (RC_BIT_MODEL_TOTAL - 1))
; 47   : 			>> RC_MOVE_REDUCING_BITS];

  00005	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000a	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0000f	c1 e8 04	 shr	 eax, 4
  00012	8b c8		 mov	 ecx, eax
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0001b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 48   : }

  0001f	c3		 ret	 0
rc_bit_1_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit_0_price
_TEXT	SEGMENT
prob$ = 8
rc_bit_0_price PROC					; COMDAT

; 38   : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 39   : 	return lzma_rc_prices[prob >> RC_MOVE_REDUCING_BITS];

  00005	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000a	c1 f8 04	 sar	 eax, 4
  0000d	48 63 c8	 movsxd	 rcx, eax
  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00017	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 40   : }

  0001b	c3		 ret	 0
rc_bit_0_price ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT rc_bit_price
_TEXT	SEGMENT
prob$ = 8
bit$ = 16
rc_bit_price PROC					; COMDAT

; 30   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx

; 31   : 	return lzma_rc_prices[(prob ^ ((UINT32_C(0) - bit)
; 32   : 			& (RC_BIT_MODEL_TOTAL - 1))) >> RC_MOVE_REDUCING_BITS];

  00009	0f b7 44 24 08	 movzx	 eax, WORD PTR prob$[rsp]
  0000e	33 c9		 xor	 ecx, ecx
  00010	2b 4c 24 10	 sub	 ecx, DWORD PTR bit$[rsp]
  00014	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  0001a	33 c1		 xor	 eax, ecx
  0001c	c1 e8 04	 shr	 eax, 4
  0001f	8b c8		 mov	 ecx, eax
  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00028	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]

; 33   : }

  0002c	c3		 ret	 0
rc_bit_price ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$mf_skip DD imagerel mf_skip
	DD	imagerel mf_skip+63
	DD	imagerel $unwind$mf_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mf_skip DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mf_skip
_TEXT	SEGMENT
mf$ = 48
amount$ = 56
mf_skip	PROC						; COMDAT

; 268  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  : 	if (amount != 0) {

  0000d	83 7c 24 38 00	 cmp	 DWORD PTR amount$[rsp], 0
  00012	74 26		 je	 SHORT $LN1@mf_skip@3

; 270  : 		mf->skip(mf, amount);

  00014	8b 54 24 38	 mov	 edx, DWORD PTR amount$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mf$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00022	ff 50 38	 call	 QWORD PTR [rax+56]

; 271  : 		mf->read_ahead += amount;

  00025	4c 8b 5c 24 30	 mov	 r11, QWORD PTR mf$[rsp]
  0002a	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  0002e	03 4c 24 38	 add	 ecx, DWORD PTR amount$[rsp]
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR mf$[rsp]
  00037	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN1@mf_skip@3:

; 272  : 	}
; 273  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
mf_skip	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_position
_TEXT	SEGMENT
mf$ = 8
mf_position PROC					; COMDAT

; 253  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 254  : 	return mf->read_pos - mf->read_ahead;

  00005	48 8b 54 24 08	 mov	 rdx, QWORD PTR mf$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000f	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00012	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00015	2b c1		 sub	 eax, ecx

; 255  : }

  00017	c3		 ret	 0
mf_position ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT write32ne
_TEXT	SEGMENT
buf$ = 8
num$ = 16
write32ne PROC						; COMDAT

; 266  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  : 	*(uint32_t *)buf = num;

  00009	48 8b 4c 24 08	 mov	 rcx, QWORD PTR buf$[rsp]
  0000e	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00012	89 01		 mov	 DWORD PTR [rcx], eax

; 268  : 	return;
; 269  : }

  00014	c3		 ret	 0
write32ne ENDP
PUBLIC	lzma_lzma_lclppb_encode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_common.h
pdata	SEGMENT
$pdata$lzma_lzma_lclppb_encode DD imagerel $LN8
	DD	imagerel $LN8+140
	DD	imagerel $unwind$lzma_lzma_lclppb_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_lclppb_encode DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT lzma_lzma_lclppb_encode
_TEXT	SEGMENT
tv86 = 0
options$ = 32
byte$ = 40
lzma_lzma_lclppb_encode PROC				; COMDAT

; 666  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 667  : 	if (!is_lclppb_valid(options))

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00013	83 78 14 04	 cmp	 DWORD PTR [rax+20], 4
  00017	77 34		 ja	 SHORT $LN6@lzma_lzma_@4
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0001e	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  00022	77 29		 ja	 SHORT $LN6@lzma_lzma_@4
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00029	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR options$[rsp]
  00031	03 41 18	 add	 eax, DWORD PTR [rcx+24]
  00034	83 f8 04	 cmp	 eax, 4
  00037	77 14		 ja	 SHORT $LN6@lzma_lzma_@4
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0003e	83 78 1c 04	 cmp	 DWORD PTR [rax+28], 4
  00042	77 09		 ja	 SHORT $LN6@lzma_lzma_@4
  00044	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv86[rsp], 1
  0004b	eb 07		 jmp	 SHORT $LN7@lzma_lzma_@4
$LN6@lzma_lzma_@4:
  0004d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv86[rsp], 0
$LN7@lzma_lzma_@4:
  00054	0f b6 04 24	 movzx	 eax, BYTE PTR tv86[rsp]
  00058	85 c0		 test	 eax, eax
  0005a	75 04		 jne	 SHORT $LN1@lzma_lzma_@4

; 668  : 		return true;

  0005c	b0 01		 mov	 al, 1
  0005e	eb 27		 jmp	 SHORT $LN2@lzma_lzma_@4
$LN1@lzma_lzma_@4:

; 669  : 
; 670  : 	*byte = (options->pb * 5 + options->lp) * 9 + options->lc;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00065	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00068	6b c9 05	 imul	 ecx, 5
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00070	03 48 18	 add	 ecx, DWORD PTR [rax+24]
  00073	6b c9 09	 imul	 ecx, 9
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0007b	03 48 14	 add	 ecx, DWORD PTR [rax+20]
  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR byte$[rsp]
  00083	88 08		 mov	 BYTE PTR [rax], cl

; 671  : 	assert(*byte <= (4 * 5 + 4) * 9 + 8);
; 672  : 
; 673  : 	return false;

  00085	32 c0		 xor	 al, al
$LN2@lzma_lzma_@4:

; 674  : }

  00087	48 83 c4 18	 add	 rsp, 24
  0008b	c3		 ret	 0
lzma_lzma_lclppb_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_common.h
pdata	SEGMENT
$pdata$is_options_valid DD imagerel is_options_valid
	DD	imagerel is_options_valid+161
	DD	imagerel $unwind$is_options_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_options_valid DD 010901H
	DD	02209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT is_options_valid
_TEXT	SEGMENT
tv88 = 0
tv76 = 4
options$ = 32
is_options_valid PROC					; COMDAT

; 431  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 432  : 	// Validate some of the options. LZ encoder validates nice_len too
; 433  : 	// but we need a valid value here earlier.
; 434  : 	return is_lclppb_valid(options)
; 435  : 			&& options->nice_len >= MATCH_LEN_MIN
; 436  : 			&& options->nice_len <= MATCH_LEN_MAX
; 437  : 			&& (options->mode == LZMA_MODE_FAST
; 438  : 				|| options->mode == LZMA_MODE_NORMAL);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	83 78 14 04	 cmp	 DWORD PTR [rax+20], 4
  00012	77 34		 ja	 SHORT $LN8@is_options
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00019	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  0001d	77 29		 ja	 SHORT $LN8@is_options
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00024	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR options$[rsp]
  0002c	03 41 18	 add	 eax, DWORD PTR [rcx+24]
  0002f	83 f8 04	 cmp	 eax, 4
  00032	77 14		 ja	 SHORT $LN8@is_options
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00039	83 78 1c 04	 cmp	 DWORD PTR [rax+28], 4
  0003d	77 09		 ja	 SHORT $LN8@is_options
  0003f	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv88[rsp], 1
  00046	eb 07		 jmp	 SHORT $LN9@is_options
$LN8@is_options:
  00048	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv88[rsp], 0
$LN9@is_options:
  0004f	0f b6 04 24	 movzx	 eax, BYTE PTR tv88[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 39		 je	 SHORT $LN3@is_options
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0005c	83 78 24 02	 cmp	 DWORD PTR [rax+36], 2
  00060	72 2e		 jb	 SHORT $LN3@is_options
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00067	81 78 24 11 01
	00 00		 cmp	 DWORD PTR [rax+36], 273	; 00000111H
  0006e	77 20		 ja	 SHORT $LN3@is_options
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00075	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  00079	74 0b		 je	 SHORT $LN4@is_options
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00080	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  00084	75 0a		 jne	 SHORT $LN3@is_options
$LN4@is_options:
  00086	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0008e	eb 08		 jmp	 SHORT $LN5@is_options
$LN3@is_options:
  00090	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@is_options:
  00098	8a 44 24 04	 mov	 al, BYTE PTR tv76[rsp]

; 439  : }

  0009c	48 83 c4 18	 add	 rsp, 24
  000a0	c3		 ret	 0
is_options_valid ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$literal_matched DD imagerel literal_matched
	DD	imagerel literal_matched+231
	DD	imagerel $unwind$literal_matched
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$literal_matched DD 011801H
	DD	02218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT literal_matched
_TEXT	SEGMENT
offset$ = 0
subcoder_index$33390 = 4
match_bit$33389 = 8
bit$33391 = 12
rc$ = 32
subcoder$ = 40
match_byte$ = 48
symbol$ = 56
literal_matched PROC					; COMDAT

; 26   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 27   : 	uint32_t offset = 0x100;

  00018	c7 04 24 00 01
	00 00		 mov	 DWORD PTR offset$[rsp], 256 ; 00000100H

; 28   : 	symbol += UINT32_C(1) << 8;

  0001f	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  00023	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00028	89 44 24 38	 mov	 DWORD PTR symbol$[rsp], eax
$LN3@literal_ma:

; 29   : 
; 30   : 	do {
; 31   : 		match_byte <<= 1;

  0002c	8b 44 24 30	 mov	 eax, DWORD PTR match_byte$[rsp]
  00030	d1 e0		 shl	 eax, 1
  00032	89 44 24 30	 mov	 DWORD PTR match_byte$[rsp], eax

; 32   :       {
; 33   : 		const uint32_t match_bit = match_byte & offset;

  00036	8b 0c 24	 mov	 ecx, DWORD PTR offset$[rsp]
  00039	8b 44 24 30	 mov	 eax, DWORD PTR match_byte$[rsp]
  0003d	23 c1		 and	 eax, ecx
  0003f	89 44 24 08	 mov	 DWORD PTR match_bit$33389[rsp], eax

; 34   : 		const uint32_t subcoder_index
; 35   : 				= offset + match_bit + (symbol >> 8);

  00043	8b 4c 24 08	 mov	 ecx, DWORD PTR match_bit$33389[rsp]
  00047	8b 04 24	 mov	 eax, DWORD PTR offset$[rsp]
  0004a	03 c1		 add	 eax, ecx
  0004c	8b 4c 24 38	 mov	 ecx, DWORD PTR symbol$[rsp]
  00050	c1 e9 08	 shr	 ecx, 8
  00053	03 c1		 add	 eax, ecx
  00055	89 44 24 04	 mov	 DWORD PTR subcoder_index$33390[rsp], eax

; 36   : 		const uint32_t bit = (symbol >> 7) & 1;

  00059	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  0005d	c1 e8 07	 shr	 eax, 7
  00060	83 e0 01	 and	 eax, 1
  00063	89 44 24 0c	 mov	 DWORD PTR bit$33391[rsp], eax

; 37   : 		rc_bit(rc, &subcoder[subcoder_index], bit);

  00067	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  0006c	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  00075	8b 44 24 0c	 mov	 eax, DWORD PTR bit$33391[rsp]
  00079	89 44 91 28	 mov	 DWORD PTR [rcx+rdx*4+40], eax
  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  00082	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00086	8b 4c 24 04	 mov	 ecx, DWORD PTR subcoder_index$33390[rsp]
  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR subcoder$[rsp]
  0008f	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  00098	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  000a5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a9	48 83 c1 01	 add	 rcx, 1
  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  000b2	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 38   : 
; 39   : 		symbol <<= 1;

  000b6	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  000ba	d1 e0		 shl	 eax, 1
  000bc	89 44 24 38	 mov	 DWORD PTR symbol$[rsp], eax

; 40   : 		offset &= ~(match_byte ^ symbol);

  000c0	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  000c4	8b 4c 24 30	 mov	 ecx, DWORD PTR match_byte$[rsp]
  000c8	33 c8		 xor	 ecx, eax
  000ca	f7 d1		 not	 ecx
  000cc	8b 04 24	 mov	 eax, DWORD PTR offset$[rsp]
  000cf	23 c1		 and	 eax, ecx
  000d1	89 04 24	 mov	 DWORD PTR offset$[rsp], eax

; 41   :       }
; 42   : 	} while (symbol < (UINT32_C(1) << 16));

  000d4	81 7c 24 38 00
	00 01 00	 cmp	 DWORD PTR symbol$[rsp], 65536 ; 00010000H
  000dc	0f 82 4a ff ff
	ff		 jb	 $LN3@literal_ma

; 43   : }

  000e2	48 83 c4 18	 add	 rsp, 24
  000e6	c3		 ret	 0
literal_matched ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$rc_encode DD imagerel rc_encode
	DD	imagerel rc_encode+768
	DD	imagerel $unwind$rc_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_encode DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_encode
_TEXT	SEGMENT
prob$33182 = 32
bound$33185 = 36
prob$33184 = 40
tv83 = 44
rc$ = 64
out$ = 72
out_pos$ = 80
out_size$ = 88
rc_encode PROC						; COMDAT

; 152  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN16@rc_encode:

; 153  : 	assert(rc->count <= RC_SYMBOLS_MAX);
; 154  : 
; 155  : 	while (rc->pos < rc->count) {

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0002a	0f 83 af 02 00
	00		 jae	 $LN15@rc_encode

; 156  : 		// Normalize
; 157  : 		if (rc->range < RC_TOP_VALUE) {

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00035	81 78 10 00 00
	00 01		 cmp	 DWORD PTR [rax+16], 16777216 ; 01000000H
  0003c	73 3a		 jae	 SHORT $LN14@rc_encode

; 158  : 			if (rc_shift_low(rc, out, out_pos, out_size))

  0003e	4c 8b 4c 24 58	 mov	 r9, QWORD PTR out_size$[rsp]
  00043	4c 8b 44 24 50	 mov	 r8, QWORD PTR out_pos$[rsp]
  00048	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  00052	e8 00 00 00 00	 call	 rc_shift_low
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	74 07		 je	 SHORT $LN13@rc_encode

; 159  : 				return true;

  0005e	b0 01		 mov	 al, 1
  00060	e9 96 02 00 00	 jmp	 $LN17@rc_encode
$LN13@rc_encode:

; 160  : 
; 161  : 			rc->range <<= RC_SHIFT_BITS;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0006a	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0006d	c1 e1 08	 shl	 ecx, 8
  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00075	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN14@rc_encode:

; 162  : 		}
; 163  : 
; 164  : 		// Encode a bit
; 165  : 		switch (rc->symbols[rc->pos]) {

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  0007d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00086	8b 44 88 28	 mov	 eax, DWORD PTR [rax+rcx*4+40]
  0008a	89 44 24 2c	 mov	 DWORD PTR tv83[rsp], eax
  0008e	83 7c 24 2c 00	 cmp	 DWORD PTR tv83[rsp], 0
  00093	74 31		 je	 SHORT $LN10@rc_encode
  00095	83 7c 24 2c 01	 cmp	 DWORD PTR tv83[rsp], 1
  0009a	0f 84 9d 00 00
	00		 je	 $LN9@rc_encode
  000a0	83 7c 24 2c 02	 cmp	 DWORD PTR tv83[rsp], 2
  000a5	0f 84 2a 01 00
	00		 je	 $LN8@rc_encode
  000ab	83 7c 24 2c 03	 cmp	 DWORD PTR tv83[rsp], 3
  000b0	0f 84 36 01 00
	00		 je	 $LN7@rc_encode
  000b6	83 7c 24 2c 04	 cmp	 DWORD PTR tv83[rsp], 4
  000bb	0f 84 5a 01 00
	00		 je	 $LN6@rc_encode
  000c1	e9 fe 01 00 00	 jmp	 $LN1@rc_encode
$LN10@rc_encode:

; 166  : 		case RC_BIT_0: {
; 167  : 			probability prob = *rc->probs[rc->pos];

  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  000cb	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  000d4	48 8b 84 c8 10
	01 00 00	 mov	 rax, QWORD PTR [rax+rcx*8+272]
  000dc	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000df	66 89 44 24 20	 mov	 WORD PTR prob$33182[rsp], ax

; 168  : 			rc->range = (rc->range >> RC_BIT_MODEL_TOTAL_BITS)
; 169  : 					* prob;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  000e9	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000ec	c1 e9 0b	 shr	 ecx, 11
  000ef	0f b7 44 24 20	 movzx	 eax, WORD PTR prob$33182[rsp]
  000f4	0f af c8	 imul	 ecx, eax
  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  000fc	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 170  : 			prob += (RC_BIT_MODEL_TOTAL - prob) >> RC_MOVE_BITS;

  000ff	0f b7 44 24 20	 movzx	 eax, WORD PTR prob$33182[rsp]
  00104	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00109	2b c8		 sub	 ecx, eax
  0010b	c1 e9 05	 shr	 ecx, 5
  0010e	0f b7 44 24 20	 movzx	 eax, WORD PTR prob$33182[rsp]
  00113	03 c1		 add	 eax, ecx
  00115	66 89 44 24 20	 mov	 WORD PTR prob$33182[rsp], ax

; 171  : 			*rc->probs[rc->pos] = prob;

  0011a	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0011f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00123	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  00128	48 8b 8c c1 10
	01 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+272]
  00130	0f b7 44 24 20	 movzx	 eax, WORD PTR prob$33182[rsp]
  00135	66 89 01	 mov	 WORD PTR [rcx], ax

; 172  : 			break;

  00138	e9 87 01 00 00	 jmp	 $LN11@rc_encode
$LN9@rc_encode:

; 173  : 		}
; 174  : 
; 175  : 		case RC_BIT_1: {
; 176  : 			probability prob = *rc->probs[rc->pos];

  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  00142	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0014b	48 8b 84 c8 10
	01 00 00	 mov	 rax, QWORD PTR [rax+rcx*8+272]
  00153	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00156	66 89 44 24 28	 mov	 WORD PTR prob$33184[rsp], ax

; 177  : 			const uint32_t bound = prob * (rc->range
; 178  : 					>> RC_BIT_MODEL_TOTAL_BITS);

  0015b	0f b7 54 24 28	 movzx	 edx, WORD PTR prob$33184[rsp]
  00160	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00165	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00168	c1 e9 0b	 shr	 ecx, 11
  0016b	8b c2		 mov	 eax, edx
  0016d	0f af c1	 imul	 eax, ecx
  00170	89 44 24 24	 mov	 DWORD PTR bound$33185[rsp], eax

; 179  : 			rc->low += bound;

  00174	8b 4c 24 24	 mov	 ecx, DWORD PTR bound$33185[rsp]
  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0017d	48 03 08	 add	 rcx, QWORD PTR [rax]
  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00185	48 89 08	 mov	 QWORD PTR [rax], rcx

; 180  : 			rc->range -= bound;

  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  0018d	8b 44 24 24	 mov	 eax, DWORD PTR bound$33185[rsp]
  00191	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00194	2b c8		 sub	 ecx, eax
  00196	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0019b	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 181  : 			prob -= prob >> RC_MOVE_BITS;

  0019e	0f b7 4c 24 28	 movzx	 ecx, WORD PTR prob$33184[rsp]
  001a3	c1 f9 05	 sar	 ecx, 5
  001a6	0f b7 44 24 28	 movzx	 eax, WORD PTR prob$33184[rsp]
  001ab	2b c1		 sub	 eax, ecx
  001ad	66 89 44 24 28	 mov	 WORD PTR prob$33184[rsp], ax

; 182  : 			*rc->probs[rc->pos] = prob;

  001b2	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  001b7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  001c0	48 8b 8c c1 10
	01 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+272]
  001c8	0f b7 44 24 28	 movzx	 eax, WORD PTR prob$33184[rsp]
  001cd	66 89 01	 mov	 WORD PTR [rcx], ax

; 183  : 			break;

  001d0	e9 ef 00 00 00	 jmp	 $LN11@rc_encode
$LN8@rc_encode:

; 184  : 		}
; 185  : 
; 186  : 		case RC_DIRECT_0:
; 187  : 			rc->range >>= 1;

  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  001da	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  001dd	d1 e9		 shr	 ecx, 1
  001df	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  001e4	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 188  : 			break;

  001e7	e9 d8 00 00 00	 jmp	 $LN11@rc_encode
$LN7@rc_encode:

; 189  : 
; 190  : 		case RC_DIRECT_1:
; 191  : 			rc->range >>= 1;

  001ec	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  001f1	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  001f4	d1 e9		 shr	 ecx, 1
  001f6	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  001fb	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 192  : 			rc->low += rc->range;

  001fe	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00203	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00206	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0020b	48 03 08	 add	 rcx, QWORD PTR [rax]
  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00213	48 89 08	 mov	 QWORD PTR [rax], rcx

; 193  : 			break;

  00216	e9 a9 00 00 00	 jmp	 $LN11@rc_encode
$LN6@rc_encode:

; 194  : 
; 195  : 		case RC_FLUSH:
; 196  : 			// Prevent further normalizations.
; 197  : 			rc->range = UINT32_MAX;

  0021b	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00220	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [rax+16], -1	; ffffffffH
$LN5@rc_encode:

; 198  : 
; 199  : 			// Flush the last five bytes (see rc_flush()).
; 200  : 			do {
; 201  : 				if (rc_shift_low(rc, out, out_pos, out_size))

  00227	4c 8b 4c 24 58	 mov	 r9, QWORD PTR out_size$[rsp]
  0022c	4c 8b 44 24 50	 mov	 r8, QWORD PTR out_pos$[rsp]
  00231	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  00236	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  0023b	e8 00 00 00 00	 call	 rc_shift_low
  00240	0f b6 c0	 movzx	 eax, al
  00243	85 c0		 test	 eax, eax
  00245	74 07		 je	 SHORT $LN2@rc_encode

; 202  : 					return true;

  00247	b0 01		 mov	 al, 1
  00249	e9 ad 00 00 00	 jmp	 $LN17@rc_encode
$LN2@rc_encode:

; 203  : 			} while (++rc->pos < rc->count);

  0024e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  00253	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00257	48 83 c1 01	 add	 rcx, 1
  0025b	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00260	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00264	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  00269	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0026e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00272	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00276	72 af		 jb	 SHORT $LN5@rc_encode

; 204  : 
; 205  : 			// Reset the range encoder so we are ready to continue
; 206  : 			// encoding if we weren't finishing the stream.
; 207  : 			rc_reset(rc);

  00278	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  0027d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00284	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00289	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1
  00291	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  00296	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [rax+16], -1	; ffffffffH
  0029d	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002a2	c6 40 14 00	 mov	 BYTE PTR [rax+20], 0
  002a6	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002ab	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  002b3	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002b8	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 208  : 			return false;

  002c0	32 c0		 xor	 al, al
  002c2	eb 37		 jmp	 SHORT $LN17@rc_encode
$LN1@rc_encode:
$LN11@rc_encode:

; 209  : 
; 210  : 		default:
; 211  : 			assert(0);
; 212  : 			break;
; 213  : 		}
; 214  : 
; 215  : 		++rc->pos;

  002c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  002c9	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002cd	48 83 c1 01	 add	 rcx, 1
  002d1	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002d6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 216  : 	}

  002da	e9 39 fd ff ff	 jmp	 $LN16@rc_encode
$LN15@rc_encode:

; 217  : 
; 218  : 	rc->count = 0;

  002df	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002e4	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 219  : 	rc->pos = 0;

  002ec	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]
  002f1	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 220  : 
; 221  : 	return false;

  002f9	32 c0		 xor	 al, al
$LN17@rc_encode:

; 222  : }

  002fb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002ff	c3		 ret	 0
rc_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rc_bittree_reverse DD imagerel rc_bittree_reverse
	DD	imagerel rc_bittree_reverse+170
	DD	imagerel $unwind$rc_bittree_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_bittree_reverse DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_bittree_reverse
_TEXT	SEGMENT
model_index$ = 0
bit$33121 = 4
rc$ = 32
probs$ = 40
bit_count$ = 48
symbol$ = 56
rc_bittree_reverse PROC					; COMDAT

; 92   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 93   : 	uint32_t model_index = 1;

  00018	c7 04 24 01 00
	00 00		 mov	 DWORD PTR model_index$[rsp], 1
$LN3@rc_bittree@3:

; 94   : 
; 95   : 	do {
; 96   : 		const uint32_t bit = symbol & 1;

  0001f	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  00023	83 e0 01	 and	 eax, 1
  00026	89 44 24 04	 mov	 DWORD PTR bit$33121[rsp], eax

; 97   : 		symbol >>= 1;

  0002a	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  0002e	d1 e8		 shr	 eax, 1
  00030	89 44 24 38	 mov	 DWORD PTR symbol$[rsp], eax

; 98   : 		rc_bit(rc, &probs[model_index], bit);

  00034	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  00039	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  00042	8b 44 24 04	 mov	 eax, DWORD PTR bit$33121[rsp]
  00046	89 44 91 28	 mov	 DWORD PTR [rcx+rdx*4+40], eax
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  0004f	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00053	8b 0c 24	 mov	 ecx, DWORD PTR model_index$[rsp]
  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR probs$[rsp]
  0005b	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  00064	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  00071	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00075	48 83 c1 01	 add	 rcx, 1
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  0007e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 99   : 		model_index = (model_index << 1) + bit;

  00082	8b 4c 24 04	 mov	 ecx, DWORD PTR bit$33121[rsp]
  00086	8b 04 24	 mov	 eax, DWORD PTR model_index$[rsp]
  00089	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  0008c	89 04 24	 mov	 DWORD PTR model_index$[rsp], eax

; 100  : 	} while (--bit_count != 0);

  0008f	8b 44 24 30	 mov	 eax, DWORD PTR bit_count$[rsp]
  00093	83 e8 01	 sub	 eax, 1
  00096	89 44 24 30	 mov	 DWORD PTR bit_count$[rsp], eax
  0009a	83 7c 24 30 00	 cmp	 DWORD PTR bit_count$[rsp], 0
  0009f	0f 85 7a ff ff
	ff		 jne	 $LN3@rc_bittree@3

; 101  : }

  000a5	48 83 c4 18	 add	 rsp, 24
  000a9	c3		 ret	 0
rc_bittree_reverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rc_bittree DD imagerel rc_bittree
	DD	imagerel rc_bittree+169
	DD	imagerel $unwind$rc_bittree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_bittree DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_bittree
_TEXT	SEGMENT
model_index$ = 0
bit$33106 = 4
rc$ = 32
probs$ = 40
bit_count$ = 48
symbol$ = 56
rc_bittree PROC						; COMDAT

; 78   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 79   : 	uint32_t model_index = 1;

  00018	c7 04 24 01 00
	00 00		 mov	 DWORD PTR model_index$[rsp], 1
$LN3@rc_bittree@4:

; 80   : 
; 81   : 	do {
; 82   : 		const uint32_t bit = (symbol >> --bit_count) & 1;

  0001f	8b 44 24 30	 mov	 eax, DWORD PTR bit_count$[rsp]
  00023	83 e8 01	 sub	 eax, 1
  00026	89 44 24 30	 mov	 DWORD PTR bit_count$[rsp], eax
  0002a	8b 44 24 30	 mov	 eax, DWORD PTR bit_count$[rsp]
  0002e	0f b6 c8	 movzx	 ecx, al
  00031	8b 44 24 38	 mov	 eax, DWORD PTR symbol$[rsp]
  00035	d3 e8		 shr	 eax, cl
  00037	83 e0 01	 and	 eax, 1
  0003a	89 44 24 04	 mov	 DWORD PTR bit$33106[rsp], eax

; 83   : 		rc_bit(rc, &probs[model_index], bit);

  0003e	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  00043	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  0004c	8b 44 24 04	 mov	 eax, DWORD PTR bit$33106[rsp]
  00050	89 44 91 28	 mov	 DWORD PTR [rcx+rdx*4+40], eax
  00054	48 8b 54 24 20	 mov	 rdx, QWORD PTR rc$[rsp]
  00059	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0005d	8b 0c 24	 mov	 ecx, DWORD PTR model_index$[rsp]
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR probs$[rsp]
  00065	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  0006e	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rc$[rsp]
  0007b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0007f	48 83 c1 01	 add	 rcx, 1
  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR rc$[rsp]
  00088	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 84   : 		model_index = (model_index << 1) + bit;

  0008c	8b 4c 24 04	 mov	 ecx, DWORD PTR bit$33106[rsp]
  00090	8b 04 24	 mov	 eax, DWORD PTR model_index$[rsp]
  00093	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  00096	89 04 24	 mov	 DWORD PTR model_index$[rsp], eax

; 85   : 	} while (bit_count != 0);

  00099	83 7c 24 30 00	 cmp	 DWORD PTR bit_count$[rsp], 0
  0009e	0f 85 7b ff ff
	ff		 jne	 $LN3@rc_bittree@4

; 86   : }

  000a4	48 83 c4 18	 add	 rsp, 24
  000a8	c3		 ret	 0
rc_bittree ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$rc_bittree_price DD imagerel rc_bittree_price
	DD	imagerel rc_bittree_price+135
	DD	imagerel $unwind$rc_bittree_price
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc_bittree_price DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rc_bittree_price
_TEXT	SEGMENT
price$ = 0
bit$33045 = 4
probs$ = 32
bit_levels$ = 40
symbol$ = 48
rc_bittree_price PROC					; COMDAT

; 54   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 55   : 	uint32_t price = 0;

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR price$[rsp], 0

; 56   : 	symbol += UINT32_C(1) << bit_levels;

  00019	8b 4c 24 28	 mov	 ecx, DWORD PTR bit_levels$[rsp]
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	d3 e0		 shl	 eax, cl
  00024	8b c8		 mov	 ecx, eax
  00026	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  0002a	03 c1		 add	 eax, ecx
  0002c	89 44 24 30	 mov	 DWORD PTR symbol$[rsp], eax
$LN3@rc_bittree@5:

; 57   : 
; 58   : 	do {
; 59   : 		const uint32_t bit = symbol & 1;

  00030	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  00034	83 e0 01	 and	 eax, 1
  00037	89 44 24 04	 mov	 DWORD PTR bit$33045[rsp], eax

; 60   : 		symbol >>= 1;

  0003b	8b 44 24 30	 mov	 eax, DWORD PTR symbol$[rsp]
  0003f	d1 e8		 shr	 eax, 1
  00041	89 44 24 30	 mov	 DWORD PTR symbol$[rsp], eax

; 61   : 		price += rc_bit_price(probs[symbol], bit);

  00045	33 d2		 xor	 edx, edx
  00047	2b 54 24 04	 sub	 edx, DWORD PTR bit$33045[rsp]
  0004b	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00051	8b 4c 24 30	 mov	 ecx, DWORD PTR symbol$[rsp]
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR probs$[rsp]
  0005a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0005e	33 c2		 xor	 eax, edx
  00060	c1 e8 04	 shr	 eax, 4
  00063	8b c8		 mov	 ecx, eax
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  0006c	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00070	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]
  00073	03 c1		 add	 eax, ecx
  00075	89 04 24	 mov	 DWORD PTR price$[rsp], eax

; 62   : 	} while (symbol != 1);

  00078	83 7c 24 30 01	 cmp	 DWORD PTR symbol$[rsp], 1
  0007d	75 b1		 jne	 SHORT $LN3@rc_bittree@5

; 63   : 
; 64   : 	return price;

  0007f	8b 04 24	 mov	 eax, DWORD PTR price$[rsp]

; 65   : }

  00082	48 83 c4 18	 add	 rsp, 24
  00086	c3		 ret	 0
rc_bittree_price ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$lzma_lzma_props_encode DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$lzma_lzma_props_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_props_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT lzma_lzma_props_encode
_TEXT	SEGMENT
opt$ = 32
$T82471 = 40
options$ = 64
out$ = 72
lzma_lzma_props_encode PROC				; COMDAT

; 680  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 681  : 	const lzma_options_lzma *const opt = options;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR opt$[rsp], rax

; 682  : 
; 683  : 	if (lzma_lzma_lclppb_encode(opt, out))

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR opt$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_lzma_lclppb_encode
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN1@lzma_lzma_@7

; 684  : 		return LZMA_PROG_ERROR;

  0002e	b8 0b 00 00 00	 mov	 eax, 11
  00033	eb 19		 jmp	 SHORT $LN2@lzma_lzma_@7
$LN1@lzma_lzma_@7:

; 685  : 
; 686  : 	unaligned_write32le(out + 1, opt->dict_size);

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$[rsp]
  0003a	8b 00		 mov	 eax, DWORD PTR [rax]
  0003c	89 44 24 28	 mov	 DWORD PTR $T82471[rsp], eax
  00040	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  00045	8b 44 24 28	 mov	 eax, DWORD PTR $T82471[rsp]
  00049	89 41 01	 mov	 DWORD PTR [rcx+1], eax

; 687  : 
; 688  : 	return LZMA_OK;

  0004c	33 c0		 xor	 eax, eax
$LN2@lzma_lzma_@7:

; 689  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
lzma_lzma_props_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$encode_init DD imagerel encode_init
	DD	imagerel encode_init+249
	DD	imagerel $unwind$encode_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_init DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT encode_init
_TEXT	SEGMENT
coder$ = 64
mf$ = 72
encode_init PROC					; COMDAT

; 274  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 275  : 	assert(mf_position(mf) == 0);
; 276  : 
; 277  : 	if (mf->read_pos == mf->read_limit) {

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR mf$[rsp]
  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  00018	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0001b	39 41 18	 cmp	 DWORD PTR [rcx+24], eax
  0001e	75 17		 jne	 SHORT $LN3@encode_ini

; 278  : 		if (mf->action == LZMA_RUN)

  00020	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  00025	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00029	75 07		 jne	 SHORT $LN2@encode_ini

; 279  : 			return false; // We cannot do anything.

  0002b	32 c0		 xor	 al, al
  0002d	e9 c2 00 00 00	 jmp	 $LN4@encode_ini
$LN2@encode_ini:

; 280  : 
; 281  : 		// We are finishing (we cannot get here when flushing).
; 282  : 		assert(mf->write_pos == mf->read_pos);
; 283  : 		assert(mf->action == LZMA_FINISH);
; 284  : 	} else {

  00032	e9 af 00 00 00	 jmp	 $LN1@encode_ini
$LN3@encode_ini:

; 285  : 		// Do the actual initialization. The first LZMA symbol must
; 286  : 		// always be a literal.
; 287  : 		mf_skip(mf, 1);

  00037	33 c0		 xor	 eax, eax
  00039	83 f8 01	 cmp	 eax, 1
  0003c	74 26		 je	 SHORT $LN6@encode_ini
  0003e	ba 01 00 00 00	 mov	 edx, 1
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR mf$[rsp]
  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  0004d	ff 50 38	 call	 QWORD PTR [rax+56]
  00050	4c 8b 5c 24 48	 mov	 r11, QWORD PTR mf$[rsp]
  00055	41 8b 4b 1c	 mov	 ecx, DWORD PTR [r11+28]
  00059	83 c1 01	 add	 ecx, 1
  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  00061	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN6@encode_ini:

; 288  : 		mf->read_ahead = 0;

  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  00069	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 289  : 		rc_bit(&coder->rc, &coder->is_match[0][0], 0);

  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00075	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0007e	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00086	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  0008b	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00094	48 81 c1 9c 6b
	00 00		 add	 rcx, 27548		; 00006b9cH
  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000a0	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  000ad	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000b1	48 83 c1 01	 add	 rcx, 1
  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000ba	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 290  : 		rc_bittree(&coder->rc, coder->literal[0], 8, mf->buffer[0]);

  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  000c3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c6	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  000ca	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  000cf	48 81 c2 9c 0b
	00 00		 add	 rdx, 2972		; 00000b9cH
  000d6	41 b8 08 00 00
	00		 mov	 r8d, 8
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  000e1	e8 00 00 00 00	 call	 rc_bittree
$LN1@encode_ini:

; 291  : 	}
; 292  : 
; 293  : 	// Initialization is done (except if empty file).
; 294  : 	coder->is_initialized = true;

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000eb	c6 80 8d 0b 00
	00 01		 mov	 BYTE PTR [rax+2957], 1

; 295  : 
; 296  : 	return true;

  000f2	b0 01		 mov	 al, 1
$LN4@encode_ini:

; 297  : }

  000f4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f8	c3		 ret	 0
encode_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\price.h
pdata	SEGMENT
$pdata$length_update_prices DD imagerel length_update_prices
	DD	imagerel length_update_prices+475
	DD	imagerel $unwind$length_update_prices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$length_update_prices DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT length_update_prices
_TEXT	SEGMENT
table_size$ = 32
b0$33414 = 36
i$33417 = 40
a1$33413 = 44
prices$33416 = 48
b1$33415 = 56
a0$33412 = 60
lc$ = 112
pos_state$ = 120
length_update_prices PROC				; COMDAT

; 80   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 81   : 	const uint32_t table_size = lc->table_size;

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00012	8b 80 04 48 00
	00		 mov	 eax, DWORD PTR [rax+18436]
  00018	89 44 24 20	 mov	 DWORD PTR table_size$[rsp], eax

; 82   : 	lc->counters[pos_state] = table_size;

  0001c	8b 54 24 78	 mov	 edx, DWORD PTR pos_state$[rsp]
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lc$[rsp]
  00025	8b 44 24 20	 mov	 eax, DWORD PTR table_size$[rsp]
  00029	89 84 91 08 48
	00 00		 mov	 DWORD PTR [rcx+rdx*4+18440], eax

; 83   : 
; 84   :   {
; 85   : 	const uint32_t a0 = rc_bit_0_price(lc->choice);

  00030	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00035	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00038	c1 f8 04	 sar	 eax, 4
  0003b	48 63 c8	 movsxd	 rcx, eax
  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00045	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00049	89 44 24 3c	 mov	 DWORD PTR a0$33412[rsp], eax

; 86   : 	const uint32_t a1 = rc_bit_1_price(lc->choice);

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00052	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00055	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  0005a	c1 e8 04	 shr	 eax, 4
  0005d	8b c8		 mov	 ecx, eax
  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00066	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006a	89 44 24 2c	 mov	 DWORD PTR a1$33413[rsp], eax

; 87   : 	const uint32_t b0 = a1 + rc_bit_0_price(lc->choice2);

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00073	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00077	c1 f8 04	 sar	 eax, 4
  0007a	48 63 c8	 movsxd	 rcx, eax
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  00084	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00088	8b 44 24 2c	 mov	 eax, DWORD PTR a1$33413[rsp]
  0008c	03 c1		 add	 eax, ecx
  0008e	89 44 24 24	 mov	 DWORD PTR b0$33414[rsp], eax

; 88   : 	const uint32_t b1 = a1 + rc_bit_1_price(lc->choice2);

  00092	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00097	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  0009b	35 ff 07 00 00	 xor	 eax, 2047		; 000007ffH
  000a0	c1 e8 04	 shr	 eax, 4
  000a3	8b c8		 mov	 ecx, eax
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_rc_prices
  000ac	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  000b0	8b 44 24 2c	 mov	 eax, DWORD PTR a1$33413[rsp]
  000b4	03 c1		 add	 eax, ecx
  000b6	89 44 24 38	 mov	 DWORD PTR b1$33415[rsp], eax

; 89   : 	uint32_t *const prices = lc->prices[pos_state];

  000ba	8b 4c 24 78	 mov	 ecx, DWORD PTR pos_state$[rsp]
  000be	48 69 c9 40 04
	00 00		 imul	 rcx, 1088		; 00000440H
  000c5	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  000ca	48 8d 84 08 04
	04 00 00	 lea	 rax, QWORD PTR [rax+rcx+1028]
  000d2	48 89 44 24 30	 mov	 QWORD PTR prices$33416[rsp], rax

; 90   : 
; 91   : 	uint32_t i;
; 92   : 	for (i = 0; i < table_size && i < LEN_LOW_SYMBOLS; ++i)

  000d7	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$33417[rsp], 0
  000df	eb 0b		 jmp	 SHORT $LN9@length_upd
$LN8@length_upd:
  000e1	8b 44 24 28	 mov	 eax, DWORD PTR i$33417[rsp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 44 24 28	 mov	 DWORD PTR i$33417[rsp], eax
$LN9@length_upd:
  000ec	8b 44 24 20	 mov	 eax, DWORD PTR table_size$[rsp]
  000f0	39 44 24 28	 cmp	 DWORD PTR i$33417[rsp], eax
  000f4	73 3c		 jae	 SHORT $LN7@length_upd
  000f6	83 7c 24 28 08	 cmp	 DWORD PTR i$33417[rsp], 8
  000fb	73 35		 jae	 SHORT $LN7@length_upd

; 93   : 		prices[i] = a0 + rc_bittree_price(lc->low[pos_state],
; 94   : 				LEN_LOW_BITS, i);

  000fd	8b 4c 24 78	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00101	48 6b c9 10	 imul	 rcx, 16
  00105	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  0010a	48 8d 4c 08 04	 lea	 rcx, QWORD PTR [rax+rcx+4]
  0010f	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$33417[rsp]
  00114	ba 03 00 00 00	 mov	 edx, 3
  00119	e8 00 00 00 00	 call	 rc_bittree_price
  0011e	8b 54 24 3c	 mov	 edx, DWORD PTR a0$33412[rsp]
  00122	03 d0		 add	 edx, eax
  00124	8b 4c 24 28	 mov	 ecx, DWORD PTR i$33417[rsp]
  00128	48 8b 44 24 30	 mov	 rax, QWORD PTR prices$33416[rsp]
  0012d	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
  00130	eb af		 jmp	 SHORT $LN8@length_upd
$LN7@length_upd:

; 95   : 
; 96   : 	for (; i < table_size && i < LEN_LOW_SYMBOLS + LEN_MID_SYMBOLS; ++i)

  00132	eb 0b		 jmp	 SHORT $LN6@length_upd
$LN5@length_upd:
  00134	8b 44 24 28	 mov	 eax, DWORD PTR i$33417[rsp]
  00138	83 c0 01	 add	 eax, 1
  0013b	89 44 24 28	 mov	 DWORD PTR i$33417[rsp], eax
$LN6@length_upd:
  0013f	8b 44 24 20	 mov	 eax, DWORD PTR table_size$[rsp]
  00143	39 44 24 28	 cmp	 DWORD PTR i$33417[rsp], eax
  00147	73 43		 jae	 SHORT $LN4@length_upd
  00149	83 7c 24 28 10	 cmp	 DWORD PTR i$33417[rsp], 16
  0014e	73 3c		 jae	 SHORT $LN4@length_upd

; 97   : 		prices[i] = b0 + rc_bittree_price(lc->mid[pos_state],
; 98   : 				LEN_MID_BITS, i - LEN_LOW_SYMBOLS);

  00150	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$33417[rsp]
  00155	41 83 e8 08	 sub	 r8d, 8
  00159	8b 4c 24 78	 mov	 ecx, DWORD PTR pos_state$[rsp]
  0015d	48 6b c9 10	 imul	 rcx, 16
  00161	48 8b 44 24 70	 mov	 rax, QWORD PTR lc$[rsp]
  00166	48 8d 8c 08 04
	01 00 00	 lea	 rcx, QWORD PTR [rax+rcx+260]
  0016e	ba 03 00 00 00	 mov	 edx, 3
  00173	e8 00 00 00 00	 call	 rc_bittree_price
  00178	8b 54 24 24	 mov	 edx, DWORD PTR b0$33414[rsp]
  0017c	03 d0		 add	 edx, eax
  0017e	8b 4c 24 28	 mov	 ecx, DWORD PTR i$33417[rsp]
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR prices$33416[rsp]
  00187	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
  0018a	eb a8		 jmp	 SHORT $LN5@length_upd
$LN4@length_upd:

; 99   : 
; 100  : 	for (; i < table_size; ++i)

  0018c	eb 0b		 jmp	 SHORT $LN3@length_upd
$LN2@length_upd:
  0018e	8b 44 24 28	 mov	 eax, DWORD PTR i$33417[rsp]
  00192	83 c0 01	 add	 eax, 1
  00195	89 44 24 28	 mov	 DWORD PTR i$33417[rsp], eax
$LN3@length_upd:
  00199	8b 44 24 20	 mov	 eax, DWORD PTR table_size$[rsp]
  0019d	39 44 24 28	 cmp	 DWORD PTR i$33417[rsp], eax
  001a1	73 33		 jae	 SHORT $LN1@length_upd

; 101  : 		prices[i] = b1 + rc_bittree_price(lc->high, LEN_HIGH_BITS,
; 102  : 				i - LEN_LOW_SYMBOLS - LEN_MID_SYMBOLS);

  001a3	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$33417[rsp]
  001a8	41 83 e8 10	 sub	 r8d, 16
  001ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lc$[rsp]
  001b1	48 81 c1 04 02
	00 00		 add	 rcx, 516		; 00000204H
  001b8	ba 08 00 00 00	 mov	 edx, 8
  001bd	e8 00 00 00 00	 call	 rc_bittree_price
  001c2	8b 54 24 38	 mov	 edx, DWORD PTR b1$33415[rsp]
  001c6	03 d0		 add	 edx, eax
  001c8	8b 4c 24 28	 mov	 ecx, DWORD PTR i$33417[rsp]
  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR prices$33416[rsp]
  001d1	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
  001d4	eb b8		 jmp	 SHORT $LN2@length_upd
$LN1@length_upd:

; 103  :   }
; 104  : 
; 105  : 	return;
; 106  : }

  001d6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001da	c3		 ret	 0
length_update_prices ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$literal DD imagerel literal
	DD	imagerel literal+407
	DD	imagerel $unwind$literal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$literal DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT literal
_TEXT	SEGMENT
subcoder$ = 32
cur_byte$ = 40
match_byte$33404 = 41
tv152 = 68
tv151 = 72
coder$ = 96
mf$ = 104
position$ = 112
literal	PROC						; COMDAT

; 48   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 49   : 	// Locate the literal byte to be encoded and the subcoder.
; 50   : 	const uint8_t cur_byte = mf->buffer[
; 51   : 			mf->read_pos - mf->read_ahead];

  00013	48 8b 54 24 68	 mov	 rdx, QWORD PTR mf$[rsp]
  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR mf$[rsp]
  0001d	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00020	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00023	2b c1		 sub	 eax, ecx
  00025	8b c8		 mov	 ecx, eax
  00027	48 8b 44 24 68	 mov	 rax, QWORD PTR mf$[rsp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00033	88 44 24 28	 mov	 BYTE PTR cur_byte$[rsp], al

; 52   : 	probability *subcoder = literal_subcoder(coder->literal,
; 53   : 			coder->literal_context_bits, coder->literal_pos_mask,
; 54   : 			position, mf->buffer[mf->read_pos - mf->read_ahead - 1]);

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0003c	8b 80 98 0b 00
	00		 mov	 eax, DWORD PTR [rax+2968]
  00042	44 8b 44 24 70	 mov	 r8d, DWORD PTR position$[rsp]
  00047	44 23 c0	 and	 r8d, eax
  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0004f	8b 80 94 0b 00
	00		 mov	 eax, DWORD PTR [rax+2964]
  00055	0f b6 c8	 movzx	 ecx, al
  00058	41 d3 e0	 shl	 r8d, cl
  0005b	48 8b 54 24 68	 mov	 rdx, QWORD PTR mf$[rsp]
  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR mf$[rsp]
  00065	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00068	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  0006b	2b c1		 sub	 eax, ecx
  0006d	83 e8 01	 sub	 eax, 1
  00070	8b c8		 mov	 ecx, eax
  00072	48 8b 44 24 68	 mov	 rax, QWORD PTR mf$[rsp]
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00083	b8 08 00 00 00	 mov	 eax, 8
  00088	2b 81 94 0b 00
	00		 sub	 eax, DWORD PTR [rcx+2964]
  0008e	0f b6 c8	 movzx	 ecx, al
  00091	8b c2		 mov	 eax, edx
  00093	d3 f8		 sar	 eax, cl
  00095	8b c8		 mov	 ecx, eax
  00097	41 8b c0	 mov	 eax, r8d
  0009a	03 c1		 add	 eax, ecx
  0009c	8b c8		 mov	 ecx, eax
  0009e	48 69 c9 00 06
	00 00		 imul	 rcx, 1536		; 00000600H
  000a5	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000aa	48 8d 84 08 9c
	0b 00 00	 lea	 rax, QWORD PTR [rax+rcx+2972]
  000b2	48 89 44 24 20	 mov	 QWORD PTR subcoder$[rsp], rax

; 55   : 
; 56   : 	if (is_literal_state(coder->state)) {

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000bc	83 b8 e0 02 00
	00 07		 cmp	 DWORD PTR [rax+736], 7
  000c3	7d 1d		 jge	 SHORT $LN2@literal

; 57   : 		// Previous LZMA-symbol was a literal. Encode a normal
; 58   : 		// literal without a match byte.
; 59   : 		rc_bittree(&coder->rc, subcoder, 8, cur_byte);

  000c5	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR cur_byte$[rsp]
  000cb	41 b8 08 00 00
	00		 mov	 r8d, 8
  000d1	48 8b 54 24 20	 mov	 rdx, QWORD PTR subcoder$[rsp]
  000d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  000db	e8 00 00 00 00	 call	 rc_bittree

; 60   : 	} else {

  000e0	eb 4d		 jmp	 SHORT $LN1@literal
$LN2@literal:

; 61   : 		// Previous LZMA-symbol was a match. Use the last byte of
; 62   : 		// the match as a "match byte". That is, compare the bits
; 63   : 		// of the current literal and the match byte.
; 64   : 		const uint8_t match_byte = mf->buffer[
; 65   : 				mf->read_pos - coder->reps[0] - 1
; 66   : 				- mf->read_ahead];

  000e2	48 8b 54 24 68	 mov	 rdx, QWORD PTR mf$[rsp]
  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000ec	8b 88 e4 02 00
	00		 mov	 ecx, DWORD PTR [rax+740]
  000f2	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  000f5	2b c1		 sub	 eax, ecx
  000f7	83 e8 01	 sub	 eax, 1
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mf$[rsp]
  000ff	2b 41 1c	 sub	 eax, DWORD PTR [rcx+28]
  00102	8b c8		 mov	 ecx, eax
  00104	48 8b 44 24 68	 mov	 rax, QWORD PTR mf$[rsp]
  00109	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00110	88 44 24 29	 mov	 BYTE PTR match_byte$33404[rsp], al

; 67   : 		literal_matched(&coder->rc, subcoder, match_byte, cur_byte);

  00114	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR cur_byte$[rsp]
  0011a	44 0f b6 44 24
	29		 movzx	 r8d, BYTE PTR match_byte$33404[rsp]
  00120	48 8b 54 24 20	 mov	 rdx, QWORD PTR subcoder$[rsp]
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  0012a	e8 00 00 00 00	 call	 literal_matched
$LN1@literal:

; 68   : 	}
; 69   : 
; 70   : 	update_literal(coder->state);

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00134	83 b8 e0 02 00
	00 03		 cmp	 DWORD PTR [rax+736], 3
  0013b	7f 0a		 jg	 SHORT $LN7@literal
  0013d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
  00145	eb 3c		 jmp	 SHORT $LN8@literal
$LN7@literal:
  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0014c	83 b8 e0 02 00
	00 09		 cmp	 DWORD PTR [rax+736], 9
  00153	7f 14		 jg	 SHORT $LN5@literal
  00155	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0015a	8b 80 e0 02 00
	00		 mov	 eax, DWORD PTR [rax+736]
  00160	83 e8 03	 sub	 eax, 3
  00163	89 44 24 48	 mov	 DWORD PTR tv151[rsp], eax
  00167	eb 12		 jmp	 SHORT $LN6@literal
$LN5@literal:
  00169	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0016e	8b 80 e0 02 00
	00		 mov	 eax, DWORD PTR [rax+736]
  00174	83 e8 06	 sub	 eax, 6
  00177	89 44 24 48	 mov	 DWORD PTR tv151[rsp], eax
$LN6@literal:
  0017b	8b 44 24 48	 mov	 eax, DWORD PTR tv151[rsp]
  0017f	89 44 24 44	 mov	 DWORD PTR tv152[rsp], eax
$LN8@literal:
  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00188	8b 44 24 44	 mov	 eax, DWORD PTR tv152[rsp]
  0018c	89 81 e0 02 00
	00		 mov	 DWORD PTR [rcx+736], eax

; 71   : }

  00192	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00196	c3		 ret	 0
literal	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma_encoder_memusage DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$lzma_lzma_encoder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_encoder_memusage DD 010901H
	DD	0e209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma_encoder_memusage
_TEXT	SEGMENT
lz_options$33684 = 32
lz_memusage$33685 = 96
options$ = 128
lzma_lzma_encoder_memusage PROC				; COMDAT

; 646  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 647  : 	if (!is_options_valid(options))

  00009	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  00011	e8 00 00 00 00	 call	 is_options_valid
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 09		 jne	 SHORT $LN2@lzma_lzma_@8

; 648  : 		return UINT64_MAX;

  0001d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00024	eb 3d		 jmp	 SHORT $LN3@lzma_lzma_@8
$LN2@lzma_lzma_@8:

; 649  : 
; 650  :   {
; 651  : 	lzma_lz_options lz_options;
; 652  : 	set_lz_options(&lz_options, options);

  00026	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR options$[rsp]
  0002e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lz_options$33684[rsp]
  00033	e8 00 00 00 00	 call	 set_lz_options

; 653  : 
; 654  :   {
; 655  : 	const uint64_t lz_memusage = lzma_lz_encoder_memusage(&lz_options);

  00038	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lz_options$33684[rsp]
  0003d	e8 00 00 00 00	 call	 lzma_lz_encoder_memusage
  00042	48 89 44 24 60	 mov	 QWORD PTR lz_memusage$33685[rsp], rax

; 656  : 	if (lz_memusage == UINT64_MAX)

  00047	48 83 7c 24 60
	ff		 cmp	 QWORD PTR lz_memusage$33685[rsp], -1
  0004d	75 09		 jne	 SHORT $LN1@lzma_lzma_@8

; 657  : 		return UINT64_MAX;

  0004f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00056	eb 0b		 jmp	 SHORT $LN3@lzma_lzma_@8
$LN1@lzma_lzma_@8:

; 658  : 
; 659  : 	return (uint64_t)(sizeof(lzma_lzma1_encoder)) + lz_memusage;

  00058	48 8b 44 24 60	 mov	 rax, QWORD PTR lz_memusage$33685[rsp]
  0005d	48 05 e8 ce 03
	00		 add	 rax, 249576		; 0003cee8H
$LN3@lzma_lzma_@8:

; 660  :   }}
; 661  : }

  00063	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00067	c3		 ret	 0
lzma_lzma_encoder_memusage ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$length_encoder_reset DD imagerel length_encoder_reset
	DD	imagerel length_encoder_reset+338
	DD	imagerel $unwind$length_encoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$length_encoder_reset DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT length_encoder_reset
_TEXT	SEGMENT
pos_state$33584 = 32
bt_i$33588 = 40
bt_i$33592 = 44
bt_i$33596 = 48
lencoder$ = 80
num_pos_states$ = 88
fast_mode$ = 96
length_encoder_reset PROC				; COMDAT

; 463  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 464  : 	bit_reset(lencoder->choice);

  00012	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR lencoder$[rsp]
  0001c	66 89 08	 mov	 WORD PTR [rax], cx

; 465  : 	bit_reset(lencoder->choice2);

  0001f	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR lencoder$[rsp]
  00029	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 466  : 
; 467  :   { size_t pos_state;
; 468  : 
; 469  : 	for (pos_state = 0; pos_state < num_pos_states; ++pos_state) {

  0002d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pos_state$33584[rsp], 0
  00036	eb 0e		 jmp	 SHORT $LN16@length_enc
$LN15@length_enc:
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR pos_state$33584[rsp]
  0003d	48 83 c0 01	 add	 rax, 1
  00041	48 89 44 24 20	 mov	 QWORD PTR pos_state$33584[rsp], rax
$LN16@length_enc:
  00046	8b 44 24 58	 mov	 eax, DWORD PTR num_pos_states$[rsp]
  0004a	48 39 44 24 20	 cmp	 QWORD PTR pos_state$33584[rsp], rax
  0004f	0f 83 84 00 00
	00		 jae	 $LN14@length_enc

; 470  : 		bittree_reset(lencoder->low[pos_state], LEN_LOW_BITS);

  00055	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR bt_i$33588[rsp], 0
  0005d	eb 0b		 jmp	 SHORT $LN13@length_enc
$LN12@length_enc:
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR bt_i$33588[rsp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 44 24 28	 mov	 DWORD PTR bt_i$33588[rsp], eax
$LN13@length_enc:
  0006a	83 7c 24 28 08	 cmp	 DWORD PTR bt_i$33588[rsp], 8
  0006f	73 22		 jae	 SHORT $LN11@length_enc
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos_state$33584[rsp]
  00076	48 6b c9 10	 imul	 rcx, 16
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR lencoder$[rsp]
  0007f	48 8d 54 08 04	 lea	 rdx, QWORD PTR [rax+rcx+4]
  00084	8b 4c 24 28	 mov	 ecx, DWORD PTR bt_i$33588[rsp]
  00088	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  0008d	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  00091	eb cc		 jmp	 SHORT $LN12@length_enc
$LN11@length_enc:

; 471  : 		bittree_reset(lencoder->mid[pos_state], LEN_MID_BITS);

  00093	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR bt_i$33592[rsp], 0
  0009b	eb 0b		 jmp	 SHORT $LN10@length_enc
$LN9@length_enc:
  0009d	8b 44 24 2c	 mov	 eax, DWORD PTR bt_i$33592[rsp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 44 24 2c	 mov	 DWORD PTR bt_i$33592[rsp], eax
$LN10@length_enc:
  000a8	83 7c 24 2c 08	 cmp	 DWORD PTR bt_i$33592[rsp], 8
  000ad	73 25		 jae	 SHORT $LN8@length_enc
  000af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos_state$33584[rsp]
  000b4	48 6b c9 10	 imul	 rcx, 16
  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR lencoder$[rsp]
  000bd	48 8d 94 08 04
	01 00 00	 lea	 rdx, QWORD PTR [rax+rcx+260]
  000c5	8b 4c 24 2c	 mov	 ecx, DWORD PTR bt_i$33592[rsp]
  000c9	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  000ce	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  000d2	eb c9		 jmp	 SHORT $LN9@length_enc
$LN8@length_enc:

; 472  : 	}

  000d4	e9 5f ff ff ff	 jmp	 $LN15@length_enc
$LN14@length_enc:

; 473  : 
; 474  : 	bittree_reset(lencoder->high, LEN_HIGH_BITS);

  000d9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bt_i$33596[rsp], 0
  000e1	eb 0b		 jmp	 SHORT $LN7@length_enc
$LN6@length_enc:
  000e3	8b 44 24 30	 mov	 eax, DWORD PTR bt_i$33596[rsp]
  000e7	83 c0 01	 add	 eax, 1
  000ea	89 44 24 30	 mov	 DWORD PTR bt_i$33596[rsp], eax
$LN7@length_enc:
  000ee	81 7c 24 30 00
	01 00 00	 cmp	 DWORD PTR bt_i$33596[rsp], 256 ; 00000100H
  000f6	73 18		 jae	 SHORT $LN5@length_enc
  000f8	8b 54 24 30	 mov	 edx, DWORD PTR bt_i$33596[rsp]
  000fc	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR lencoder$[rsp]
  00106	66 89 8c 50 04
	02 00 00	 mov	 WORD PTR [rax+rdx*2+516], cx
  0010e	eb d3		 jmp	 SHORT $LN6@length_enc
$LN5@length_enc:

; 475  : 
; 476  : 	if (!fast_mode)

  00110	0f b6 44 24 60	 movzx	 eax, BYTE PTR fast_mode$[rsp]
  00115	85 c0		 test	 eax, eax
  00117	75 34		 jne	 SHORT $LN4@length_enc

; 477  : 		for (pos_state = 0; pos_state < num_pos_states;
; 478  : 				++pos_state)

  00119	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pos_state$33584[rsp], 0
  00122	eb 0e		 jmp	 SHORT $LN3@length_enc
$LN2@length_enc:
  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR pos_state$33584[rsp]
  00129	48 83 c0 01	 add	 rax, 1
  0012d	48 89 44 24 20	 mov	 QWORD PTR pos_state$33584[rsp], rax
$LN3@length_enc:
  00132	8b 44 24 58	 mov	 eax, DWORD PTR num_pos_states$[rsp]
  00136	48 39 44 24 20	 cmp	 QWORD PTR pos_state$33584[rsp], rax
  0013b	73 10		 jae	 SHORT $LN1@length_enc

; 479  : 			length_update_prices(lencoder, (const uint32_t)pos_state);

  0013d	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$33584[rsp]
  00141	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lencoder$[rsp]
  00146	e8 00 00 00 00	 call	 length_update_prices
  0014b	eb d7		 jmp	 SHORT $LN2@length_enc
$LN1@length_enc:
$LN4@length_enc:

; 480  :   }
; 481  : 
; 482  : 	return;
; 483  : }

  0014d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00151	c3		 ret	 0
length_encoder_reset ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$length DD imagerel length
	DD	imagerel length+566
	DD	imagerel $unwind$length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$length DD 011801H
	DD	08218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT length
_TEXT	SEGMENT
rc$ = 80
lc$ = 88
pos_state$ = 96
len$ = 104
fast_mode$ = 112
length	PROC						; COMDAT

; 112  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 113  : 	assert(len <= MATCH_LEN_MAX);
; 114  : 	len -= MATCH_LEN_MIN;

  00018	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0001c	83 e8 02	 sub	 eax, 2
  0001f	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 115  : 
; 116  : 	if (len < LEN_LOW_SYMBOLS) {

  00023	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00028	73 73		 jae	 SHORT $LN6@length

; 117  : 		rc_bit(rc, &lc->choice, 0);

  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  0002f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  00038	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00040	48 8b 54 24 50	 mov	 rdx, QWORD PTR rc$[rsp]
  00045	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  00053	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  00060	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00064	48 83 c1 01	 add	 rcx, 1
  00068	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  0006d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 118  : 		rc_bittree(rc, lc->low[pos_state], LEN_LOW_BITS, len);

  00071	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00075	48 6b c9 10	 imul	 rcx, 16
  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  0007e	48 8d 54 08 04	 lea	 rdx, QWORD PTR [rax+rcx+4]
  00083	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  00088	41 b8 03 00 00
	00		 mov	 r8d, 3
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  00093	e8 00 00 00 00	 call	 rc_bittree

; 119  : 	} else {

  00098	e9 47 01 00 00	 jmp	 $LN5@length
$LN6@length:

; 120  : 		rc_bit(rc, &lc->choice, 1);

  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  000a2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  000ab	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  000b3	48 8b 54 24 50	 mov	 rdx, QWORD PTR rc$[rsp]
  000b8	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  000bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  000c6	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  000ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  000d3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000d7	48 83 c1 01	 add	 rcx, 1
  000db	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  000e0	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 121  : 		len -= LEN_LOW_SYMBOLS;

  000e4	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000e8	83 e8 08	 sub	 eax, 8
  000eb	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 122  : 
; 123  : 		if (len < LEN_MID_SYMBOLS) {

  000ef	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  000f4	73 77		 jae	 SHORT $LN4@length

; 124  : 			rc_bit(rc, &lc->choice2, 0);

  000f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  000fb	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000ff	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  00104	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  0010c	48 8b 54 24 50	 mov	 rdx, QWORD PTR rc$[rsp]
  00111	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00115	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lc$[rsp]
  0011a	48 83 c1 02	 add	 rcx, 2
  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  00123	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  00130	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00134	48 83 c1 01	 add	 rcx, 1
  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  0013d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 125  : 			rc_bittree(rc, lc->mid[pos_state], LEN_MID_BITS, len);

  00141	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00145	48 6b c9 10	 imul	 rcx, 16
  00149	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  0014e	48 8d 94 08 04
	01 00 00	 lea	 rdx, QWORD PTR [rax+rcx+260]
  00156	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  0015b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00161	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  00166	e8 00 00 00 00	 call	 rc_bittree

; 126  : 		} else {

  0016b	eb 77		 jmp	 SHORT $LN3@length
$LN4@length:

; 127  : 			rc_bit(rc, &lc->choice2, 1);

  0016d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  00172	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00176	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  0017b	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  00183	48 8b 54 24 50	 mov	 rdx, QWORD PTR rc$[rsp]
  00188	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0018c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lc$[rsp]
  00191	48 83 c1 02	 add	 rcx, 2
  00195	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  0019a	48 89 8c d0 10
	01 00 00	 mov	 QWORD PTR [rax+rdx*8+272], rcx
  001a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  001a7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001ab	48 83 c1 01	 add	 rcx, 1
  001af	48 8b 44 24 50	 mov	 rax, QWORD PTR rc$[rsp]
  001b4	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 128  : 			len -= LEN_MID_SYMBOLS;

  001b8	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  001bc	83 e8 08	 sub	 eax, 8
  001bf	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 129  : 			rc_bittree(rc, lc->high, LEN_HIGH_BITS, len);

  001c3	48 8b 54 24 58	 mov	 rdx, QWORD PTR lc$[rsp]
  001c8	48 81 c2 04 02
	00 00		 add	 rdx, 516		; 00000204H
  001cf	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  001d4	41 b8 08 00 00
	00		 mov	 r8d, 8
  001da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rc$[rsp]
  001df	e8 00 00 00 00	 call	 rc_bittree
$LN3@length:
$LN5@length:

; 130  : 		}
; 131  : 	}
; 132  : 
; 133  : 	// Only getoptimum uses the prices so don't update the table when
; 134  : 	// in fast mode.
; 135  : 	if (!fast_mode)

  001e4	0f b6 44 24 70	 movzx	 eax, BYTE PTR fast_mode$[rsp]
  001e9	85 c0		 test	 eax, eax
  001eb	75 44		 jne	 SHORT $LN2@length

; 136  : 		if (--lc->counters[pos_state] == 0)

  001ed	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  001f1	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  001f6	8b 94 88 08 48
	00 00		 mov	 edx, DWORD PTR [rax+rcx*4+18440]
  001fd	83 ea 01	 sub	 edx, 1
  00200	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00204	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  00209	89 94 88 08 48
	00 00		 mov	 DWORD PTR [rax+rcx*4+18440], edx
  00210	8b 4c 24 60	 mov	 ecx, DWORD PTR pos_state$[rsp]
  00214	48 8b 44 24 58	 mov	 rax, QWORD PTR lc$[rsp]
  00219	83 bc 88 08 48
	00 00 00	 cmp	 DWORD PTR [rax+rcx*4+18440], 0
  00221	75 0e		 jne	 SHORT $LN1@length

; 137  : 			length_update_prices(lc, pos_state);

  00223	8b 54 24 60	 mov	 edx, DWORD PTR pos_state$[rsp]
  00227	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lc$[rsp]
  0022c	e8 00 00 00 00	 call	 length_update_prices
$LN1@length:
$LN2@length:

; 138  : }

  00231	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00235	c3		 ret	 0
length	ENDP
PUBLIC	lzma_lzma_encoder_reset
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_common.h
pdata	SEGMENT
$pdata$lzma_lzma_encoder_reset DD imagerel $LN35
	DD	imagerel $LN35+1042
	DD	imagerel $unwind$lzma_lzma_encoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_encoder_reset DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT lzma_lzma_encoder_reset
_TEXT	SEGMENT
i$33611 = 32
j$33615 = 40
bt_i$33628 = 48
bt_i$33632 = 52
i$83661 = 56
coders$83660 = 60
j$83662 = 64
$T83670 = 68
$T83671 = 72
coder$ = 96
options$ = 104
lzma_lzma_encoder_reset PROC				; COMDAT

; 489  : {

$LN35:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 490  : 	if (!is_options_valid(options))

  0000e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR options$[rsp]
  00013	e8 00 00 00 00	 call	 is_options_valid
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 0a		 jne	 SHORT $LN22@lzma_lzma_@11

; 491  : 		return LZMA_OPTIONS_ERROR;

  0001f	b8 08 00 00 00	 mov	 eax, 8
  00024	e9 e4 03 00 00	 jmp	 $LN23@lzma_lzma_@11
$LN22@lzma_lzma_@11:

; 492  : 
; 493  : 	coder->pos_mask = (1U << options->pb) - 1;

  00029	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  0002e	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	d3 e0		 shl	 eax, cl
  00038	8b c8		 mov	 ecx, eax
  0003a	83 e9 01	 sub	 ecx, 1
  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00042	89 88 90 0b 00
	00		 mov	 DWORD PTR [rax+2960], ecx

; 494  : 	coder->literal_context_bits = options->lc;

  00048	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  0004d	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  00052	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00055	89 81 94 0b 00
	00		 mov	 DWORD PTR [rcx+2964], eax

; 495  : 	coder->literal_pos_mask = (1U << options->lp) - 1;

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  00060	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	d3 e0		 shl	 eax, cl
  0006a	8b c8		 mov	 ecx, eax
  0006c	83 e9 01	 sub	 ecx, 1
  0006f	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00074	89 88 98 0b 00
	00		 mov	 DWORD PTR [rax+2968], ecx

; 496  : 
; 497  : 	// Range coder
; 498  : 	rc_reset(&coder->rc);

  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0007f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0008b	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00098	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [rax+16], -1	; ffffffffH
  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000a4	c6 40 14 00	 mov	 BYTE PTR [rax+20], 0
  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000ad	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  000b5	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000ba	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 499  : 
; 500  : 	// State
; 501  : 	coder->state = STATE_LIT_LIT;

  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000c7	c7 80 e0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+736], 0

; 502  :   { size_t i;
; 503  : 	for (i = 0; i < REPS; ++i)

  000d1	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$33611[rsp], 0
  000da	eb 0e		 jmp	 SHORT $LN21@lzma_lzma_@11
$LN20@lzma_lzma_@11:
  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  000e1	48 83 c0 01	 add	 rax, 1
  000e5	48 89 44 24 20	 mov	 QWORD PTR i$33611[rsp], rax
$LN21@lzma_lzma_@11:
  000ea	48 83 7c 24 20
	04		 cmp	 QWORD PTR i$33611[rsp], 4
  000f0	73 17		 jae	 SHORT $LN19@lzma_lzma_@11

; 504  : 		coder->reps[i] = 0;

  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  000f7	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  000fc	c7 84 81 e4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+740], 0
  00107	eb d3		 jmp	 SHORT $LN20@lzma_lzma_@11
$LN19@lzma_lzma_@11:

; 505  : 
; 506  : 	literal_init(coder->literal, options->lc, options->lp);

  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  0010e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00111	89 44 24 48	 mov	 DWORD PTR $T83671[rsp], eax
  00115	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  0011a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011d	89 44 24 44	 mov	 DWORD PTR $T83670[rsp], eax
  00121	8b 44 24 48	 mov	 eax, DWORD PTR $T83671[rsp]
  00125	8b 4c 24 44	 mov	 ecx, DWORD PTR $T83670[rsp]
  00129	03 c8		 add	 ecx, eax
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	d3 e0		 shl	 eax, cl
  00132	89 44 24 3c	 mov	 DWORD PTR coders$83660[rsp], eax
  00136	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$83661[rsp], 0
  0013e	eb 0b		 jmp	 SHORT $LN32@lzma_lzma_@11
$LN31@lzma_lzma_@11:
  00140	8b 44 24 38	 mov	 eax, DWORD PTR i$83661[rsp]
  00144	83 c0 01	 add	 eax, 1
  00147	89 44 24 38	 mov	 DWORD PTR i$83661[rsp], eax
$LN32@lzma_lzma_@11:
  0014b	8b 44 24 3c	 mov	 eax, DWORD PTR coders$83660[rsp]
  0014f	39 44 24 38	 cmp	 DWORD PTR i$83661[rsp], eax
  00153	73 48		 jae	 SHORT $LN30@lzma_lzma_@11
  00155	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR j$83662[rsp], 0
  0015d	eb 0b		 jmp	 SHORT $LN29@lzma_lzma_@11
$LN28@lzma_lzma_@11:
  0015f	8b 44 24 40	 mov	 eax, DWORD PTR j$83662[rsp]
  00163	83 c0 01	 add	 eax, 1
  00166	89 44 24 40	 mov	 DWORD PTR j$83662[rsp], eax
$LN29@lzma_lzma_@11:
  0016a	81 7c 24 40 00
	03 00 00	 cmp	 DWORD PTR j$83662[rsp], 768 ; 00000300H
  00172	73 27		 jae	 SHORT $LN27@lzma_lzma_@11
  00174	8b 4c 24 38	 mov	 ecx, DWORD PTR i$83661[rsp]
  00178	48 69 c9 00 06
	00 00		 imul	 rcx, 1536		; 00000600H
  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00184	48 8d 94 08 9c
	0b 00 00	 lea	 rdx, QWORD PTR [rax+rcx+2972]
  0018c	8b 4c 24 40	 mov	 ecx, DWORD PTR j$83662[rsp]
  00190	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00195	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  00199	eb c4		 jmp	 SHORT $LN28@lzma_lzma_@11
$LN27@lzma_lzma_@11:
  0019b	eb a3		 jmp	 SHORT $LN31@lzma_lzma_@11
$LN30@lzma_lzma_@11:

; 507  : 
; 508  : 	// Bit encoders
; 509  :   { size_t j;
; 510  : 	for (i = 0; i < STATES; ++i) {

  0019d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$33611[rsp], 0
  001a6	eb 0e		 jmp	 SHORT $LN18@lzma_lzma_@11
$LN17@lzma_lzma_@11:
  001a8	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  001ad	48 83 c0 01	 add	 rax, 1
  001b1	48 89 44 24 20	 mov	 QWORD PTR i$33611[rsp], rax
$LN18@lzma_lzma_@11:
  001b6	48 83 7c 24 20
	0c		 cmp	 QWORD PTR i$33611[rsp], 12
  001bc	0f 83 d6 00 00
	00		 jae	 $LN16@lzma_lzma_@11

; 511  : 		for (j = 0; j <= coder->pos_mask; ++j) {

  001c2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR j$33615[rsp], 0
  001cb	eb 0e		 jmp	 SHORT $LN15@lzma_lzma_@11
$LN14@lzma_lzma_@11:
  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR j$33615[rsp]
  001d2	48 83 c0 01	 add	 rax, 1
  001d6	48 89 44 24 28	 mov	 QWORD PTR j$33615[rsp], rax
$LN15@lzma_lzma_@11:
  001db	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  001e0	8b 80 90 0b 00
	00		 mov	 eax, DWORD PTR [rax+2960]
  001e6	48 39 44 24 28	 cmp	 QWORD PTR j$33615[rsp], rax
  001eb	77 4a		 ja	 SHORT $LN13@lzma_lzma_@11

; 512  : 			bit_reset(coder->is_match[i][j]);

  001ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$33611[rsp]
  001f2	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  001f6	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  001fb	48 8d 94 08 9c
	6b 00 00	 lea	 rdx, QWORD PTR [rax+rcx+27548]
  00203	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00208	48 8b 44 24 28	 mov	 rax, QWORD PTR j$33615[rsp]
  0020d	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 513  : 			bit_reset(coder->is_rep0_long[i][j]);

  00211	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$33611[rsp]
  00216	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0021f	48 8d 94 08 7c
	6d 00 00	 lea	 rdx, QWORD PTR [rax+rcx+28028]
  00227	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0022c	48 8b 44 24 28	 mov	 rax, QWORD PTR j$33615[rsp]
  00231	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 514  : 		}

  00235	eb 96		 jmp	 SHORT $LN14@lzma_lzma_@11
$LN13@lzma_lzma_@11:

; 515  : 
; 516  : 		bit_reset(coder->is_rep[i]);

  00237	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0023c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00241	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  00246	66 89 94 41 1c
	6d 00 00	 mov	 WORD PTR [rcx+rax*2+27932], dx

; 517  : 		bit_reset(coder->is_rep0[i]);

  0024e	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00253	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00258	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  0025d	66 89 94 41 34
	6d 00 00	 mov	 WORD PTR [rcx+rax*2+27956], dx

; 518  : 		bit_reset(coder->is_rep1[i]);

  00265	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0026a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  00274	66 89 94 41 4c
	6d 00 00	 mov	 WORD PTR [rcx+rax*2+27980], dx

; 519  : 		bit_reset(coder->is_rep2[i]);

  0027c	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00281	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00286	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  0028b	66 89 94 41 64
	6d 00 00	 mov	 WORD PTR [rcx+rax*2+28004], dx

; 520  : 	}

  00293	e9 10 ff ff ff	 jmp	 $LN17@lzma_lzma_@11
$LN16@lzma_lzma_@11:

; 521  :   }
; 522  : 
; 523  : 	for (i = 0; i < FULL_DISTANCES - DIST_MODEL_END; ++i)

  00298	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$33611[rsp], 0
  002a1	eb 0e		 jmp	 SHORT $LN12@lzma_lzma_@11
$LN11@lzma_lzma_@11:
  002a3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  002a8	48 83 c0 01	 add	 rax, 1
  002ac	48 89 44 24 20	 mov	 QWORD PTR i$33611[rsp], rax
$LN12@lzma_lzma_@11:
  002b1	48 83 7c 24 20
	72		 cmp	 QWORD PTR i$33611[rsp], 114 ; 00000072H
  002b7	73 19		 jae	 SHORT $LN10@lzma_lzma_@11

; 524  : 		bit_reset(coder->dist_special[i]);

  002b9	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  002be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  002c3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  002c8	66 89 94 41 fc
	70 00 00	 mov	 WORD PTR [rcx+rax*2+28924], dx
  002d0	eb d1		 jmp	 SHORT $LN11@lzma_lzma_@11
$LN10@lzma_lzma_@11:

; 525  : 
; 526  : 	// Bit tree encoders
; 527  : 	for (i = 0; i < DIST_STATES; ++i)

  002d2	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$33611[rsp], 0
  002db	eb 0e		 jmp	 SHORT $LN9@lzma_lzma_@11
$LN8@lzma_lzma_@11:
  002dd	48 8b 44 24 20	 mov	 rax, QWORD PTR i$33611[rsp]
  002e2	48 83 c0 01	 add	 rax, 1
  002e6	48 89 44 24 20	 mov	 QWORD PTR i$33611[rsp], rax
$LN9@lzma_lzma_@11:
  002eb	48 83 7c 24 20
	04		 cmp	 QWORD PTR i$33611[rsp], 4
  002f1	73 46		 jae	 SHORT $LN7@lzma_lzma_@11

; 528  : 		bittree_reset(coder->dist_slot[i], DIST_SLOT_BITS);

  002f3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bt_i$33628[rsp], 0
  002fb	eb 0b		 jmp	 SHORT $LN6@lzma_lzma_@11
$LN5@lzma_lzma_@11:
  002fd	8b 44 24 30	 mov	 eax, DWORD PTR bt_i$33628[rsp]
  00301	83 c0 01	 add	 eax, 1
  00304	89 44 24 30	 mov	 DWORD PTR bt_i$33628[rsp], eax
$LN6@lzma_lzma_@11:
  00308	83 7c 24 30 40	 cmp	 DWORD PTR bt_i$33628[rsp], 64 ; 00000040H
  0030d	73 28		 jae	 SHORT $LN4@lzma_lzma_@11
  0030f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$33611[rsp]
  00314	48 69 c9 80 00
	00 00		 imul	 rcx, 128		; 00000080H
  0031b	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00320	48 8d 94 08 fc
	6e 00 00	 lea	 rdx, QWORD PTR [rax+rcx+28412]
  00328	8b 4c 24 30	 mov	 ecx, DWORD PTR bt_i$33628[rsp]
  0032c	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00331	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  00335	eb c6		 jmp	 SHORT $LN5@lzma_lzma_@11
$LN4@lzma_lzma_@11:
  00337	eb a4		 jmp	 SHORT $LN8@lzma_lzma_@11
$LN7@lzma_lzma_@11:

; 529  :   }
; 530  : 
; 531  : 	bittree_reset(coder->dist_align, ALIGN_BITS);

  00339	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR bt_i$33632[rsp], 0
  00341	eb 0b		 jmp	 SHORT $LN3@lzma_lzma_@11
$LN2@lzma_lzma_@11:
  00343	8b 44 24 34	 mov	 eax, DWORD PTR bt_i$33632[rsp]
  00347	83 c0 01	 add	 eax, 1
  0034a	89 44 24 34	 mov	 DWORD PTR bt_i$33632[rsp], eax
$LN3@lzma_lzma_@11:
  0034e	83 7c 24 34 10	 cmp	 DWORD PTR bt_i$33632[rsp], 16
  00353	73 18		 jae	 SHORT $LN1@lzma_lzma_@11
  00355	8b 54 24 34	 mov	 edx, DWORD PTR bt_i$33632[rsp]
  00359	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0035e	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00363	66 89 8c 50 e0
	71 00 00	 mov	 WORD PTR [rax+rdx*2+29152], cx
  0036b	eb d6		 jmp	 SHORT $LN2@lzma_lzma_@11
$LN1@lzma_lzma_@11:

; 532  : 
; 533  : 	// Length encoders
; 534  : 	length_encoder_reset(&coder->match_len_encoder,
; 535  : 			1U << options->pb, coder->fast_mode);

  0036d	48 8b 44 24 68	 mov	 rax, QWORD PTR options$[rsp]
  00372	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00375	ba 01 00 00 00	 mov	 edx, 1
  0037a	0f b6 c8	 movzx	 ecx, al
  0037d	d3 e2		 shl	 edx, cl
  0037f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00384	48 81 c1 00 72
	00 00		 add	 rcx, 29184		; 00007200H
  0038b	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00390	44 0f b6 80 8c
	0b 00 00	 movzx	 r8d, BYTE PTR [rax+2956]
  00398	e8 00 00 00 00	 call	 length_encoder_reset

; 536  : 
; 537  : 	length_encoder_reset(&coder->rep_len_encoder,
; 538  : 			1U << options->pb, coder->fast_mode);

  0039d	4c 8b 5c 24 68	 mov	 r11, QWORD PTR options$[rsp]
  003a2	41 8b 43 1c	 mov	 eax, DWORD PTR [r11+28]
  003a6	ba 01 00 00 00	 mov	 edx, 1
  003ab	0f b6 c8	 movzx	 ecx, al
  003ae	d3 e2		 shl	 edx, cl
  003b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  003b5	48 81 c1 48 ba
	00 00		 add	 rcx, 47688		; 0000ba48H
  003bc	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  003c1	44 0f b6 80 8c
	0b 00 00	 movzx	 r8d, BYTE PTR [rax+2956]
  003c9	e8 00 00 00 00	 call	 length_encoder_reset

; 539  : 
; 540  : 	// Price counts are incremented every time appropriate probabilities
; 541  : 	// are changed. price counts are set to zero when the price tables
; 542  : 	// are updated, which is done when the appropriate price counts have
; 543  : 	// big enough value, and lzma_mf.read_ahead == 0 which happens at
; 544  : 	// least every OPTS (a few thousand) possible price count increments.
; 545  : 	//
; 546  : 	// By resetting price counts to UINT32_MAX / 2, we make sure that the
; 547  : 	// price tables will be initialized before they will be used (since
; 548  : 	// the value is definitely big enough), and that it is OK to increment
; 549  : 	// price counts without risk of integer overflow (since UINT32_MAX / 2
; 550  : 	// is small enough). The current code doesn't increment price counts
; 551  : 	// before initializing price tables, but it maybe done in future if
; 552  : 	// we add support for saving the state between LZMA2 chunks.
; 553  : 	coder->match_price_count = UINT32_MAX / 2;

  003ce	4c 8b 5c 24 60	 mov	 r11, QWORD PTR coder$[rsp]
  003d3	41 c7 83 94 0e
	01 00 ff ff ff
	7f		 mov	 DWORD PTR [r11+69268], 2147483647 ; 7fffffffH

; 554  : 	coder->align_price_count = UINT32_MAX / 2;

  003de	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  003e3	c7 80 d8 0e 01
	00 ff ff ff 7f	 mov	 DWORD PTR [rax+69336], 2147483647 ; 7fffffffH

; 555  : 
; 556  : 	coder->opts_end_index = 0;

  003ed	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  003f2	c7 80 dc 0e 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+69340], 0

; 557  : 	coder->opts_current_index = 0;

  003fc	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00401	c7 80 e0 0e 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+69344], 0

; 558  : 
; 559  : 	return LZMA_OK;

  0040b	33 c0		 xor	 eax, eax
$LN23@lzma_lzma_@11:

; 560  : }

  0040d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00411	c3		 ret	 0
lzma_lzma_encoder_reset ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$rep_match DD imagerel rep_match
	DD	imagerel rep_match+1209
	DD	imagerel $unwind$rep_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rep_match DD 021a01H
	DD	013011aH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT rep_match
_TEXT	SEGMENT
distance$33476 = 48
$T83687 = 56
$T83691 = 64
$T83692 = 72
$T83696 = 80
$T83700 = 88
$T83704 = 96
$T83708 = 104
tv175 = 136
tv186 = 140
coder$ = 160
pos_state$ = 168
rep$ = 176
len$ = 184
rep_match PROC						; COMDAT

; 197  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 198  : 	if (rep == 0) {

  0001a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rep$[rsp], 0
  00022	0f 85 2a 01 00
	00		 jne	 $LN7@rep_match

; 199  : 		rc_bit(&coder->rc, &coder->is_rep0[coder->state], 0);

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00030	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00037	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0003f	48 8d 84 48 34
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27956]
  00047	48 89 44 24 38	 mov	 QWORD PTR $T83687[rsp], rax
  0004c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00054	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00058	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00060	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00068	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00070	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00074	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0007c	48 8b 44 24 38	 mov	 rax, QWORD PTR $T83687[rsp]
  00081	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  00089	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00091	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00095	48 83 c1 01	 add	 rcx, 1
  00099	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000a1	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 200  : 		rc_bit(&coder->rc,
; 201  : 				&coder->is_rep0_long[coder->state][pos_state],
; 202  : 				len != 1);

  000a5	83 bc 24 b8 00
	00 00 01	 cmp	 DWORD PTR len$[rsp], 1
  000ad	74 0a		 je	 SHORT $LN10@rep_match
  000af	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR $T83692[rsp], 1
  000b7	eb 08		 jmp	 SHORT $LN11@rep_match
$LN10@rep_match:
  000b9	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR $T83692[rsp], 0
$LN11@rep_match:
  000c1	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pos_state$[rsp]
  000c8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000d0	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  000d7	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  000db	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000e3	48 8d 84 08 7c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx+28028]
  000eb	48 8d 04 50	 lea	 rax, QWORD PTR [rax+rdx*2]
  000ef	48 89 44 24 40	 mov	 QWORD PTR $T83691[rsp], rax
  000f4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  000fc	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00100	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00108	8b 44 24 48	 mov	 eax, DWORD PTR $T83692[rsp]
  0010c	89 44 91 28	 mov	 DWORD PTR [rcx+rdx*4+40], eax
  00110	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00118	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0011c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00124	48 8b 44 24 40	 mov	 rax, QWORD PTR $T83691[rsp]
  00129	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  00131	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00139	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0013d	48 83 c1 01	 add	 rcx, 1
  00141	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00149	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 203  : 	} else {

  0014d	e9 97 02 00 00	 jmp	 $LN6@rep_match
$LN7@rep_match:

; 204  : 		const uint32_t distance = coder->reps[rep];

  00152	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR rep$[rsp]
  00159	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00161	8b 84 88 e4 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+740]
  00168	89 44 24 30	 mov	 DWORD PTR distance$33476[rsp], eax

; 205  : 		rc_bit(&coder->rc, &coder->is_rep0[coder->state], 1);

  0016c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00174	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  0017b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00183	48 8d 84 48 34
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27956]
  0018b	48 89 44 24 50	 mov	 QWORD PTR $T83696[rsp], rax
  00190	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00198	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0019c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001a4	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  001ac	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  001b4	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  001b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001c0	48 8b 44 24 50	 mov	 rax, QWORD PTR $T83696[rsp]
  001c5	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  001cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001d5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001d9	48 83 c1 01	 add	 rcx, 1
  001dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001e5	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 206  : 
; 207  : 		if (rep == 1) {

  001e9	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR rep$[rsp], 1
  001f1	0f 85 82 00 00
	00		 jne	 $LN5@rep_match

; 208  : 			rc_bit(&coder->rc, &coder->is_rep1[coder->state], 0);

  001f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001ff	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00206	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0020e	48 8d 84 48 4c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27980]
  00216	48 89 44 24 58	 mov	 QWORD PTR $T83700[rsp], rax
  0021b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00223	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00227	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0022f	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00237	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  0023f	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00243	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0024b	48 8b 44 24 58	 mov	 rax, QWORD PTR $T83700[rsp]
  00250	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  00258	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00260	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00264	48 83 c1 01	 add	 rcx, 1
  00268	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00270	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 209  : 		} else {

  00274	e9 42 01 00 00	 jmp	 $LN4@rep_match
$LN5@rep_match:

; 210  : 			rc_bit(&coder->rc, &coder->is_rep1[coder->state], 1);

  00279	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00281	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00288	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00290	48 8d 84 48 4c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27980]
  00298	48 89 44 24 60	 mov	 QWORD PTR $T83704[rsp], rax
  0029d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002a5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002a9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002b1	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  002b9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  002c1	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  002c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002cd	48 8b 44 24 60	 mov	 rax, QWORD PTR $T83704[rsp]
  002d2	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  002da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002e2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002e6	48 83 c1 01	 add	 rcx, 1
  002ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002f2	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 211  : 			rc_bit(&coder->rc, &coder->is_rep2[coder->state],
; 212  : 					rep - 2);

  002f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002fe	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00305	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0030d	48 8d 84 48 64
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+28004]
  00315	48 89 44 24 68	 mov	 QWORD PTR $T83708[rsp], rax
  0031a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00322	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00326	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR rep$[rsp]
  0032d	83 e9 02	 sub	 ecx, 2
  00330	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00338	89 4c 90 28	 mov	 DWORD PTR [rax+rdx*4+40], ecx
  0033c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00344	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00348	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00350	48 8b 44 24 68	 mov	 rax, QWORD PTR $T83708[rsp]
  00355	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  0035d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00365	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00369	48 83 c1 01	 add	 rcx, 1
  0036d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00375	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 213  : 
; 214  : 			if (rep == 3)

  00379	83 bc 24 b0 00
	00 00 03	 cmp	 DWORD PTR rep$[rsp], 3
  00381	75 1c		 jne	 SHORT $LN3@rep_match

; 215  : 				coder->reps[3] = coder->reps[2];

  00383	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0038b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00393	8b 80 ec 02 00
	00		 mov	 eax, DWORD PTR [rax+748]
  00399	89 81 f0 02 00
	00		 mov	 DWORD PTR [rcx+752], eax
$LN3@rep_match:

; 216  : 
; 217  : 			coder->reps[2] = coder->reps[1];

  0039f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  003a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003af	8b 80 e8 02 00
	00		 mov	 eax, DWORD PTR [rax+744]
  003b5	89 81 ec 02 00
	00		 mov	 DWORD PTR [rcx+748], eax
$LN4@rep_match:

; 218  : 		}
; 219  : 
; 220  : 		coder->reps[1] = coder->reps[0];

  003bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  003c3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003cb	8b 80 e4 02 00
	00		 mov	 eax, DWORD PTR [rax+740]
  003d1	89 81 e8 02 00
	00		 mov	 DWORD PTR [rcx+744], eax

; 221  : 		coder->reps[0] = distance;

  003d7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  003df	8b 44 24 30	 mov	 eax, DWORD PTR distance$33476[rsp]
  003e3	89 81 e4 02 00
	00		 mov	 DWORD PTR [rcx+740], eax
$LN6@rep_match:

; 222  : 	}
; 223  : 
; 224  : 	if (len == 1) {

  003e9	83 bc 24 b8 00
	00 00 01	 cmp	 DWORD PTR len$[rsp], 1
  003f1	75 40		 jne	 SHORT $LN2@rep_match

; 225  : 		update_short_rep(coder->state);

  003f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  003fb	83 b8 e0 02 00
	00 07		 cmp	 DWORD PTR [rax+736], 7
  00402	7d 0d		 jge	 SHORT $LN12@rep_match
  00404	c7 84 24 88 00
	00 00 09 00 00
	00		 mov	 DWORD PTR tv175[rsp], 9
  0040f	eb 0b		 jmp	 SHORT $LN13@rep_match
$LN12@rep_match:
  00411	c7 84 24 88 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv175[rsp], 11
$LN13@rep_match:
  0041c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00424	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv175[rsp]
  0042b	89 81 e0 02 00
	00		 mov	 DWORD PTR [rcx+736], eax

; 226  : 	} else {

  00431	eb 7e		 jmp	 SHORT $LN1@rep_match
$LN2@rep_match:

; 227  : 		length(&coder->rc, &coder->rep_len_encoder, pos_state, len,
; 228  : 				coder->fast_mode);

  00433	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  0043b	48 81 c2 48 ba
	00 00		 add	 rdx, 47688		; 0000ba48H
  00442	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0044a	0f b6 80 8c 0b
	00 00		 movzx	 eax, BYTE PTR [rax+2956]
  00451	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00455	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0045d	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR pos_state$[rsp]
  00465	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0046d	e8 00 00 00 00	 call	 length

; 229  : 		update_long_rep(coder->state);

  00472	4c 8b 9c 24 a0
	00 00 00	 mov	 r11, QWORD PTR coder$[rsp]
  0047a	41 83 bb e0 02
	00 00 07	 cmp	 DWORD PTR [r11+736], 7
  00482	7d 0d		 jge	 SHORT $LN14@rep_match
  00484	c7 84 24 8c 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv186[rsp], 8
  0048f	eb 0b		 jmp	 SHORT $LN15@rep_match
$LN14@rep_match:
  00491	c7 84 24 8c 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv186[rsp], 11
$LN15@rep_match:
  0049c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  004a4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv186[rsp]
  004ab	89 81 e0 02 00
	00		 mov	 DWORD PTR [rcx+736], eax
$LN1@rep_match:

; 230  : 	}
; 231  : }

  004b1	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004b8	c3		 ret	 0
rep_match ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$match DD	imagerel match
	DD	imagerel match+708
	DD	imagerel $unwind$match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match DD 021a01H
	DD	011011aH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT match
_TEXT	SEGMENT
dist_state$33457 = 48
dist_slot$33456 = 52
dist_reduced$33461 = 56
footer_bits$33459 = 60
base$33460 = 64
$T83771 = 96
tv67 = 108
tv79 = 112
coder$ = 144
pos_state$ = 152
distance$ = 160
len$ = 168
match	PROC						; COMDAT

; 148  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 149  : 	update_match(coder->state);

  0001a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00022	83 b8 e0 02 00
	00 07		 cmp	 DWORD PTR [rax+736], 7
  00029	7d 0a		 jge	 SHORT $LN6@match
  0002b	c7 44 24 6c 07
	00 00 00	 mov	 DWORD PTR tv67[rsp], 7
  00033	eb 08		 jmp	 SHORT $LN7@match
$LN6@match:
  00035	c7 44 24 6c 0a
	00 00 00	 mov	 DWORD PTR tv67[rsp], 10
$LN7@match:
  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00045	8b 44 24 6c	 mov	 eax, DWORD PTR tv67[rsp]
  00049	89 81 e0 02 00
	00		 mov	 DWORD PTR [rcx+736], eax

; 150  : 
; 151  : 	length(&coder->rc, &coder->match_len_encoder, pos_state, len,
; 152  : 			coder->fast_mode);

  0004f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00057	48 81 c2 00 72
	00 00		 add	 rdx, 29184		; 00007200H
  0005e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00066	0f b6 80 8c 0b
	00 00		 movzx	 eax, BYTE PTR [rax+2956]
  0006d	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00071	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  00079	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR pos_state$[rsp]
  00081	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00089	e8 00 00 00 00	 call	 length

; 153  : 
; 154  :   {
; 155  : 	const uint32_t dist_slot = get_dist_slot(distance);

  0008e	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR distance$[rsp]
  00095	e8 00 00 00 00	 call	 get_dist_slot
  0009a	89 44 24 34	 mov	 DWORD PTR dist_slot$33456[rsp], eax

; 156  : 	const uint32_t dist_state = get_dist_state(len);

  0009e	83 bc 24 a8 00
	00 00 06	 cmp	 DWORD PTR len$[rsp], 6
  000a6	73 10		 jae	 SHORT $LN8@match
  000a8	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000af	83 e8 02	 sub	 eax, 2
  000b2	89 44 24 70	 mov	 DWORD PTR tv79[rsp], eax
  000b6	eb 08		 jmp	 SHORT $LN9@match
$LN8@match:
  000b8	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR tv79[rsp], 3
$LN9@match:
  000c0	8b 44 24 70	 mov	 eax, DWORD PTR tv79[rsp]
  000c4	89 44 24 30	 mov	 DWORD PTR dist_state$33457[rsp], eax

; 157  : 	rc_bittree(&coder->rc, coder->dist_slot[dist_state],
; 158  : 			DIST_SLOT_BITS, dist_slot);

  000c8	8b 4c 24 30	 mov	 ecx, DWORD PTR dist_state$33457[rsp]
  000cc	48 69 c9 80 00
	00 00		 imul	 rcx, 128		; 00000080H
  000d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000db	48 8d 94 08 fc
	6e 00 00	 lea	 rdx, QWORD PTR [rax+rcx+28412]
  000e3	44 8b 4c 24 34	 mov	 r9d, DWORD PTR dist_slot$33456[rsp]
  000e8	41 b8 06 00 00
	00		 mov	 r8d, 6
  000ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000f6	e8 00 00 00 00	 call	 rc_bittree

; 159  : 
; 160  : 	if (dist_slot >= DIST_MODEL_START) {

  000fb	83 7c 24 34 04	 cmp	 DWORD PTR dist_slot$33456[rsp], 4
  00100	0f 82 2e 01 00
	00		 jb	 $LN3@match

; 161  : 		const uint32_t footer_bits = (dist_slot >> 1) - 1;

  00106	8b 44 24 34	 mov	 eax, DWORD PTR dist_slot$33456[rsp]
  0010a	d1 e8		 shr	 eax, 1
  0010c	83 e8 01	 sub	 eax, 1
  0010f	89 44 24 3c	 mov	 DWORD PTR footer_bits$33459[rsp], eax

; 162  : 		const uint32_t base = (2 | (dist_slot & 1)) << footer_bits;

  00113	8b 54 24 34	 mov	 edx, DWORD PTR dist_slot$33456[rsp]
  00117	83 e2 01	 and	 edx, 1
  0011a	83 ca 02	 or	 edx, 2
  0011d	8b 44 24 3c	 mov	 eax, DWORD PTR footer_bits$33459[rsp]
  00121	0f b6 c8	 movzx	 ecx, al
  00124	8b c2		 mov	 eax, edx
  00126	d3 e0		 shl	 eax, cl
  00128	89 44 24 40	 mov	 DWORD PTR base$33460[rsp], eax

; 163  : 		const uint32_t dist_reduced = distance - base;

  0012c	8b 4c 24 40	 mov	 ecx, DWORD PTR base$33460[rsp]
  00130	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR distance$[rsp]
  00137	2b c1		 sub	 eax, ecx
  00139	89 44 24 38	 mov	 DWORD PTR dist_reduced$33461[rsp], eax

; 164  : 
; 165  : 		if (dist_slot < DIST_MODEL_END) {

  0013d	83 7c 24 34 0e	 cmp	 DWORD PTR dist_slot$33456[rsp], 14
  00142	73 3e		 jae	 SHORT $LN2@match

; 166  : 			// Careful here: base - dist_slot - 1 can be -1, but
; 167  : 			// rc_bittree_reverse starts at probs[1], not probs[0].
; 168  : 			rc_bittree_reverse(&coder->rc,
; 169  : 				coder->dist_special + base - dist_slot - 1,
; 170  : 				footer_bits, dist_reduced);

  00144	8b 4c 24 40	 mov	 ecx, DWORD PTR base$33460[rsp]
  00148	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00150	48 8d 94 48 fc
	70 00 00	 lea	 rdx, QWORD PTR [rax+rcx*2+28924]
  00158	8b 44 24 34	 mov	 eax, DWORD PTR dist_slot$33456[rsp]
  0015c	48 d1 e0	 shl	 rax, 1
  0015f	48 2b d0	 sub	 rdx, rax
  00162	48 83 ea 02	 sub	 rdx, 2
  00166	44 8b 4c 24 38	 mov	 r9d, DWORD PTR dist_reduced$33461[rsp]
  0016b	44 8b 44 24 3c	 mov	 r8d, DWORD PTR footer_bits$33459[rsp]
  00170	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00178	e8 00 00 00 00	 call	 rc_bittree_reverse

; 171  : 		} else {

  0017d	e9 b2 00 00 00	 jmp	 $LN1@match
$LN2@match:

; 172  : 			rc_direct(&coder->rc, dist_reduced >> ALIGN_BITS,
; 173  : 					footer_bits - ALIGN_BITS);

  00182	8b 44 24 3c	 mov	 eax, DWORD PTR footer_bits$33459[rsp]
  00186	83 e8 04	 sub	 eax, 4
  00189	89 44 24 60	 mov	 DWORD PTR $T83771[rsp], eax
$LN45@match:
  0018d	8b 44 24 60	 mov	 eax, DWORD PTR $T83771[rsp]
  00191	83 e8 01	 sub	 eax, 1
  00194	89 44 24 60	 mov	 DWORD PTR $T83771[rsp], eax
  00198	8b 54 24 38	 mov	 edx, DWORD PTR dist_reduced$33461[rsp]
  0019c	c1 ea 04	 shr	 edx, 4
  0019f	8b 44 24 60	 mov	 eax, DWORD PTR $T83771[rsp]
  001a3	0f b6 c8	 movzx	 ecx, al
  001a6	d3 ea		 shr	 edx, cl
  001a8	83 e2 01	 and	 edx, 1
  001ab	83 c2 02	 add	 edx, 2
  001ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001b6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001c2	89 54 88 28	 mov	 DWORD PTR [rax+rcx*4+40], edx
  001c6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001ce	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001d2	48 83 c1 01	 add	 rcx, 1
  001d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001de	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  001e2	83 7c 24 60 00	 cmp	 DWORD PTR $T83771[rsp], 0
  001e7	75 a4		 jne	 SHORT $LN45@match

; 174  : 			rc_bittree_reverse(
; 175  : 					&coder->rc, coder->dist_align,
; 176  : 					ALIGN_BITS, dist_reduced & ALIGN_MASK);

  001e9	44 8b 4c 24 38	 mov	 r9d, DWORD PTR dist_reduced$33461[rsp]
  001ee	41 83 e1 0f	 and	 r9d, 15
  001f2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  001fa	48 81 c2 e0 71
	00 00		 add	 rdx, 29152		; 000071e0H
  00201	41 b8 04 00 00
	00		 mov	 r8d, 4
  00207	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0020f	e8 00 00 00 00	 call	 rc_bittree_reverse

; 177  : 			++coder->align_price_count;

  00214	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR coder$[rsp]
  0021c	41 8b 8b d8 0e
	01 00		 mov	 ecx, DWORD PTR [r11+69336]
  00223	83 c1 01	 add	 ecx, 1
  00226	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0022e	89 88 d8 0e 01
	00		 mov	 DWORD PTR [rax+69336], ecx
$LN1@match:
$LN3@match:

; 178  : 		}
; 179  : 	}
; 180  : 
; 181  : 	coder->reps[3] = coder->reps[2];

  00234	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0023c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00244	8b 80 ec 02 00
	00		 mov	 eax, DWORD PTR [rax+748]
  0024a	89 81 f0 02 00
	00		 mov	 DWORD PTR [rcx+752], eax

; 182  : 	coder->reps[2] = coder->reps[1];

  00250	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00258	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00260	8b 80 e8 02 00
	00		 mov	 eax, DWORD PTR [rax+744]
  00266	89 81 ec 02 00
	00		 mov	 DWORD PTR [rcx+748], eax

; 183  : 	coder->reps[1] = coder->reps[0];

  0026c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00274	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0027c	8b 80 e4 02 00
	00		 mov	 eax, DWORD PTR [rax+740]
  00282	89 81 e8 02 00
	00		 mov	 DWORD PTR [rcx+744], eax

; 184  : 	coder->reps[0] = distance;

  00288	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00290	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR distance$[rsp]
  00297	89 81 e4 02 00
	00		 mov	 DWORD PTR [rcx+740], eax

; 185  : 	++coder->match_price_count;

  0029d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002a5	8b 88 94 0e 01
	00		 mov	 ecx, DWORD PTR [rax+69268]
  002ab	83 c1 01	 add	 ecx, 1
  002ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002b6	89 88 94 0e 01
	00		 mov	 DWORD PTR [rax+69268], ecx

; 186  :   }
; 187  : }

  002bc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002c3	c3		 ret	 0
match	ENDP
PUBLIC	lzma_lzma_encoder_create
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma_encoder_create DD imagerel $LN14
	DD	imagerel $LN14+369
	DD	imagerel $unwind$lzma_lzma_encoder_create
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_encoder_create DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma_encoder_create
_TEXT	SEGMENT
coder$33650 = 32
log_size$33657 = 40
tv70 = 44
tv93 = 48
coder_ptr$ = 80
allocator$ = 88
options$ = 96
lz_options$ = 104
lzma_lzma_encoder_create PROC				; COMDAT

; 567  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 568  : 	// Allocate lzma_lzma1_encoder if it wasn't already allocated.
; 569  : 	if (*coder_ptr == NULL) {

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00021	75 2f		 jne	 SHORT $LN9@lzma_lzma_@12

; 570  : 		*coder_ptr = lzma_alloc(sizeof(lzma_lzma1_encoder), allocator);

  00023	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00028	b9 e8 ce 03 00	 mov	 ecx, 249576		; 0003cee8H
  0002d	e8 00 00 00 00	 call	 lzma_alloc
  00032	4c 8b d8	 mov	 r11, rax
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0003a	4c 89 18	 mov	 QWORD PTR [rax], r11

; 571  : 		if (*coder_ptr == NULL)

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00042	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00046	75 0a		 jne	 SHORT $LN8@lzma_lzma_@12

; 572  : 			return LZMA_MEM_ERROR;

  00048	b8 05 00 00 00	 mov	 eax, 5
  0004d	e9 1a 01 00 00	 jmp	 $LN10@lzma_lzma_@12
$LN8@lzma_lzma_@12:
$LN9@lzma_lzma_@12:

; 573  : 	}
; 574  : 
; 575  :   { lzma_lzma1_encoder *coder = *coder_ptr;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 89 44 24 20	 mov	 QWORD PTR coder$33650[rsp], rax

; 576  : 
; 577  : 	// Set compression mode. We haven't validates the options yet,
; 578  : 	// but it's OK here, since nothing bad happens with invalid
; 579  : 	// options in the code below, and they will get rejected by
; 580  : 	// lzma_lzma_encoder_reset() call at the end of this function.
; 581  : 	switch (options->mode) {

  0005f	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00064	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00067	89 44 24 2c	 mov	 DWORD PTR tv70[rsp], eax
  0006b	83 7c 24 2c 01	 cmp	 DWORD PTR tv70[rsp], 1
  00070	74 0c		 je	 SHORT $LN5@lzma_lzma_@12
  00072	83 7c 24 2c 02	 cmp	 DWORD PTR tv70[rsp], 2
  00077	74 13		 je	 SHORT $LN4@lzma_lzma_@12
  00079	e9 84 00 00 00	 jmp	 $LN1@lzma_lzma_@12
$LN5@lzma_lzma_@12:

; 582  : 		case LZMA_MODE_FAST:
; 583  : 			coder->fast_mode = true;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  00083	c6 80 8c 0b 00
	00 01		 mov	 BYTE PTR [rax+2956], 1

; 584  : 			break;

  0008a	eb 7d		 jmp	 SHORT $LN6@lzma_lzma_@12
$LN4@lzma_lzma_@12:

; 585  : 
; 586  : 		case LZMA_MODE_NORMAL: {
; 587  : 			coder->fast_mode = false;

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  00091	c6 80 8c 0b 00
	00 00		 mov	 BYTE PTR [rax+2956], 0

; 588  : 
; 589  : 			// Set dist_table_size.
; 590  : 			// Round the dictionary size up to next 2^n.
; 591  : 		  { uint32_t log_size = 0;

  00098	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR log_size$33657[rsp], 0
$LN3@lzma_lzma_@12:

; 592  : 			while ((UINT32_C(1) << log_size) < options->dict_size)

  000a0	8b 4c 24 28	 mov	 ecx, DWORD PTR log_size$33657[rsp]
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	d3 e0		 shl	 eax, cl
  000ab	8b c8		 mov	 ecx, eax
  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  000b2	3b 08		 cmp	 ecx, DWORD PTR [rax]
  000b4	73 0d		 jae	 SHORT $LN2@lzma_lzma_@12

; 593  : 				++log_size;

  000b6	8b 44 24 28	 mov	 eax, DWORD PTR log_size$33657[rsp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 44 24 28	 mov	 DWORD PTR log_size$33657[rsp], eax
  000c1	eb dd		 jmp	 SHORT $LN3@lzma_lzma_@12
$LN2@lzma_lzma_@12:

; 594  : 
; 595  : 			coder->dist_table_size = log_size * 2;

  000c3	8b 4c 24 28	 mov	 ecx, DWORD PTR log_size$33657[rsp]
  000c7	d1 e1		 shl	 ecx, 1
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  000ce	89 88 90 0e 01
	00		 mov	 DWORD PTR [rax+69264], ecx

; 596  : 		  }
; 597  : 
; 598  : 			// Length encoders' price table size
; 599  : 			coder->match_len_encoder.table_size
; 600  : 				= options->nice_len + 1 - MATCH_LEN_MIN;

  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  000d9	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  000dc	83 e9 01	 sub	 ecx, 1
  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  000e4	89 88 04 ba 00
	00		 mov	 DWORD PTR [rax+47620], ecx

; 601  : 			coder->rep_len_encoder.table_size
; 602  : 				= options->nice_len + 1 - MATCH_LEN_MIN;

  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  000ef	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  000f2	83 e9 01	 sub	 ecx, 1
  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  000fa	89 88 4c 02 01
	00		 mov	 DWORD PTR [rax+66124], ecx

; 603  : 			break;

  00100	eb 07		 jmp	 SHORT $LN6@lzma_lzma_@12
$LN1@lzma_lzma_@12:

; 604  : 		}
; 605  : 
; 606  : 		default:
; 607  : 			return LZMA_OPTIONS_ERROR;

  00102	b8 08 00 00 00	 mov	 eax, 8
  00107	eb 63		 jmp	 SHORT $LN10@lzma_lzma_@12
$LN6@lzma_lzma_@12:

; 608  : 	}
; 609  : 
; 610  : 	// We don't need to write the first byte as literal if there is
; 611  : 	// a non-empty preset dictionary. encode_init() wouldn't even work
; 612  : 	// if there is a non-empty preset dictionary, because encode_init()
; 613  : 	// assumes that position is zero and previous byte is also zero.
; 614  : 	coder->is_initialized = options->preset_dict != NULL
; 615  : 			&& options->preset_dict_size > 0;

  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0010e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00113	74 15		 je	 SHORT $LN12@lzma_lzma_@12
  00115	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0011a	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0011e	76 0a		 jbe	 SHORT $LN12@lzma_lzma_@12
  00120	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  00128	eb 08		 jmp	 SHORT $LN13@lzma_lzma_@12
$LN12@lzma_lzma_@12:
  0012a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN13@lzma_lzma_@12:
  00132	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33650[rsp]
  00137	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv93[rsp]
  0013c	88 81 8d 0b 00
	00		 mov	 BYTE PTR [rcx+2957], al

; 616  : 	coder->is_flushed = false;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33650[rsp]
  00147	c6 80 8e 0b 00
	00 00		 mov	 BYTE PTR [rax+2958], 0

; 617  : 
; 618  : 	set_lz_options(lz_options, options);

  0014e	48 8b 54 24 60	 mov	 rdx, QWORD PTR options$[rsp]
  00153	48 8b 4c 24 68	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00158	e8 00 00 00 00	 call	 set_lz_options

; 619  : 
; 620  : 	return lzma_lzma_encoder_reset(coder, options);

  0015d	48 8b 54 24 60	 mov	 rdx, QWORD PTR options$[rsp]
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33650[rsp]
  00167	e8 00 00 00 00	 call	 lzma_lzma_encoder_reset
$LN10@lzma_lzma_@12:

; 621  :   }
; 622  : }

  0016c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00170	c3		 ret	 0
lzma_lzma_encoder_create ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$encode_eopm DD imagerel encode_eopm
	DD	imagerel encode_eopm+336
	DD	imagerel $unwind$encode_eopm
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_eopm DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT encode_eopm
_TEXT	SEGMENT
pos_state$ = 32
$T83986 = 40
$T83990 = 48
coder$ = 128
position$ = 136
encode_eopm PROC					; COMDAT

; 302  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 303  : 	const uint32_t pos_state = position & coder->pos_mask;

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00015	8b 88 90 0b 00
	00		 mov	 ecx, DWORD PTR [rax+2960]
  0001b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  00022	23 c1		 and	 eax, ecx
  00024	89 44 24 20	 mov	 DWORD PTR pos_state$[rsp], eax

; 304  : 	rc_bit(&coder->rc, &coder->is_match[coder->state][pos_state], 1);

  00028	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  0002c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00034	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  0003b	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00047	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  0004f	48 8d 04 50	 lea	 rax, QWORD PTR [rax+rdx*2]
  00053	48 89 44 24 28	 mov	 QWORD PTR $T83986[rsp], rax
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00060	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00064	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0006c	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  00074	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  0007c	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR $T83986[rsp]
  0008d	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  00095	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0009d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a1	48 83 c1 01	 add	 rcx, 1
  000a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000ad	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 305  : 	rc_bit(&coder->rc, &coder->is_rep[coder->state], 0);

  000b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000b9	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  000c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000c8	48 8d 84 48 1c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27932]
  000d0	48 89 44 24 30	 mov	 QWORD PTR $T83990[rsp], rax
  000d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000dd	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000e9	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  000f1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  000f9	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  000fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR $T83990[rsp]
  0010a	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  00112	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0011a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0011e	48 83 c1 01	 add	 rcx, 1
  00122	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0012a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 306  : 	match(coder, pos_state, UINT32_MAX, MATCH_LEN_MIN);

  0012e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00134	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0013a	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  0013e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00146	e8 00 00 00 00	 call	 match

; 307  : }

  0014b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0014f	c3		 ret	 0
encode_eopm ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$encode_symbol DD imagerel encode_symbol
	DD	imagerel encode_symbol+754
	DD	imagerel $unwind$encode_symbol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_symbol DD 021b01H
	DD	015011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT encode_symbol
_TEXT	SEGMENT
pos_state$ = 32
$T84028 = 40
$T84046 = 72
$T84050 = 80
$T84070 = 120
coder$ = 176
mf$ = 184
back$ = 192
len$ = 200
position$ = 208
encode_symbol PROC					; COMDAT

; 241  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 242  : 	const uint32_t pos_state = position & coder->pos_mask;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00023	8b 88 90 0b 00
	00		 mov	 ecx, DWORD PTR [rax+2960]
  00029	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR position$[rsp]
  00030	23 c1		 and	 eax, ecx
  00032	89 44 24 20	 mov	 DWORD PTR pos_state$[rsp], eax

; 243  : 
; 244  : 	if (back == UINT32_MAX) {

  00036	83 bc 24 c0 00
	00 00 ff	 cmp	 DWORD PTR back$[rsp], -1 ; ffffffffH
  0003e	0f 85 ab 00 00
	00		 jne	 $LN4@encode_sym

; 245  : 		// Literal i.e. eight-bit byte
; 246  : 		assert(len == 1);
; 247  : 		rc_bit(&coder->rc,
; 248  : 				&coder->is_match[coder->state][pos_state], 0);

  00044	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  00048	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00050	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00057	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0005b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00063	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  0006b	48 8d 04 50	 lea	 rax, QWORD PTR [rax+rdx*2]
  0006f	48 89 44 24 28	 mov	 QWORD PTR $T84028[rsp], rax
  00074	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0007c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00080	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00088	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00090	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00098	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0009c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR $T84028[rsp]
  000a9	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  000b1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000b9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000bd	48 83 c1 01	 add	 rcx, 1
  000c1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000c9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 249  : 		literal(coder, mf, position);

  000cd	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR position$[rsp]
  000d5	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  000dd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000e5	e8 00 00 00 00	 call	 literal

; 250  : 	} else {

  000ea	e9 dc 01 00 00	 jmp	 $LN3@encode_sym
$LN4@encode_sym:

; 251  : 		// Some type of match
; 252  : 		rc_bit(&coder->rc,
; 253  : 			&coder->is_match[coder->state][pos_state], 1);

  000ef	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  000f3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000fb	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00102	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00106	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0010e	48 8d 84 08 9c
	6b 00 00	 lea	 rax, QWORD PTR [rax+rcx+27548]
  00116	48 8d 04 50	 lea	 rax, QWORD PTR [rax+rdx*2]
  0011a	48 89 44 24 48	 mov	 QWORD PTR $T84046[rsp], rax
  0011f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00127	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0012b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00133	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  0013b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00143	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00147	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0014f	48 8b 44 24 48	 mov	 rax, QWORD PTR $T84046[rsp]
  00154	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  0015c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00164	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00168	48 83 c1 01	 add	 rcx, 1
  0016c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00174	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 254  : 
; 255  : 		if (back < REPS) {

  00178	83 bc 24 c0 00
	00 00 04	 cmp	 DWORD PTR back$[rsp], 4
  00180	0f 83 a3 00 00
	00		 jae	 $LN2@encode_sym

; 256  : 			// It's a repeated match i.e. the same distance
; 257  : 			// has been used earlier.
; 258  : 			rc_bit(&coder->rc, &coder->is_rep[coder->state], 1);

  00186	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0018e	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00195	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0019d	48 8d 84 48 1c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27932]
  001a5	48 89 44 24 50	 mov	 QWORD PTR $T84050[rsp], rax
  001aa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001b2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001be	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 1
  001c6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  001ce	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  001d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001da	48 8b 44 24 50	 mov	 rax, QWORD PTR $T84050[rsp]
  001df	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  001e7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001ef	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001f3	48 83 c1 01	 add	 rcx, 1
  001f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001ff	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 259  : 			rep_match(coder, pos_state, back, len);

  00203	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0020b	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR back$[rsp]
  00213	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  00217	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0021f	e8 00 00 00 00	 call	 rep_match

; 260  : 		} else {

  00224	e9 a2 00 00 00	 jmp	 $LN1@encode_sym
$LN2@encode_sym:

; 261  : 			// Normal match
; 262  : 			rc_bit(&coder->rc, &coder->is_rep[coder->state], 0);

  00229	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00231	48 63 88 e0 02
	00 00		 movsxd	 rcx, DWORD PTR [rax+736]
  00238	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00240	48 8d 84 48 1c
	6d 00 00	 lea	 rax, QWORD PTR [rax+rcx*2+27932]
  00248	48 89 44 24 78	 mov	 QWORD PTR $T84070[rsp], rax
  0024d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00255	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00259	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00261	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+40], 0
  00269	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR coder$[rsp]
  00271	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00275	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0027d	48 8b 44 24 78	 mov	 rax, QWORD PTR $T84070[rsp]
  00282	48 89 84 d1 10
	01 00 00	 mov	 QWORD PTR [rcx+rdx*8+272], rax
  0028a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00292	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00296	48 83 c1 01	 add	 rcx, 1
  0029a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002a2	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 263  : 			match(coder, pos_state, back - REPS, len);

  002a6	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR back$[rsp]
  002ae	41 83 e8 04	 sub	 r8d, 4
  002b2	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  002ba	8b 54 24 20	 mov	 edx, DWORD PTR pos_state$[rsp]
  002be	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002c6	e8 00 00 00 00	 call	 match
$LN1@encode_sym:
$LN3@encode_sym:

; 264  : 		}
; 265  : 	}
; 266  : 
; 267  : 	assert(mf->read_ahead >= len);
; 268  : 	mf->read_ahead -= len;

  002cb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  002d3	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002da	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  002dd	2b c8		 sub	 ecx, eax
  002df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002e7	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 269  : }

  002ea	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002f1	c3		 ret	 0
encode_symbol ENDP
PUBLIC	lzma_lzma_encode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\rangecoder\range_encoder.h
pdata	SEGMENT
$pdata$lzma_lzma_encode DD imagerel $LN88
	DD	imagerel $LN88+536
	DD	imagerel $unwind$lzma_lzma_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_encode DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma_encoder.c
xdata	ENDS
;	COMDAT lzma_lzma_encode
_TEXT	SEGMENT
position$33534 = 48
len$33545 = 52
back$33546 = 56
coder$ = 112
mf$ = 120
out$ = 128
out_pos$ = 136
out_size$ = 144
limit$ = 152
lzma_lzma_encode PROC					; COMDAT

; 320  : {

$LN88:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 321  : 	// Initialize the stream if no data has been encoded yet.
; 322  : 	if (!coder->is_initialized && !encode_init(coder, mf))

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0001d	0f b6 80 8d 0b
	00 00		 movzx	 eax, BYTE PTR [rax+2957]
  00024	85 c0		 test	 eax, eax
  00026	75 1d		 jne	 SHORT $LN14@lzma_lzma_@13
  00028	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00032	e8 00 00 00 00	 call	 encode_init
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 07		 jne	 SHORT $LN14@lzma_lzma_@13

; 323  : 		return LZMA_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 ce 01 00 00	 jmp	 $LN15@lzma_lzma_@13
$LN14@lzma_lzma_@13:

; 324  : 
; 325  : 	// Get the lowest bits of the uncompressed offset from the LZ layer.
; 326  :   { uint32_t position = mf_position(mf);

  00045	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  0004a	48 8b 44 24 78	 mov	 rax, QWORD PTR mf$[rsp]
  0004f	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00052	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00055	2b c1		 sub	 eax, ecx
  00057	89 44 24 30	 mov	 DWORD PTR position$33534[rsp], eax
$LN13@lzma_lzma_@13:

; 327  : 
; 328  : 	while (true) {

  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 84 31 01 00
	00		 je	 $LN12@lzma_lzma_@13

; 329  : 		// Encode pending bits, if any. Calling this before encoding
; 330  : 		// the next symbol is needed only with plain LZMA, since
; 331  : 		// LZMA2 always provides big enough buffer to flush
; 332  : 		// everything out from the range encoder. For the same reason,
; 333  : 		// rc_encode() never returns true when this function is used
; 334  : 		// as part of LZMA2 encoder.
; 335  : 		if (rc_encode(&coder->rc, out, out_pos, out_size)) {

  00066	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR out_size$[rsp]
  0006e	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR out_pos$[rsp]
  00076	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00083	e8 00 00 00 00	 call	 rc_encode
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	74 07		 je	 SHORT $LN11@lzma_lzma_@13

; 336  : 			assert(limit == UINT32_MAX);
; 337  : 			return LZMA_OK;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 7d 01 00 00	 jmp	 $LN15@lzma_lzma_@13
$LN11@lzma_lzma_@13:

; 338  : 		}
; 339  : 
; 340  : 		// With LZMA2 we need to take care that compressed size of
; 341  : 		// a chunk doesn't get too big.
; 342  : 		// FIXME? Check if this could be improved.
; 343  : 		if (limit != UINT32_MAX
; 344  : 				&& (mf->read_pos - mf->read_ahead >= limit
; 345  : 					|| *out_pos + rc_pending(&coder->rc)
; 346  : 						>= LZMA2_CHUNK_MAX
; 347  : 							- LOOP_INPUT_MAX))

  00096	83 bc 24 98 00
	00 00 ff	 cmp	 DWORD PTR limit$[rsp], -1 ; ffffffffH
  0009e	74 41		 je	 SHORT $LN10@lzma_lzma_@13
  000a0	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  000a5	48 8b 44 24 78	 mov	 rax, QWORD PTR mf$[rsp]
  000aa	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  000ad	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  000b0	2b c1		 sub	 eax, ecx
  000b2	3b 84 24 98 00
	00 00		 cmp	 eax, DWORD PTR limit$[rsp]
  000b9	73 21		 jae	 SHORT $LN9@lzma_lzma_@13
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  000c0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000c4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  000d4	48 3d ff ef 00
	00		 cmp	 rax, 61439		; 0000efffH
  000da	72 05		 jb	 SHORT $LN10@lzma_lzma_@13
$LN9@lzma_lzma_@13:

; 348  : 			break;

  000dc	e9 b6 00 00 00	 jmp	 $LN12@lzma_lzma_@13
$LN10@lzma_lzma_@13:

; 349  : 
; 350  : 		// Check that there is some input to process.
; 351  : 		if (mf->read_pos >= mf->read_limit) {

  000e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR mf$[rsp]
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR mf$[rsp]
  000eb	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000ee	39 41 18	 cmp	 DWORD PTR [rcx+24], eax
  000f1	72 22		 jb	 SHORT $LN8@lzma_lzma_@13

; 352  : 			if (mf->action == LZMA_RUN)

  000f3	48 8b 44 24 78	 mov	 rax, QWORD PTR mf$[rsp]
  000f8	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000fc	75 07		 jne	 SHORT $LN7@lzma_lzma_@13

; 353  : 				return LZMA_OK;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 0e 01 00 00	 jmp	 $LN15@lzma_lzma_@13
$LN7@lzma_lzma_@13:

; 354  : 
; 355  : 			if (mf->read_ahead == 0)

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR mf$[rsp]
  0010a	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0010e	75 05		 jne	 SHORT $LN6@lzma_lzma_@13

; 356  : 				break;

  00110	e9 82 00 00 00	 jmp	 $LN12@lzma_lzma_@13
$LN6@lzma_lzma_@13:
$LN8@lzma_lzma_@13:

; 357  : 		}
; 358  : 
; 359  : 		// Get optimal match (repeat position and length).
; 360  : 		// Value ranges for pos:
; 361  : 		//   - [0, REPS): repeated match
; 362  : 		//   - [REPS, UINT32_MAX):
; 363  : 		//     match at (pos - REPS)
; 364  : 		//   - UINT32_MAX: not a match but a literal
; 365  : 		// Value ranges for len:
; 366  : 		//   - [MATCH_LEN_MIN, MATCH_LEN_MAX]
; 367  :       {
; 368  : 		uint32_t len;
; 369  : 		uint32_t back;
; 370  : 
; 371  : 		if (coder->fast_mode)

  00115	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0011a	0f b6 80 8c 0b
	00 00		 movzx	 eax, BYTE PTR [rax+2956]
  00121	85 c0		 test	 eax, eax
  00123	74 1b		 je	 SHORT $LN5@lzma_lzma_@13

; 372  : 			lzma_lzma_optimum_fast(coder, mf, &back, &len);

  00125	4c 8d 4c 24 34	 lea	 r9, QWORD PTR len$33545[rsp]
  0012a	4c 8d 44 24 38	 lea	 r8, QWORD PTR back$33546[rsp]
  0012f	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  00134	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00139	e8 00 00 00 00	 call	 lzma_lzma_optimum_fast

; 373  : 		else

  0013e	eb 21		 jmp	 SHORT $LN4@lzma_lzma_@13
$LN5@lzma_lzma_@13:

; 374  : 			lzma_lzma_optimum_normal(
; 375  : 					coder, mf, &back, &len, position);

  00140	8b 44 24 30	 mov	 eax, DWORD PTR position$33534[rsp]
  00144	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00148	4c 8d 4c 24 34	 lea	 r9, QWORD PTR len$33545[rsp]
  0014d	4c 8d 44 24 38	 lea	 r8, QWORD PTR back$33546[rsp]
  00152	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  00157	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  0015c	e8 00 00 00 00	 call	 lzma_lzma_optimum_normal
$LN4@lzma_lzma_@13:

; 376  : 
; 377  : 		encode_symbol(coder, mf, back, len, position);

  00161	8b 44 24 30	 mov	 eax, DWORD PTR position$33534[rsp]
  00165	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00169	44 8b 4c 24 34	 mov	 r9d, DWORD PTR len$33545[rsp]
  0016e	44 8b 44 24 38	 mov	 r8d, DWORD PTR back$33546[rsp]
  00173	48 8b 54 24 78	 mov	 rdx, QWORD PTR mf$[rsp]
  00178	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  0017d	e8 00 00 00 00	 call	 encode_symbol

; 378  : 
; 379  : 		position += len;

  00182	44 8b 5c 24 34	 mov	 r11d, DWORD PTR len$33545[rsp]
  00187	8b 44 24 30	 mov	 eax, DWORD PTR position$33534[rsp]
  0018b	41 03 c3	 add	 eax, r11d
  0018e	89 44 24 30	 mov	 DWORD PTR position$33534[rsp], eax

; 380  : 	  }
; 381  : 	}

  00192	e9 c4 fe ff ff	 jmp	 $LN13@lzma_lzma_@13
$LN12@lzma_lzma_@13:

; 382  : 
; 383  : 	if (!coder->is_flushed) {

  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0019c	0f b6 80 8e 0b
	00 00		 movzx	 eax, BYTE PTR [rax+2958]
  001a3	85 c0		 test	 eax, eax
  001a5	75 5b		 jne	 SHORT $LN3@lzma_lzma_@13

; 384  : 		coder->is_flushed = true;

  001a7	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  001ac	c6 80 8e 0b 00
	00 01		 mov	 BYTE PTR [rax+2958], 1

; 385  : 
; 386  : 		// We don't support encoding plain LZMA streams without EOPM,
; 387  : 		// and LZMA2 doesn't use EOPM at LZMA level.
; 388  : 		if (limit == UINT32_MAX)

  001b3	83 bc 24 98 00
	00 00 ff	 cmp	 DWORD PTR limit$[rsp], -1 ; ffffffffH
  001bb	75 0e		 jne	 SHORT $LN2@lzma_lzma_@13

; 389  : 			encode_eopm(coder, position);

  001bd	8b 54 24 30	 mov	 edx, DWORD PTR position$33534[rsp]
  001c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  001c6	e8 00 00 00 00	 call	 encode_eopm
$LN2@lzma_lzma_@13:

; 390  : 
; 391  : 		// Flush the remaining bytes from the range encoder.
; 392  : 		rc_flush(&coder->rc);

  001cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  001d0	e8 00 00 00 00	 call	 rc_flush

; 393  : 
; 394  : 		// Copy the remaining bytes to the output buffer. If there
; 395  : 		// isn't enough output space, we will copy out the remaining
; 396  : 		// bytes on the next call to this function by using
; 397  : 		// the rc_encode() call in the encoding loop above.
; 398  : 		if (rc_encode(&coder->rc, out, out_pos, out_size)) {

  001d5	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR out_size$[rsp]
  001dd	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR out_pos$[rsp]
  001e5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  001f2	e8 00 00 00 00	 call	 rc_encode
  001f7	0f b6 c0	 movzx	 eax, al
  001fa	85 c0		 test	 eax, eax
  001fc	74 04		 je	 SHORT $LN1@lzma_lzma_@13

; 399  : 			assert(limit == UINT32_MAX);
; 400  : 			return LZMA_OK;

  001fe	33 c0		 xor	 eax, eax
  00200	eb 11		 jmp	 SHORT $LN15@lzma_lzma_@13
$LN1@lzma_lzma_@13:
$LN3@lzma_lzma_@13:

; 401  : 		}
; 402  :   }
; 403  :   }
; 404  : 
; 405  : 	// Make it ready for the next LZMA2 chunk.
; 406  : 	coder->is_flushed = false;

  00202	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00207	c6 80 8e 0b 00
	00 00		 mov	 BYTE PTR [rax+2958], 0

; 407  : 
; 408  : 	return LZMA_STREAM_END;

  0020e	b8 01 00 00 00	 mov	 eax, 1
$LN15@lzma_lzma_@13:

; 409  : }

  00213	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00217	c3		 ret	 0
lzma_lzma_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_encode DD imagerel lzma_encode
	DD	imagerel lzma_encode+90
	DD	imagerel $unwind$lzma_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_encode DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_encode
_TEXT	SEGMENT
coder$ = 64
mf$ = 72
out$ = 80
out_pos$ = 88
out_size$ = 96
lzma_encode PROC					; COMDAT

; 416  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 417  : 	// Plain LZMA has no support for sync-flushing.
; 418  : 	if (unlikely(mf->action == LZMA_SYNC_FLUSH))

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR mf$[rsp]
  0001d	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  00021	75 07		 jne	 SHORT $LN1@lzma_encod

; 419  : 		return LZMA_OPTIONS_ERROR;

  00023	b8 08 00 00 00	 mov	 eax, 8
  00028	eb 2b		 jmp	 SHORT $LN2@lzma_encod
$LN1@lzma_encod:

; 420  : 
; 421  : 	return lzma_lzma_encode(coder, mf, out, out_pos, out_size, UINT32_MAX);

  0002a	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1	; ffffffffH
  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR out_size$[rsp]
  00037	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR out_pos$[rsp]
  00041	4c 8b 44 24 50	 mov	 r8, QWORD PTR out$[rsp]
  00046	48 8b 54 24 48	 mov	 rdx, QWORD PTR mf$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00050	e8 00 00 00 00	 call	 lzma_lzma_encode
$LN2@lzma_encod:

; 422  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
lzma_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_encoder_init DD imagerel lzma_encoder_init
	DD	imagerel lzma_encoder_init+70
	DD	imagerel $unwind$lzma_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_encoder_init DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_encoder_init
_TEXT	SEGMENT
lz$ = 48
allocator$ = 56
options$ = 64
lz_options$ = 72
lzma_encoder_init PROC					; COMDAT

; 628  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 629  : 	lz->code = &lzma_encode;

  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_encode
  00024	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 630  : 	return lzma_lzma_encoder_create(
; 631  : 			&lz->coder, allocator, options, lz_options);

  00028	4c 8b 4c 24 48	 mov	 r9, QWORD PTR lz_options$[rsp]
  0002d	4c 8b 44 24 40	 mov	 r8, QWORD PTR options$[rsp]
  00032	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0003c	e8 00 00 00 00	 call	 lzma_lzma_encoder_create

; 632  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
lzma_encoder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma_encoder_init DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$lzma_lzma_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma_encoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma_encoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_lzma_encoder_init PROC				; COMDAT

; 638  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 639  : 	return lzma_lz_encoder_init(
; 640  : 			next, allocator, filters, &lzma_encoder_init);

  00013	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:lzma_encoder_init
  0001a	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00029	e8 00 00 00 00	 call	 lzma_lz_encoder_init

; 641  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
lzma_lzma_encoder_init ENDP
END
