; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_armthumb_decoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\armthumb.c
pdata	SEGMENT
$pdata$armthumb_code DD imagerel armthumb_code
	DD	imagerel armthumb_code+420
	DD	imagerel $unwind$armthumb_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$armthumb_code DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT armthumb_code
_TEXT	SEGMENT
i$ = 0
src$32958 = 8
dest$32959 = 12
simple$ = 32
now_pos$ = 40
is_encoder$ = 48
buffer$ = 56
size$ = 64
armthumb_code PROC					; COMDAT

; 21   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 22   : 	size_t i;
; 23   : 	for (i = 0; i + 4 <= size; i += 2) {

  00017	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001f	eb 0c		 jmp	 SHORT $LN6@armthumb_c
$LN5@armthumb_c:
  00021	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00025	48 83 c0 02	 add	 rax, 2
  00029	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN6@armthumb_c:
  0002d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00031	48 83 c0 04	 add	 rax, 4
  00035	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0003a	0f 87 5b 01 00
	00		 ja	 $LN4@armthumb_c

; 24   : 		if ((buffer[i + 1] & 0xF8) == 0xF0
; 25   : 				&& (buffer[i + 3] & 0xF8) == 0xF8) {

  00040	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00044	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00049	48 03 c1	 add	 rax, rcx
  0004c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00050	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00055	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0005a	0f 85 36 01 00
	00		 jne	 $LN3@armthumb_c
  00060	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00069	48 03 c1	 add	 rax, rcx
  0006c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00070	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00075	3d f8 00 00 00	 cmp	 eax, 248		; 000000f8H
  0007a	0f 85 16 01 00
	00		 jne	 $LN3@armthumb_c

; 26   : 			uint32_t src = ((buffer[i + 1] & 0x7) << 19)
; 27   : 					| (buffer[i + 0] << 11)
; 28   : 					| ((buffer[i + 3] & 0x7) << 8)
; 29   : 					| (buffer[i + 2]);

  00080	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00084	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00089	48 03 c1	 add	 rax, rcx
  0008c	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00090	83 e2 07	 and	 edx, 7
  00093	c1 e2 13	 shl	 edx, 19
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0009f	48 03 c1	 add	 rax, rcx
  000a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a5	c1 e0 0b	 shl	 eax, 11
  000a8	0b d0		 or	 edx, eax
  000aa	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000b3	48 03 c1	 add	 rax, rcx
  000b6	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000ba	83 e0 07	 and	 eax, 7
  000bd	c1 e0 08	 shl	 eax, 8
  000c0	0b d0		 or	 edx, eax
  000c2	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000c6	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000cb	48 03 c1	 add	 rax, rcx
  000ce	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000d2	8b c2		 mov	 eax, edx
  000d4	0b c1		 or	 eax, ecx
  000d6	89 44 24 08	 mov	 DWORD PTR src$32958[rsp], eax

; 30   : 
; 31   : 			src <<= 1;

  000da	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  000de	03 c0		 add	 eax, eax
  000e0	89 44 24 08	 mov	 DWORD PTR src$32958[rsp], eax

; 32   : 
; 33   :           { uint32_t dest;
; 34   : 			if (is_encoder)

  000e4	0f b6 44 24 30	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  000e9	85 c0		 test	 eax, eax
  000eb	74 17		 je	 SHORT $LN2@armthumb_c

; 35   : 				dest = now_pos + (uint32_t)(i) + 4 + src;

  000ed	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000f0	8b 4c 24 28	 mov	 ecx, DWORD PTR now_pos$[rsp]
  000f4	03 c8		 add	 ecx, eax
  000f6	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  000fa	8d 44 01 04	 lea	 eax, DWORD PTR [rcx+rax+4]
  000fe	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax

; 36   : 			else

  00102	eb 15		 jmp	 SHORT $LN1@armthumb_c
$LN2@armthumb_c:

; 37   : 				dest = src - (now_pos + (uint32_t)(i) + 4);

  00104	8b 4c 24 28	 mov	 ecx, DWORD PTR now_pos$[rsp]
  00108	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0010b	8d 4c 01 04	 lea	 ecx, DWORD PTR [rcx+rax+4]
  0010f	8b 44 24 08	 mov	 eax, DWORD PTR src$32958[rsp]
  00113	2b c1		 sub	 eax, ecx
  00115	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax
$LN1@armthumb_c:

; 38   : 
; 39   : 			dest >>= 1;

  00119	8b 44 24 0c	 mov	 eax, DWORD PTR dest$32959[rsp]
  0011d	d1 e8		 shr	 eax, 1
  0011f	89 44 24 0c	 mov	 DWORD PTR dest$32959[rsp], eax

; 40   : 			buffer[i + 1] = 0xF0 | ((dest >> 19) & 0x7);

  00123	8b 54 24 0c	 mov	 edx, DWORD PTR dest$32959[rsp]
  00127	c1 ea 13	 shr	 edx, 19
  0012a	83 e2 07	 and	 edx, 7
  0012d	81 ca f0 00 00
	00		 or	 edx, 240		; 000000f0H
  00133	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00137	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0013c	48 03 c1	 add	 rax, rcx
  0013f	88 50 01	 mov	 BYTE PTR [rax+1], dl

; 41   : 			buffer[i + 0] = (dest >> 11);

  00142	8b 54 24 0c	 mov	 edx, DWORD PTR dest$32959[rsp]
  00146	c1 ea 0b	 shr	 edx, 11
  00149	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0014d	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00152	48 03 c1	 add	 rax, rcx
  00155	88 10		 mov	 BYTE PTR [rax], dl

; 42   : 			buffer[i + 3] = 0xF8 | ((dest >> 8) & 0x7);

  00157	8b 54 24 0c	 mov	 edx, DWORD PTR dest$32959[rsp]
  0015b	c1 ea 08	 shr	 edx, 8
  0015e	83 e2 07	 and	 edx, 7
  00161	81 ca f8 00 00
	00		 or	 edx, 248		; 000000f8H
  00167	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0016b	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00170	48 03 c1	 add	 rax, rcx
  00173	88 50 03	 mov	 BYTE PTR [rax+3], dl

; 43   : 			buffer[i + 2] = (dest);

  00176	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  0017a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buffer$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	0f b6 44 24 0c	 movzx	 eax, BYTE PTR dest$32959[rsp]
  00187	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 44   : 			i += 2;

  0018a	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  0018e	48 83 c0 02	 add	 rax, 2
  00192	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@armthumb_c:

; 45   : 		  }
; 46   : 		}
; 47   : 	}

  00196	e9 86 fe ff ff	 jmp	 $LN5@armthumb_c
$LN4@armthumb_c:

; 48   : 
; 49   : 	return i;

  0019b	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]

; 50   : }

  0019f	48 83 c4 18	 add	 rsp, 24
  001a3	c3		 ret	 0
armthumb_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$armthumb_coder_init DD imagerel armthumb_coder_init
	DD	imagerel armthumb_coder_init+91
	DD	imagerel $unwind$armthumb_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$armthumb_coder_init DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT armthumb_coder_init
_TEXT	SEGMENT
next$ = 80
allocator$ = 88
filters$ = 96
is_encoder$ = 104
armthumb_coder_init PROC				; COMDAT

; 56   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 57   : 	return lzma_simple_coder_init(next, allocator, filters,
; 58   : 			&armthumb_code, 0, 4, 2, is_encoder);

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0001d	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00021	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  00029	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR [rsp+40], 4
  00032	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:armthumb_code
  00042	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  00047	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00051	e8 00 00 00 00	 call	 lzma_simple_coder_init

; 59   : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
armthumb_coder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_armthumb_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$lzma_simple_armthumb_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_armthumb_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_armthumb_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_simple_armthumb_decoder_init PROC			; COMDAT

; 75   : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 76   : 	return armthumb_coder_init(next, allocator, filters, false);

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00025	e8 00 00 00 00	 call	 armthumb_coder_init

; 77   : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
lzma_simple_armthumb_decoder_init ENDP
END
