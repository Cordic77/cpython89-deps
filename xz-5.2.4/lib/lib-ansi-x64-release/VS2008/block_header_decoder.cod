; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$read32le DD imagerel read32le
	DD	imagerel read32le+27
	DD	imagerel $unwind$read32le
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read32le DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read32le
_TEXT	SEGMENT
num$ = 0
buf$ = 32
read32le PROC						; COMDAT

; 220  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 221  : 	uint32_t num = *(const uint32_t *)buf;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR num$[rsp], eax

; 222  : 	return conv32le(num);

  00013	8b 04 24	 mov	 eax, DWORD PTR num$[rsp]

; 223  : }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
read32le ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_header_decoder.c
pdata	SEGMENT
$pdata$free_properties DD imagerel free_properties
	DD	imagerel free_properties+140
	DD	imagerel $unwind$free_properties
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_properties DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT free_properties
_TEXT	SEGMENT
i$ = 32
block$ = 64
allocator$ = 72
free_properties PROC					; COMDAT

; 19   : {	size_t i;

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   : 
; 21   : 	// Free allocated filter options. The last array member is not
; 22   : 	// touched after the initialization in the beginning of
; 23   : 	// lzma_block_header_decode(), so we don't need to touch that here.
; 24   : 	for (i = 0; i < LZMA_FILTERS_MAX; ++i) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0e		 jmp	 SHORT $LN3@free_prope
$LN2@free_prope:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 83 c0 01	 add	 rax, 1
  00022	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@free_prope:
  00027	48 83 7c 24 20
	04		 cmp	 QWORD PTR i$[rsp], 4
  0002d	73 58		 jae	 SHORT $LN1@free_prope

; 25   : 		lzma_free(block->filters[i].options, allocator);

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00034	48 6b c0 10	 imul	 rax, 16
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR block$[rsp]
  0003d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00046	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0004b	e8 00 00 00 00	 call	 lzma_free

; 26   : 		block->filters[i].id = LZMA_VLI_UNKNOWN;

  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00055	48 6b c9 10	 imul	 rcx, 16
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  0005e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00062	48 c7 04 01 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax], -1

; 27   : 		block->filters[i].options = NULL;

  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0006f	48 6b c9 10	 imul	 rcx, 16
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR block$[rsp]
  00078	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007c	48 c7 44 08 08
	00 00 00 00	 mov	 QWORD PTR [rax+rcx+8], 0

; 28   : 	}

  00085	eb 92		 jmp	 SHORT $LN2@free_prope
$LN1@free_prope:

; 29   : 
; 30   : 	return;
; 31   : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
free_properties ENDP
PUBLIC	lzma_block_header_decode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$lzma_block_header_decode DD imagerel $LN33
	DD	imagerel $LN33+813
	DD	imagerel $unwind$lzma_block_header_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_header_decode DD 011301H
	DD	0e213H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_header_decoder.c
xdata	ENDS
;	COMDAT lzma_block_header_decode
_TEXT	SEGMENT
i$ = 48
in_size$32884 = 56
in_pos$32887 = 64
ret_$32892 = 72
ret_$32901 = 76
filter_count$32905 = 80
i$32906 = 88
ret$32910 = 96
num$37427 = 100
block$ = 128
allocator$ = 136
in$ = 144
lzma_block_header_decode PROC				; COMDAT

; 37   : {	size_t i;

$LN33:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 38   : 
; 39   : 	// NOTE: We consider the header to be corrupt not only when the
; 40   : 	// CRC32 doesn't match, but also when variable-length integers
; 41   : 	// are invalid or over 63 bits, or if the header is too small
; 42   : 	// to contain the claimed information.
; 43   : 
; 44   : 	// Initialize the filter options array. This way the caller can
; 45   : 	// safely free() the options even if an error occurs in this function.
; 46   : 	for (i = 0; i <= LZMA_FILTERS_MAX; ++i) {

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001c	eb 0e		 jmp	 SHORT $LN28@lzma_block@2
$LN27@lzma_block@2:
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00023	48 83 c0 01	 add	 rax, 1
  00027	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN28@lzma_block@2:
  0002c	48 83 7c 24 30
	04		 cmp	 QWORD PTR i$[rsp], 4
  00032	77 3d		 ja	 SHORT $LN26@lzma_block@2

; 47   : 		block->filters[i].id = LZMA_VLI_UNKNOWN;

  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00039	48 6b c9 10	 imul	 rcx, 16
  0003d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00045	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00049	48 c7 04 01 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax], -1

; 48   : 		block->filters[i].options = NULL;

  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00056	48 6b c9 10	 imul	 rcx, 16
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00062	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00066	48 c7 44 08 08
	00 00 00 00	 mov	 QWORD PTR [rax+rcx+8], 0

; 49   : 	}

  0006f	eb ad		 jmp	 SHORT $LN27@lzma_block@2
$LN26@lzma_block@2:

; 50   : 
; 51   : 	// Versions 0 and 1 are supported. If a newer version was specified,
; 52   : 	// we need to downgrade it.
; 53   : 	if (block->version > 1)

  00071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00079	83 38 01	 cmp	 DWORD PTR [rax], 1
  0007c	76 0e		 jbe	 SHORT $LN25@lzma_block@2

; 54   : 		block->version = 1;

  0007e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00086	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN25@lzma_block@2:

; 55   : 
; 56   : 	// This isn't a Block Header option, but since the decompressor will
; 57   : 	// read it if version >= 1, it's better to initialize it here than
; 58   : 	// to expect the caller to do it since in almost all cases this
; 59   : 	// should be false.
; 60   : 	block->ignore_check = false;

  0008c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00094	c6 80 c8 00 00
	00 00		 mov	 BYTE PTR [rax+200], 0

; 61   : 
; 62   : 	// Validate Block Header Size and Check type. The caller must have
; 63   : 	// already set these, so it is a programming error if this test fails.
; 64   : 	if (lzma_block_header_size_decode(in[0]) != block->header_size
; 65   : 			|| (unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  0009b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  000a3	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a6	8d 0c 8d 04 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+4]
  000ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000b5	3b 48 04	 cmp	 ecx, DWORD PTR [rax+4]
  000b8	75 0e		 jne	 SHORT $LN23@lzma_block@2
  000ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000c2	83 78 08 0f	 cmp	 DWORD PTR [rax+8], 15
  000c6	76 0a		 jbe	 SHORT $LN24@lzma_block@2
$LN23@lzma_block@2:

; 66   : 		return LZMA_PROG_ERROR;

  000c8	b8 0b 00 00 00	 mov	 eax, 11
  000cd	e9 56 02 00 00	 jmp	 $LN29@lzma_block@2
$LN24@lzma_block@2:

; 67   : 
; 68   : 	// Exclude the CRC32 field.
; 69   :   {
; 70   : 	const size_t in_size = block->header_size - 4;

  000d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  000da	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000dd	83 e8 04	 sub	 eax, 4
  000e0	8b c0		 mov	 eax, eax
  000e2	48 89 44 24 38	 mov	 QWORD PTR in_size$32884[rsp], rax

; 71   : 
; 72   : 	// Verify CRC32
; 73   : 	if (lzma_crc32(in, in_size, 0) != unaligned_read32le(in + in_size))

  000e7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR in_size$32884[rsp]
  000ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  000f4	48 03 c1	 add	 rax, rcx
  000f7	8b 00		 mov	 eax, DWORD PTR [rax]
  000f9	89 44 24 64	 mov	 DWORD PTR num$37427[rsp], eax
  000fd	45 33 c0	 xor	 r8d, r8d
  00100	48 8b 54 24 38	 mov	 rdx, QWORD PTR in_size$32884[rsp]
  00105	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  0010d	e8 00 00 00 00	 call	 lzma_crc32
  00112	3b 44 24 64	 cmp	 eax, DWORD PTR num$37427[rsp]
  00116	74 0a		 je	 SHORT $LN22@lzma_block@2

; 74   : 		return LZMA_DATA_ERROR;

  00118	b8 09 00 00 00	 mov	 eax, 9
  0011d	e9 06 02 00 00	 jmp	 $LN29@lzma_block@2
$LN22@lzma_block@2:

; 75   : 
; 76   : 	// Check for unsupported flags.
; 77   : 	if (in[1] & 0x3C)

  00122	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0012a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0012e	83 e0 3c	 and	 eax, 60			; 0000003cH
  00131	85 c0		 test	 eax, eax
  00133	74 0a		 je	 SHORT $LN21@lzma_block@2

; 78   : 		return LZMA_OPTIONS_ERROR;

  00135	b8 08 00 00 00	 mov	 eax, 8
  0013a	e9 e9 01 00 00	 jmp	 $LN29@lzma_block@2
$LN21@lzma_block@2:

; 79   : 
; 80   : 	// Start after the Block Header Size and Block Flags fields.
; 81   :   {
; 82   : 	size_t in_pos = 2;

  0013f	48 c7 44 24 40
	02 00 00 00	 mov	 QWORD PTR in_pos$32887[rsp], 2

; 83   : 
; 84   : 	// Compressed Size
; 85   : 	if (in[1] & 0x40) {

  00148	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00150	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00154	83 e0 40	 and	 eax, 64			; 00000040H
  00157	85 c0		 test	 eax, eax
  00159	74 62		 je	 SHORT $LN20@lzma_block@2
$LN19@lzma_block@2:

; 86   : 		return_if_error(lzma_vli_decode(&block->compressed_size,
; 87   : 				NULL, in, &in_pos, in_size));

  0015b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00163	48 83 c1 10	 add	 rcx, 16
  00167	48 8b 44 24 38	 mov	 rax, QWORD PTR in_size$32884[rsp]
  0016c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00171	4c 8d 4c 24 40	 lea	 r9, QWORD PTR in_pos$32887[rsp]
  00176	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0017e	33 d2		 xor	 edx, edx
  00180	e8 00 00 00 00	 call	 lzma_vli_decode
  00185	89 44 24 48	 mov	 DWORD PTR ret_$32892[rsp], eax
  00189	83 7c 24 48 00	 cmp	 DWORD PTR ret_$32892[rsp], 0
  0018e	74 09		 je	 SHORT $LN16@lzma_block@2
  00190	8b 44 24 48	 mov	 eax, DWORD PTR ret_$32892[rsp]
  00194	e9 8f 01 00 00	 jmp	 $LN29@lzma_block@2
$LN16@lzma_block@2:
  00199	33 c0		 xor	 eax, eax
  0019b	85 c0		 test	 eax, eax
  0019d	75 bc		 jne	 SHORT $LN19@lzma_block@2

; 88   : 
; 89   : 		// Validate Compressed Size. This checks that it isn't zero
; 90   : 		// and that the total size of the Block is a valid VLI.
; 91   : 		if (lzma_block_unpadded_size(block) == 0)

  0019f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  001a7	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  001ac	48 85 c0	 test	 rax, rax
  001af	75 0a		 jne	 SHORT $LN15@lzma_block@2

; 92   : 			return LZMA_DATA_ERROR;

  001b1	b8 09 00 00 00	 mov	 eax, 9
  001b6	e9 6d 01 00 00	 jmp	 $LN29@lzma_block@2
$LN15@lzma_block@2:

; 93   : 	} else {

  001bb	eb 10		 jmp	 SHORT $LN14@lzma_block@2
$LN20@lzma_block@2:

; 94   : 		block->compressed_size = LZMA_VLI_UNKNOWN;

  001bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  001c5	48 c7 40 10 ff
	ff ff ff	 mov	 QWORD PTR [rax+16], -1
$LN14@lzma_block@2:

; 95   : 	}
; 96   : 
; 97   : 	// Uncompressed Size
; 98   : 	if (in[1] & 0x80)

  001cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001d5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001d9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001de	85 c0		 test	 eax, eax
  001e0	74 46		 je	 SHORT $LN13@lzma_block@2
$LN12@lzma_block@2:

; 99   : 		return_if_error(lzma_vli_decode(&block->uncompressed_size,
; 100  : 				NULL, in, &in_pos, in_size));

  001e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  001ea	48 83 c1 18	 add	 rcx, 24
  001ee	48 8b 44 24 38	 mov	 rax, QWORD PTR in_size$32884[rsp]
  001f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f8	4c 8d 4c 24 40	 lea	 r9, QWORD PTR in_pos$32887[rsp]
  001fd	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00205	33 d2		 xor	 edx, edx
  00207	e8 00 00 00 00	 call	 lzma_vli_decode
  0020c	89 44 24 4c	 mov	 DWORD PTR ret_$32901[rsp], eax
  00210	83 7c 24 4c 00	 cmp	 DWORD PTR ret_$32901[rsp], 0
  00215	74 09		 je	 SHORT $LN9@lzma_block@2
  00217	8b 44 24 4c	 mov	 eax, DWORD PTR ret_$32901[rsp]
  0021b	e9 08 01 00 00	 jmp	 $LN29@lzma_block@2
$LN9@lzma_block@2:
  00220	33 c0		 xor	 eax, eax
  00222	85 c0		 test	 eax, eax
  00224	75 bc		 jne	 SHORT $LN12@lzma_block@2

; 101  : 	else

  00226	eb 10		 jmp	 SHORT $LN8@lzma_block@2
$LN13@lzma_block@2:

; 102  : 		block->uncompressed_size = LZMA_VLI_UNKNOWN;

  00228	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00230	48 c7 40 18 ff
	ff ff ff	 mov	 QWORD PTR [rax+24], -1
$LN8@lzma_block@2:

; 103  : 
; 104  : 	// Filter Flags
; 105  :   {
; 106  : 	const size_t filter_count = (in[1] & 3) + 1;

  00238	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00240	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00244	83 e0 03	 and	 eax, 3
  00247	83 c0 01	 add	 eax, 1
  0024a	48 98		 cdqe
  0024c	48 89 44 24 50	 mov	 QWORD PTR filter_count$32905[rsp], rax

; 107  : 	size_t i;
; 108  : 
; 109  : 	for (i = 0; i < filter_count; ++i) {

  00251	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i$32906[rsp], 0
  0025a	eb 0e		 jmp	 SHORT $LN7@lzma_block@2
$LN6@lzma_block@2:
  0025c	48 8b 44 24 58	 mov	 rax, QWORD PTR i$32906[rsp]
  00261	48 83 c0 01	 add	 rax, 1
  00265	48 89 44 24 58	 mov	 QWORD PTR i$32906[rsp], rax
$LN7@lzma_block@2:
  0026a	48 8b 44 24 50	 mov	 rax, QWORD PTR filter_count$32905[rsp]
  0026f	48 39 44 24 58	 cmp	 QWORD PTR i$32906[rsp], rax
  00274	73 61		 jae	 SHORT $LN5@lzma_block@2

; 110  : 		const lzma_ret ret = lzma_filter_flags_decode(
; 111  : 				&block->filters[i], allocator,
; 112  : 				in, &in_pos, in_size);

  00276	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$32906[rsp]
  0027b	48 6b c9 10	 imul	 rcx, 16
  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR block$[rsp]
  00287	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  0028b	48 8b 44 24 38	 mov	 rax, QWORD PTR in_size$32884[rsp]
  00290	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00295	4c 8d 4c 24 40	 lea	 r9, QWORD PTR in_pos$32887[rsp]
  0029a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  002a2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002aa	e8 00 00 00 00	 call	 lzma_filter_flags_decode
  002af	89 44 24 60	 mov	 DWORD PTR ret$32910[rsp], eax

; 113  : 		if (ret != LZMA_OK) {

  002b3	83 7c 24 60 00	 cmp	 DWORD PTR ret$32910[rsp], 0
  002b8	74 1b		 je	 SHORT $LN4@lzma_block@2

; 114  : 			free_properties(block, allocator);

  002ba	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002c2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  002ca	e8 00 00 00 00	 call	 free_properties

; 115  : 			return ret;

  002cf	8b 44 24 60	 mov	 eax, DWORD PTR ret$32910[rsp]
  002d3	eb 53		 jmp	 SHORT $LN29@lzma_block@2
$LN4@lzma_block@2:

; 116  : 		}
; 117  : 	}

  002d5	eb 85		 jmp	 SHORT $LN6@lzma_block@2
$LN5@lzma_block@2:
$LN3@lzma_block@2:

; 118  : 
; 119  : 	// Padding
; 120  : 	while (in_pos < in_size) {

  002d7	48 8b 44 24 38	 mov	 rax, QWORD PTR in_size$32884[rsp]
  002dc	48 39 44 24 40	 cmp	 QWORD PTR in_pos$32887[rsp], rax
  002e1	73 43		 jae	 SHORT $LN2@lzma_block@2

; 121  : 		if (in[in_pos++] != 0x00) {

  002e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR in_pos$32887[rsp]
  002e8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002f0	48 03 c1	 add	 rax, rcx
  002f3	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002f6	48 8b 44 24 40	 mov	 rax, QWORD PTR in_pos$32887[rsp]
  002fb	48 83 c0 01	 add	 rax, 1
  002ff	48 89 44 24 40	 mov	 QWORD PTR in_pos$32887[rsp], rax
  00304	85 c9		 test	 ecx, ecx
  00306	74 1c		 je	 SHORT $LN1@lzma_block@2

; 122  : 			free_properties(block, allocator);

  00308	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00310	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR block$[rsp]
  00318	e8 00 00 00 00	 call	 free_properties

; 123  : 
; 124  : 			// Possibly some new field present so use
; 125  : 			// LZMA_OPTIONS_ERROR instead of LZMA_DATA_ERROR.
; 126  : 			return LZMA_OPTIONS_ERROR;

  0031d	b8 08 00 00 00	 mov	 eax, 8
  00322	eb 04		 jmp	 SHORT $LN29@lzma_block@2
$LN1@lzma_block@2:

; 127  : 		}
; 128  : 	}

  00324	eb b1		 jmp	 SHORT $LN3@lzma_block@2
$LN2@lzma_block@2:

; 129  :   }}}
; 130  : 
; 131  : 	return LZMA_OK;

  00326	33 c0		 xor	 eax, eax
$LN29@lzma_block@2:

; 132  : }

  00328	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0032c	c3		 ret	 0
lzma_block_header_decode ENDP
END
