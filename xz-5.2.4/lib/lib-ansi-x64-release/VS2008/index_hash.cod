; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	memcmp:PROC
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_size_unpadded DD imagerel index_size_unpadded
	DD	imagerel index_size_unpadded+44
	DD	imagerel $unwind$index_size_unpadded
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_size_unpadded DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_size_unpadded
_TEXT	SEGMENT
count$ = 48
index_list_size$ = 56
index_size_unpadded PROC				; COMDAT

; 49   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 50   : 	// Index Indicator + Number of Records + List of Records + CRC32
; 51   : 	return 1 + lzma_vli_size(count) + index_list_size + 4;

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_vli_size
  00018	83 c0 01	 add	 eax, 1
  0001b	8b c8		 mov	 ecx, eax
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR index_list_size$[rsp]
  00022	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]

; 52   : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
index_size_unpadded ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT vli_ceil4
_TEXT	SEGMENT
vli$ = 8
vli_ceil4 PROC						; COMDAT

; 40   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 41   : 	assert(vli <= LZMA_VLI_MAX);
; 42   : 	return (vli + 3) & ~LZMA_VLI_C(3);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR vli$[rsp]
  0000a	48 83 c0 03	 add	 rax, 3
  0000e	48 83 e0 fc	 and	 rax, -4

; 43   : }

  00012	c3		 ret	 0
vli_ceil4 ENDP
PUBLIC	lzma_index_hash_end
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
pdata	SEGMENT
$pdata$lzma_index_hash_end DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$lzma_index_hash_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_hash_end DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_hash_end
_TEXT	SEGMENT
index_hash$ = 48
allocator$ = 56
lzma_index_hash_end PROC				; COMDAT

; 107  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 108  : 	lzma_free(index_hash, allocator);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_free

; 109  : 	return;
; 110  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
lzma_index_hash_end ENDP
_TEXT	ENDS
PUBLIC	lzma_index_hash_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_hash_init DD imagerel $LN5
	DD	imagerel $LN5+298
	DD	imagerel $unwind$lzma_index_hash_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_hash_init DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_hash_init
_TEXT	SEGMENT
index_hash$ = 48
allocator$ = 56
lzma_index_hash_init PROC				; COMDAT

; 75   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 76   : 	if (index_hash == NULL) {

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR index_hash$[rsp], 0
  00014	75 23		 jne	 SHORT $LN2@lzma_index

; 77   : 		index_hash = lzma_alloc(sizeof(lzma_index_hash), allocator);

  00016	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001b	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00020	e8 00 00 00 00	 call	 lzma_alloc
  00025	48 89 44 24 30	 mov	 QWORD PTR index_hash$[rsp], rax

; 78   : 		if (index_hash == NULL)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR index_hash$[rsp], 0
  00030	75 07		 jne	 SHORT $LN1@lzma_index

; 79   : 			return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 ec 00 00 00	 jmp	 $LN3@lzma_index
$LN1@lzma_index:
$LN2@lzma_index:

; 80   : 	}
; 81   : 
; 82   : 	index_hash->sequence = SEQ_BLOCK;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 83   : 	index_hash->blocks.blocks_size = 0;

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  00049	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 84   : 	index_hash->blocks.uncompressed_size = 0;

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  00056	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 85   : 	index_hash->blocks.count = 0;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  00063	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 86   : 	index_hash->blocks.index_list_size = 0;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  00070	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 87   : 	index_hash->records.blocks_size = 0;

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  0007d	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 88   : 	index_hash->records.uncompressed_size = 0;

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  0008d	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0

; 89   : 	index_hash->records.count = 0;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  0009d	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 90   : 	index_hash->records.index_list_size = 0;

  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  000ad	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 91   : 	index_hash->unpadded_size = 0;

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  000bd	48 c7 80 20 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+288], 0

; 92   : 	index_hash->uncompressed_size = 0;

  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  000cd	48 c7 80 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+296], 0

; 93   : 	index_hash->pos = 0;

  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  000dd	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 94   : 	index_hash->crc32 = 0;

  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
  000ed	c7 80 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+312], 0

; 95   : 
; 96   : 	// These cannot fail because LZMA_CHECK_BEST is known to be supported.
; 97   : 	(void)lzma_check_init(&index_hash->blocks.check, LZMA_CHECK_BEST);

  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR index_hash$[rsp]
  000fc	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00100	ba 0a 00 00 00	 mov	 edx, 10
  00105	e8 00 00 00 00	 call	 lzma_check_init

; 98   : 	(void)lzma_check_init(&index_hash->records.check, LZMA_CHECK_BEST);

  0010a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0010f	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00116	ba 0a 00 00 00	 mov	 edx, 10
  0011b	e8 00 00 00 00	 call	 lzma_check_init

; 99   : 
; 100  : 	return index_hash;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR index_hash$[rsp]
$LN3@lzma_index:

; 101  : }

  00125	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00129	c3		 ret	 0
lzma_index_hash_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_size DD imagerel index_size
	DD	imagerel index_size+62
	DD	imagerel $unwind$index_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_size DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_size
_TEXT	SEGMENT
$T37203 = 32
count$ = 64
index_list_size$ = 72
index_size PROC						; COMDAT

; 58   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 59   : 	return vli_ceil4(index_size_unpadded(count, index_list_size));

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR count$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_vli_size
  00018	83 c0 01	 add	 eax, 1
  0001b	8b c8		 mov	 ecx, eax
  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR index_list_size$[rsp]
  00022	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00027	48 89 44 24 20	 mov	 QWORD PTR $T37203[rsp], rax
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR $T37203[rsp]
  00031	48 83 c0 03	 add	 rax, 3
  00035	48 83 e0 fc	 and	 rax, -4

; 60   : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
index_size ENDP
PUBLIC	lzma_index_hash_size
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_hash_size DD imagerel $LN9
	DD	imagerel $LN9+85
	DD	imagerel $unwind$lzma_index_hash_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_hash_size DD 010901H
	DD	08209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
xdata	ENDS
;	COMDAT lzma_index_hash_size
_TEXT	SEGMENT
$T37439 = 32
$T37449 = 40
$T37450 = 48
index_hash$ = 80
lzma_index_hash_size PROC				; COMDAT

; 115  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 116  : 	// Get the size of the Index from ->blocks instead of ->records for
; 117  : 	// cases where application wants to know the Index Size before
; 118  : 	// decoding the Index.
; 119  : 	return index_size(index_hash->blocks.count,
; 120  : 			index_hash->blocks.index_list_size);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR index_hash$[rsp]
  0000e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00012	48 89 44 24 30	 mov	 QWORD PTR $T37450[rsp], rax
  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR index_hash$[rsp]
  0001c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00020	48 89 44 24 28	 mov	 QWORD PTR $T37449[rsp], rax
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T37449[rsp]
  0002a	e8 00 00 00 00	 call	 lzma_vli_size
  0002f	83 c0 01	 add	 eax, 1
  00032	8b c8		 mov	 ecx, eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR $T37450[rsp]
  00039	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0003e	48 89 44 24 20	 mov	 QWORD PTR $T37439[rsp], rax
  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR $T37439[rsp]
  00048	48 83 c0 03	 add	 rax, 3
  0004c	48 83 e0 fc	 and	 rax, -4

; 121  : }

  00050	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00054	c3		 ret	 0
lzma_index_hash_size ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_stream_size DD imagerel index_stream_size
	DD	imagerel index_stream_size+77
	DD	imagerel $unwind$index_stream_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_stream_size DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_stream_size
_TEXT	SEGMENT
$T37461 = 32
blocks_size$ = 64
count$ = 72
index_list_size$ = 80
index_stream_size PROC					; COMDAT

; 67   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 68   : 	return LZMA_STREAM_HEADER_SIZE + blocks_size
; 69   : 			+ index_size(count, index_list_size)
; 70   : 			+ LZMA_STREAM_HEADER_SIZE;

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR count$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_vli_size
  0001d	83 c0 01	 add	 eax, 1
  00020	8b c8		 mov	 ecx, eax
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR index_list_size$[rsp]
  00027	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0002c	48 89 44 24 20	 mov	 QWORD PTR $T37461[rsp], rax
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T37461[rsp]
  00036	48 83 c1 03	 add	 rcx, 3
  0003a	48 83 e1 fc	 and	 rcx, -4
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR blocks_size$[rsp]
  00043	48 8d 44 08 18	 lea	 rax, QWORD PTR [rax+rcx+24]

; 71   : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
index_stream_size ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$hash_append DD imagerel hash_append
	DD	imagerel hash_append+202
	DD	imagerel $unwind$hash_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hash_append DD 021401H
	DD	030105214H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
xdata	ENDS
;	COMDAT hash_append
_TEXT	SEGMENT
sizes$32942 = 32
info$ = 64
unpadded_size$ = 72
uncompressed_size$ = 80
hash_append PROC					; COMDAT

; 128  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 129  : 	info->blocks_size += vli_ceil4(unpadded_size);

  00014	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unpadded_size$[rsp]
  00019	48 83 c1 03	 add	 rcx, 3
  0001d	48 83 e1 fc	 and	 rcx, -4
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00026	48 03 08	 add	 rcx, QWORD PTR [rax]
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0002e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 130  : 	info->uncompressed_size += uncompressed_size;

  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00036	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003a	48 03 4c 24 50	 add	 rcx, QWORD PTR uncompressed_size$[rsp]
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00044	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 131  : 	info->index_list_size += lzma_vli_size(unpadded_size)
; 132  : 			+ lzma_vli_size(uncompressed_size);

  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unpadded_size$[rsp]
  0004d	e8 00 00 00 00	 call	 lzma_vli_size
  00052	8b d8		 mov	 ebx, eax
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR uncompressed_size$[rsp]
  00059	e8 00 00 00 00	 call	 lzma_vli_size
  0005e	44 8b d8	 mov	 r11d, eax
  00061	8b c3		 mov	 eax, ebx
  00063	41 03 c3	 add	 eax, r11d
  00066	8b c8		 mov	 ecx, eax
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0006d	48 03 48 18	 add	 rcx, QWORD PTR [rax+24]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00076	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 133  : 	++info->count;

  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0007f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00083	48 83 c1 01	 add	 rcx, 1
  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0008c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 134  : 
; 135  :   {
; 136  : 	const lzma_vli sizes[2] = { unpadded_size, uncompressed_size };

  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR unpadded_size$[rsp]
  00095	48 89 44 24 20	 mov	 QWORD PTR sizes$32942[rsp], rax
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR uncompressed_size$[rsp]
  0009f	48 89 44 24 28	 mov	 QWORD PTR sizes$32942[rsp+8], rax

; 137  : 	lzma_check_update(&info->check, LZMA_CHECK_BEST,
; 138  : 			(const uint8_t *)(sizes), sizeof(sizes));

  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000a9	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000ad	41 b9 10 00 00
	00		 mov	 r9d, 16
  000b3	4c 8d 44 24 20	 lea	 r8, QWORD PTR sizes$32942[rsp]
  000b8	ba 0a 00 00 00	 mov	 edx, 10
  000bd	e8 00 00 00 00	 call	 lzma_check_update

; 139  :   }
; 140  : 
; 141  : 	return LZMA_OK;

  000c2	33 c0		 xor	 eax, eax

; 142  : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5b		 pop	 rbx
  000c9	c3		 ret	 0
hash_append ENDP
PUBLIC	lzma_index_hash_decode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_hash_decode DD imagerel $LN48
	DD	imagerel $LN48+1788
	DD	imagerel $unwind$lzma_index_hash_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_hash_decode DD 021b01H
	DD	011011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
xdata	ENDS
;	COMDAT lzma_index_hash_decode
_TEXT	SEGMENT
ret$32971 = 48
in_start$32970 = 56
size$32986 = 64
ret_$32995 = 72
$T37711 = 80
$T37712 = 88
tv66 = 96
tv86 = 100
tv90 = 104
tv160 = 112
index_hash$ = 144
in$ = 152
in_pos$ = 160
in_size$ = 168
lzma_index_hash_decode PROC				; COMDAT

; 179  : {

$LN48:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 180  : 	// Catch zero input buffer here, because in contrast to Index encoder
; 181  : 	// and decoder functions, applications call this function directly
; 182  : 	// instead of via lzma_code(), which does the buffer checking.
; 183  : 	if (*in_pos >= in_size)

  0001b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00023	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0002b	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0002e	72 0a		 jb	 SHORT $LN36@lzma_index@2

; 184  : 		return LZMA_BUF_ERROR;

  00030	b8 0a 00 00 00	 mov	 eax, 10
  00035	e9 9e 06 00 00	 jmp	 $LN37@lzma_index@2
$LN36@lzma_index@2:

; 185  : 
; 186  : 	// NOTE: This function has many similarities to index_encode() and
; 187  : 	// index_decode() functions found from index_encoder.c and
; 188  : 	// index_decoder.c. See the comments especially in index_encoder.c.
; 189  :   {
; 190  : 	const size_t in_start = *in_pos;

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	48 89 44 24 38	 mov	 QWORD PTR in_start$32970[rsp], rax

; 191  : 	lzma_ret ret = LZMA_OK;

  0004a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$32971[rsp], 0
$LN35@lzma_index@2:

; 192  : 
; 193  : 	while (*in_pos < in_size)

  00052	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0005a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00062	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00065	0f 83 20 06 00
	00		 jae	 $LN34@lzma_index@2

; 194  : 	switch (index_hash->sequence) {

  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00073	8b 00		 mov	 eax, DWORD PTR [rax]
  00075	89 44 24 60	 mov	 DWORD PTR tv66[rsp], eax
  00079	83 7c 24 60 06	 cmp	 DWORD PTR tv66[rsp], 6
  0007e	0f 87 fb 05 00
	00		 ja	 $LN1@lzma_index@2
  00084	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv66[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00090	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN47@lzma_index@2[rcx+rax*4]
  00097	48 03 c1	 add	 rax, rcx
  0009a	ff e0		 jmp	 rax
$LN31@lzma_index@2:

; 195  : 	case SEQ_BLOCK:
; 196  : 		// Check the Index Indicator is present.
; 197  : 		if (in[(*in_pos)++] != 0x00)

  0009c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000a4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  000af	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  000b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000be	48 83 c1 01	 add	 rcx, 1
  000c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cd	85 d2		 test	 edx, edx
  000cf	74 0a		 je	 SHORT $LN30@lzma_index@2

; 198  : 			return LZMA_DATA_ERROR;

  000d1	b8 09 00 00 00	 mov	 eax, 9
  000d6	e9 fd 05 00 00	 jmp	 $LN37@lzma_index@2
$LN30@lzma_index@2:

; 199  : 
; 200  : 		index_hash->sequence = SEQ_COUNT;

  000db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  000e3	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 201  : 		break;

  000e9	e9 98 05 00 00	 jmp	 $LN32@lzma_index@2
$LN29@lzma_index@2:

; 202  : 
; 203  : 	case SEQ_COUNT: {
; 204  : 		ret = lzma_vli_decode(&index_hash->remaining,
; 205  : 				&index_hash->pos, in, in_pos, in_size);

  000ee	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR index_hash$[rsp]
  000f6	48 81 c2 30 01
	00 00		 add	 rdx, 304		; 00000130H
  000fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00105	48 81 c1 18 01
	00 00		 add	 rcx, 280		; 00000118H
  0010c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00121	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00129	e8 00 00 00 00	 call	 lzma_vli_decode
  0012e	89 44 24 30	 mov	 DWORD PTR ret$32971[rsp], eax

; 206  : 		if (ret != LZMA_STREAM_END)

  00132	83 7c 24 30 01	 cmp	 DWORD PTR ret$32971[rsp], 1
  00137	74 05		 je	 SHORT $LN28@lzma_index@2

; 207  : 			goto out;

  00139	e9 4d 05 00 00	 jmp	 $out$32983
$LN28@lzma_index@2:

; 208  : 
; 209  : 		// The count must match the count of the Blocks decoded.
; 210  : 		if (index_hash->remaining != index_hash->blocks.count)

  0013e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00146	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0014e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00152	48 39 81 18 01
	00 00		 cmp	 QWORD PTR [rcx+280], rax
  00159	74 0a		 je	 SHORT $LN27@lzma_index@2

; 211  : 			return LZMA_DATA_ERROR;

  0015b	b8 09 00 00 00	 mov	 eax, 9
  00160	e9 73 05 00 00	 jmp	 $LN37@lzma_index@2
$LN27@lzma_index@2:

; 212  : 
; 213  : 		ret = LZMA_OK;

  00165	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$32971[rsp], 0

; 214  : 		index_hash->pos = 0;

  0016d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00175	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 215  : 
; 216  : 		// Handle the special case when there are no Blocks.
; 217  : 		index_hash->sequence = index_hash->remaining == 0
; 218  : 				? SEQ_PADDING_INIT : SEQ_UNPADDED;

  00180	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00188	48 83 b8 18 01
	00 00 00	 cmp	 QWORD PTR [rax+280], 0
  00190	75 0a		 jne	 SHORT $LN39@lzma_index@2
  00192	c7 44 24 64 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  0019a	eb 08		 jmp	 SHORT $LN40@lzma_index@2
$LN39@lzma_index@2:
  0019c	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv86[rsp], 2
$LN40@lzma_index@2:
  001a4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  001ac	8b 44 24 64	 mov	 eax, DWORD PTR tv86[rsp]
  001b0	89 01		 mov	 DWORD PTR [rcx], eax

; 219  : 		break;

  001b2	e9 cf 04 00 00	 jmp	 $LN32@lzma_index@2
$LN26@lzma_index@2:

; 220  : 	}
; 221  : 
; 222  : 	case SEQ_UNPADDED:
; 223  : 	case SEQ_UNCOMPRESSED: {
; 224  : 		lzma_vli *size = index_hash->sequence == SEQ_UNPADDED
; 225  : 				? &index_hash->unpadded_size
; 226  : 				: &index_hash->uncompressed_size;

  001b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  001bf	83 38 02	 cmp	 DWORD PTR [rax], 2
  001c2	75 15		 jne	 SHORT $LN41@lzma_index@2
  001c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  001cc	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  001d2	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  001d7	eb 13		 jmp	 SHORT $LN42@lzma_index@2
$LN41@lzma_index@2:
  001d9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  001e1	48 05 28 01 00
	00		 add	 rax, 296		; 00000128H
  001e7	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
$LN42@lzma_index@2:
  001ec	48 8b 44 24 68	 mov	 rax, QWORD PTR tv90[rsp]
  001f1	48 89 44 24 40	 mov	 QWORD PTR size$32986[rsp], rax

; 227  : 
; 228  : 		ret = lzma_vli_decode(size, &index_hash->pos,
; 229  : 				in, in_pos, in_size);

  001f6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR index_hash$[rsp]
  001fe	48 81 c2 30 01
	00 00		 add	 rdx, 304		; 00000130H
  00205	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0020d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00212	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  0021a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00222	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$32986[rsp]
  00227	e8 00 00 00 00	 call	 lzma_vli_decode
  0022c	89 44 24 30	 mov	 DWORD PTR ret$32971[rsp], eax

; 230  : 		if (ret != LZMA_STREAM_END)

  00230	83 7c 24 30 01	 cmp	 DWORD PTR ret$32971[rsp], 1
  00235	74 05		 je	 SHORT $LN25@lzma_index@2

; 231  : 			goto out;

  00237	e9 4f 04 00 00	 jmp	 $out$32983
$LN25@lzma_index@2:

; 232  : 
; 233  : 		ret = LZMA_OK;

  0023c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$32971[rsp], 0

; 234  : 		index_hash->pos = 0;

  00244	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0024c	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 235  : 
; 236  : 		if (index_hash->sequence == SEQ_UNPADDED) {

  00257	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0025f	83 38 02	 cmp	 DWORD PTR [rax], 2
  00262	75 4a		 jne	 SHORT $LN24@lzma_index@2

; 237  : 			if (index_hash->unpadded_size < UNPADDED_SIZE_MIN
; 238  : 					|| index_hash->unpadded_size
; 239  : 						> UNPADDED_SIZE_MAX)

  00264	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0026c	48 83 b8 20 01
	00 00 05	 cmp	 QWORD PTR [rax+288], 5
  00274	72 1b		 jb	 SHORT $LN22@lzma_index@2
  00276	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0027e	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  00288	48 39 81 20 01
	00 00		 cmp	 QWORD PTR [rcx+288], rax
  0028f	76 0a		 jbe	 SHORT $LN23@lzma_index@2
$LN22@lzma_index@2:

; 240  : 				return LZMA_DATA_ERROR;

  00291	b8 09 00 00 00	 mov	 eax, 9
  00296	e9 3d 04 00 00	 jmp	 $LN37@lzma_index@2
$LN23@lzma_index@2:

; 241  : 
; 242  : 			index_hash->sequence = SEQ_UNCOMPRESSED;

  0029b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  002a3	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 243  : 		} else {

  002a9	e9 01 01 00 00	 jmp	 $LN21@lzma_index@2
$LN24@lzma_index@2:
$LN20@lzma_index@2:

; 244  : 			// Update the hash.
; 245  : 			return_if_error(hash_append(&index_hash->records,
; 246  : 					index_hash->unpadded_size,
; 247  : 					index_hash->uncompressed_size));

  002ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  002b6	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  002bd	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR index_hash$[rsp]
  002c5	4d 8b 80 28 01
	00 00		 mov	 r8, QWORD PTR [r8+296]
  002cc	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR index_hash$[rsp]
  002d4	48 8b 92 20 01
	00 00		 mov	 rdx, QWORD PTR [rdx+288]
  002db	e8 00 00 00 00	 call	 hash_append
  002e0	89 44 24 48	 mov	 DWORD PTR ret_$32995[rsp], eax
  002e4	83 7c 24 48 00	 cmp	 DWORD PTR ret_$32995[rsp], 0
  002e9	74 09		 je	 SHORT $LN17@lzma_index@2
  002eb	8b 44 24 48	 mov	 eax, DWORD PTR ret_$32995[rsp]
  002ef	e9 e4 03 00 00	 jmp	 $LN37@lzma_index@2
$LN17@lzma_index@2:
  002f4	33 c0		 xor	 eax, eax
  002f6	85 c0		 test	 eax, eax
  002f8	75 b4		 jne	 SHORT $LN20@lzma_index@2

; 248  : 
; 249  : 			// Verify that we don't go over the known sizes. Note
; 250  : 			// that this validation is simpler than the one used
; 251  : 			// in lzma_index_hash_append(), because here we know
; 252  : 			// that values in index_hash->blocks are already
; 253  : 			// validated and we are fine as long as we don't
; 254  : 			// exceed them in index_hash->records.
; 255  : 			if (index_hash->blocks.blocks_size
; 256  : 					< index_hash->records.blocks_size
; 257  : 					|| index_hash->blocks.uncompressed_size
; 258  : 					< index_hash->records.uncompressed_size
; 259  : 					|| index_hash->blocks.index_list_size
; 260  : 					< index_hash->records.index_list_size)

  002fa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00302	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0030a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00311	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00315	72 3a		 jb	 SHORT $LN15@lzma_index@2
  00317	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0031f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00327	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0032e	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00332	72 1d		 jb	 SHORT $LN15@lzma_index@2
  00334	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0033c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00344	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  0034b	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0034f	73 0a		 jae	 SHORT $LN16@lzma_index@2
$LN15@lzma_index@2:

; 261  : 				return LZMA_DATA_ERROR;

  00351	b8 09 00 00 00	 mov	 eax, 9
  00356	e9 7d 03 00 00	 jmp	 $LN37@lzma_index@2
$LN16@lzma_index@2:

; 262  : 
; 263  : 			// Check if this was the last Record.
; 264  : 			index_hash->sequence = --index_hash->remaining == 0
; 265  : 					? SEQ_PADDING_INIT : SEQ_UNPADDED;

  0035b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00363	48 8b 89 18 01
	00 00		 mov	 rcx, QWORD PTR [rcx+280]
  0036a	48 83 e9 01	 sub	 rcx, 1
  0036e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00376	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx
  0037d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00385	48 83 b8 18 01
	00 00 00	 cmp	 QWORD PTR [rax+280], 0
  0038d	75 0a		 jne	 SHORT $LN43@lzma_index@2
  0038f	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv160[rsp], 4
  00397	eb 08		 jmp	 SHORT $LN44@lzma_index@2
$LN43@lzma_index@2:
  00399	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
$LN44@lzma_index@2:
  003a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  003a9	8b 44 24 70	 mov	 eax, DWORD PTR tv160[rsp]
  003ad	89 01		 mov	 DWORD PTR [rcx], eax
$LN21@lzma_index@2:

; 266  : 		}
; 267  : 
; 268  : 		break;

  003af	e9 d2 02 00 00	 jmp	 $LN32@lzma_index@2
$LN14@lzma_index@2:

; 269  : 	}
; 270  : 
; 271  : 	case SEQ_PADDING_INIT:
; 272  : 		index_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(
; 273  : 				index_hash->records.count,
; 274  : 				index_hash->records.index_list_size)) & 3;

  003b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  003bc	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  003c3	48 89 44 24 58	 mov	 QWORD PTR $T37712[rsp], rax
  003c8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  003d0	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  003d7	48 89 44 24 50	 mov	 QWORD PTR $T37711[rsp], rax
  003dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T37711[rsp]
  003e1	e8 00 00 00 00	 call	 lzma_vli_size
  003e6	83 c0 01	 add	 eax, 1
  003e9	8b c8		 mov	 ecx, eax
  003eb	48 8b 44 24 58	 mov	 rax, QWORD PTR $T37712[rsp]
  003f0	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  003f5	b9 04 00 00 00	 mov	 ecx, 4
  003fa	48 2b c8	 sub	 rcx, rax
  003fd	48 83 e1 03	 and	 rcx, 3
  00401	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00409	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 275  : 		index_hash->sequence = SEQ_PADDING;

  00410	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00418	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN13@lzma_index@2:

; 276  : 
; 277  : 	// Fall through
; 278  : 
; 279  : 	case SEQ_PADDING:
; 280  : 		if (index_hash->pos > 0) {

  0041e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00426	48 83 b8 30 01
	00 00 00	 cmp	 QWORD PTR [rax+304], 0
  0042e	76 66		 jbe	 SHORT $LN12@lzma_index@2

; 281  : 			--index_hash->pos;

  00430	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00438	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  0043f	48 83 e9 01	 sub	 rcx, 1
  00443	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0044b	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 282  : 			if (in[(*in_pos)++] != 0x00)

  00452	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0045a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0045d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00465	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00469	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00471	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00474	48 83 c1 01	 add	 rcx, 1
  00478	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00480	48 89 08	 mov	 QWORD PTR [rax], rcx
  00483	85 d2		 test	 edx, edx
  00485	74 0a		 je	 SHORT $LN11@lzma_index@2

; 283  : 				return LZMA_DATA_ERROR;

  00487	b8 09 00 00 00	 mov	 eax, 9
  0048c	e9 47 02 00 00	 jmp	 $LN37@lzma_index@2
$LN11@lzma_index@2:

; 284  : 
; 285  : 			break;

  00491	e9 f0 01 00 00	 jmp	 $LN32@lzma_index@2
$LN12@lzma_index@2:

; 286  : 		}
; 287  : 
; 288  : 		// Compare the sizes.
; 289  : 		if (index_hash->blocks.blocks_size
; 290  : 				!= index_hash->records.blocks_size
; 291  : 				|| index_hash->blocks.uncompressed_size
; 292  : 				!= index_hash->records.uncompressed_size
; 293  : 				|| index_hash->blocks.index_list_size
; 294  : 				!= index_hash->records.index_list_size)

  00496	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0049e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  004a6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004ad	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  004b1	75 3a		 jne	 SHORT $LN9@lzma_index@2
  004b3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  004bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  004c3	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  004ca	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  004ce	75 1d		 jne	 SHORT $LN9@lzma_index@2
  004d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  004d8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  004e0	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  004e7	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  004eb	74 0a		 je	 SHORT $LN10@lzma_index@2
$LN9@lzma_index@2:

; 295  : 			return LZMA_DATA_ERROR;

  004ed	b8 09 00 00 00	 mov	 eax, 9
  004f2	e9 e1 01 00 00	 jmp	 $LN37@lzma_index@2
$LN10@lzma_index@2:

; 296  : 
; 297  : 		// Finish the hashes and compare them.
; 298  : 		lzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);

  004f7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  004ff	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00503	ba 0a 00 00 00	 mov	 edx, 10
  00508	e8 00 00 00 00	 call	 lzma_check_finish

; 299  : 		lzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);

  0050d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00515	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  0051c	ba 0a 00 00 00	 mov	 edx, 10
  00521	e8 00 00 00 00	 call	 lzma_check_finish

; 300  : 		if (memcmp(index_hash->blocks.check.buffer.u8,
; 301  : 				index_hash->records.check.buffer.u8,
; 302  : 				lzma_check_size(LZMA_CHECK_BEST)) != 0)

  00526	b9 0a 00 00 00	 mov	 ecx, 10
  0052b	e8 00 00 00 00	 call	 lzma_check_size
  00530	44 8b c0	 mov	 r8d, eax
  00533	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR index_hash$[rsp]
  0053b	48 81 c2 b0 00
	00 00		 add	 rdx, 176		; 000000b0H
  00542	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0054a	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0054e	e8 00 00 00 00	 call	 memcmp
  00553	85 c0		 test	 eax, eax
  00555	74 0a		 je	 SHORT $LN8@lzma_index@2

; 303  : 			return LZMA_DATA_ERROR;

  00557	b8 09 00 00 00	 mov	 eax, 9
  0055c	e9 77 01 00 00	 jmp	 $LN37@lzma_index@2
$LN8@lzma_index@2:

; 304  : 
; 305  : 		// Finish the CRC32 calculation.
; 306  : 		index_hash->crc32 = lzma_crc32(in + in_start,
; 307  : 				*in_pos - in_start, index_hash->crc32);

  00561	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00569	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$32970[rsp]
  0056e	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00571	48 2b d0	 sub	 rdx, rax
  00574	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$32970[rsp]
  00579	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00581	48 03 c8	 add	 rcx, rax
  00584	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0058c	44 8b 80 38 01
	00 00		 mov	 r8d, DWORD PTR [rax+312]
  00593	e8 00 00 00 00	 call	 lzma_crc32
  00598	44 8b d8	 mov	 r11d, eax
  0059b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  005a3	44 89 98 38 01
	00 00		 mov	 DWORD PTR [rax+312], r11d

; 308  : 
; 309  : 		index_hash->sequence = SEQ_CRC32;

  005aa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  005b2	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN7@lzma_index@2:
$LN6@lzma_index@2:

; 310  : 
; 311  : 	// Fall through
; 312  : 
; 313  : 	case SEQ_CRC32:
; 314  : 		do {
; 315  : 			if (*in_pos == in_size)

  005b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  005c0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  005c8	48 39 01	 cmp	 QWORD PTR [rcx], rax
  005cb	75 07		 jne	 SHORT $LN3@lzma_index@2

; 316  : 				return LZMA_OK;

  005cd	33 c0		 xor	 eax, eax
  005cf	e9 04 01 00 00	 jmp	 $LN37@lzma_index@2
$LN3@lzma_index@2:

; 317  : 
; 318  : 			if (((index_hash->crc32 >> (index_hash->pos * 8))
; 319  : 					& 0xFF) != in[(*in_pos)++])

  005d4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  005dc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005df	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  005e7	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  005eb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  005f3	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  005fa	48 c1 e1 03	 shl	 rcx, 3
  005fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  00606	44 8b 80 38 01
	00 00		 mov	 r8d, DWORD PTR [rax+312]
  0060d	41 d3 e8	 shr	 r8d, cl
  00610	41 81 e0 ff 00
	00 00		 and	 r8d, 255		; 000000ffH
  00617	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0061f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00622	48 83 c1 01	 add	 rcx, 1
  00626	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  0062e	48 89 08	 mov	 QWORD PTR [rax], rcx
  00631	44 3b c2	 cmp	 r8d, edx
  00634	74 0a		 je	 SHORT $LN2@lzma_index@2

; 320  : 				return LZMA_DATA_ERROR;

  00636	b8 09 00 00 00	 mov	 eax, 9
  0063b	e9 98 00 00 00	 jmp	 $LN37@lzma_index@2
$LN2@lzma_index@2:

; 321  : 
; 322  : 		} while (++index_hash->pos < 4);

  00640	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00648	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  0064f	48 83 c1 01	 add	 rcx, 1
  00653	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0065b	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx
  00662	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  0066a	48 83 b8 30 01
	00 00 04	 cmp	 QWORD PTR [rax+304], 4
  00672	0f 82 40 ff ff
	ff		 jb	 $LN6@lzma_index@2

; 323  : 
; 324  : 		return LZMA_STREAM_END;

  00678	b8 01 00 00 00	 mov	 eax, 1
  0067d	eb 59		 jmp	 SHORT $LN37@lzma_index@2
$LN1@lzma_index@2:

; 325  : 
; 326  : 	default:
; 327  : 		assert(0);
; 328  : 		return LZMA_PROG_ERROR;

  0067f	b8 0b 00 00 00	 mov	 eax, 11
  00684	eb 52		 jmp	 SHORT $LN37@lzma_index@2
$LN32@lzma_index@2:

; 329  : 	}

  00686	e9 c7 f9 ff ff	 jmp	 $LN35@lzma_index@2
$LN34@lzma_index@2:
$out$32983:

; 330  : 
; 331  : out:
; 332  : 	// Update the CRC32,
; 333  : 	index_hash->crc32 = lzma_crc32(in + in_start,
; 334  : 			*in_pos - in_start, index_hash->crc32);

  0068b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00693	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$32970[rsp]
  00698	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0069b	48 2b d0	 sub	 rdx, rax
  0069e	48 8b 44 24 38	 mov	 rax, QWORD PTR in_start$32970[rsp]
  006a3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  006ab	48 03 c8	 add	 rcx, rax
  006ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  006b6	44 8b 80 38 01
	00 00		 mov	 r8d, DWORD PTR [rax+312]
  006bd	e8 00 00 00 00	 call	 lzma_crc32
  006c2	44 8b d8	 mov	 r11d, eax
  006c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR index_hash$[rsp]
  006cd	44 89 98 38 01
	00 00		 mov	 DWORD PTR [rax+312], r11d

; 335  : 
; 336  : 	return ret;

  006d4	8b 44 24 30	 mov	 eax, DWORD PTR ret$32971[rsp]
$LN37@lzma_index@2:

; 337  :   }
; 338  : }

  006d8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  006df	c3		 ret	 0
$LN47@lzma_index@2:
  006e0	00 00 00 00	 DD	 $LN31@lzma_index@2
  006e4	00 00 00 00	 DD	 $LN29@lzma_index@2
  006e8	00 00 00 00	 DD	 $LN26@lzma_index@2
  006ec	00 00 00 00	 DD	 $LN26@lzma_index@2
  006f0	00 00 00 00	 DD	 $LN14@lzma_index@2
  006f4	00 00 00 00	 DD	 $LN13@lzma_index@2
  006f8	00 00 00 00	 DD	 $LN7@lzma_index@2
lzma_index_hash_decode ENDP
_TEXT	ENDS
PUBLIC	lzma_index_hash_append
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_hash_append DD imagerel $LN25
	DD	imagerel $LN25+397
	DD	imagerel $unwind$lzma_index_hash_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_hash_append DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_hash.c
xdata	ENDS
;	COMDAT lzma_index_hash_append
_TEXT	SEGMENT
ret_$32956 = 32
$T37724 = 40
$T37734 = 48
$T37735 = 56
$T37741 = 64
$T37759 = 72
$T37760 = 80
$T37761 = 88
index_hash$ = 112
unpadded_size$ = 120
uncompressed_size$ = 128
lzma_index_hash_append PROC				; COMDAT

; 148  : {

$LN25:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 149  : 	// Validate the arguments.
; 150  : 	if (index_hash->sequence != SEQ_BLOCK
; 151  : 			|| unpadded_size < UNPADDED_SIZE_MIN
; 152  : 			|| unpadded_size > UNPADDED_SIZE_MAX
; 153  : 			|| uncompressed_size > LZMA_VLI_MAX)

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  00018	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001b	75 2d		 jne	 SHORT $LN7@lzma_index@3
  0001d	48 83 7c 24 78
	05		 cmp	 QWORD PTR unpadded_size$[rsp], 5
  00023	72 25		 jb	 SHORT $LN7@lzma_index@3
  00025	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  0002f	48 39 44 24 78	 cmp	 QWORD PTR unpadded_size$[rsp], rax
  00034	77 14		 ja	 SHORT $LN7@lzma_index@3
  00036	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00040	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR uncompressed_size$[rsp], rax
  00048	76 0a		 jbe	 SHORT $LN8@lzma_index@3
$LN7@lzma_index@3:

; 154  : 		return LZMA_PROG_ERROR;

  0004a	b8 0b 00 00 00	 mov	 eax, 11
  0004f	e9 34 01 00 00	 jmp	 $LN9@lzma_index@3
$LN8@lzma_index@3:
$LN6@lzma_index@3:

; 155  : 
; 156  : 	// Update the hash.
; 157  : 	return_if_error(hash_append(&index_hash->blocks,
; 158  : 			unpadded_size, uncompressed_size));

  00054	48 8b 4c 24 70	 mov	 rcx, QWORD PTR index_hash$[rsp]
  00059	48 83 c1 08	 add	 rcx, 8
  0005d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR uncompressed_size$[rsp]
  00065	48 8b 54 24 78	 mov	 rdx, QWORD PTR unpadded_size$[rsp]
  0006a	e8 00 00 00 00	 call	 hash_append
  0006f	89 44 24 20	 mov	 DWORD PTR ret_$32956[rsp], eax
  00073	83 7c 24 20 00	 cmp	 DWORD PTR ret_$32956[rsp], 0
  00078	74 09		 je	 SHORT $LN3@lzma_index@3
  0007a	8b 44 24 20	 mov	 eax, DWORD PTR ret_$32956[rsp]
  0007e	e9 05 01 00 00	 jmp	 $LN9@lzma_index@3
$LN3@lzma_index@3:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 cb		 jne	 SHORT $LN6@lzma_index@3

; 159  : 
; 160  : 	// Validate the properties of *info are still in allowed limits.
; 161  : 	if (index_hash->blocks.blocks_size > LZMA_VLI_MAX
; 162  : 			|| index_hash->blocks.uncompressed_size > LZMA_VLI_MAX
; 163  : 			|| index_size(index_hash->blocks.count,
; 164  : 					index_hash->blocks.index_list_size)
; 165  : 				> LZMA_BACKWARD_SIZE_MAX
; 166  : 			|| index_stream_size(index_hash->blocks.blocks_size,
; 167  : 					index_hash->blocks.count,
; 168  : 					index_hash->blocks.index_list_size)
; 169  : 				> LZMA_VLI_MAX)

  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR index_hash$[rsp]
  0008e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00098	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0009c	0f 87 dd 00 00
	00		 ja	 $LN1@lzma_index@3
  000a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR index_hash$[rsp]
  000a7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000b1	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  000b5	0f 87 c4 00 00
	00		 ja	 $LN1@lzma_index@3
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  000c0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c4	48 89 44 24 38	 mov	 QWORD PTR $T37735[rsp], rax
  000c9	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  000ce	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d2	48 89 44 24 30	 mov	 QWORD PTR $T37734[rsp], rax
  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T37734[rsp]
  000dc	e8 00 00 00 00	 call	 lzma_vli_size
  000e1	83 c0 01	 add	 eax, 1
  000e4	8b c8		 mov	 ecx, eax
  000e6	48 8b 44 24 38	 mov	 rax, QWORD PTR $T37735[rsp]
  000eb	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  000f0	48 89 44 24 28	 mov	 QWORD PTR $T37724[rsp], rax
  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T37724[rsp]
  000fa	48 83 c1 03	 add	 rcx, 3
  000fe	48 83 e1 fc	 and	 rcx, -4
  00102	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  0010c	48 3b c8	 cmp	 rcx, rax
  0010f	77 6e		 ja	 SHORT $LN1@lzma_index@3
  00111	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  00116	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0011a	48 89 44 24 58	 mov	 QWORD PTR $T37761[rsp], rax
  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  00124	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00128	48 89 44 24 50	 mov	 QWORD PTR $T37760[rsp], rax
  0012d	48 8b 44 24 70	 mov	 rax, QWORD PTR index_hash$[rsp]
  00132	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00136	48 89 44 24 48	 mov	 QWORD PTR $T37759[rsp], rax
  0013b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T37760[rsp]
  00140	e8 00 00 00 00	 call	 lzma_vli_size
  00145	83 c0 01	 add	 eax, 1
  00148	8b c8		 mov	 ecx, eax
  0014a	48 8b 44 24 58	 mov	 rax, QWORD PTR $T37761[rsp]
  0014f	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00154	48 89 44 24 40	 mov	 QWORD PTR $T37741[rsp], rax
  00159	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T37741[rsp]
  0015e	48 83 c1 03	 add	 rcx, 3
  00162	48 83 e1 fc	 and	 rcx, -4
  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR $T37759[rsp]
  0016b	48 8d 4c 08 18	 lea	 rcx, QWORD PTR [rax+rcx+24]
  00170	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0017a	48 3b c8	 cmp	 rcx, rax
  0017d	76 07		 jbe	 SHORT $LN2@lzma_index@3
$LN1@lzma_index@3:

; 170  : 		return LZMA_DATA_ERROR;

  0017f	b8 09 00 00 00	 mov	 eax, 9
  00184	eb 02		 jmp	 SHORT $LN9@lzma_index@3
$LN2@lzma_index@3:

; 171  : 
; 172  : 	return LZMA_OK;

  00186	33 c0		 xor	 eax, eax
$LN9@lzma_index@3:

; 173  : }

  00188	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018c	c3		 ret	 0
lzma_index_hash_append ENDP
END
