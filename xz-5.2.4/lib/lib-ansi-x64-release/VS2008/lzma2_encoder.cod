; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_lzma2_props_encode
PUBLIC	lzma_lzma2_block_size
PUBLIC	lzma_lzma2_encoder_memusage
PUBLIC	lzma_lzma2_encoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
pdata	SEGMENT
$pdata$lzma_lzma2_block_size DD imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$lzma_lzma2_block_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_block_size DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_block_size
_TEXT	SEGMENT
opt$ = 0
tv69 = 8
options$ = 32
lzma_lzma2_block_size PROC				; COMDAT

; 416  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 417  : 	const lzma_options_lzma *const opt = options;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR opt$[rsp], rax

; 418  : 
; 419  : 	// Use at least 1 MiB to keep compression ratio better.
; 420  : 	return my_max((uint64_t)(opt->dict_size) * 3, UINT64_C(1) << 20);

  00012	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00016	8b 00		 mov	 eax, DWORD PTR [rax]
  00018	48 6b c0 03	 imul	 rax, 3
  0001c	48 3d 00 00 10
	00		 cmp	 rax, 1048576		; 00100000H
  00022	76 11		 jbe	 SHORT $LN3@lzma_lzma2
  00024	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	48 6b c0 03	 imul	 rax, 3
  0002e	48 89 44 24 08	 mov	 QWORD PTR tv69[rsp], rax
  00033	eb 09		 jmp	 SHORT $LN4@lzma_lzma2
$LN3@lzma_lzma2:
  00035	48 c7 44 24 08
	00 00 10 00	 mov	 QWORD PTR tv69[rsp], 1048576 ; 00100000H
$LN4@lzma_lzma2:
  0003e	48 8b 44 24 08	 mov	 rax, QWORD PTR tv69[rsp]

; 421  : }

  00043	48 83 c4 18	 add	 rsp, 24
  00047	c3		 ret	 0
lzma_lzma2_block_size ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_encoder_options_update DD imagerel lzma2_encoder_options_update
	DD	imagerel lzma2_encoder_options_update+258
	DD	imagerel $unwind$lzma2_encoder_options_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_encoder_options_update DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_encoder_options_update
_TEXT	SEGMENT
coder$ = 0
opt$33182 = 8
coder_ptr$ = 32
filter$ = 40
lzma2_encoder_options_update PROC			; COMDAT

; 286  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 287  : 	lzma_lzma2_coder *coder = coder_ptr;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR coder$[rsp], rax

; 288  : 
; 289  : 	// New options can be set only when there is no incomplete chunk.
; 290  : 	// This is the case at the beginning of the raw stream and right
; 291  : 	// after LZMA_SYNC_FLUSH.
; 292  : 	if (filter->options == NULL || coder->sequence != SEQ_INIT)

  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR filter$[rsp]
  0001c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00021	74 09		 je	 SHORT $LN5@lzma2_enco
  00023	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  00027	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002a	74 0a		 je	 SHORT $LN6@lzma2_enco
$LN5@lzma2_enco:

; 293  : 		return LZMA_PROG_ERROR;

  0002c	b8 0b 00 00 00	 mov	 eax, 11
  00031	e9 c7 00 00 00	 jmp	 $LN7@lzma2_enco
$LN6@lzma2_enco:

; 294  : 
; 295  : 	// Look if there are new options. At least for now,
; 296  : 	// only lc/lp/pb can be changed.
; 297  :   { const lzma_options_lzma *opt = filter->options;

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR filter$[rsp]
  0003b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003f	48 89 44 24 08	 mov	 QWORD PTR opt$33182[rsp], rax

; 298  : 	if (coder->opt_cur.lc != opt->lc || coder->opt_cur.lp != opt->lp
; 299  : 			|| coder->opt_cur.pb != opt->pb) {

  00044	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  00048	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00050	39 41 24	 cmp	 DWORD PTR [rcx+36], eax
  00053	75 26		 jne	 SHORT $LN3@lzma2_enco
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  00059	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  0005e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00061	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00064	75 15		 jne	 SHORT $LN3@lzma2_enco
  00066	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  0006a	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  0006f	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00072	39 41 2c	 cmp	 DWORD PTR [rcx+44], eax
  00075	0f 84 80 00 00
	00		 je	 $LN4@lzma2_enco
$LN3@lzma2_enco:

; 300  : 		// Validate the options.
; 301  : 		if (opt->lc > LZMA_LCLP_MAX || opt->lp > LZMA_LCLP_MAX
; 302  : 				|| opt->lc + opt->lp > LZMA_LCLP_MAX
; 303  : 				|| opt->pb > LZMA_PB_MAX)

  0007b	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  00080	83 78 14 04	 cmp	 DWORD PTR [rax+20], 4
  00084	77 2b		 ja	 SHORT $LN1@lzma2_enco
  00086	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  0008b	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  0008f	77 20		 ja	 SHORT $LN1@lzma2_enco
  00091	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  00096	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00099	48 8b 4c 24 08	 mov	 rcx, QWORD PTR opt$33182[rsp]
  0009e	03 41 18	 add	 eax, DWORD PTR [rcx+24]
  000a1	83 f8 04	 cmp	 eax, 4
  000a4	77 0b		 ja	 SHORT $LN1@lzma2_enco
  000a6	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  000ab	83 78 1c 04	 cmp	 DWORD PTR [rax+28], 4
  000af	76 07		 jbe	 SHORT $LN2@lzma2_enco
$LN1@lzma2_enco:

; 304  : 			return LZMA_OPTIONS_ERROR;

  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	eb 45		 jmp	 SHORT $LN7@lzma2_enco
$LN2@lzma2_enco:

; 305  : 
; 306  : 		// The new options will be used when the encoder starts
; 307  : 		// a new LZMA2 chunk.
; 308  : 		coder->opt_cur.lc = opt->lc;

  000b8	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  000bc	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  000c1	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c4	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 309  : 		coder->opt_cur.lp = opt->lp;

  000c7	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  000cb	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  000d0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000d3	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 310  : 		coder->opt_cur.pb = opt->pb;

  000d6	48 8b 0c 24	 mov	 rcx, QWORD PTR coder$[rsp]
  000da	48 8b 44 24 08	 mov	 rax, QWORD PTR opt$33182[rsp]
  000df	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000e2	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 311  : 		coder->need_properties = true;

  000e5	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  000e9	c6 80 80 00 00
	00 01		 mov	 BYTE PTR [rax+128], 1

; 312  : 		coder->need_state_reset = true;

  000f0	48 8b 04 24	 mov	 rax, QWORD PTR coder$[rsp]
  000f4	c6 80 81 00 00
	00 01		 mov	 BYTE PTR [rax+129], 1
$LN4@lzma2_enco:

; 313  : 	}
; 314  :   }
; 315  : 
; 316  : 	return LZMA_OK;

  000fb	33 c0		 xor	 eax, eax
$LN7@lzma2_enco:

; 317  : }

  000fd	48 83 c4 18	 add	 rsp, 24
  00101	c3		 ret	 0
lzma2_encoder_options_update ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT lzma2_header_uncompressed
_TEXT	SEGMENT
coder$ = 8
lzma2_header_uncompressed PROC				; COMDAT

; 118  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 119  : 	assert(coder->uncompressed_size > 0);
; 120  : 	assert(coder->uncompressed_size <= LZMA2_CHUNK_MAX);
; 121  : 
; 122  : 	// If this is the first chunk, we need to include dictionary
; 123  : 	// reset indicator.
; 124  : 	if (coder->need_dictionary_reset)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  0000a	0f b6 80 82 00
	00 00		 movzx	 eax, BYTE PTR [rax+130]
  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN2@lzma2_head

; 125  : 		coder->buf[0] = 1;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  0001a	c6 80 a0 00 00
	00 01		 mov	 BYTE PTR [rax+160], 1

; 126  : 	else

  00021	eb 0c		 jmp	 SHORT $LN1@lzma2_head
$LN2@lzma2_head:

; 127  : 		coder->buf[0] = 2;

  00023	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00028	c6 80 a0 00 00
	00 02		 mov	 BYTE PTR [rax+160], 2
$LN1@lzma2_head:

; 128  : 
; 129  : 	coder->need_dictionary_reset = false;

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00034	c6 80 82 00 00
	00 00		 mov	 BYTE PTR [rax+130], 0

; 130  : 
; 131  : 	// "Compressed" size
; 132  : 	coder->buf[1] = (uint8_t)((coder->uncompressed_size - 1) >> 8);

  0003b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR coder$[rsp]
  00040	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00047	48 83 e9 01	 sub	 rcx, 1
  0004b	48 c1 e9 08	 shr	 rcx, 8
  0004f	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00054	88 88 a1 00 00
	00		 mov	 BYTE PTR [rax+161], cl

; 133  : 	coder->buf[2] = (coder->uncompressed_size - 1) & 0xFF;

  0005a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR coder$[rsp]
  0005f	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00066	48 83 e9 01	 sub	 rcx, 1
  0006a	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00071	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00076	88 88 a2 00 00
	00		 mov	 BYTE PTR [rax+162], cl

; 134  : 
; 135  : 	// Set the start position for copying.
; 136  : 	coder->buf_pos = 0;

  0007c	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00081	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0

; 137  : 	return;
; 138  : }

  0008c	c3		 ret	 0
lzma2_header_uncompressed ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
_TEXT	ENDS
;	COMDAT get_dist_slot
_TEXT	SEGMENT
dist$ = 8
get_dist_slot PROC					; COMDAT

; 110  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 111  : 	// If it is small enough, we can pick the result directly from
; 112  : 	// the precalculated table.
; 113  : 	if (dist < fastpos_limit(0, 0))

  00004	81 7c 24 08 00
	20 00 00	 cmp	 DWORD PTR dist$[rsp], 8192 ; 00002000H
  0000c	73 11		 jae	 SHORT $LN2@get_dist_s@3

; 114  : 		return lzma_fastpos[dist];

  0000e	8b 4c 24 08	 mov	 ecx, DWORD PTR dist$[rsp]
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00019	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0001d	eb 3a		 jmp	 SHORT $LN3@get_dist_s@3
$LN2@get_dist_s@3:

; 115  : 
; 116  : 	if (dist < fastpos_limit(0, 1))

  0001f	81 7c 24 08 00
	00 00 02	 cmp	 DWORD PTR dist$[rsp], 33554432 ; 02000000H
  00027	73 19		 jae	 SHORT $LN1@get_dist_s@3

; 117  : 		return fastpos_result(dist, 0, 1);

  00029	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  0002d	c1 e8 0c	 shr	 eax, 12
  00030	8b c8		 mov	 ecx, eax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00039	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0003d	83 c0 18	 add	 eax, 24
  00040	eb 17		 jmp	 SHORT $LN3@get_dist_s@3
$LN1@get_dist_s@3:

; 118  : 
; 119  : 	return fastpos_result(dist, 0, 2);

  00042	8b 44 24 08	 mov	 eax, DWORD PTR dist$[rsp]
  00046	c1 e8 18	 shr	 eax, 24
  00049	8b c8		 mov	 ecx, eax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_fastpos
  00052	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00056	83 c0 30	 add	 eax, 48			; 00000030H
$LN3@get_dist_s@3:

; 120  : }

  00059	f3 c3		 fatret	 0
get_dist_slot ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$mf_read DD imagerel mf_read
	DD	imagerel mf_read+198
	DD	imagerel $unwind$mf_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mf_read DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mf_read
_TEXT	SEGMENT
out_avail$ = 32
copy_size$ = 40
tv66 = 48
mf$ = 80
out$ = 88
out_pos$ = 96
out_size$ = 104
left$ = 112
mf_read	PROC						; COMDAT

; 281  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 282  : 	const size_t out_avail = out_size - *out_pos;

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0001d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00020	48 8b 44 24 68	 mov	 rax, QWORD PTR out_size$[rsp]
  00025	48 2b c1	 sub	 rax, rcx
  00028	48 89 44 24 20	 mov	 QWORD PTR out_avail$[rsp], rax

; 283  : 	const size_t copy_size = my_min(out_avail, *left);

  0002d	48 8b 44 24 70	 mov	 rax, QWORD PTR left$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 39 44 24 20	 cmp	 QWORD PTR out_avail$[rsp], rax
  0003a	73 0c		 jae	 SHORT $LN3@mf_read
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR out_avail$[rsp]
  00041	48 89 44 24 30	 mov	 QWORD PTR tv66[rsp], rax
  00046	eb 0d		 jmp	 SHORT $LN4@mf_read
$LN3@mf_read:
  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR left$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 89 44 24 30	 mov	 QWORD PTR tv66[rsp], rax
$LN4@mf_read:
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR tv66[rsp]
  0005a	48 89 44 24 28	 mov	 QWORD PTR copy_size$[rsp], rax

; 284  : 
; 285  : 	assert(mf->read_ahead == 0);
; 286  : 	assert(mf->read_pos >= *left);
; 287  : 
; 288  : 	memcpy(out + *out_pos, mf->buffer + mf->read_pos - *left,
; 289  : 			copy_size);

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR mf$[rsp]
  00064	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00067	48 8b 54 24 50	 mov	 rdx, QWORD PTR mf$[rsp]
  0006c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0006f	48 03 d0	 add	 rdx, rax
  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR left$[rsp]
  00077	48 2b 10	 sub	 rdx, QWORD PTR [rax]
  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR out_pos$[rsp]
  0007f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR out$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	4c 8b 44 24 28	 mov	 r8, QWORD PTR copy_size$[rsp]
  0008f	e8 00 00 00 00	 call	 memcpy

; 290  : 
; 291  : 	*out_pos += copy_size;

  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00099	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009c	48 03 4c 24 28	 add	 rcx, QWORD PTR copy_size$[rsp]
  000a1	48 8b 44 24 60	 mov	 rax, QWORD PTR out_pos$[rsp]
  000a6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 292  : 	*left -= copy_size;

  000a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR left$[rsp]
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR copy_size$[rsp]
  000b3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b6	48 2b c8	 sub	 rcx, rax
  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR left$[rsp]
  000be	48 89 08	 mov	 QWORD PTR [rax], rcx

; 293  : 	return;
; 294  : }

  000c1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c5	c3		 ret	 0
mf_read	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mf_unencoded
_TEXT	SEGMENT
mf$ = 8
mf_unencoded PROC					; COMDAT

; 239  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 240  : 	return mf->write_pos - mf->read_pos + mf->read_ahead;

  00005	48 8b 54 24 08	 mov	 rdx, QWORD PTR mf$[rsp]
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR mf$[rsp]
  0000f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00012	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00015	2b c1		 sub	 eax, ecx
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR mf$[rsp]
  0001c	03 41 1c	 add	 eax, DWORD PTR [rcx+28]

; 241  : }

  0001f	c3		 ret	 0
mf_unencoded ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\fastpos.h
pdata	SEGMENT
$pdata$lzma_lzma2_props_encode DD imagerel $LN11
	DD	imagerel $LN11+210
	DD	imagerel $unwind$lzma_lzma2_props_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_props_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
xdata	ENDS
;	COMDAT lzma_lzma2_props_encode
_TEXT	SEGMENT
opt$ = 32
d$ = 40
tv65 = 44
options$ = 64
out$ = 72
lzma_lzma2_props_encode PROC				; COMDAT

; 391  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 392  : 	const lzma_options_lzma *const opt = options;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR opt$[rsp], rax

; 393  : 	uint32_t d = my_max(opt->dict_size, LZMA_DICT_SIZE_MIN);

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$[rsp]
  0001d	81 38 00 10 00
	00		 cmp	 DWORD PTR [rax], 4096	; 00001000H
  00023	76 0d		 jbe	 SHORT $LN5@lzma_lzma2@2
  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	89 44 24 2c	 mov	 DWORD PTR tv65[rsp], eax
  00030	eb 08		 jmp	 SHORT $LN6@lzma_lzma2@2
$LN5@lzma_lzma2@2:
  00032	c7 44 24 2c 00
	10 00 00	 mov	 DWORD PTR tv65[rsp], 4096 ; 00001000H
$LN6@lzma_lzma2@2:
  0003a	8b 44 24 2c	 mov	 eax, DWORD PTR tv65[rsp]
  0003e	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 394  : 
; 395  : 	// Round up to the next 2^n - 1 or 2^n + 2^(n - 1) - 1 depending
; 396  : 	// on which one is the next:
; 397  : 	--d;

  00042	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  00046	83 e8 01	 sub	 eax, 1
  00049	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 398  : 	d |= d >> 2;

  0004d	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  00051	c1 e9 02	 shr	 ecx, 2
  00054	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  00058	0b c1		 or	 eax, ecx
  0005a	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 399  : 	d |= d >> 3;

  0005e	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  00069	0b c1		 or	 eax, ecx
  0006b	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 400  : 	d |= d >> 4;

  0006f	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  00073	c1 e9 04	 shr	 ecx, 4
  00076	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  0007a	0b c1		 or	 eax, ecx
  0007c	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 401  : 	d |= d >> 8;

  00080	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  00084	c1 e9 08	 shr	 ecx, 8
  00087	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  0008b	0b c1		 or	 eax, ecx
  0008d	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 402  : 	d |= d >> 16;

  00091	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  00095	c1 e9 10	 shr	 ecx, 16
  00098	8b 44 24 28	 mov	 eax, DWORD PTR d$[rsp]
  0009c	0b c1		 or	 eax, ecx
  0009e	89 44 24 28	 mov	 DWORD PTR d$[rsp], eax

; 403  : 
; 404  : 	// Get the highest two bits using the proper encoding:
; 405  : 	if (d == UINT32_MAX)

  000a2	83 7c 24 28 ff	 cmp	 DWORD PTR d$[rsp], -1	; ffffffffH
  000a7	75 0a		 jne	 SHORT $LN2@lzma_lzma2@2

; 406  : 		out[0] = 40;

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
  000ae	c6 00 28	 mov	 BYTE PTR [rax], 40	; 00000028H

; 407  : 	else

  000b1	eb 18		 jmp	 SHORT $LN1@lzma_lzma2@2
$LN2@lzma_lzma2@2:

; 408  : 		out[0] = get_dist_slot(d + 1) - 24;

  000b3	8b 4c 24 28	 mov	 ecx, DWORD PTR d$[rsp]
  000b7	83 c1 01	 add	 ecx, 1
  000ba	e8 00 00 00 00	 call	 get_dist_slot
  000bf	8b c8		 mov	 ecx, eax
  000c1	83 e9 18	 sub	 ecx, 24
  000c4	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
  000c9	88 08		 mov	 BYTE PTR [rax], cl
$LN1@lzma_lzma2@2:

; 409  : 
; 410  : 	return LZMA_OK;

  000cb	33 c0		 xor	 eax, eax

; 411  : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
lzma_lzma2_props_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_encoder_end DD imagerel lzma2_encoder_end
	DD	imagerel lzma2_encoder_end+63
	DD	imagerel $unwind$lzma2_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_encoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_encoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
lzma2_encoder_end PROC					; COMDAT

; 276  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 277  : 	lzma_lzma2_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 278  : 	lzma_free(coder->lzma, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00026	e8 00 00 00 00	 call	 lzma_free

; 279  : 	lzma_free(coder, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_free

; 280  : 	return;
; 281  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
lzma2_encoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_header_lzma DD imagerel lzma2_header_lzma
	DD	imagerel lzma2_header_lzma+583
	DD	imagerel $unwind$lzma2_header_lzma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_header_lzma DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_header_lzma
_TEXT	SEGMENT
pos$33097 = 32
size$33104 = 40
coder$ = 64
lzma2_header_lzma PROC					; COMDAT

; 56   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 57   : 	assert(coder->uncompressed_size > 0);
; 58   : 	assert(coder->uncompressed_size <= LZMA2_UNCOMPRESSED_MAX);
; 59   : 	assert(coder->compressed_size > 0);
; 60   : 	assert(coder->compressed_size <= LZMA2_CHUNK_MAX);
; 61   : 
; 62   :   {
; 63   : 	size_t pos;
; 64   : 
; 65   : 	if (coder->need_properties) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0000e	0f b6 80 80 00
	00 00		 movzx	 eax, BYTE PTR [rax+128]
  00015	85 c0		 test	 eax, eax
  00017	74 45		 je	 SHORT $LN7@lzma2_head@2

; 66   : 		pos = 0;

  00019	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pos$33097[rsp], 0

; 67   : 
; 68   : 		if (coder->need_dictionary_reset)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00027	0f b6 80 82 00
	00 00		 movzx	 eax, BYTE PTR [rax+130]
  0002e	85 c0		 test	 eax, eax
  00030	74 16		 je	 SHORT $LN6@lzma2_head@2

; 69   : 			coder->buf[pos] = 0x80 + (3 << 5);

  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0003c	48 03 c1	 add	 rax, rcx
  0003f	c6 80 a0 00 00
	00 e0		 mov	 BYTE PTR [rax+160], 224	; 000000e0H

; 70   : 		else

  00046	eb 14		 jmp	 SHORT $LN5@lzma2_head@2
$LN6@lzma2_head@2:

; 71   : 			coder->buf[pos] = 0x80 + (2 << 5);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00052	48 03 c1	 add	 rax, rcx
  00055	c6 80 a0 00 00
	00 c0		 mov	 BYTE PTR [rax+160], 192	; 000000c0H
$LN5@lzma2_head@2:

; 72   : 	} else {

  0005c	eb 43		 jmp	 SHORT $LN4@lzma2_head@2
$LN7@lzma2_head@2:

; 73   : 		pos = 1;

  0005e	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR pos$33097[rsp], 1

; 74   : 
; 75   : 		if (coder->need_state_reset)

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0006c	0f b6 80 81 00
	00 00		 movzx	 eax, BYTE PTR [rax+129]
  00073	85 c0		 test	 eax, eax
  00075	74 16		 je	 SHORT $LN3@lzma2_head@2

; 76   : 			coder->buf[pos] = 0x80 + (1 << 5);

  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00081	48 03 c1	 add	 rax, rcx
  00084	c6 80 a0 00 00
	00 a0		 mov	 BYTE PTR [rax+160], 160	; 000000a0H

; 77   : 		else

  0008b	eb 14		 jmp	 SHORT $LN2@lzma2_head@2
$LN3@lzma2_head@2:

; 78   : 			coder->buf[pos] = 0x80;

  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00097	48 03 c1	 add	 rax, rcx
  0009a	c6 80 a0 00 00
	00 80		 mov	 BYTE PTR [rax+160], 128	; 00000080H
$LN2@lzma2_head@2:
$LN4@lzma2_head@2:

; 79   : 	}
; 80   : 
; 81   : 	// Set the start position for copying.
; 82   : 	coder->buf_pos = pos;

  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  000ab	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 83   : 
; 84   : 	// Uncompressed size
; 85   :   {
; 86   : 	size_t size = coder->uncompressed_size - 1;

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000b7	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  000be	48 83 e8 01	 sub	 rax, 1
  000c2	48 89 44 24 28	 mov	 QWORD PTR size$33104[rsp], rax

; 87   : //W	coder->buf[pos++] += size >> 16;
; 88   : 	coder->buf[pos] = (uint8_t)(coder->buf[pos] + (size >> 16));

  000c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000d1	48 03 c1	 add	 rax, rcx
  000d4	0f b6 90 a0 00
	00 00		 movzx	 edx, BYTE PTR [rax+160]
  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR size$33104[rsp]
  000e0	48 c1 e8 10	 shr	 rax, 16
  000e4	48 03 d0	 add	 rdx, rax
  000e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000f1	48 03 c1	 add	 rax, rcx
  000f4	88 90 a0 00 00
	00		 mov	 BYTE PTR [rax+160], dl

; 89   :   ++pos;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  000ff	48 83 c0 01	 add	 rax, 1
  00103	48 89 44 24 20	 mov	 QWORD PTR pos$33097[rsp], rax

; 90   : 	coder->buf[pos++] = (size >> 8) & 0xFF;

  00108	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$33104[rsp]
  0010d	48 c1 ea 08	 shr	 rdx, 8
  00111	48 81 e2 ff 00
	00 00		 and	 rdx, 255		; 000000ffH
  00118	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  0011d	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00122	48 03 c1	 add	 rax, rcx
  00125	88 90 a0 00 00
	00		 mov	 BYTE PTR [rax+160], dl
  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  00130	48 83 c0 01	 add	 rax, 1
  00134	48 89 44 24 20	 mov	 QWORD PTR pos$33097[rsp], rax

; 91   : 	coder->buf[pos++] = size & 0xFF;

  00139	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$33104[rsp]
  0013e	48 81 e2 ff 00
	00 00		 and	 rdx, 255		; 000000ffH
  00145	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  0014a	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0014f	48 03 c1	 add	 rax, rcx
  00152	88 90 a0 00 00
	00		 mov	 BYTE PTR [rax+160], dl
  00158	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  0015d	48 83 c0 01	 add	 rax, 1
  00161	48 89 44 24 20	 mov	 QWORD PTR pos$33097[rsp], rax

; 92   : 
; 93   : 	// Compressed size
; 94   : 	size = coder->compressed_size - 1;

  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0016b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00172	48 83 e8 01	 sub	 rax, 1
  00176	48 89 44 24 28	 mov	 QWORD PTR size$33104[rsp], rax

; 95   : 	coder->buf[pos++] = (uint8_t)(size >> 8);

  0017b	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$33104[rsp]
  00180	48 c1 ea 08	 shr	 rdx, 8
  00184	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  00189	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0018e	48 03 c1	 add	 rax, rcx
  00191	88 90 a0 00 00
	00		 mov	 BYTE PTR [rax+160], dl
  00197	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  0019c	48 83 c0 01	 add	 rax, 1
  001a0	48 89 44 24 20	 mov	 QWORD PTR pos$33097[rsp], rax

; 96   : 	coder->buf[pos++] = size & 0xFF;

  001a5	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$33104[rsp]
  001aa	48 81 e2 ff 00
	00 00		 and	 rdx, 255		; 000000ffH
  001b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$33097[rsp]
  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001bb	48 03 c1	 add	 rax, rcx
  001be	88 90 a0 00 00
	00		 mov	 BYTE PTR [rax+160], dl
  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  001c9	48 83 c0 01	 add	 rax, 1
  001cd	48 89 44 24 20	 mov	 QWORD PTR pos$33097[rsp], rax

; 97   :   }
; 98   : 
; 99   : 	// Properties, if needed
; 100  : 	if (coder->need_properties)

  001d2	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001d7	0f b6 80 80 00
	00 00		 movzx	 eax, BYTE PTR [rax+128]
  001de	85 c0		 test	 eax, eax
  001e0	74 20		 je	 SHORT $LN1@lzma2_head@2

; 101  : 		lzma_lzma_lclppb_encode(&coder->opt_cur, coder->buf + pos);

  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  001e7	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$33097[rsp]
  001ec	48 8d 94 01 a0
	00 00 00	 lea	 rdx, QWORD PTR [rcx+rax+160]
  001f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  001f9	48 83 c1 10	 add	 rcx, 16
  001fd	e8 00 00 00 00	 call	 lzma_lzma_lclppb_encode
$LN1@lzma2_head@2:

; 102  :   }
; 103  : 
; 104  : 	coder->need_properties = false;

  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00207	c6 80 80 00 00
	00 00		 mov	 BYTE PTR [rax+128], 0

; 105  : 	coder->need_state_reset = false;

  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00213	c6 80 81 00 00
	00 00		 mov	 BYTE PTR [rax+129], 0

; 106  : 	coder->need_dictionary_reset = false;

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0021f	c6 80 82 00 00
	00 00		 mov	 BYTE PTR [rax+130], 0

; 107  : 
; 108  : 	// The copying code uses coder->compressed_size to indicate the end
; 109  : 	// of coder->buf[], so we need add the maximum size of the header here.
; 110  : 	coder->compressed_size += LZMA2_HEADER_MAX;

  00226	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0022b	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00232	48 83 c1 06	 add	 rcx, 6
  00236	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0023b	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 111  : 
; 112  : 	return;
; 113  : }

  00242	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00246	c3		 ret	 0
lzma2_header_lzma ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma2_encoder_memusage DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$lzma_lzma2_encoder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_encoder_memusage DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_encoder_memusage
_TEXT	SEGMENT
lzma_mem$ = 32
options$ = 64
lzma_lzma2_encoder_memusage PROC			; COMDAT

; 380  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 381  : 	const uint64_t lzma_mem = lzma_lzma_encoder_memusage(options);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  0000e	e8 00 00 00 00	 call	 lzma_lzma_encoder_memusage
  00013	48 89 44 24 20	 mov	 QWORD PTR lzma_mem$[rsp], rax

; 382  : 	if (lzma_mem == UINT64_MAX)

  00018	48 83 7c 24 20
	ff		 cmp	 QWORD PTR lzma_mem$[rsp], -1
  0001e	75 09		 jne	 SHORT $LN1@lzma_lzma2@4

; 383  : 		return UINT64_MAX;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 0b		 jmp	 SHORT $LN2@lzma_lzma2@4
$LN1@lzma_lzma2@4:

; 384  : 
; 385  : 	return sizeof(lzma_lzma2_coder) + lzma_mem;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR lzma_mem$[rsp]
  0002e	48 05 a8 00 01
	00		 add	 rax, 65704		; 000100a8H
$LN2@lzma_lzma2@4:

; 386  : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
lzma_lzma2_encoder_memusage ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.h
pdata	SEGMENT
$pdata$lzma2_encode DD imagerel lzma2_encode
	DD	imagerel lzma2_encode+1254
	DD	imagerel $unwind$lzma2_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_encode DD 021b01H
	DD	011011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_encoder.c
xdata	ENDS
;	COMDAT lzma2_encode
_TEXT	SEGMENT
coder$ = 48
ret_$33144 = 56
left$33147 = 60
limit$33149 = 64
read_start$33152 = 68
ret$33153 = 72
out_avail$84446 = 80
copy_size$84447 = 88
$T84451 = 96
tv65 = 104
tv75 = 108
tv207 = 112
coder_ptr$ = 144
mf$ = 152
out$ = 160
out_pos$ = 168
out_size$ = 176
lzma2_encode PROC					; COMDAT

; 145  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 146  : 	lzma_lzma2_coder *restrict coder = coder_ptr;

  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 30	 mov	 QWORD PTR coder$[rsp], rax
$LN23@lzma2_enco@2:

; 147  : 
; 148  : 	while (*out_pos < out_size)

  00028	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00030	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00038	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003b	0f 83 9b 04 00
	00		 jae	 $LN22@lzma2_enco@2

; 149  : 	switch (coder->sequence) {

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	89 44 24 68	 mov	 DWORD PTR tv65[rsp], eax
  0004c	83 7c 24 68 00	 cmp	 DWORD PTR tv65[rsp], 0
  00051	74 31		 je	 SHORT $LN19@lzma2_enco@2
  00053	83 7c 24 68 01	 cmp	 DWORD PTR tv65[rsp], 1
  00058	0f 84 21 01 00
	00		 je	 $LN11@lzma2_enco@2
  0005e	83 7c 24 68 02	 cmp	 DWORD PTR tv65[rsp], 2
  00063	0f 84 9d 02 00
	00		 je	 $LN6@lzma2_enco@2
  00069	83 7c 24 68 03	 cmp	 DWORD PTR tv65[rsp], 3
  0006e	0f 84 0e 03 00
	00		 je	 $LN4@lzma2_enco@2
  00074	83 7c 24 68 04	 cmp	 DWORD PTR tv65[rsp], 4
  00079	0f 84 69 03 00
	00		 je	 $LN2@lzma2_enco@2
  0007f	e9 53 04 00 00	 jmp	 $LN20@lzma2_enco@2
$LN19@lzma2_enco@2:

; 150  : 	case SEQ_INIT:
; 151  : 		// If there's no input left and we are flushing or finishing,
; 152  : 		// don't start a new chunk.
; 153  : 		if (mf_unencoded(mf) == 0) {

  00084	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  0008c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00094	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00097	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  0009a	2b c1		 sub	 eax, ecx
  0009c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  000a4	03 41 1c	 add	 eax, DWORD PTR [rcx+28]
  000a7	85 c0		 test	 eax, eax
  000a9	75 68		 jne	 SHORT $LN18@lzma2_enco@2

; 154  : 			// Write end of payload marker if finishing.
; 155  : 			if (mf->action == LZMA_FINISH)

  000ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000b3	83 78 68 03	 cmp	 DWORD PTR [rax+104], 3
  000b7	75 31		 jne	 SHORT $LN17@lzma2_enco@2

; 156  : 				out[(*out_pos)++] = 0;

  000b9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000c1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000cc	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  000d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000d8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000db	48 83 c1 01	 add	 rcx, 1
  000df	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000e7	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN17@lzma2_enco@2:

; 157  : 
; 158  : 			return mf->action == LZMA_RUN
; 159  : 					? LZMA_OK : LZMA_STREAM_END;

  000ea	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  000f2	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000f6	75 0a		 jne	 SHORT $LN26@lzma2_enco@2
  000f8	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00100	eb 08		 jmp	 SHORT $LN27@lzma2_enco@2
$LN26@lzma2_enco@2:
  00102	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN27@lzma2_enco@2:
  0010a	8b 44 24 6c	 mov	 eax, DWORD PTR tv75[rsp]
  0010e	e9 cb 03 00 00	 jmp	 $LN24@lzma2_enco@2
$LN18@lzma2_enco@2:

; 160  : 		}
; 161  : 
; 162  : 		if (coder->need_state_reset)

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00118	0f b6 80 81 00
	00 00		 movzx	 eax, BYTE PTR [rax+129]
  0011f	85 c0		 test	 eax, eax
  00121	74 31		 je	 SHORT $LN16@lzma2_enco@2
$LN15@lzma2_enco@2:

; 163  : 			return_if_error(lzma_lzma_encoder_reset(
; 164  : 					coder->lzma, &coder->opt_cur));

  00123	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  00128	48 83 c2 10	 add	 rdx, 16
  0012c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00131	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00135	e8 00 00 00 00	 call	 lzma_lzma_encoder_reset
  0013a	89 44 24 38	 mov	 DWORD PTR ret_$33144[rsp], eax
  0013e	83 7c 24 38 00	 cmp	 DWORD PTR ret_$33144[rsp], 0
  00143	74 09		 je	 SHORT $LN12@lzma2_enco@2
  00145	8b 44 24 38	 mov	 eax, DWORD PTR ret_$33144[rsp]
  00149	e9 90 03 00 00	 jmp	 $LN24@lzma2_enco@2
$LN12@lzma2_enco@2:
  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 cf		 jne	 SHORT $LN15@lzma2_enco@2
$LN16@lzma2_enco@2:

; 165  : 
; 166  : 		coder->uncompressed_size = 0;

  00154	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00159	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 167  : 		coder->compressed_size = 0;

  00164	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00169	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 168  : 		coder->sequence = SEQ_LZMA_ENCODE;

  00174	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00179	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN11@lzma2_enco@2:

; 169  : 
; 170  : 	// Fall through
; 171  : 
; 172  : 	case SEQ_LZMA_ENCODE: {
; 173  : 		// Calculate how much more uncompressed data this chunk
; 174  : 		// could accept.
; 175  : 		const uint32_t left = (const uint32_t)(LZMA2_UNCOMPRESSED_MAX
; 176  : 				- coder->uncompressed_size);

  0017f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00184	b8 00 00 20 00	 mov	 eax, 2097152		; 00200000H
  00189	48 2b 81 88 00
	00 00		 sub	 rax, QWORD PTR [rcx+136]
  00190	89 44 24 3c	 mov	 DWORD PTR left$33147[rsp], eax

; 177  : 		uint32_t limit;
; 178  : 
; 179  : 		if (left < mf->match_len_max) {

  00194	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0019c	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0019f	39 44 24 3c	 cmp	 DWORD PTR left$33147[rsp], eax
  001a3	73 0a		 jae	 SHORT $LN10@lzma2_enco@2

; 180  : 			// Must flush immediately since the next LZMA symbol
; 181  : 			// could make the uncompressed size of the chunk too
; 182  : 			// big.
; 183  : 			limit = 0;

  001a5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR limit$33149[rsp], 0

; 184  : 		} else {

  001ad	eb 2b		 jmp	 SHORT $LN9@lzma2_enco@2
$LN10@lzma2_enco@2:

; 185  : 			// Calculate maximum read_limit that is OK from point
; 186  : 			// of view of LZMA2 chunk size.
; 187  : 			limit = mf->read_pos - mf->read_ahead
; 188  : 					+ left - mf->match_len_max;

  001af	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  001b7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001bf	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  001c2	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  001c5	2b c1		 sub	 eax, ecx
  001c7	03 44 24 3c	 add	 eax, DWORD PTR left$33147[rsp]
  001cb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR mf$[rsp]
  001d3	2b 41 64	 sub	 eax, DWORD PTR [rcx+100]
  001d6	89 44 24 40	 mov	 DWORD PTR limit$33149[rsp], eax
$LN9@lzma2_enco@2:

; 189  : 		}
; 190  : 
; 191  : 		// Save the start position so that we can update
; 192  : 		// coder->uncompressed_size.
; 193  : 	  {
; 194  : 		const uint32_t read_start = mf->read_pos - mf->read_ahead;

  001da	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  001e2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  001ea	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  001ed	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  001f0	2b c1		 sub	 eax, ecx
  001f2	89 44 24 44	 mov	 DWORD PTR read_start$33152[rsp], eax

; 195  : 
; 196  : 		// Call the LZMA encoder until the chunk is finished.
; 197  : 		const lzma_ret ret = lzma_lzma_encode(coder->lzma, mf,
; 198  : 				coder->buf + LZMA2_HEADER_MAX,
; 199  : 				&coder->compressed_size,
; 200  : 				LZMA2_CHUNK_MAX, limit);

  001f6	4c 8b 4c 24 30	 mov	 r9, QWORD PTR coder$[rsp]
  001fb	49 81 c1 90 00
	00 00		 add	 r9, 144			; 00000090H
  00202	4c 8b 44 24 30	 mov	 r8, QWORD PTR coder$[rsp]
  00207	49 81 c0 a6 00
	00 00		 add	 r8, 166			; 000000a6H
  0020e	8b 44 24 40	 mov	 eax, DWORD PTR limit$33149[rsp]
  00212	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00216	48 c7 44 24 20
	00 00 01 00	 mov	 QWORD PTR [rsp+32], 65536 ; 00010000H
  0021f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00227	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0022c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00230	e8 00 00 00 00	 call	 lzma_lzma_encode
  00235	89 44 24 48	 mov	 DWORD PTR ret$33153[rsp], eax

; 201  : 
; 202  : 		coder->uncompressed_size += mf->read_pos - mf->read_ahead
; 203  : 				- read_start;

  00239	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00241	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  00249	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0024c	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  0024f	2b c1		 sub	 eax, ecx
  00251	2b 44 24 44	 sub	 eax, DWORD PTR read_start$33152[rsp]
  00255	8b c8		 mov	 ecx, eax
  00257	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0025c	48 03 88 88 00
	00 00		 add	 rcx, QWORD PTR [rax+136]
  00263	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00268	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 204  : 
; 205  : 		assert(coder->compressed_size <= LZMA2_CHUNK_MAX);
; 206  : 		assert(coder->uncompressed_size <= LZMA2_UNCOMPRESSED_MAX);
; 207  : 
; 208  : 		if (ret != LZMA_STREAM_END)

  0026f	83 7c 24 48 01	 cmp	 DWORD PTR ret$33153[rsp], 1
  00274	74 07		 je	 SHORT $LN8@lzma2_enco@2

; 209  : 			return LZMA_OK;

  00276	33 c0		 xor	 eax, eax
  00278	e9 61 02 00 00	 jmp	 $LN24@lzma2_enco@2
$LN8@lzma2_enco@2:

; 210  : 
; 211  : 		// See if the chunk compressed. If it didn't, we encode it
; 212  : 		// as uncompressed chunk. This saves a few bytes of space
; 213  : 		// and makes decoding faster.
; 214  : 		if (coder->compressed_size >= coder->uncompressed_size) {

  0027d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00282	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00287	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0028e	48 39 81 90 00
	00 00		 cmp	 QWORD PTR [rcx+144], rax
  00295	72 59		 jb	 SHORT $LN7@lzma2_enco@2

; 215  : 			coder->uncompressed_size += mf->read_ahead;

  00297	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0029f	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  002a2	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002a7	48 03 88 88 00
	00 00		 add	 rcx, QWORD PTR [rax+136]
  002ae	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002b3	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 216  : 			assert(coder->uncompressed_size
; 217  : 					<= LZMA2_UNCOMPRESSED_MAX);
; 218  : 			mf->read_ahead = 0;

  002ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  002c2	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 219  : 			lzma2_header_uncompressed(coder);

  002c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  002ce	e8 00 00 00 00	 call	 lzma2_header_uncompressed

; 220  : 			coder->need_state_reset = true;

  002d3	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  002d8	41 c6 83 81 00
	00 00 01	 mov	 BYTE PTR [r11+129], 1

; 221  : 			coder->sequence = SEQ_UNCOMPRESSED_HEADER;

  002e0	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002e5	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 222  : 			break;

  002eb	e9 e7 01 00 00	 jmp	 $LN20@lzma2_enco@2
$LN7@lzma2_enco@2:

; 223  : 		}
; 224  : 
; 225  : 		// The chunk did compress at least by one byte, so we store
; 226  : 		// the chunk as LZMA.
; 227  : 		lzma2_header_lzma(coder);

  002f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  002f5	e8 00 00 00 00	 call	 lzma2_header_lzma

; 228  : 
; 229  : 		coder->sequence = SEQ_LZMA_COPY;

  002fa	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  002ff	41 c7 03 02 00
	00 00		 mov	 DWORD PTR [r11], 2
$LN6@lzma2_enco@2:

; 230  : 	  }
; 231  : 	}
; 232  : 
; 233  : 	// Fall through
; 234  : 
; 235  : 	case SEQ_LZMA_COPY:
; 236  : 		// Copy the compressed chunk along its headers to the
; 237  : 		// output buffer.
; 238  : 		lzma_bufcpy(coder->buf, &coder->buf_pos,
; 239  : 				coder->compressed_size,
; 240  : 				out, out_pos, out_size);

  00306	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  0030b	48 81 c2 98 00
	00 00		 add	 rdx, 152		; 00000098H
  00312	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00317	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0031e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00326	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0032b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00333	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00338	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  00340	4c 8b 44 24 30	 mov	 r8, QWORD PTR coder$[rsp]
  00345	4d 8b 80 90 00
	00 00		 mov	 r8, QWORD PTR [r8+144]
  0034c	e8 00 00 00 00	 call	 lzma_bufcpy

; 241  : 		if (coder->buf_pos != coder->compressed_size)

  00351	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  00356	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0035b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00362	49 39 83 98 00
	00 00		 cmp	 QWORD PTR [r11+152], rax
  00369	74 07		 je	 SHORT $LN5@lzma2_enco@2

; 242  : 			return LZMA_OK;

  0036b	33 c0		 xor	 eax, eax
  0036d	e9 6c 01 00 00	 jmp	 $LN24@lzma2_enco@2
$LN5@lzma2_enco@2:

; 243  : 
; 244  : 		coder->sequence = SEQ_INIT;

  00372	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00377	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 245  : 		break;

  0037d	e9 55 01 00 00	 jmp	 $LN20@lzma2_enco@2
$LN4@lzma2_enco@2:

; 246  : 
; 247  : 	case SEQ_UNCOMPRESSED_HEADER:
; 248  : 		// Copy the three-byte header to indicate uncompressed chunk.
; 249  : 		lzma_bufcpy(coder->buf, &coder->buf_pos,
; 250  : 				LZMA2_HEADER_UNCOMPRESSED,
; 251  : 				out, out_pos, out_size);

  00382	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  00387	48 81 c2 98 00
	00 00		 add	 rdx, 152		; 00000098H
  0038e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00393	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0039a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  003a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003a7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  003af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b4	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  003bc	41 b8 03 00 00
	00		 mov	 r8d, 3
  003c2	e8 00 00 00 00	 call	 lzma_bufcpy

; 252  : 		if (coder->buf_pos != LZMA2_HEADER_UNCOMPRESSED)

  003c7	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  003cc	49 83 bb 98 00
	00 00 03	 cmp	 QWORD PTR [r11+152], 3
  003d4	74 07		 je	 SHORT $LN3@lzma2_enco@2

; 253  : 			return LZMA_OK;

  003d6	33 c0		 xor	 eax, eax
  003d8	e9 01 01 00 00	 jmp	 $LN24@lzma2_enco@2
$LN3@lzma2_enco@2:

; 254  : 
; 255  : 		coder->sequence = SEQ_UNCOMPRESSED_COPY;

  003dd	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  003e2	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN2@lzma2_enco@2:

; 256  : 
; 257  : 	// Fall through
; 258  : 
; 259  : 	case SEQ_UNCOMPRESSED_COPY:
; 260  : 		// Copy the uncompressed data as is from the dictionary
; 261  : 		// to the output buffer.
; 262  : 		mf_read(mf, out, out_pos, out_size, &coder->uncompressed_size);

  003e8	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  003ed	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  003f3	48 89 44 24 60	 mov	 QWORD PTR $T84451[rsp], rax
  003f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00400	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00403	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0040b	48 2b c1	 sub	 rax, rcx
  0040e	48 89 44 24 50	 mov	 QWORD PTR out_avail$84446[rsp], rax
  00413	48 8b 44 24 60	 mov	 rax, QWORD PTR $T84451[rsp]
  00418	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041b	48 39 44 24 50	 cmp	 QWORD PTR out_avail$84446[rsp], rax
  00420	73 0c		 jae	 SHORT $LN32@lzma2_enco@2
  00422	48 8b 44 24 50	 mov	 rax, QWORD PTR out_avail$84446[rsp]
  00427	48 89 44 24 70	 mov	 QWORD PTR tv207[rsp], rax
  0042c	eb 0d		 jmp	 SHORT $LN33@lzma2_enco@2
$LN32@lzma2_enco@2:
  0042e	48 8b 44 24 60	 mov	 rax, QWORD PTR $T84451[rsp]
  00433	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00436	48 89 44 24 70	 mov	 QWORD PTR tv207[rsp], rax
$LN33@lzma2_enco@2:
  0043b	48 8b 44 24 70	 mov	 rax, QWORD PTR tv207[rsp]
  00440	48 89 44 24 58	 mov	 QWORD PTR copy_size$84447[rsp], rax
  00445	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mf$[rsp]
  0044d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00450	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR mf$[rsp]
  00458	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0045b	48 03 d0	 add	 rdx, rax
  0045e	48 8b 44 24 60	 mov	 rax, QWORD PTR $T84451[rsp]
  00463	48 2b 10	 sub	 rdx, QWORD PTR [rax]
  00466	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0046e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00471	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00479	48 03 c8	 add	 rcx, rax
  0047c	4c 8b 44 24 58	 mov	 r8, QWORD PTR copy_size$84447[rsp]
  00481	e8 00 00 00 00	 call	 memcpy
  00486	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0048e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00491	48 03 4c 24 58	 add	 rcx, QWORD PTR copy_size$84447[rsp]
  00496	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0049e	48 89 08	 mov	 QWORD PTR [rax], rcx
  004a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T84451[rsp]
  004a6	48 8b 44 24 58	 mov	 rax, QWORD PTR copy_size$84447[rsp]
  004ab	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004ae	48 2b c8	 sub	 rcx, rax
  004b1	48 8b 44 24 60	 mov	 rax, QWORD PTR $T84451[rsp]
  004b6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 263  : 		if (coder->uncompressed_size != 0)

  004b9	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  004be	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  004c6	74 04		 je	 SHORT $LN1@lzma2_enco@2

; 264  : 			return LZMA_OK;

  004c8	33 c0		 xor	 eax, eax
  004ca	eb 12		 jmp	 SHORT $LN24@lzma2_enco@2
$LN1@lzma2_enco@2:

; 265  : 
; 266  : 		coder->sequence = SEQ_INIT;

  004cc	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  004d1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN20@lzma2_enco@2:

; 267  : 		break;
; 268  : 	}

  004d7	e9 4c fb ff ff	 jmp	 $LN23@lzma2_enco@2
$LN22@lzma2_enco@2:

; 269  : 
; 270  : 	return LZMA_OK;

  004dc	33 c0		 xor	 eax, eax
$LN24@lzma2_enco@2:

; 271  : }

  004de	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004e5	c3		 ret	 0
lzma2_encode ENDP
PUBLIC	$T84537
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_encoder_init DD imagerel lzma2_encoder_init
	DD	imagerel lzma2_encoder_init+476
	DD	imagerel $unwind$lzma2_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_encoder_init DD 041d01H
	DD	017011dH
	DD	060157016H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_encoder_init
_TEXT	SEGMENT
coder$33199 = 32
ret_$33211 = 40
$T84537 = 48
tv83 = 160
lz$ = 208
allocator$ = 216
options$ = 224
lz_options$ = 232
lzma2_encoder_init PROC					; COMDAT

; 323  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 324  : 	if (options == NULL)

  0001d	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR options$[rsp], 0
  00026	75 0a		 jne	 SHORT $LN8@lzma2_enco@3

; 325  : 		return LZMA_PROG_ERROR;

  00028	b8 0b 00 00 00	 mov	 eax, 11
  0002d	e9 a0 01 00 00	 jmp	 $LN9@lzma2_enco@3
$LN8@lzma2_enco@3:

; 326  : 
; 327  :   {
; 328  : 	lzma_lzma2_coder *coder = lz->coder;

  00032	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 44 24 20	 mov	 QWORD PTR coder$33199[rsp], rax

; 329  : 	if (coder == NULL) {

  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33199[rsp], 0
  00048	75 7f		 jne	 SHORT $LN7@lzma2_enco@3

; 330  : 		coder = lzma_alloc(sizeof(lzma_lzma2_coder), allocator);

  0004a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00052	b9 a8 00 01 00	 mov	 ecx, 65704		; 000100a8H
  00057	e8 00 00 00 00	 call	 lzma_alloc
  0005c	48 89 44 24 20	 mov	 QWORD PTR coder$33199[rsp], rax

; 331  : 		if (coder == NULL)

  00061	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$33199[rsp], 0
  00067	75 0a		 jne	 SHORT $LN6@lzma2_enco@3

; 332  : 			return LZMA_MEM_ERROR;

  00069	b8 05 00 00 00	 mov	 eax, 5
  0006e	e9 5f 01 00 00	 jmp	 $LN9@lzma2_enco@3
$LN6@lzma2_enco@3:

; 333  : 
; 334  : 		lz->coder = coder;

  00073	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  00080	48 89 01	 mov	 QWORD PTR [rcx], rax

; 335  : 		lz->code = &lzma2_encode;

  00083	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma2_encode
  00092	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 336  : 		lz->end = &lzma2_encoder_end;

  00096	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma2_encoder_end
  000a5	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 337  : 		lz->options_update = &lzma2_encoder_options_update;

  000a9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma2_encoder_options_update
  000b8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 338  : 
; 339  : 		coder->lzma = NULL;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  000c1	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN7@lzma2_enco@3:

; 340  : 	}
; 341  : 
; 342  : 	coder->opt_cur = *(const lzma_options_lzma *)(options);

  000c9	48 8d 7c 24 30	 lea	 rdi, QWORD PTR $T84537[rsp]
  000ce	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR options$[rsp]
  000d6	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000db	f3 a4		 rep movsb
  000dd	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$33199[rsp]
  000e2	48 8d 74 24 30	 lea	 rsi, QWORD PTR $T84537[rsp]
  000e7	48 83 c7 10	 add	 rdi, 16
  000eb	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000f0	f3 a4		 rep movsb

; 343  : 
; 344  : 	coder->sequence = SEQ_INIT;

  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  000f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 345  : 	coder->need_properties = true;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  00102	c6 80 80 00 00
	00 01		 mov	 BYTE PTR [rax+128], 1

; 346  : 	coder->need_state_reset = false;

  00109	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  0010e	c6 80 81 00 00
	00 00		 mov	 BYTE PTR [rax+129], 0

; 347  : 	coder->need_dictionary_reset
; 348  : 			= coder->opt_cur.preset_dict == NULL
; 349  : 			|| coder->opt_cur.preset_dict_size == 0;

  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  0011a	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0011f	74 18		 je	 SHORT $LN11@lzma2_enco@3
  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$33199[rsp]
  00126	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0012a	74 0d		 je	 SHORT $LN11@lzma2_enco@3
  0012c	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv83[rsp], 0
  00137	eb 0b		 jmp	 SHORT $LN12@lzma2_enco@3
$LN11@lzma2_enco@3:
  00139	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv83[rsp], 1
$LN12@lzma2_enco@3:
  00144	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33199[rsp]
  00149	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv83[rsp]
  00151	88 81 82 00 00
	00		 mov	 BYTE PTR [rcx+130], al
$LN5@lzma2_enco@3:

; 350  : 
; 351  : 	// Initialize LZMA encoder
; 352  : 	return_if_error(lzma_lzma_encoder_create(&coder->lzma, allocator,
; 353  : 			&coder->opt_cur, lz_options));

  00157	4c 8b 44 24 20	 mov	 r8, QWORD PTR coder$33199[rsp]
  0015c	49 83 c0 10	 add	 r8, 16
  00160	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$33199[rsp]
  00165	48 83 c1 08	 add	 rcx, 8
  00169	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR lz_options$[rsp]
  00171	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00179	e8 00 00 00 00	 call	 lzma_lzma_encoder_create
  0017e	89 44 24 28	 mov	 DWORD PTR ret_$33211[rsp], eax
  00182	83 7c 24 28 00	 cmp	 DWORD PTR ret_$33211[rsp], 0
  00187	74 06		 je	 SHORT $LN2@lzma2_enco@3
  00189	8b 44 24 28	 mov	 eax, DWORD PTR ret_$33211[rsp]
  0018d	eb 43		 jmp	 SHORT $LN9@lzma2_enco@3
$LN2@lzma2_enco@3:
  0018f	33 c0		 xor	 eax, eax
  00191	85 c0		 test	 eax, eax
  00193	75 c2		 jne	 SHORT $LN5@lzma2_enco@3

; 354  :   }
; 355  : 
; 356  : 	// Make sure that we will always have enough history available in
; 357  : 	// case we need to use uncompressed chunks. They are used when the
; 358  : 	// compressed size of a chunk is not smaller than the uncompressed
; 359  : 	// size, so we need to have at least LZMA2_COMPRESSED_MAX bytes
; 360  : 	// history available.
; 361  : 	if (lz_options->before_size + lz_options->dict_size < LZMA2_CHUNK_MAX)

  00195	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR lz_options$[rsp]
  0019d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR lz_options$[rsp]
  001a8	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  001ac	48 3d 00 00 01
	00		 cmp	 rax, 65536		; 00010000H
  001b2	73 1c		 jae	 SHORT $LN1@lzma2_enco@3

; 362  : 		lz_options->before_size
; 363  : 				= LZMA2_CHUNK_MAX - lz_options->dict_size;

  001b4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR lz_options$[rsp]
  001bc	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  001c1	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  001c5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR lz_options$[rsp]
  001cd	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@lzma2_enco@3:

; 364  : 
; 365  : 	return LZMA_OK;

  001d0	33 c0		 xor	 eax, eax
$LN9@lzma2_enco@3:

; 366  : }

  001d2	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  001d9	5f		 pop	 rdi
  001da	5e		 pop	 rsi
  001db	c3		 ret	 0
lzma2_encoder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma2_encoder_init DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$lzma_lzma2_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_encoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_encoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_lzma2_encoder_init PROC				; COMDAT

; 372  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 373  : 	return lzma_lz_encoder_init(
; 374  : 			next, allocator, filters, &lzma2_encoder_init);

  00013	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:lzma2_encoder_init
  0001a	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00029	e8 00 00 00 00	 call	 lzma_lz_encoder_init

; 375  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
lzma_lzma2_encoder_init ENDP
END
