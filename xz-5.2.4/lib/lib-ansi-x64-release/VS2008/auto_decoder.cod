; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\projects\mpython\cpython89\externals\xz-5.2.3\src\c89\liblzma\common\auto_decoder.c
pdata	SEGMENT
$pdata$auto_decoder_memconfig DD imagerel auto_decoder_memconfig
	DD	imagerel auto_decoder_memconfig+158
	DD	imagerel $unwind$auto_decoder_memconfig
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$auto_decoder_memconfig DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT auto_decoder_memconfig
_TEXT	SEGMENT
ret$ = 32
coder$ = 40
coder_ptr$ = 64
memusage$ = 72
old_memlimit$ = 80
new_memlimit$ = 88
auto_decoder_memconfig PROC				; COMDAT

; 128  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 129  : 	lzma_auto_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR coder$[rsp], rax

; 130  : 
; 131  : 	lzma_ret ret;
; 132  : 
; 133  : 	if (coder->next.memconfig != NULL) {

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  00027	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0002c	74 25		 je	 SHORT $LN3@auto_decod

; 134  : 		ret = coder->next.memconfig(coder->next.coder,
; 135  : 				memusage, old_memlimit, new_memlimit);

  0002e	4c 8b 4c 24 58	 mov	 r9, QWORD PTR new_memlimit$[rsp]
  00033	4c 8b 44 24 50	 mov	 r8, QWORD PTR old_memlimit$[rsp]
  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR memusage$[rsp]
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR coder$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  0004a	ff 50 38	 call	 QWORD PTR [rax+56]
  0004d	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 136  : 		assert(*old_memlimit == coder->memlimit);
; 137  : 	} else {

  00051	eb 25		 jmp	 SHORT $LN2@auto_decod
$LN3@auto_decod:

; 138  : 		// No coder is configured yet. Use the base value as
; 139  : 		// the current memory usage.
; 140  : 		*memusage = LZMA_MEMUSAGE_BASE;

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR memusage$[rsp]
  00058	48 c7 00 00 80
	00 00		 mov	 QWORD PTR [rax], 32768	; 00008000H

; 141  : 		*old_memlimit = coder->memlimit;

  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR old_memlimit$[rsp]
  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  00069	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0006d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 142  : 		ret = LZMA_OK;

  00070	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN2@auto_decod:

; 143  : 	}
; 144  : 
; 145  : 	if (ret == LZMA_OK && new_memlimit != 0)

  00078	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  0007d	75 16		 jne	 SHORT $LN1@auto_decod
  0007f	48 83 7c 24 58
	00		 cmp	 QWORD PTR new_memlimit$[rsp], 0
  00085	74 0e		 je	 SHORT $LN1@auto_decod

; 146  : 		coder->memlimit = new_memlimit;

  00087	48 8b 4c 24 28	 mov	 rcx, QWORD PTR coder$[rsp]
  0008c	48 8b 44 24 58	 mov	 rax, QWORD PTR new_memlimit$[rsp]
  00091	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN1@auto_decod:

; 147  : 
; 148  : 	return ret;

  00095	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]

; 149  : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
auto_decoder_memconfig ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$auto_decoder_get_check DD imagerel auto_decoder_get_check
	DD	imagerel auto_decoder_get_check+70
	DD	imagerel $unwind$auto_decoder_get_check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$auto_decoder_get_check DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT auto_decoder_get_check
_TEXT	SEGMENT
coder$ = 32
tv69 = 40
coder_ptr$ = 64
auto_decoder_get_check PROC				; COMDAT

; 116  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 117  : 	const lzma_auto_coder *coder = coder_ptr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 118  : 
; 119  : 	// It is LZMA_Alone if get_check is NULL.
; 120  : 	return coder->next.get_check == NULL ? LZMA_CHECK_NONE
; 121  : 			: coder->next.get_check(coder->next.coder);

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00018	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0001d	75 0a		 jne	 SHORT $LN3@auto_decod@2
  0001f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00027	eb 14		 jmp	 SHORT $LN4@auto_decod@2
$LN3@auto_decod@2:
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0002e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00036	ff 50 30	 call	 QWORD PTR [rax+48]
  00039	89 44 24 28	 mov	 DWORD PTR tv69[rsp], eax
$LN4@auto_decod@2:
  0003d	8b 44 24 28	 mov	 eax, DWORD PTR tv69[rsp]

; 122  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
auto_decoder_get_check ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$auto_decoder_end DD imagerel auto_decoder_end
	DD	imagerel auto_decoder_end+59
	DD	imagerel $unwind$auto_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$auto_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT auto_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
auto_decoder_end PROC					; COMDAT

; 106  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 107  : 	lzma_auto_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 108  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 109  : 	lzma_free(coder, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_free

; 110  : 	return;
; 111  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
auto_decoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$auto_decode DD imagerel auto_decode
	DD	imagerel auto_decode+542
	DD	imagerel $unwind$auto_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$auto_decode DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT auto_decode
_TEXT	SEGMENT
coder$ = 80
ret_$32867 = 88
ret_$32873 = 92
ret$32878 = 96
tv65 = 100
tv144 = 104
coder_ptr$ = 128
allocator$ = 136
in$ = 144
in_pos$ = 152
in_size$ = 160
out$ = 168
out_pos$ = 176
out_size$ = 184
action$ = 192
auto_decode PROC					; COMDAT

; 37   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 38   : 	lzma_auto_coder *coder = coder_ptr;

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00020	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 39   : 
; 40   : 	switch (coder->sequence) {

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0002a	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0002d	89 44 24 64	 mov	 DWORD PTR tv65[rsp], eax
  00031	83 7c 24 64 00	 cmp	 DWORD PTR tv65[rsp], 0
  00036	74 1b		 je	 SHORT $LN20@auto_decod@3
  00038	83 7c 24 64 01	 cmp	 DWORD PTR tv65[rsp], 1
  0003d	0f 84 00 01 00
	00		 je	 $LN6@auto_decod@3
  00043	83 7c 24 64 02	 cmp	 DWORD PTR tv65[rsp], 2
  00048	0f 84 88 01 00
	00		 je	 $LN3@auto_decod@3
  0004e	e9 c1 01 00 00	 jmp	 $LN1@auto_decod@3
$LN20@auto_decod@3:

; 41   : 	case SEQ_INIT:
; 42   : 		if (*in_pos >= in_size)

  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0005b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00063	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00066	72 07		 jb	 SHORT $LN19@auto_decod@3

; 43   : 			return LZMA_OK;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 aa 01 00 00	 jmp	 $LN23@auto_decod@3
$LN19@auto_decod@3:

; 44   : 
; 45   : 		// Update the sequence now, because we want to continue from
; 46   : 		// SEQ_CODE even if we return some LZMA_*_CHECK.
; 47   : 		coder->sequence = SEQ_CODE;

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00074	c7 40 54 01 00
	00 00		 mov	 DWORD PTR [rax+84], 1

; 48   : 
; 49   : 		// Detect the file format. For now this is simple, since if
; 50   : 		// it doesn't start with 0xFD (the first magic byte of the
; 51   : 		// new format), it has to be LZMA_Alone, or something that
; 52   : 		// we don't support at all.
; 53   : 		if (in[*in_pos] == 0xFD) {

  0007b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0008e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00092	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  00097	75 40		 jne	 SHORT $LN18@auto_decod@3
$LN17@auto_decod@3:

; 54   : 			return_if_error(lzma_stream_decoder_init(
; 55   : 					&coder->next, allocator,
; 56   : 					coder->memlimit, coder->flags));

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0009e	44 8b 48 50	 mov	 r9d, DWORD PTR [rax+80]
  000a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  000a7	4d 8b 40 48	 mov	 r8, QWORD PTR [r8+72]
  000ab	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000b8	e8 00 00 00 00	 call	 lzma_stream_decoder_init
  000bd	89 44 24 58	 mov	 DWORD PTR ret_$32867[rsp], eax
  000c1	83 7c 24 58 00	 cmp	 DWORD PTR ret_$32867[rsp], 0
  000c6	74 09		 je	 SHORT $LN14@auto_decod@3
  000c8	8b 44 24 58	 mov	 eax, DWORD PTR ret_$32867[rsp]
  000cc	e9 48 01 00 00	 jmp	 $LN23@auto_decod@3
$LN14@auto_decod@3:
  000d1	33 c0		 xor	 eax, eax
  000d3	85 c0		 test	 eax, eax
  000d5	75 c2		 jne	 SHORT $LN17@auto_decod@3

; 57   : 		} else {

  000d7	eb 6a		 jmp	 SHORT $LN13@auto_decod@3
$LN18@auto_decod@3:
$LN12@auto_decod@3:

; 58   : 			return_if_error(lzma_alone_decoder_init(&coder->next,
; 59   : 					allocator, coder->memlimit, true));

  000d9	41 b1 01	 mov	 r9b, 1
  000dc	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  000e1	4d 8b 40 48	 mov	 r8, QWORD PTR [r8+72]
  000e5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000f2	e8 00 00 00 00	 call	 lzma_alone_decoder_init
  000f7	89 44 24 5c	 mov	 DWORD PTR ret_$32873[rsp], eax
  000fb	83 7c 24 5c 00	 cmp	 DWORD PTR ret_$32873[rsp], 0
  00100	74 09		 je	 SHORT $LN9@auto_decod@3
  00102	8b 44 24 5c	 mov	 eax, DWORD PTR ret_$32873[rsp]
  00106	e9 0e 01 00 00	 jmp	 $LN23@auto_decod@3
$LN9@auto_decod@3:
  0010b	33 c0		 xor	 eax, eax
  0010d	85 c0		 test	 eax, eax
  0010f	75 c8		 jne	 SHORT $LN12@auto_decod@3

; 60   : 
; 61   : 			// If the application wants to know about missing
; 62   : 			// integrity check or about the check in general, we
; 63   : 			// need to handle it here, because LZMA_Alone decoder
; 64   : 			// doesn't accept any flags.
; 65   : 			if (coder->flags & LZMA_TELL_NO_CHECK)

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00116	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00119	83 e0 01	 and	 eax, 1
  0011c	85 c0		 test	 eax, eax
  0011e	74 0a		 je	 SHORT $LN8@auto_decod@3

; 66   : 				return LZMA_NO_CHECK;

  00120	b8 02 00 00 00	 mov	 eax, 2
  00125	e9 ef 00 00 00	 jmp	 $LN23@auto_decod@3
$LN8@auto_decod@3:

; 67   : 
; 68   : 			if (coder->flags & LZMA_TELL_ANY_CHECK)

  0012a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0012f	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00132	83 e0 04	 and	 eax, 4
  00135	85 c0		 test	 eax, eax
  00137	74 0a		 je	 SHORT $LN7@auto_decod@3

; 69   : 				return LZMA_GET_CHECK;

  00139	b8 04 00 00 00	 mov	 eax, 4
  0013e	e9 d6 00 00 00	 jmp	 $LN23@auto_decod@3
$LN7@auto_decod@3:
$LN13@auto_decod@3:
$LN6@auto_decod@3:

; 70   : 		}
; 71   : 
; 72   : 	// Fall through
; 73   : 
; 74   : 	case SEQ_CODE: {
; 75   : 		const lzma_ret ret = coder->next.code(
; 76   : 				coder->next.coder, allocator,
; 77   : 				in, in_pos, in_size,
; 78   : 				out, out_pos, out_size, action);

  00143	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  0014a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0014e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00156	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0015b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00163	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00168	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00170	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00175	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0017d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00182	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  0018a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00192	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0019a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0019f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001a2	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001a7	ff 50 18	 call	 QWORD PTR [rax+24]
  001aa	89 44 24 60	 mov	 DWORD PTR ret$32878[rsp], eax

; 79   : 		if (ret != LZMA_STREAM_END
; 80   : 				|| (coder->flags & LZMA_CONCATENATED) == 0)

  001ae	83 7c 24 60 01	 cmp	 DWORD PTR ret$32878[rsp], 1
  001b3	75 0f		 jne	 SHORT $LN4@auto_decod@3
  001b5	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001ba	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  001bd	83 e0 08	 and	 eax, 8
  001c0	85 c0		 test	 eax, eax
  001c2	75 06		 jne	 SHORT $LN5@auto_decod@3
$LN4@auto_decod@3:

; 81   : 			return ret;

  001c4	8b 44 24 60	 mov	 eax, DWORD PTR ret$32878[rsp]
  001c8	eb 4f		 jmp	 SHORT $LN23@auto_decod@3
$LN5@auto_decod@3:

; 82   : 
; 83   : 		coder->sequence = SEQ_FINISH;

  001ca	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001cf	c7 40 54 02 00
	00 00		 mov	 DWORD PTR [rax+84], 2
$LN3@auto_decod@3:

; 84   : 	}
; 85   : 
; 86   : 	// Fall through
; 87   : 
; 88   : 	case SEQ_FINISH:
; 89   : 		// When LZMA_DECODE_CONCATENATED was used and we were decoding
; 90   : 		// LZMA_Alone file, we need to check check that there is no
; 91   : 		// trailing garbage and wait for LZMA_FINISH.
; 92   : 		if (*in_pos < in_size)

  001d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  001de	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001e6	48 39 01	 cmp	 QWORD PTR [rcx], rax
  001e9	73 07		 jae	 SHORT $LN2@auto_decod@3

; 93   : 			return LZMA_DATA_ERROR;

  001eb	b8 09 00 00 00	 mov	 eax, 9
  001f0	eb 27		 jmp	 SHORT $LN23@auto_decod@3
$LN2@auto_decod@3:

; 94   : 
; 95   : 		return action == LZMA_FINISH ? LZMA_STREAM_END : LZMA_OK;

  001f2	83 bc 24 c0 00
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  001fa	75 0a		 jne	 SHORT $LN25@auto_decod@3
  001fc	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  00204	eb 08		 jmp	 SHORT $LN26@auto_decod@3
$LN25@auto_decod@3:
  00206	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN26@auto_decod@3:
  0020e	8b 44 24 68	 mov	 eax, DWORD PTR tv144[rsp]
  00212	eb 05		 jmp	 SHORT $LN23@auto_decod@3
$LN1@auto_decod@3:

; 96   : 
; 97   : 	default:
; 98   : 		assert(0);
; 99   : 		return LZMA_PROG_ERROR;

  00214	b8 0b 00 00 00	 mov	 eax, 11
$LN23@auto_decod@3:

; 100  : 	}
; 101  : }

  00219	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0021d	c3		 ret	 0
auto_decode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$auto_decoder_init DD imagerel auto_decoder_init
	DD	imagerel auto_decoder_init+326
	DD	imagerel $unwind$auto_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$auto_decoder_init DD 031a01H
	DD	07016621aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT auto_decoder_init
_TEXT	SEGMENT
coder$32933 = 32
next$ = 80
allocator$ = 88
memlimit$ = 96
flags$ = 104
auto_decoder_init PROC					; COMDAT

; 155  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@auto_decod@4:

; 156  : 	lzma_next_coder_init(&auto_decoder_init, next, allocator);

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:auto_decoder_init
  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00026	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0002a	74 0f		 je	 SHORT $LN5@auto_decod@4
  0002c	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00036	e8 00 00 00 00	 call	 lzma_next_end
$LN5@auto_decod@4:
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:auto_decoder_init
  00047	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 c9		 jne	 SHORT $LN8@auto_decod@4

; 157  : 
; 158  : 	if (memlimit == 0)

  00051	48 83 7c 24 60
	00		 cmp	 QWORD PTR memlimit$[rsp], 0
  00057	75 0a		 jne	 SHORT $LN4@auto_decod@4

; 159  : 		return LZMA_PROG_ERROR;

  00059	b8 0b 00 00 00	 mov	 eax, 11
  0005e	e9 dc 00 00 00	 jmp	 $LN9@auto_decod@4
$LN4@auto_decod@4:

; 160  : 
; 161  : 	if (flags & ~LZMA_SUPPORTED_FLAGS)

  00063	8b 44 24 68	 mov	 eax, DWORD PTR flags$[rsp]
  00067	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0006a	85 c0		 test	 eax, eax
  0006c	74 0a		 je	 SHORT $LN3@auto_decod@4

; 162  : 		return LZMA_OPTIONS_ERROR;

  0006e	b8 08 00 00 00	 mov	 eax, 8
  00073	e9 c7 00 00 00	 jmp	 $LN9@auto_decod@4
$LN3@auto_decod@4:

; 163  : 
; 164  :   {
; 165  : 	lzma_auto_coder *coder = next->coder;

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 89 44 24 20	 mov	 QWORD PTR coder$32933[rsp], rax

; 166  : 	if (coder == NULL) {

  00085	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32933[rsp], 0
  0008b	0f 85 86 00 00
	00		 jne	 $LN2@auto_decod@4

; 167  : 		coder = lzma_alloc(sizeof(lzma_auto_coder), allocator);

  00091	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00096	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  0009b	e8 00 00 00 00	 call	 lzma_alloc
  000a0	48 89 44 24 20	 mov	 QWORD PTR coder$32933[rsp], rax

; 168  : 		if (coder == NULL)

  000a5	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32933[rsp], 0
  000ab	75 0a		 jne	 SHORT $LN1@auto_decod@4

; 169  : 			return LZMA_MEM_ERROR;

  000ad	b8 05 00 00 00	 mov	 eax, 5
  000b2	e9 88 00 00 00	 jmp	 $LN9@auto_decod@4
$LN1@auto_decod@4:

; 170  : 
; 171  : 		next->coder = coder;

  000b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32933[rsp]
  000c1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 172  : 		next->code = &auto_decode;

  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:auto_decode
  000d0	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 173  : 		next->end = &auto_decoder_end;

  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:auto_decoder_end
  000e0	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 174  : 		next->get_check = &auto_decoder_get_check;

  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:auto_decoder_get_check
  000f0	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 175  : 		next->memconfig = &auto_decoder_memconfig;

  000f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:auto_decoder_memconfig
  00100	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 176  : 		coder->next = LZMA_NEXT_CODER_INIT;

  00104	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  0010b	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32933[rsp]
  00110	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00115	f3 a4		 rep movsb
$LN2@auto_decod@4:

; 177  : 	}
; 178  : 
; 179  : 	coder->memlimit = memlimit;

  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32933[rsp]
  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR memlimit$[rsp]
  00121	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 180  : 	coder->flags = flags;

  00125	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32933[rsp]
  0012a	8b 44 24 68	 mov	 eax, DWORD PTR flags$[rsp]
  0012e	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 181  : 	coder->sequence = SEQ_INIT;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32933[rsp]
  00136	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 182  :   }
; 183  : 
; 184  : 	return LZMA_OK;

  0013d	33 c0		 xor	 eax, eax
$LN9@auto_decod@4:

; 185  : }

  0013f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00143	5f		 pop	 rdi
  00144	5e		 pop	 rsi
  00145	c3		 ret	 0
auto_decoder_init ENDP
PUBLIC	lzma_auto_decoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_auto_decoder DD imagerel $LN11
	DD	imagerel $LN11+151
	DD	imagerel $unwind$lzma_auto_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_auto_decoder DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_auto_decoder
_TEXT	SEGMENT
ret_$32952 = 32
ret_$32954 = 36
strm$ = 64
memlimit$ = 72
flags$ = 80
lzma_auto_decoder PROC					; COMDAT

; 190  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_auto_:
$LN5@lzma_auto_:

; 191  : 	lzma_next_strm_init(auto_decoder_init, strm, memlimit, flags);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_strm_init
  0001d	89 44 24 20	 mov	 DWORD PTR ret_$32952[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR ret_$32952[rsp], 0
  00026	74 06		 je	 SHORT $LN2@lzma_auto_
  00028	8b 44 24 20	 mov	 eax, DWORD PTR ret_$32952[rsp]
  0002c	eb 64		 jmp	 SHORT $LN9@lzma_auto_
$LN2@lzma_auto_:
  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 df		 jne	 SHORT $LN5@lzma_auto_
  00034	44 8b 4c 24 50	 mov	 r9d, DWORD PTR flags$[rsp]
  00039	4c 8b 44 24 48	 mov	 r8, QWORD PTR memlimit$[rsp]
  0003e	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00043	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0004c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00050	e8 00 00 00 00	 call	 auto_decoder_init
  00055	89 44 24 24	 mov	 DWORD PTR ret_$32954[rsp], eax
  00059	83 7c 24 24 00	 cmp	 DWORD PTR ret_$32954[rsp], 0
  0005e	74 10		 je	 SHORT $LN1@lzma_auto_
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00065	e8 00 00 00 00	 call	 lzma_end
  0006a	8b 44 24 24	 mov	 eax, DWORD PTR ret_$32954[rsp]
  0006e	eb 22		 jmp	 SHORT $LN9@lzma_auto_
$LN1@lzma_auto_:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 9d		 jne	 SHORT $LN8@lzma_auto_

; 192  : 
; 193  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0007f	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 194  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00088	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008c	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 195  : 
; 196  : 	return LZMA_OK;

  00090	33 c0		 xor	 eax, eax
$LN9@lzma_auto_:

; 197  : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
lzma_auto_decoder ENDP
END
