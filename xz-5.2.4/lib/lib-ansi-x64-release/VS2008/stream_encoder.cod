; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+6
?convert@?7??stream_encode@@9@9 DD 00H			; `stream_encode'::`8'::convert
	DD	01H
	DD	03H
	DD	03H
	DD	03H
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder.c
pdata	SEGMENT
$pdata$stream_encoder_end DD imagerel stream_encoder_end
	DD	imagerel stream_encoder_end+191
	DD	imagerel $unwind$stream_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_encoder_end
_TEXT	SEGMENT
coder$ = 32
i$32927 = 40
coder_ptr$ = 64
allocator$ = 72
stream_encoder_end PROC					; COMDAT

; 226  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 227  : 	lzma_stream_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 228  : 
; 229  : 	lzma_next_end(&coder->block_encoder, allocator);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 83 c1 08	 add	 rcx, 8
  00021	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00026	e8 00 00 00 00	 call	 lzma_next_end

; 230  : 	lzma_next_end(&coder->index_encoder, allocator);

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00030	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  00037	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0003c	e8 00 00 00 00	 call	 lzma_next_end

; 231  : 	lzma_index_end(coder->index, allocator);

  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0004b	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  00052	e8 00 00 00 00	 call	 lzma_index_end

; 232  :   {
; 233  :   size_t i;
; 234  : 
; 235  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  00057	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$32927[rsp], 0
  00060	eb 0e		 jmp	 SHORT $LN3@stream_enc
$LN2@stream_enc:
  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR i$32927[rsp]
  00067	48 83 c0 01	 add	 rax, 1
  0006b	48 89 44 24 28	 mov	 QWORD PTR i$32927[rsp], rax
$LN3@stream_enc:
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$32927[rsp]
  00075	48 6b c9 10	 imul	 rcx, 16
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0007e	48 83 bc 08 20
	01 00 00 ff	 cmp	 QWORD PTR [rax+rcx+288], -1
  00087	74 22		 je	 SHORT $LN1@stream_enc

; 236  : 		lzma_free(coder->filters[i].options, allocator);

  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR i$32927[rsp]
  0008e	48 6b c0 10	 imul	 rax, 16
  00092	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0009c	48 8b 8c 01 28
	01 00 00	 mov	 rcx, QWORD PTR [rcx+rax+296]
  000a4	e8 00 00 00 00	 call	 lzma_free
  000a9	eb b7		 jmp	 SHORT $LN2@stream_enc
$LN1@stream_enc:

; 237  :   }
; 238  : 
; 239  : 	lzma_free(coder, allocator);

  000ab	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000b5	e8 00 00 00 00	 call	 lzma_free

; 240  : 	return;
; 241  : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
stream_encoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_encoder_init DD imagerel block_encoder_init
	DD	imagerel block_encoder_init+110
	DD	imagerel $unwind$block_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encoder_init DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encoder_init
_TEXT	SEGMENT
ret_$32849 = 32
coder$ = 64
allocator$ = 72
block_encoder_init PROC					; COMDAT

; 63   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 64   : 	// Prepare the Block options. Even though Block encoder doesn't need
; 65   : 	// compressed_size, uncompressed_size, and header_size to be
; 66   : 	// initialized, it is a good idea to do it here, because this way
; 67   : 	// we catch if someone gave us Filter ID that cannot be used in
; 68   : 	// Blocks/Streams.
; 69   : 	coder->block_options.compressed_size = LZMA_VLI_UNKNOWN;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00013	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 70   : 	coder->block_options.uncompressed_size = LZMA_VLI_UNKNOWN;

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00020	48 c7 40 68 ff
	ff ff ff	 mov	 QWORD PTR [rax+104], -1
$LN4@block_enco@5:

; 71   : 
; 72   : 	return_if_error(lzma_block_header_size(&coder->block_options));

  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0002d	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00031	e8 00 00 00 00	 call	 lzma_block_header_size
  00036	89 44 24 20	 mov	 DWORD PTR ret_$32849[rsp], eax
  0003a	83 7c 24 20 00	 cmp	 DWORD PTR ret_$32849[rsp], 0
  0003f	74 06		 je	 SHORT $LN1@block_enco@5
  00041	8b 44 24 20	 mov	 eax, DWORD PTR ret_$32849[rsp]
  00045	eb 22		 jmp	 SHORT $LN5@block_enco@5
$LN1@block_enco@5:
  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 db		 jne	 SHORT $LN4@block_enco@5

; 73   : 
; 74   : 	// Initialize the actual Block encoder.
; 75   : 	return lzma_block_encoder_init(&coder->block_encoder, allocator,
; 76   : 			&coder->block_options);

  0004d	4c 8b 44 24 40	 mov	 r8, QWORD PTR coder$[rsp]
  00052	49 83 c0 50	 add	 r8, 80			; 00000050H
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0005b	48 83 c1 08	 add	 rcx, 8
  0005f	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00064	e8 00 00 00 00	 call	 lzma_block_encoder_init
$LN5@block_enco@5:

; 77   : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
block_encoder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_encoder_update DD imagerel stream_encoder_update
	DD	imagerel stream_encoder_update+324
	DD	imagerel $unwind$stream_encoder_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encoder_update DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_encoder_update
_TEXT	SEGMENT
coder$ = 32
ret$32944 = 40
ret_$32951 = 44
i$32954 = 48
coder_ptr$ = 80
allocator$ = 88
filters$ = 96
reversed_filters$ = 104
stream_encoder_update PROC				; COMDAT

; 248  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 249  : 	lzma_stream_coder *coder = coder_ptr;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 250  : 
; 251  : 	if (coder->sequence <= SEQ_BLOCK_INIT) {

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00027	83 38 01	 cmp	 DWORD PTR [rax], 1
  0002a	7f 5a		 jg	 SHORT $LN12@stream_enc@3

; 252  : 		// There is no incomplete Block waiting to be finished,
; 253  : 		// thus we can change the whole filter chain. Start by
; 254  : 		// trying to initialize the Block encoder with the new
; 255  : 		// chain. This way we detect if the chain is valid.
; 256  : 		coder->block_encoder_is_initialized = false;

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00031	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 257  : 		coder->block_options.filters = (lzma_filter *)(filters);

  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR filters$[rsp]
  0003f	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 258  :     {
; 259  : 		const lzma_ret ret = block_encoder_init(coder, allocator);

  00043	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0004d	e8 00 00 00 00	 call	 block_encoder_init
  00052	89 44 24 28	 mov	 DWORD PTR ret$32944[rsp], eax

; 260  : 		coder->block_options.filters = coder->filters;

  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0005b	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00067	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 261  : 		if (ret != LZMA_OK)

  0006b	83 7c 24 28 00	 cmp	 DWORD PTR ret$32944[rsp], 0
  00070	74 09		 je	 SHORT $LN11@stream_enc@3

; 262  : 			return ret;

  00072	8b 44 24 28	 mov	 eax, DWORD PTR ret$32944[rsp]
  00076	e9 c4 00 00 00	 jmp	 $LN13@stream_enc@3
$LN11@stream_enc@3:

; 263  :     }
; 264  : 
; 265  : 		coder->block_encoder_is_initialized = true;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00080	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1
  00084	eb 4a		 jmp	 SHORT $LN10@stream_enc@3
$LN12@stream_enc@3:

; 266  : 
; 267  : 	} else if (coder->sequence <= SEQ_BLOCK_ENCODE) {

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0008b	83 38 03	 cmp	 DWORD PTR [rax], 3
  0008e	7f 39		 jg	 SHORT $LN9@stream_enc@3
$LN8@stream_enc@3:

; 268  : 		// We are in the middle of a Block. Try to update only
; 269  : 		// the filter-specific options.
; 270  : 		return_if_error(coder->block_encoder.update(
; 271  : 				coder->block_encoder.coder, allocator,
; 272  : 				filters, reversed_filters));

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR reversed_filters$[rsp]
  00095	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000a4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000ad	ff 50 48	 call	 QWORD PTR [rax+72]
  000b0	89 44 24 2c	 mov	 DWORD PTR ret_$32951[rsp], eax
  000b4	83 7c 24 2c 00	 cmp	 DWORD PTR ret_$32951[rsp], 0
  000b9	74 06		 je	 SHORT $LN5@stream_enc@3
  000bb	8b 44 24 2c	 mov	 eax, DWORD PTR ret_$32951[rsp]
  000bf	eb 7e		 jmp	 SHORT $LN13@stream_enc@3
$LN5@stream_enc@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 c9		 jne	 SHORT $LN8@stream_enc@3

; 273  : 	} else {

  000c7	eb 07		 jmp	 SHORT $LN4@stream_enc@3
$LN9@stream_enc@3:

; 274  : 		// Trying to update the filter chain when we are already
; 275  : 		// encoding Index or Stream Footer.
; 276  : 		return LZMA_PROG_ERROR;

  000c9	b8 0b 00 00 00	 mov	 eax, 11
  000ce	eb 6f		 jmp	 SHORT $LN13@stream_enc@3
$LN4@stream_enc@3:
$LN10@stream_enc@3:

; 277  : 	}
; 278  : 
; 279  : 	// Free the copy of the old chain and make a copy of the new chain.
; 280  :   { size_t i;
; 281  : 
; 282  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  000d0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$32954[rsp], 0
  000d9	eb 0e		 jmp	 SHORT $LN3@stream_enc@3
$LN2@stream_enc@3:
  000db	48 8b 44 24 30	 mov	 rax, QWORD PTR i$32954[rsp]
  000e0	48 83 c0 01	 add	 rax, 1
  000e4	48 89 44 24 30	 mov	 QWORD PTR i$32954[rsp], rax
$LN3@stream_enc@3:
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$32954[rsp]
  000ee	48 6b c9 10	 imul	 rcx, 16
  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000f7	48 83 bc 08 20
	01 00 00 ff	 cmp	 QWORD PTR [rax+rcx+288], -1
  00100	74 22		 je	 SHORT $LN1@stream_enc@3

; 283  : 		lzma_free(coder->filters[i].options, allocator);

  00102	48 8b 44 24 30	 mov	 rax, QWORD PTR i$32954[rsp]
  00107	48 6b c0 10	 imul	 rax, 16
  0010b	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00110	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00115	48 8b 8c 01 28
	01 00 00	 mov	 rcx, QWORD PTR [rcx+rax+296]
  0011d	e8 00 00 00 00	 call	 lzma_free
  00122	eb b7		 jmp	 SHORT $LN2@stream_enc@3
$LN1@stream_enc@3:

; 284  :   }
; 285  : 
; 286  : 	return lzma_filters_copy(filters, coder->filters, allocator);

  00124	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$[rsp]
  00129	48 81 c2 20 01
	00 00		 add	 rdx, 288		; 00000120H
  00130	4c 8b 44 24 58	 mov	 r8, QWORD PTR allocator$[rsp]
  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filters$[rsp]
  0013a	e8 00 00 00 00	 call	 lzma_filters_copy
$LN13@stream_enc@3:

; 287  : }

  0013f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00143	c3		 ret	 0
stream_encoder_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_encode DD imagerel stream_encode
	DD	imagerel stream_encode+1120
	DD	imagerel $unwind$stream_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encode DD 021b01H
	DD	019011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_encode
_TEXT	SEGMENT
coder$ = 80
ret_$32888 = 88
ret_$32894 = 92
ret$32901 = 96
unpadded_size$32904 = 104
ret_$32909 = 112
ret$32912 = 116
stream_flags$32916 = 120
tv65 = 176
tv84 = 180
coder_ptr$ = 208
allocator$ = 216
in$ = 224
in_pos$ = 232
in_size$ = 240
out$ = 248
out_pos$ = 256
out_size$ = 264
action$ = 272
stream_encode PROC					; COMDAT

; 85   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 86   : 	lzma_stream_coder *coder = coder_ptr;

  0001b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax
$LN31@stream_enc@4:

; 87   : 
; 88   : 	// Main loop
; 89   : 	while (*out_pos < out_size)

  00028	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00030	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00038	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003b	0f 83 fd 03 00
	00		 jae	 $LN30@stream_enc@4

; 90   : 	switch (coder->sequence) {

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  0004f	83 bc 24 b0 00
	00 00 05	 cmp	 DWORD PTR tv65[rsp], 5
  00057	0f 87 d5 03 00
	00		 ja	 $LN1@stream_enc@4
  0005d	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0006c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN36@stream_enc@4[rcx+rax*4]
  00073	48 03 c1	 add	 rax, rcx
  00076	ff e0		 jmp	 rax
$LN27@stream_enc@4:

; 91   : 	case SEQ_STREAM_HEADER:
; 92   : 	case SEQ_BLOCK_HEADER:
; 93   : 	case SEQ_STREAM_FOOTER:
; 94   : 		lzma_bufcpy(coder->buffer, &coder->buffer_pos,
; 95   : 				coder->buffer_size, out, out_pos, out_size);

  00078	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  0007d	48 81 c2 c0 01
	00 00		 add	 rdx, 448		; 000001c0H
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00089	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  00090	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00098	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  000b2	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  000b7	4d 8b 80 c8 01
	00 00		 mov	 r8, QWORD PTR [r8+456]
  000be	e8 00 00 00 00	 call	 lzma_bufcpy

; 96   : 		if (coder->buffer_pos < coder->buffer_size)

  000c3	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000cd	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  000d4	49 39 83 c0 01
	00 00		 cmp	 QWORD PTR [r11+448], rax
  000db	73 07		 jae	 SHORT $LN26@stream_enc@4

; 97   : 			return LZMA_OK;

  000dd	33 c0		 xor	 eax, eax
  000df	e9 5c 03 00 00	 jmp	 $LN32@stream_enc@4
$LN26@stream_enc@4:

; 98   : 
; 99   : 		if (coder->sequence == SEQ_STREAM_FOOTER)

  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000e9	83 38 05	 cmp	 DWORD PTR [rax], 5
  000ec	75 0a		 jne	 SHORT $LN25@stream_enc@4

; 100  : 			return LZMA_STREAM_END;

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	e9 48 03 00 00	 jmp	 $LN32@stream_enc@4
$LN25@stream_enc@4:

; 101  : 
; 102  : 		coder->buffer_pos = 0;

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000fd	48 c7 80 c0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+448], 0

; 103  : 		++coder->sequence;

  00108	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0010d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0010f	83 c1 01	 add	 ecx, 1
  00112	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00117	89 08		 mov	 DWORD PTR [rax], ecx

; 104  : 		break;

  00119	e9 1b 03 00 00	 jmp	 $LN28@stream_enc@4
$LN24@stream_enc@4:

; 105  : 
; 106  : 	case SEQ_BLOCK_INIT: {
; 107  : 		if (*in_pos == in_size) {

  0011e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00126	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0012e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00131	0f 85 87 00 00
	00		 jne	 $LN23@stream_enc@4

; 108  : 			// If we are requested to flush or finish the current
; 109  : 			// Block, return LZMA_STREAM_END immediately since
; 110  : 			// there's nothing to do.
; 111  : 			if (action != LZMA_FINISH)

  00137	83 bc 24 10 01
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  0013f	74 2e		 je	 SHORT $LN22@stream_enc@4

; 112  : 				return action == LZMA_RUN
; 113  : 						? LZMA_OK : LZMA_STREAM_END;

  00141	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  00149	75 0d		 jne	 SHORT $LN34@stream_enc@4
  0014b	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv84[rsp], 0
  00156	eb 0b		 jmp	 SHORT $LN35@stream_enc@4
$LN34@stream_enc@4:
  00158	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv84[rsp], 1
$LN35@stream_enc@4:
  00163	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv84[rsp]
  0016a	e9 d1 02 00 00	 jmp	 $LN32@stream_enc@4
$LN22@stream_enc@4:
$LN21@stream_enc@4:

; 114  : 
; 115  : 			// The application had used LZMA_FULL_FLUSH to finish
; 116  : 			// the previous Block, but now wants to finish without
; 117  : 			// encoding new data, or it is simply creating an
; 118  : 			// empty Stream with no Blocks.
; 119  : 			//
; 120  : 			// Initialize the Index encoder, and continue to
; 121  : 			// actually encoding the Index.
; 122  : 			return_if_error(lzma_index_encoder_init(
; 123  : 					&coder->index_encoder, allocator,
; 124  : 					coder->index));

  0016f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00174	48 81 c1 70 01
	00 00		 add	 rcx, 368		; 00000170H
  0017b	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  00180	4d 8b 80 b8 01
	00 00		 mov	 r8, QWORD PTR [r8+440]
  00187	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0018f	e8 00 00 00 00	 call	 lzma_index_encoder_init
  00194	89 44 24 58	 mov	 DWORD PTR ret_$32888[rsp], eax
  00198	83 7c 24 58 00	 cmp	 DWORD PTR ret_$32888[rsp], 0
  0019d	74 09		 je	 SHORT $LN18@stream_enc@4
  0019f	8b 44 24 58	 mov	 eax, DWORD PTR ret_$32888[rsp]
  001a3	e9 98 02 00 00	 jmp	 $LN32@stream_enc@4
$LN18@stream_enc@4:
  001a8	33 c0		 xor	 eax, eax
  001aa	85 c0		 test	 eax, eax
  001ac	75 c1		 jne	 SHORT $LN21@stream_enc@4

; 125  : 			coder->sequence = SEQ_INDEX_ENCODE;

  001ae	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001b3	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 126  : 			break;

  001b9	e9 7b 02 00 00	 jmp	 $LN28@stream_enc@4
$LN23@stream_enc@4:

; 127  : 		}
; 128  : 
; 129  : 		// Initialize the Block encoder unless it was already
; 130  : 		// initialized by stream_encoder_init() or
; 131  : 		// stream_encoder_update().
; 132  : 		if (!coder->block_encoder_is_initialized)

  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001c3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001c7	85 c0		 test	 eax, eax
  001c9	75 2c		 jne	 SHORT $LN17@stream_enc@4
$LN16@stream_enc@4:

; 133  : 			return_if_error(block_encoder_init(coder, allocator));

  001cb	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  001d8	e8 00 00 00 00	 call	 block_encoder_init
  001dd	89 44 24 5c	 mov	 DWORD PTR ret_$32894[rsp], eax
  001e1	83 7c 24 5c 00	 cmp	 DWORD PTR ret_$32894[rsp], 0
  001e6	74 09		 je	 SHORT $LN13@stream_enc@4
  001e8	8b 44 24 5c	 mov	 eax, DWORD PTR ret_$32894[rsp]
  001ec	e9 4f 02 00 00	 jmp	 $LN32@stream_enc@4
$LN13@stream_enc@4:
  001f1	33 c0		 xor	 eax, eax
  001f3	85 c0		 test	 eax, eax
  001f5	75 d4		 jne	 SHORT $LN16@stream_enc@4
$LN17@stream_enc@4:

; 134  : 
; 135  : 		// Make it false so that we don't skip the initialization
; 136  : 		// with the next Block.
; 137  : 		coder->block_encoder_is_initialized = false;

  001f7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001fc	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 138  : 
; 139  : 		// Encode the Block Header. This shouldn't fail since we have
; 140  : 		// already initialized the Block encoder.
; 141  : 		if (lzma_block_header_encode(&coder->block_options,
; 142  : 				coder->buffer) != LZMA_OK)

  00200	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00205	48 81 c2 d0 01
	00 00		 add	 rdx, 464		; 000001d0H
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00211	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00215	e8 00 00 00 00	 call	 lzma_block_header_encode
  0021a	85 c0		 test	 eax, eax
  0021c	74 0a		 je	 SHORT $LN12@stream_enc@4

; 143  : 			return LZMA_PROG_ERROR;

  0021e	b8 0b 00 00 00	 mov	 eax, 11
  00223	e9 18 02 00 00	 jmp	 $LN32@stream_enc@4
$LN12@stream_enc@4:

; 144  : 
; 145  : 		coder->buffer_size = coder->block_options.header_size;

  00228	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0022d	8b 48 54	 mov	 ecx, DWORD PTR [rax+84]
  00230	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00235	48 89 88 c8 01
	00 00		 mov	 QWORD PTR [rax+456], rcx

; 146  : 		coder->sequence = SEQ_BLOCK_HEADER;

  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00241	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 147  : 		break;

  00247	e9 ed 01 00 00	 jmp	 $LN28@stream_enc@4
$LN11@stream_enc@4:

; 148  : 	}
; 149  : 
; 150  : 	case SEQ_BLOCK_ENCODE: {
; 151  : 		static const lzma_action convert[LZMA_ACTION_MAX + 1] = {
; 152  : 			LZMA_RUN,
; 153  : 			LZMA_SYNC_FLUSH,
; 154  : 			LZMA_FINISH,
; 155  : 			LZMA_FINISH,
; 156  : 			LZMA_FINISH,
; 157  : 		};
; 158  : 
; 159  : 		const lzma_ret ret = coder->block_encoder.code(
; 160  : 				coder->block_encoder.coder, allocator,
; 161  : 				in, in_pos, in_size,
; 162  : 				out, out_pos, out_size, convert[action]);

  0024c	48 63 8c 24 10
	01 00 00	 movsxd	 rcx, DWORD PTR action$[rsp]
  00254	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?convert@?7??stream_encode@@9@9
  0025b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0025e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00262	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0026a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0026f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00277	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0027c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00284	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00289	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00291	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00296	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  0029e	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  002a6	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002b3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002b7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002bc	ff 50 20	 call	 QWORD PTR [rax+32]
  002bf	89 44 24 60	 mov	 DWORD PTR ret$32901[rsp], eax

; 163  : 		if (ret != LZMA_STREAM_END || action == LZMA_SYNC_FLUSH)

  002c3	83 7c 24 60 01	 cmp	 DWORD PTR ret$32901[rsp], 1
  002c8	75 0a		 jne	 SHORT $LN9@stream_enc@4
  002ca	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR action$[rsp], 1
  002d2	75 09		 jne	 SHORT $LN10@stream_enc@4
$LN9@stream_enc@4:

; 164  : 			return ret;

  002d4	8b 44 24 60	 mov	 eax, DWORD PTR ret$32901[rsp]
  002d8	e9 63 01 00 00	 jmp	 $LN32@stream_enc@4
$LN10@stream_enc@4:

; 165  : 
; 166  : 		// Add a new Index Record.
; 167  : 	  {
; 168  : 		const lzma_vli unpadded_size = lzma_block_unpadded_size(
; 169  : 				&coder->block_options);

  002dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002e2	48 83 c1 50	 add	 rcx, 80			; 00000050H
  002e6	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  002eb	48 89 44 24 68	 mov	 QWORD PTR unpadded_size$32904[rsp], rax
$LN8@stream_enc@4:

; 170  : 		assert(unpadded_size != 0);
; 171  : 		return_if_error(lzma_index_append(coder->index, allocator,
; 172  : 				unpadded_size,
; 173  : 				coder->block_options.uncompressed_size));

  002f0	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  002f5	4d 8b 49 68	 mov	 r9, QWORD PTR [r9+104]
  002f9	4c 8b 44 24 68	 mov	 r8, QWORD PTR unpadded_size$32904[rsp]
  002fe	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00306	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0030b	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  00312	e8 00 00 00 00	 call	 lzma_index_append
  00317	89 44 24 70	 mov	 DWORD PTR ret_$32909[rsp], eax
  0031b	83 7c 24 70 00	 cmp	 DWORD PTR ret_$32909[rsp], 0
  00320	74 09		 je	 SHORT $LN5@stream_enc@4
  00322	8b 44 24 70	 mov	 eax, DWORD PTR ret_$32909[rsp]
  00326	e9 15 01 00 00	 jmp	 $LN32@stream_enc@4
$LN5@stream_enc@4:
  0032b	33 c0		 xor	 eax, eax
  0032d	85 c0		 test	 eax, eax
  0032f	75 bf		 jne	 SHORT $LN8@stream_enc@4

; 174  : 	  }
; 175  : 
; 176  : 		coder->sequence = SEQ_BLOCK_INIT;

  00331	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00336	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 177  : 		break;

  0033c	e9 f8 00 00 00	 jmp	 $LN28@stream_enc@4
$LN4@stream_enc@4:

; 178  : 	}
; 179  : 
; 180  : 	case SEQ_INDEX_ENCODE: {
; 181  : 		// Call the Index encoder. It doesn't take any input, so
; 182  : 		// those pointers can be NULL.
; 183  : 		const lzma_ret ret = coder->index_encoder.code(
; 184  : 				coder->index_encoder.coder, allocator,
; 185  : 				NULL, NULL, 0,
; 186  : 				out, out_pos, out_size, LZMA_RUN);

  00341	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  00349	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00351	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00356	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0035e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00363	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0036b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00370	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00379	45 33 c9	 xor	 r9d, r9d
  0037c	45 33 c0	 xor	 r8d, r8d
  0037f	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00387	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0038c	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00393	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00398	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0039e	89 44 24 74	 mov	 DWORD PTR ret$32912[rsp], eax

; 187  : 		if (ret != LZMA_STREAM_END)

  003a2	83 7c 24 74 01	 cmp	 DWORD PTR ret$32912[rsp], 1
  003a7	74 09		 je	 SHORT $LN3@stream_enc@4

; 188  : 			return ret;

  003a9	8b 44 24 74	 mov	 eax, DWORD PTR ret$32912[rsp]
  003ad	e9 8e 00 00 00	 jmp	 $LN32@stream_enc@4
$LN3@stream_enc@4:

; 189  : 
; 190  : 		// Encode the Stream Footer into coder->buffer.
; 191  : 		{ //MiSt
; 192  : 		/*
; 193  : 		const lzma_stream_flags stream_flags = {
; 194  : 				.version = 0,
; 195  : 				.backward_size = lzma_index_size(coder->index),
; 196  : 				.check = coder->block_options.check,
; 197  : 		};
; 198  : 		*/
; 199  : 		lzma_stream_flags stream_flags;
; 200  : 		memset (&stream_flags, 0, sizeof(stream_flags));

  003b2	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  003b8	33 d2		 xor	 edx, edx
  003ba	48 8d 4c 24 78	 lea	 rcx, QWORD PTR stream_flags$32916[rsp]
  003bf	e8 00 00 00 00	 call	 memset

; 201  : 		stream_flags.version       = 0;

  003c4	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR stream_flags$32916[rsp], 0

; 202  : 		stream_flags.backward_size = lzma_index_size(coder->index);

  003cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003d1	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  003d8	e8 00 00 00 00	 call	 lzma_index_size
  003dd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR stream_flags$32916[rsp+8], rax

; 203  : 		stream_flags.check         = coder->block_options.check;

  003e5	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  003ea	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  003ed	89 84 24 88 00
	00 00		 mov	 DWORD PTR stream_flags$32916[rsp+16], eax

; 204  : 
; 205  : 		if (lzma_stream_footer_encode(&stream_flags, coder->buffer)
; 206  : 				!= LZMA_OK)

  003f4	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  003f9	48 81 c2 d0 01
	00 00		 add	 rdx, 464		; 000001d0H
  00400	48 8d 4c 24 78	 lea	 rcx, QWORD PTR stream_flags$32916[rsp]
  00405	e8 00 00 00 00	 call	 lzma_stream_footer_encode
  0040a	85 c0		 test	 eax, eax
  0040c	74 07		 je	 SHORT $LN2@stream_enc@4

; 207  : 			return LZMA_PROG_ERROR;

  0040e	b8 0b 00 00 00	 mov	 eax, 11
  00413	eb 2b		 jmp	 SHORT $LN32@stream_enc@4
$LN2@stream_enc@4:

; 208  : 
; 209  : 		coder->buffer_size = LZMA_STREAM_HEADER_SIZE;

  00415	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0041a	48 c7 80 c8 01
	00 00 0c 00 00
	00		 mov	 QWORD PTR [rax+456], 12

; 210  : 		coder->sequence = SEQ_STREAM_FOOTER;

  00425	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0042a	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5

; 211  : 		}
; 212  : 		break;

  00430	eb 07		 jmp	 SHORT $LN28@stream_enc@4
$LN1@stream_enc@4:

; 213  : 	}
; 214  : 
; 215  : 	default:
; 216  : 		assert(0);
; 217  : 		return LZMA_PROG_ERROR;

  00432	b8 0b 00 00 00	 mov	 eax, 11
  00437	eb 07		 jmp	 SHORT $LN32@stream_enc@4
$LN28@stream_enc@4:

; 218  : 	}

  00439	e9 ea fb ff ff	 jmp	 $LN31@stream_enc@4
$LN30@stream_enc@4:

; 219  : 
; 220  : 	return LZMA_OK;

  0043e	33 c0		 xor	 eax, eax
$LN32@stream_enc@4:

; 221  : }

  00440	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00447	c3		 ret	 0
$LN36@stream_enc@4:
  00448	00 00 00 00	 DD	 $LN27@stream_enc@4
  0044c	00 00 00 00	 DD	 $LN24@stream_enc@4
  00450	00 00 00 00	 DD	 $LN27@stream_enc@4
  00454	00 00 00 00	 DD	 $LN11@stream_enc@4
  00458	00 00 00 00	 DD	 $LN4@stream_enc@4
  0045c	00 00 00 00	 DD	 $LN27@stream_enc@4
stream_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$stream_encoder_init DD imagerel stream_encoder_init
	DD	imagerel stream_encoder_init+603
	DD	imagerel $unwind$stream_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encoder_init DD 031a01H
	DD	07016e21aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stream_encoder_init
_TEXT	SEGMENT
coder$32976 = 32
stream_flags$32985 = 40
ret_$32989 = 96
next$ = 144
allocator$ = 152
filters$ = 160
check$ = 168
stream_encoder_init PROC				; COMDAT

; 293  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN12@stream_enc@5:

; 294  : 	lzma_next_coder_init(&stream_encoder_init, next, allocator);

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stream_encoder_init
  00021	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00029	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0002d	74 15		 je	 SHORT $LN9@stream_enc@5
  0002f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00037	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0003f	e8 00 00 00 00	 call	 lzma_next_end
$LN9@stream_enc@5:
  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encoder_init
  00053	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00057	33 c0		 xor	 eax, eax
  00059	85 c0		 test	 eax, eax
  0005b	75 bd		 jne	 SHORT $LN12@stream_enc@5

; 295  : 
; 296  : 	if (filters == NULL)

  0005d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR filters$[rsp], 0
  00066	75 0a		 jne	 SHORT $LN8@stream_enc@5

; 297  : 		return LZMA_PROG_ERROR;

  00068	b8 0b 00 00 00	 mov	 eax, 11
  0006d	e9 e2 01 00 00	 jmp	 $LN13@stream_enc@5
$LN8@stream_enc@5:

; 298  : 
; 299  :   {
; 300  : 	lzma_stream_coder *coder = next->coder;

  00072	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 89 44 24 20	 mov	 QWORD PTR coder$32976[rsp], rax

; 301  : 
; 302  : 	if (coder == NULL) {

  00082	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32976[rsp], 0
  00088	0f 85 c3 00 00
	00		 jne	 $LN7@stream_enc@5

; 303  : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  0008e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00096	b9 d0 05 00 00	 mov	 ecx, 1488		; 000005d0H
  0009b	e8 00 00 00 00	 call	 lzma_alloc
  000a0	48 89 44 24 20	 mov	 QWORD PTR coder$32976[rsp], rax

; 304  : 		if (coder == NULL)

  000a5	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32976[rsp], 0
  000ab	75 0a		 jne	 SHORT $LN6@stream_enc@5

; 305  : 			return LZMA_MEM_ERROR;

  000ad	b8 05 00 00 00	 mov	 eax, 5
  000b2	e9 9d 01 00 00	 jmp	 $LN13@stream_enc@5
$LN6@stream_enc@5:

; 306  : 
; 307  : 		next->coder = coder;

  000b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  000c4	48 89 01	 mov	 QWORD PTR [rcx], rax

; 308  : 		next->code = &stream_encode;

  000c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encode
  000d6	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 309  : 		next->end = &stream_encoder_end;

  000da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encoder_end
  000e9	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 310  : 		next->update = &stream_encoder_update;

  000ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encoder_update
  000fc	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 311  : 
; 312  : 		coder->filters[0].id = LZMA_VLI_UNKNOWN;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  00105	48 c7 80 20 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+288], -1

; 313  : 		coder->block_encoder = LZMA_NEXT_CODER_INIT;

  00110	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32976[rsp]
  00115	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  0011c	48 83 c7 08	 add	 rdi, 8
  00120	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00125	f3 a4		 rep movsb

; 314  : 		coder->index_encoder = LZMA_NEXT_CODER_INIT;

  00127	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32976[rsp]
  0012c	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  00133	48 81 c7 70 01
	00 00		 add	 rdi, 368		; 00000170H
  0013a	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0013f	f3 a4		 rep movsb

; 315  : 		coder->index = NULL;

  00141	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  00146	48 c7 80 b8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+440], 0
$LN7@stream_enc@5:

; 316  : 	}
; 317  : 
; 318  : 	// Basic initializations
; 319  : 	coder->sequence = SEQ_STREAM_HEADER;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  00156	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 320  : 	coder->block_options.version = 0;

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  00161	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 321  : 	coder->block_options.check = check;

  00168	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32976[rsp]
  0016d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR check$[rsp]
  00174	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 322  : 
; 323  : 	// Initialize the Index
; 324  : 	lzma_index_end(coder->index, allocator);

  00177	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32976[rsp]
  00184	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  0018b	e8 00 00 00 00	 call	 lzma_index_end

; 325  : 	coder->index = lzma_index_init(allocator);

  00190	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR allocator$[rsp]
  00198	e8 00 00 00 00	 call	 lzma_index_init
  0019d	48 8b d0	 mov	 rdx, rax
  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  001a5	48 89 90 b8 01
	00 00		 mov	 QWORD PTR [rax+440], rdx

; 326  : 	if (coder->index == NULL)

  001ac	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  001b1	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  001b9	75 0a		 jne	 SHORT $LN5@stream_enc@5

; 327  : 		return LZMA_MEM_ERROR;

  001bb	b8 05 00 00 00	 mov	 eax, 5
  001c0	e9 8f 00 00 00	 jmp	 $LN13@stream_enc@5
$LN5@stream_enc@5:

; 328  : 
; 329  : 	// Encode the Stream Header
; 330  : 	{
; 331  : 	/*
; 332  : 	lzma_stream_flags stream_flags = {
; 333  :     		.version = 0,
; 334  :     		.check = check,
; 335  : 	};
; 336  : 	*/
; 337  : 	lzma_stream_flags stream_flags;
; 338  : 	memset (&stream_flags, 0, sizeof(stream_flags));

  001c5	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  001cb	33 d2		 xor	 edx, edx
  001cd	48 8d 4c 24 28	 lea	 rcx, QWORD PTR stream_flags$32985[rsp]
  001d2	e8 00 00 00 00	 call	 memset

; 339  : 	stream_flags.version = 0;

  001d7	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR stream_flags$32985[rsp], 0

; 340  : 	stream_flags.check   = check;

  001df	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR check$[rsp]
  001e6	89 44 24 38	 mov	 DWORD PTR stream_flags$32985[rsp+16], eax
$LN4@stream_enc@5:

; 341  : 
; 342  : 	return_if_error(lzma_stream_header_encode(
; 343  : 			&stream_flags, coder->buffer));

  001ea	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$32976[rsp]
  001ef	48 81 c2 d0 01
	00 00		 add	 rdx, 464		; 000001d0H
  001f6	48 8d 4c 24 28	 lea	 rcx, QWORD PTR stream_flags$32985[rsp]
  001fb	e8 00 00 00 00	 call	 lzma_stream_header_encode
  00200	89 44 24 60	 mov	 DWORD PTR ret_$32989[rsp], eax
  00204	83 7c 24 60 00	 cmp	 DWORD PTR ret_$32989[rsp], 0
  00209	74 06		 je	 SHORT $LN1@stream_enc@5
  0020b	8b 44 24 60	 mov	 eax, DWORD PTR ret_$32989[rsp]
  0020f	eb 43		 jmp	 SHORT $LN13@stream_enc@5
$LN1@stream_enc@5:
  00211	33 c0		 xor	 eax, eax
  00213	85 c0		 test	 eax, eax
  00215	75 d3		 jne	 SHORT $LN4@stream_enc@5

; 344  : 
; 345  : 	coder->buffer_pos = 0;

  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  0021c	48 c7 80 c0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+448], 0

; 346  : 	coder->buffer_size = LZMA_STREAM_HEADER_SIZE;

  00227	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32976[rsp]
  0022c	48 c7 80 c8 01
	00 00 0c 00 00
	00		 mov	 QWORD PTR [rax+456], 12

; 347  : 
; 348  : 	// Initialize the Block encoder. This way we detect unsupported
; 349  : 	// filter chains when initializing the Stream encoder instead of
; 350  : 	// giving an error after Stream Header has already written out.
; 351  : 	return stream_encoder_update(coder, allocator, filters, NULL);

  00237	45 33 c9	 xor	 r9d, r9d
  0023a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  00242	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0024a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32976[rsp]
  0024f	e8 00 00 00 00	 call	 stream_encoder_update
$LN13@stream_enc@5:

; 352  :   }}
; 353  : }

  00254	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00258	5f		 pop	 rdi
  00259	5e		 pop	 rsi
  0025a	c3		 ret	 0
stream_encoder_init ENDP
PUBLIC	lzma_stream_encoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_encoder DD imagerel $LN11
	DD	imagerel $LN11+193
	DD	imagerel $unwind$lzma_stream_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_encoder DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_stream_encoder
_TEXT	SEGMENT
ret_$33005 = 32
ret_$33007 = 36
strm$ = 64
filters$ = 72
check$ = 80
lzma_stream_encoder PROC				; COMDAT

; 359  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_strea@9:
$LN5@lzma_strea@9:

; 360  : 	lzma_next_strm_init(stream_encoder_init, strm, filters, check);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_strm_init
  0001d	89 44 24 20	 mov	 DWORD PTR ret_$33005[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33005[rsp], 0
  00026	74 09		 je	 SHORT $LN2@lzma_strea@9
  00028	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33005[rsp]
  0002c	e9 8b 00 00 00	 jmp	 $LN9@lzma_strea@9
$LN2@lzma_strea@9:
  00031	33 c0		 xor	 eax, eax
  00033	85 c0		 test	 eax, eax
  00035	75 dc		 jne	 SHORT $LN5@lzma_strea@9
  00037	44 8b 4c 24 50	 mov	 r9d, DWORD PTR check$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR filters$[rsp]
  00041	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00046	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0004f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00053	e8 00 00 00 00	 call	 stream_encoder_init
  00058	89 44 24 24	 mov	 DWORD PTR ret_$33007[rsp], eax
  0005c	83 7c 24 24 00	 cmp	 DWORD PTR ret_$33007[rsp], 0
  00061	74 10		 je	 SHORT $LN1@lzma_strea@9
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00068	e8 00 00 00 00	 call	 lzma_end
  0006d	8b 44 24 24	 mov	 eax, DWORD PTR ret_$33007[rsp]
  00071	eb 49		 jmp	 SHORT $LN9@lzma_strea@9
$LN1@lzma_strea@9:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 9a		 jne	 SHORT $LN8@lzma_strea@9

; 361  : 
; 362  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00082	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 363  : 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008f	c6 40 59 01	 mov	 BYTE PTR [rax+89], 1

; 364  : 	strm->internal->supported_actions[LZMA_FULL_FLUSH] = true;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00098	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009c	c6 40 5a 01	 mov	 BYTE PTR [rax+90], 1

; 365  : 	strm->internal->supported_actions[LZMA_FULL_BARRIER] = true;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000a9	c6 40 5c 01	 mov	 BYTE PTR [rax+92], 1

; 366  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000b6	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 367  : 
; 368  : 	return LZMA_OK;

  000ba	33 c0		 xor	 eax, eax
$LN9@lzma_strea@9:

; 369  : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
lzma_stream_encoder ENDP
END
