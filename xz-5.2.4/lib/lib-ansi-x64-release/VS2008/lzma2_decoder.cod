; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_lzma2_props_decode
PUBLIC	lzma_lzma2_decoder_memusage
PUBLIC	lzma_lzma2_decoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
pdata	SEGMENT
$pdata$lzma_lzma2_decoder_memusage DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$lzma_lzma2_decoder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_decoder_memusage DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_decoder_memusage
_TEXT	SEGMENT
options$ = 48
lzma_lzma2_decoder_memusage PROC			; COMDAT

; 273  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 274  : 	return sizeof(lzma_lzma2_coder)
; 275  : 			+ lzma_lzma_decoder_memusage_nocheck(options);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR options$[rsp]
  0000e	e8 00 00 00 00	 call	 lzma_lzma_decoder_memusage_nocheck
  00013	48 05 b8 00 00
	00		 add	 rax, 184		; 000000b8H

; 276  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
lzma_lzma2_decoder_memusage ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.h
_TEXT	ENDS
;	COMDAT dict_reset
_TEXT	SEGMENT
dict$ = 8
dict_reset PROC						; COMDAT

; 234  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 235  : 	dict->need_reset = true;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dict$[rsp]
  0000a	c6 40 28 01	 mov	 BYTE PTR [rax+40], 1

; 236  : 	return;
; 237  : }

  0000e	c3		 ret	 0
dict_reset ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
pdata	SEGMENT
$pdata$lzma_lzma2_props_decode DD imagerel $LN9
	DD	imagerel $LN9+255
	DD	imagerel $unwind$lzma_lzma2_props_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_props_decode DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_props_decode
_TEXT	SEGMENT
opt$33124 = 32
options$ = 64
allocator$ = 72
props$ = 80
props_size$ = 88
lzma_lzma2_props_decode PROC				; COMDAT

; 282  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 283  : 	if (props_size != 1)

  00018	48 83 7c 24 58
	01		 cmp	 QWORD PTR props_size$[rsp], 1
  0001e	74 0a		 je	 SHORT $LN6@lzma_lzma2

; 284  : 		return LZMA_OPTIONS_ERROR;

  00020	b8 08 00 00 00	 mov	 eax, 8
  00025	e9 d0 00 00 00	 jmp	 $LN7@lzma_lzma2
$LN6@lzma_lzma2:

; 285  : 
; 286  : 	// Check that reserved bits are unset.
; 287  : 	if (props[0] & 0xC0)

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR props$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00037	85 c0		 test	 eax, eax
  00039	74 0a		 je	 SHORT $LN5@lzma_lzma2

; 288  : 		return LZMA_OPTIONS_ERROR;

  0003b	b8 08 00 00 00	 mov	 eax, 8
  00040	e9 b5 00 00 00	 jmp	 $LN7@lzma_lzma2
$LN5@lzma_lzma2:

; 289  : 
; 290  : 	// Decode the dictionary size.
; 291  : 	if (props[0] > 40)

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR props$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004d	83 f8 28	 cmp	 eax, 40			; 00000028H
  00050	7e 0a		 jle	 SHORT $LN4@lzma_lzma2

; 292  : 		return LZMA_OPTIONS_ERROR;

  00052	b8 08 00 00 00	 mov	 eax, 8
  00057	e9 9e 00 00 00	 jmp	 $LN7@lzma_lzma2
$LN4@lzma_lzma2:

; 293  : 
; 294  :   {
; 295  : 	lzma_options_lzma *opt = lzma_alloc(
; 296  : 			sizeof(lzma_options_lzma), allocator);

  0005c	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00061	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00066	e8 00 00 00 00	 call	 lzma_alloc
  0006b	48 89 44 24 20	 mov	 QWORD PTR opt$33124[rsp], rax

; 297  : 	if (opt == NULL)

  00070	48 83 7c 24 20
	00		 cmp	 QWORD PTR opt$33124[rsp], 0
  00076	75 07		 jne	 SHORT $LN3@lzma_lzma2

; 298  : 		return LZMA_MEM_ERROR;

  00078	b8 05 00 00 00	 mov	 eax, 5
  0007d	eb 7b		 jmp	 SHORT $LN7@lzma_lzma2
$LN3@lzma_lzma2:

; 299  : 
; 300  : 	if (props[0] == 40) {

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR props$[rsp]
  00084	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00087	83 f8 28	 cmp	 eax, 40			; 00000028H
  0008a	75 0d		 jne	 SHORT $LN2@lzma_lzma2

; 301  : 		opt->dict_size = UINT32_MAX;

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  00091	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1	; ffffffffH

; 302  : 	} else {

  00097	eb 39		 jmp	 SHORT $LN1@lzma_lzma2
$LN2@lzma_lzma2:

; 303  : 		opt->dict_size = 2 | (props[0] & 1);

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR props$[rsp]
  0009e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a1	83 e1 01	 and	 ecx, 1
  000a4	83 c9 02	 or	 ecx, 2
  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000ac	89 08		 mov	 DWORD PTR [rax], ecx

; 304  : 		opt->dict_size <<= props[0] / 2 + 11;

  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR props$[rsp]
  000b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b6	99		 cdq
  000b7	2b c2		 sub	 eax, edx
  000b9	d1 f8		 sar	 eax, 1
  000bb	8b c8		 mov	 ecx, eax
  000bd	83 c1 0b	 add	 ecx, 11
  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000c5	8b 00		 mov	 eax, DWORD PTR [rax]
  000c7	d3 e0		 shl	 eax, cl
  000c9	8b c8		 mov	 ecx, eax
  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000d0	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@lzma_lzma2:

; 305  : 	}
; 306  : 
; 307  : 	opt->preset_dict = NULL;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000d7	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 308  : 	opt->preset_dict_size = 0;

  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000e4	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 309  : 
; 310  : 	*options = opt;

  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  000f0	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$33124[rsp]
  000f5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 311  :   }
; 312  : 
; 313  : 	return LZMA_OK;

  000f8	33 c0		 xor	 eax, eax
$LN7@lzma_lzma2:

; 314  : }

  000fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fe	c3		 ret	 0
lzma_lzma2_props_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_decoder_end DD imagerel lzma2_decoder_end
	DD	imagerel lzma2_decoder_end+63
	DD	imagerel $unwind$lzma2_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
lzma2_decoder_end PROC					; COMDAT

; 215  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 216  : 	lzma_lzma2_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 217  : 
; 218  : 	assert(coder->lzma.end == NULL);
; 219  : 	lzma_free(coder->lzma.coder, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00026	e8 00 00 00 00	 call	 lzma_free

; 220  : 
; 221  : 	lzma_free(coder, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_free

; 222  : 
; 223  : 	return;
; 224  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
lzma2_decoder_end ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.h
pdata	SEGMENT
$pdata$dict_write DD imagerel dict_write
	DD	imagerel dict_write+189
	DD	imagerel $unwind$dict_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dict_write DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dict_write
_TEXT	SEGMENT
dict$ = 64
in$ = 72
in_pos$ = 80
in_size$ = 88
left$ = 96
dict_write PROC						; COMDAT

; 211  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 212  : 	// NOTE: If we are being given more data than the size of the
; 213  : 	// dictionary, it could be possible to optimize the LZ decoder
; 214  : 	// so that not everything needs to go through the dictionary.
; 215  : 	// This shouldn't be very common thing in practice though, and
; 216  : 	// the slowdown of one extra memcpy() isn't bad compared to how
; 217  : 	// much time it would have taken if the data were compressed.
; 218  : 
; 219  : 	if (in_size - *in_pos > *left)

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR in_pos$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in_size$[rsp]
  00025	48 2b c8	 sub	 rcx, rax
  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  0002d	48 3b 08	 cmp	 rcx, QWORD PTR [rax]
  00030	76 15		 jbe	 SHORT $LN2@dict_write

; 220  : 		in_size = *in_pos + *left;

  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR in_pos$[rsp]
  00037	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  0003f	48 03 01	 add	 rax, QWORD PTR [rcx]
  00042	48 89 44 24 58	 mov	 QWORD PTR in_size$[rsp], rax
$LN2@dict_write:

; 221  : 
; 222  : 	*left -= lzma_bufcpy(in, in_pos, in_size,
; 223  : 			dict->buf, &dict->pos, dict->limit);

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dict$[rsp]
  0004c	48 83 c1 08	 add	 rcx, 8
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR dict$[rsp]
  00055	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00059	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00063	4c 8b 4c 24 40	 mov	 r9, QWORD PTR dict$[rsp]
  00068	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  0006b	4c 8b 44 24 58	 mov	 r8, QWORD PTR in_size$[rsp]
  00070	48 8b 54 24 50	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  0007a	e8 00 00 00 00	 call	 lzma_bufcpy
  0007f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  00084	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00087	48 2b c8	 sub	 rcx, rax
  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  0008f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 224  : 
; 225  : 	if (dict->pos > dict->full)

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dict$[rsp]
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR dict$[rsp]
  0009c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a0	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000a4	76 12		 jbe	 SHORT $LN1@dict_write

; 226  : 		dict->full = dict->pos;

  000a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dict$[rsp]
  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR dict$[rsp]
  000b0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b4	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN1@dict_write:

; 227  : 
; 228  : 	return;
; 229  : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
dict_write ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_decode DD imagerel lzma2_decode
	DD	imagerel lzma2_decode+1500
	DD	imagerel $unwind$lzma2_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_decode DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lzma\lzma2_decoder.c
xdata	ENDS
;	COMDAT lzma2_decode
_TEXT	SEGMENT
coder$ = 48
control$33040 = 56
in_used$33066 = 64
ret$33065 = 72
in_start$33064 = 80
$T37389 = 88
$T37390 = 96
tv66 = 104
tv174 = 108
coder_ptr$ = 128
dict$ = 136
in$ = 144
in_pos$ = 152
in_size$ = 160
lzma2_decode PROC					; COMDAT

; 60   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 61   : 	lzma_lzma2_coder *restrict coder = coder_ptr;

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00020	48 89 44 24 30	 mov	 QWORD PTR coder$[rsp], rax
$LN33@lzma2_deco:

; 62   : 
; 63   : 	// With SEQ_LZMA it is possible that no new input is needed to do
; 64   : 	// some progress. The rest of the sequences assume that there is
; 65   : 	// at least one byte of input.
; 66   : 	while (*in_pos < in_size || coder->sequence == SEQ_LZMA)

  00025	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00035	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00038	72 0e		 jb	 SHORT $LN31@lzma2_deco
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0003f	83 38 06	 cmp	 DWORD PTR [rax], 6
  00042	0f 85 6c 05 00
	00		 jne	 $LN32@lzma2_deco
$LN31@lzma2_deco:

; 67   : 	switch (coder->sequence) {

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0004d	8b 00		 mov	 eax, DWORD PTR [rax]
  0004f	89 44 24 68	 mov	 DWORD PTR tv66[rsp], eax
  00053	83 7c 24 68 07	 cmp	 DWORD PTR tv66[rsp], 7
  00058	0f 87 4a 05 00
	00		 ja	 $LN1@lzma2_deco
  0005e	48 63 44 24 68	 movsxd	 rax, DWORD PTR tv66[rsp]
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0006a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN42@lzma2_deco[rcx+rax*4]
  00071	48 03 c1	 add	 rax, rcx
  00074	ff e0		 jmp	 rax
$LN28@lzma2_deco:

; 68   : 	case SEQ_CONTROL: {
; 69   : 		const uint32_t control = in[*in_pos];

  00076	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00089	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0008d	89 44 24 38	 mov	 DWORD PTR control$33040[rsp], eax

; 70   : 		++*in_pos;

  00091	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00099	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009c	48 83 c1 01	 add	 rcx, 1
  000a0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   : 
; 72   : 		// End marker
; 73   : 		if (control == 0x00)

  000ab	83 7c 24 38 00	 cmp	 DWORD PTR control$33040[rsp], 0
  000b0	75 0a		 jne	 SHORT $LN27@lzma2_deco

; 74   : 			return LZMA_STREAM_END;

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	e9 fa 04 00 00	 jmp	 $LN34@lzma2_deco
$LN27@lzma2_deco:

; 75   : 
; 76   : 		if (control >= 0xE0 || control == 1) {

  000bc	81 7c 24 38 e0
	00 00 00	 cmp	 DWORD PTR control$33040[rsp], 224 ; 000000e0H
  000c4	73 07		 jae	 SHORT $LN25@lzma2_deco
  000c6	83 7c 24 38 01	 cmp	 DWORD PTR control$33040[rsp], 1
  000cb	75 14		 jne	 SHORT $LN26@lzma2_deco
$LN25@lzma2_deco:

; 77   : 			// Dictionary reset implies that next LZMA chunk has
; 78   : 			// to set new properties.
; 79   : 			coder->need_properties = true;

  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000d2	c6 40 40 01	 mov	 BYTE PTR [rax+64], 1

; 80   : 			coder->need_dictionary_reset = true;

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000db	c6 40 41 01	 mov	 BYTE PTR [rax+65], 1
  000df	eb 17		 jmp	 SHORT $LN24@lzma2_deco
$LN26@lzma2_deco:

; 81   : 		} else if (coder->need_dictionary_reset) {

  000e1	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000e6	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  000ea	85 c0		 test	 eax, eax
  000ec	74 0a		 je	 SHORT $LN23@lzma2_deco

; 82   : 			return LZMA_DATA_ERROR;

  000ee	b8 09 00 00 00	 mov	 eax, 9
  000f3	e9 be 04 00 00	 jmp	 $LN34@lzma2_deco
$LN23@lzma2_deco:
$LN24@lzma2_deco:

; 83   : 		}
; 84   : 
; 85   : 		if (control >= 0x80) {

  000f8	81 7c 24 38 80
	00 00 00	 cmp	 DWORD PTR control$33040[rsp], 128 ; 00000080H
  00100	0f 82 8c 00 00
	00		 jb	 $LN22@lzma2_deco

; 86   : 			// LZMA chunk. The highest five bits of the
; 87   : 			// uncompressed size are taken from the control byte.
; 88   : 			coder->uncompressed_size = (control & 0x1F) << 16;

  00106	8b 44 24 38	 mov	 eax, DWORD PTR control$33040[rsp]
  0010a	83 e0 1f	 and	 eax, 31
  0010d	c1 e0 10	 shl	 eax, 16
  00110	8b c8		 mov	 ecx, eax
  00112	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00117	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 89   : 			coder->sequence = SEQ_UNCOMPRESSED_1;

  0011b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00120	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 90   : 
; 91   : 			// See if there are new properties or if we need to
; 92   : 			// reset the state.
; 93   : 			if (control >= 0xC0) {

  00126	81 7c 24 38 c0
	00 00 00	 cmp	 DWORD PTR control$33040[rsp], 192 ; 000000c0H
  0012e	72 17		 jb	 SHORT $LN21@lzma2_deco

; 94   : 				// When there are new properties, state reset
; 95   : 				// is done at SEQ_PROPERTIES.
; 96   : 				coder->need_properties = false;

  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00135	c6 40 40 00	 mov	 BYTE PTR [rax+64], 0

; 97   : 				coder->next_sequence = SEQ_PROPERTIES;

  00139	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0013e	c7 40 04 05 00
	00 00		 mov	 DWORD PTR [rax+4], 5
  00145	eb 49		 jmp	 SHORT $LN20@lzma2_deco
$LN21@lzma2_deco:

; 98   : 
; 99   : 			} else if (coder->need_properties) {

  00147	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0014c	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  00150	85 c0		 test	 eax, eax
  00152	74 0c		 je	 SHORT $LN19@lzma2_deco

; 100  : 				return LZMA_DATA_ERROR;

  00154	b8 09 00 00 00	 mov	 eax, 9
  00159	e9 58 04 00 00	 jmp	 $LN34@lzma2_deco

; 101  : 
; 102  : 			} else {

  0015e	eb 30		 jmp	 SHORT $LN18@lzma2_deco
$LN19@lzma2_deco:

; 103  : 				coder->next_sequence = SEQ_LZMA;

  00160	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00165	c7 40 04 06 00
	00 00		 mov	 DWORD PTR [rax+4], 6

; 104  : 
; 105  : 				// If only state reset is wanted with old
; 106  : 				// properties, do the resetting here for
; 107  : 				// simplicity.
; 108  : 				if (control >= 0xA0)

  0016c	81 7c 24 38 a0
	00 00 00	 cmp	 DWORD PTR control$33040[rsp], 160 ; 000000a0H
  00174	72 1a		 jb	 SHORT $LN17@lzma2_deco

; 109  : 					coder->lzma.reset(coder->lzma.coder,
; 110  : 							&coder->options);

  00176	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  0017b	48 83 c2 48	 add	 rdx, 72			; 00000048H
  0017f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00184	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00188	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0018d	ff 50 18	 call	 QWORD PTR [rax+24]
$LN17@lzma2_deco:
$LN18@lzma2_deco:
$LN20@lzma2_deco:

; 111  : 			}
; 112  : 		} else {

  00190	eb 28		 jmp	 SHORT $LN16@lzma2_deco
$LN22@lzma2_deco:

; 113  : 			// Invalid control values
; 114  : 			if (control > 2)

  00192	83 7c 24 38 02	 cmp	 DWORD PTR control$33040[rsp], 2
  00197	76 0a		 jbe	 SHORT $LN15@lzma2_deco

; 115  : 				return LZMA_DATA_ERROR;

  00199	b8 09 00 00 00	 mov	 eax, 9
  0019e	e9 13 04 00 00	 jmp	 $LN34@lzma2_deco
$LN15@lzma2_deco:

; 116  : 
; 117  : 			// It's uncompressed chunk
; 118  : 			coder->sequence = SEQ_COMPRESSED_0;

  001a3	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001a8	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 119  : 			coder->next_sequence = SEQ_COPY;

  001ae	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001b3	c7 40 04 07 00
	00 00		 mov	 DWORD PTR [rax+4], 7
$LN16@lzma2_deco:

; 120  : 		}
; 121  : 
; 122  : 		if (coder->need_dictionary_reset) {

  001ba	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001bf	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001c3	85 c0		 test	 eax, eax
  001c5	74 1c		 je	 SHORT $LN14@lzma2_deco

; 123  : 			// Finish the dictionary reset and let the caller
; 124  : 			// flush the dictionary to the actual output buffer.
; 125  : 			coder->need_dictionary_reset = false;

  001c7	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  001cc	c6 40 41 00	 mov	 BYTE PTR [rax+65], 0

; 126  : 			dict_reset(dict);

  001d0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dict$[rsp]
  001d8	c6 40 28 01	 mov	 BYTE PTR [rax+40], 1

; 127  : 			return LZMA_OK;

  001dc	33 c0		 xor	 eax, eax
  001de	e9 d3 03 00 00	 jmp	 $LN34@lzma2_deco
$LN14@lzma2_deco:

; 128  : 		}
; 129  : 
; 130  : 		break;

  001e3	e9 c7 03 00 00	 jmp	 $LN29@lzma2_deco
$LN13@lzma2_deco:

; 131  : 	}
; 132  : 
; 133  : 	case SEQ_UNCOMPRESSED_1:
; 134  : 		coder->uncompressed_size += (uint32_t)(in[(*in_pos)++]) << 8;

  001e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  001f0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001f3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001fb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001ff	c1 e0 08	 shl	 eax, 8
  00202	8b c8		 mov	 ecx, eax
  00204	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00209	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  0020d	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00212	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  00216	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0021e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00221	48 83 c1 01	 add	 rcx, 1
  00225	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  0022d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 135  : 		coder->sequence = SEQ_UNCOMPRESSED_2;

  00230	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00235	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 136  : 		break;

  0023b	e9 6f 03 00 00	 jmp	 $LN29@lzma2_deco
$LN12@lzma2_deco:

; 137  : 
; 138  : 	case SEQ_UNCOMPRESSED_2:
; 139  : 		coder->uncompressed_size += in[(*in_pos)++] + 1;

  00240	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00248	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00253	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00257	83 c0 01	 add	 eax, 1
  0025a	48 63 c8	 movsxd	 rcx, eax
  0025d	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00262	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  00266	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0026b	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  0026f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00277	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0027a	48 83 c1 01	 add	 rcx, 1
  0027e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00286	48 89 08	 mov	 QWORD PTR [rax], rcx

; 140  : 		coder->sequence = SEQ_COMPRESSED_0;

  00289	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0028e	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 141  : 		coder->lzma.set_uncompressed(coder->lzma.coder,
; 142  : 				coder->uncompressed_size);

  00294	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  00299	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0029d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  002a2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002ab	ff 50 20	 call	 QWORD PTR [rax+32]

; 143  : 		break;

  002ae	e9 fc 02 00 00	 jmp	 $LN29@lzma2_deco
$LN11@lzma2_deco:

; 144  : 
; 145  : 	case SEQ_COMPRESSED_0:
; 146  : 		coder->compressed_size = (uint32_t)(in[(*in_pos)++]) << 8;

  002b3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  002bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002be	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002c6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002ca	c1 e0 08	 shl	 eax, 8
  002cd	8b c8		 mov	 ecx, eax
  002cf	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002d4	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
  002d8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  002e0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002e3	48 83 c1 01	 add	 rcx, 1
  002e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  002ef	48 89 08	 mov	 QWORD PTR [rax], rcx

; 147  : 		coder->sequence = SEQ_COMPRESSED_1;

  002f2	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  002f7	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 148  : 		break;

  002fd	e9 ad 02 00 00	 jmp	 $LN29@lzma2_deco
$LN10@lzma2_deco:

; 149  : 
; 150  : 	case SEQ_COMPRESSED_1:
; 151  : 		coder->compressed_size += in[(*in_pos)++] + 1;

  00302	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0030a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0030d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00315	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00319	83 c0 01	 add	 eax, 1
  0031c	48 63 c8	 movsxd	 rcx, eax
  0031f	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00324	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  00328	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0032d	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
  00331	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00339	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0033c	48 83 c1 01	 add	 rcx, 1
  00340	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00348	48 89 08	 mov	 QWORD PTR [rax], rcx

; 152  : 		coder->sequence = coder->next_sequence;

  0034b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00350	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00355	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00358	89 01		 mov	 DWORD PTR [rcx], eax

; 153  : 		break;

  0035a	e9 50 02 00 00	 jmp	 $LN29@lzma2_deco
$LN9@lzma2_deco:

; 154  : 
; 155  : 	case SEQ_PROPERTIES:
; 156  : 		if (lzma_lzma_lclppb_decode(&coder->options, in[(*in_pos)++]))

  0035f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00367	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0036a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00372	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00376	88 44 24 6c	 mov	 BYTE PTR tv174[rsp], al
  0037a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00382	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00385	48 83 c1 01	 add	 rcx, 1
  00389	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00391	48 89 08	 mov	 QWORD PTR [rax], rcx
  00394	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00399	48 83 c1 48	 add	 rcx, 72			; 00000048H
  0039d	0f b6 54 24 6c	 movzx	 edx, BYTE PTR tv174[rsp]
  003a2	e8 00 00 00 00	 call	 lzma_lzma_lclppb_decode
  003a7	0f b6 c0	 movzx	 eax, al
  003aa	85 c0		 test	 eax, eax
  003ac	74 0a		 je	 SHORT $LN8@lzma2_deco

; 157  : 			return LZMA_DATA_ERROR;

  003ae	b8 09 00 00 00	 mov	 eax, 9
  003b3	e9 fe 01 00 00	 jmp	 $LN34@lzma2_deco
$LN8@lzma2_deco:

; 158  : 
; 159  : 		coder->lzma.reset(coder->lzma.coder, &coder->options);

  003b8	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  003bd	48 83 c2 48	 add	 rdx, 72			; 00000048H
  003c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  003c6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  003ca	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  003cf	ff 50 18	 call	 QWORD PTR [rax+24]

; 160  : 
; 161  : 		coder->sequence = SEQ_LZMA;

  003d2	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  003d7	41 c7 03 06 00
	00 00		 mov	 DWORD PTR [r11], 6

; 162  : 		break;

  003de	e9 cc 01 00 00	 jmp	 $LN29@lzma2_deco
$LN7@lzma2_deco:

; 163  : 
; 164  : 	case SEQ_LZMA: {
; 165  : 		// Store the start offset so that we can update
; 166  : 		// coder->compressed_size later.
; 167  : 		const size_t in_start = *in_pos;

  003e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  003eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ee	48 89 44 24 50	 mov	 QWORD PTR in_start$33064[rsp], rax

; 168  : 
; 169  : 		// Decode from in[] to *dict.
; 170  : 		const lzma_ret ret = coder->lzma.code(coder->lzma.coder,
; 171  : 				dict, in, in_pos, in_size);

  003f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  003fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00400	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00408	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00410	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR dict$[rsp]
  00418	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0041d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00421	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00426	ff 50 10	 call	 QWORD PTR [rax+16]
  00429	89 44 24 48	 mov	 DWORD PTR ret$33065[rsp], eax

; 172  : 
; 173  : 		// Validate and update coder->compressed_size.
; 174  : 		const size_t in_used = *in_pos - in_start;

  0042d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00435	48 8b 4c 24 50	 mov	 rcx, QWORD PTR in_start$33064[rsp]
  0043a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043d	48 2b c1	 sub	 rax, rcx
  00440	48 89 44 24 40	 mov	 QWORD PTR in_used$33066[rsp], rax

; 175  : 		if (in_used > coder->compressed_size)

  00445	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0044a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0044e	48 39 44 24 40	 cmp	 QWORD PTR in_used$33066[rsp], rax
  00453	76 0a		 jbe	 SHORT $LN6@lzma2_deco

; 176  : 			return LZMA_DATA_ERROR;

  00455	b8 09 00 00 00	 mov	 eax, 9
  0045a	e9 57 01 00 00	 jmp	 $LN34@lzma2_deco
$LN6@lzma2_deco:

; 177  : 
; 178  : 		coder->compressed_size -= in_used;

  0045f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00464	48 8b 44 24 40	 mov	 rax, QWORD PTR in_used$33066[rsp]
  00469	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0046d	48 2b c8	 sub	 rcx, rax
  00470	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00475	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 179  : 
; 180  : 		// Return if we didn't finish the chunk, or an error occurred.
; 181  : 		if (ret != LZMA_STREAM_END)

  00479	83 7c 24 48 01	 cmp	 DWORD PTR ret$33065[rsp], 1
  0047e	74 09		 je	 SHORT $LN5@lzma2_deco

; 182  : 			return ret;

  00480	8b 44 24 48	 mov	 eax, DWORD PTR ret$33065[rsp]
  00484	e9 2d 01 00 00	 jmp	 $LN34@lzma2_deco
$LN5@lzma2_deco:

; 183  : 
; 184  : 		// The LZMA decoder must have consumed the whole chunk now.
; 185  : 		// We don't need to worry about uncompressed size since it
; 186  : 		// is checked by the LZMA decoder.
; 187  : 		if (coder->compressed_size != 0)

  00489	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0048e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00493	74 0a		 je	 SHORT $LN4@lzma2_deco

; 188  : 			return LZMA_DATA_ERROR;

  00495	b8 09 00 00 00	 mov	 eax, 9
  0049a	e9 17 01 00 00	 jmp	 $LN34@lzma2_deco
$LN4@lzma2_deco:

; 189  : 
; 190  : 		coder->sequence = SEQ_CONTROL;

  0049f	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  004a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 191  : 		break;

  004aa	e9 00 01 00 00	 jmp	 $LN29@lzma2_deco
$LN3@lzma2_deco:

; 192  : 	}
; 193  : 
; 194  : 	case SEQ_COPY: {
; 195  : 		// Copy from input to the dictionary as is.
; 196  : 		dict_write(dict, in, in_pos, in_size, &coder->compressed_size);

  004af	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  004b4	48 83 c0 38	 add	 rax, 56			; 00000038H
  004b8	48 89 44 24 60	 mov	 QWORD PTR $T37390[rsp], rax
  004bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  004c5	48 89 44 24 58	 mov	 QWORD PTR $T37389[rsp], rax
  004ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  004d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T37389[rsp]
  004da	48 2b c8	 sub	 rcx, rax
  004dd	48 8b 44 24 60	 mov	 rax, QWORD PTR $T37390[rsp]
  004e2	48 3b 08	 cmp	 rcx, QWORD PTR [rax]
  004e5	76 18		 jbe	 SHORT $LN39@lzma2_deco
  004e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T37390[rsp]
  004f7	48 03 01	 add	 rax, QWORD PTR [rcx]
  004fa	48 89 44 24 58	 mov	 QWORD PTR $T37389[rsp], rax
$LN39@lzma2_deco:
  004ff	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  00507	48 83 c1 08	 add	 rcx, 8
  0050b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dict$[rsp]
  00513	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00517	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0051c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00521	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR dict$[rsp]
  00529	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  0052c	4c 8b 44 24 58	 mov	 r8, QWORD PTR $T37389[rsp]
  00531	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00539	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00541	e8 00 00 00 00	 call	 lzma_bufcpy
  00546	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T37390[rsp]
  0054b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0054e	48 2b c8	 sub	 rcx, rax
  00551	48 8b 44 24 60	 mov	 rax, QWORD PTR $T37390[rsp]
  00556	48 89 08	 mov	 QWORD PTR [rax], rcx
  00559	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  00561	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dict$[rsp]
  00569	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0056d	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00571	76 18		 jbe	 SHORT $LN38@lzma2_deco
  00573	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  0057b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dict$[rsp]
  00583	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00587	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN38@lzma2_deco:

; 197  : 		if (coder->compressed_size != 0)

  0058b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00590	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00595	74 04		 je	 SHORT $LN2@lzma2_deco

; 198  : 			return LZMA_OK;

  00597	33 c0		 xor	 eax, eax
  00599	eb 1b		 jmp	 SHORT $LN34@lzma2_deco
$LN2@lzma2_deco:

; 199  : 
; 200  : 		coder->sequence = SEQ_CONTROL;

  0059b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  005a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 201  : 		break;

  005a6	eb 07		 jmp	 SHORT $LN29@lzma2_deco
$LN1@lzma2_deco:

; 202  : 	}
; 203  : 
; 204  : 	default:
; 205  : 		assert(0);
; 206  : 		return LZMA_PROG_ERROR;

  005a8	b8 0b 00 00 00	 mov	 eax, 11
  005ad	eb 07		 jmp	 SHORT $LN34@lzma2_deco
$LN29@lzma2_deco:

; 207  : 	}

  005af	e9 71 fa ff ff	 jmp	 $LN33@lzma2_deco
$LN32@lzma2_deco:

; 208  : 
; 209  : 	return LZMA_OK;

  005b4	33 c0		 xor	 eax, eax
$LN34@lzma2_deco:

; 210  : }

  005b6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  005ba	c3		 ret	 0
  005bb	90		 npad	 1
$LN42@lzma2_deco:
  005bc	00 00 00 00	 DD	 $LN28@lzma2_deco
  005c0	00 00 00 00	 DD	 $LN13@lzma2_deco
  005c4	00 00 00 00	 DD	 $LN12@lzma2_deco
  005c8	00 00 00 00	 DD	 $LN11@lzma2_deco
  005cc	00 00 00 00	 DD	 $LN10@lzma2_deco
  005d0	00 00 00 00	 DD	 $LN9@lzma2_deco
  005d4	00 00 00 00	 DD	 $LN7@lzma2_deco
  005d8	00 00 00 00	 DD	 $LN3@lzma2_deco
lzma2_decode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma2_decoder_init DD imagerel lzma2_decoder_init
	DD	imagerel lzma2_decoder_init+273
	DD	imagerel $unwind$lzma2_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma2_decoder_init DD 031a01H
	DD	07016821aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma2_decoder_init
_TEXT	SEGMENT
coder$ = 32
options$33098 = 40
tv78 = 48
lz$ = 96
allocator$ = 104
opt$ = 112
lz_options$ = 120
lzma2_decoder_init PROC					; COMDAT

; 230  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 231  : 	lzma_lzma2_coder *coder = lz->coder;

  0001a	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 232  : 	if (coder == NULL) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  0002d	75 6a		 jne	 SHORT $LN2@lzma2_deco@2

; 233  : 		coder = lzma_alloc(sizeof(lzma_lzma2_coder), allocator);

  0002f	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  00034	b9 b8 00 00 00	 mov	 ecx, 184		; 000000b8H
  00039	e8 00 00 00 00	 call	 lzma_alloc
  0003e	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 234  : 		if (coder == NULL)

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00049	75 0a		 jne	 SHORT $LN1@lzma2_deco@2

; 235  : 			return LZMA_MEM_ERROR;

  0004b	b8 05 00 00 00	 mov	 eax, 5
  00050	e9 b5 00 00 00	 jmp	 $LN3@lzma2_deco@2
$LN1@lzma2_deco@2:

; 236  : 
; 237  : 		lz->coder = coder;

  00055	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0005f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 238  : 		lz->code = &lzma2_decode;

  00062	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma2_decode
  0006e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 239  : 		lz->end = &lzma2_decoder_end;

  00072	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma2_decoder_end
  0007e	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 240  : 
; 241  : 		coder->lzma = LZMA_LZ_DECODER_INIT;

  00082	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  00087	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_LZ_DECODER_INIT
  0008e	48 83 c7 08	 add	 rdi, 8
  00092	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00097	f3 a4		 rep movsb
$LN2@lzma2_deco@2:

; 242  : 	}
; 243  : 
; 244  :   {
; 245  : 	const lzma_options_lzma *options = opt;

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR opt$[rsp]
  0009e	48 89 44 24 28	 mov	 QWORD PTR options$33098[rsp], rax

; 246  : 
; 247  : 	coder->sequence = SEQ_CONTROL;

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 248  : 	coder->need_properties = true;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000b3	c6 40 40 01	 mov	 BYTE PTR [rax+64], 1

; 249  : 	coder->need_dictionary_reset = options->preset_dict == NULL
; 250  : 			|| options->preset_dict_size == 0;

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR options$33098[rsp]
  000bc	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c1	74 15		 je	 SHORT $LN5@lzma2_deco@2
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR options$33098[rsp]
  000c8	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  000cc	74 0a		 je	 SHORT $LN5@lzma2_deco@2
  000ce	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  000d6	eb 08		 jmp	 SHORT $LN6@lzma2_deco@2
$LN5@lzma2_deco@2:
  000d8	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN6@lzma2_deco@2:
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000e5	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv78[rsp]
  000ea	88 41 41	 mov	 BYTE PTR [rcx+65], al

; 251  : 
; 252  : 	return lzma_lzma_decoder_create(&coder->lzma,
; 253  : 			allocator, options, lz_options);

  000ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000f2	48 83 c1 08	 add	 rcx, 8
  000f6	4c 8b 4c 24 78	 mov	 r9, QWORD PTR lz_options$[rsp]
  000fb	4c 8b 44 24 28	 mov	 r8, QWORD PTR options$33098[rsp]
  00100	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  00105	e8 00 00 00 00	 call	 lzma_lzma_decoder_create
$LN3@lzma2_deco@2:

; 254  :   }
; 255  : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	5f		 pop	 rdi
  0010f	5e		 pop	 rsi
  00110	c3		 ret	 0
lzma2_decoder_init ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lzma2_decoder_init DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$lzma_lzma2_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lzma2_decoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lzma2_decoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_lzma2_decoder_init PROC				; COMDAT

; 261  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 262  : 	// LZMA2 can only be the last filter in the chain. This is enforced
; 263  : 	// by the raw_decoder initialization.
; 264  : 	assert(filters[1].init == NULL);
; 265  : 
; 266  : 	return lzma_lz_decoder_init(next, allocator, filters,
; 267  : 			&lzma2_decoder_init);

  00013	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:lzma2_decoder_init
  0001a	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00029	e8 00 00 00 00	 call	 lzma_lz_decoder_init

; 268  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
lzma_lzma2_decoder_init ENDP
END
