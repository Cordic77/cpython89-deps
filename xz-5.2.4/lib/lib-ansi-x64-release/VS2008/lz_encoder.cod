; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_encoder.c
pdata	SEGMENT
$pdata$move_window DD imagerel move_window
	DD	imagerel move_window+177
	DD	imagerel $unwind$move_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$move_window DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT move_window
_TEXT	SEGMENT
move_offset$33078 = 32
move_size$33080 = 40
mf$ = 64
move_window PROC					; COMDAT

; 47   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 48   : 	// Align the move to a multiple of 16 bytes. Some LZ-based encoders
; 49   : 	// like LZMA use the lowest bits of mf->read_pos to know the
; 50   : 	// alignment of the uncompressed data. We also get better speed
; 51   : 	// for memmove() with aligned buffers.
; 52   : 	assert(mf->read_pos > mf->keep_size_before);
; 53   :   {
; 54   : 	const uint32_t move_offset
; 55   : 		= (mf->read_pos - mf->keep_size_before) & ~UINT32_C(15);

  00009	48 8b 54 24 40	 mov	 rdx, QWORD PTR mf$[rsp]
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00013	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00016	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00019	2b c1		 sub	 eax, ecx
  0001b	83 e0 f0	 and	 eax, -16		; fffffff0H
  0001e	89 44 24 20	 mov	 DWORD PTR move_offset$33078[rsp], eax

; 56   : 
; 57   : 	assert(mf->write_pos > move_offset);
; 58   :   {
; 59   : 	const size_t move_size = mf->write_pos - move_offset;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00027	8b 4c 24 20	 mov	 ecx, DWORD PTR move_offset$33078[rsp]
  0002b	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0002e	2b c1		 sub	 eax, ecx
  00030	8b c0		 mov	 eax, eax
  00032	48 89 44 24 28	 mov	 QWORD PTR move_size$33080[rsp], rax

; 60   : 
; 61   : 	assert(move_offset + move_size <= mf->size);
; 62   : 
; 63   : 	memmove(mf->buffer, mf->buffer + move_offset, move_size);

  00037	8b 54 24 20	 mov	 edx, DWORD PTR move_offset$33078[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00040	48 03 10	 add	 rdx, QWORD PTR [rax]
  00043	4c 8b 44 24 28	 mov	 r8, QWORD PTR move_size$33080[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	e8 00 00 00 00	 call	 memmove

; 64   : 
; 65   : 	mf->offset += move_offset;

  00055	4c 8b 5c 24 40	 mov	 r11, QWORD PTR mf$[rsp]
  0005a	41 8b 4b 14	 mov	 ecx, DWORD PTR [r11+20]
  0005e	03 4c 24 20	 add	 ecx, DWORD PTR move_offset$33078[rsp]
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00067	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 66   : 	mf->read_pos -= move_offset;

  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  0006f	8b 44 24 20	 mov	 eax, DWORD PTR move_offset$33078[rsp]
  00073	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00076	2b c8		 sub	 ecx, eax
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0007d	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 67   : 	mf->read_limit -= move_offset;

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  00085	8b 44 24 20	 mov	 eax, DWORD PTR move_offset$33078[rsp]
  00089	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  0008c	2b c8		 sub	 ecx, eax
  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00093	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 68   : 	mf->write_pos -= move_offset;

  00096	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  0009b	8b 44 24 20	 mov	 eax, DWORD PTR move_offset$33078[rsp]
  0009f	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  000a2	2b c8		 sub	 ecx, eax
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000a9	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 69   :   }}
; 70   : 
; 71   : 	return;
; 72   : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
move_window ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_encoder_update DD imagerel lz_encoder_update
	DD	imagerel lz_encoder_update+133
	DD	imagerel $unwind$lz_encoder_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_encoder_update DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_encoder_update
_TEXT	SEGMENT
coder$ = 32
ret_$33260 = 40
coder_ptr$ = 64
allocator$ = 72
filters_null$ = 80
reversed_filters$ = 88
lz_encoder_update PROC					; COMDAT

; 554  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 555  : 	lzma_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 556  : 
; 557  : 	if (coder->lz.options_update == NULL)

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00027	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0002c	75 07		 jne	 SHORT $LN5@lz_encoder

; 558  : 		return LZMA_PROG_ERROR;

  0002e	b8 0b 00 00 00	 mov	 eax, 11
  00033	eb 4b		 jmp	 SHORT $LN6@lz_encoder
$LN5@lz_encoder:
$LN4@lz_encoder:

; 559  : 
; 560  : 	return_if_error(coder->lz.options_update(
; 561  : 			coder->lz.coder, reversed_filters));

  00035	48 8b 54 24 58	 mov	 rdx, QWORD PTR reversed_filters$[rsp]
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00047	ff 50 18	 call	 QWORD PTR [rax+24]
  0004a	89 44 24 28	 mov	 DWORD PTR ret_$33260[rsp], eax
  0004e	83 7c 24 28 00	 cmp	 DWORD PTR ret_$33260[rsp], 0
  00053	74 06		 je	 SHORT $LN1@lz_encoder
  00055	8b 44 24 28	 mov	 eax, DWORD PTR ret_$33260[rsp]
  00059	eb 25		 jmp	 SHORT $LN6@lz_encoder
$LN1@lz_encoder:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 d4		 jne	 SHORT $LN4@lz_encoder

; 562  : 
; 563  : 	return lzma_next_filter_update(
; 564  : 			&coder->next, allocator, reversed_filters + 1);

  00061	4c 8b 44 24 58	 mov	 r8, QWORD PTR reversed_filters$[rsp]
  00066	49 83 c0 10	 add	 r8, 16
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0006f	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00076	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0007b	e8 00 00 00 00	 call	 lzma_next_filter_update
$LN6@lz_encoder:

; 565  : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
lz_encoder_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_encoder_init DD imagerel lz_encoder_init
	DD	imagerel lz_encoder_init+602
	DD	imagerel $unwind$lz_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_encoder_init DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_encoder_init
_TEXT	SEGMENT
tv163 = 32
mf$ = 64
allocator$ = 72
lz_options$ = 80
lz_encoder_init PROC					; COMDAT

; 387  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 388  : 	// Allocate the history buffer.
; 389  : 	if (mf->buffer == NULL) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00018	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001c	75 51		 jne	 SHORT $LN7@lz_encoder@2

; 390  : 		// lzma_memcmplen() is used for the dictionary buffer
; 391  : 		// so we need to allocate a few extra bytes to prevent
; 392  : 		// it from reading past the end of the buffer.
; 393  : 		mf->buffer = lzma_alloc(mf->size + LZMA_MEMCMPLEN_EXTRA,
; 394  : 				allocator);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	83 c0 08	 add	 eax, 8
  00029	8b c8		 mov	 ecx, eax
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	e8 00 00 00 00	 call	 lzma_alloc
  00035	4c 8b d8	 mov	 r11, rax
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0003d	4c 89 18	 mov	 QWORD PTR [rax], r11

; 395  : 		if (mf->buffer == NULL)

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00045	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00049	75 07		 jne	 SHORT $LN6@lz_encoder@2

; 396  : 			return true;

  0004b	b0 01		 mov	 al, 1
  0004d	e9 03 02 00 00	 jmp	 $LN8@lz_encoder@2
$LN6@lz_encoder@2:

; 397  : 
; 398  : 		// Keep Valgrind happy with lzma_memcmplen() and initialize
; 399  : 		// the extra bytes whose value may get read but which will
; 400  : 		// effectively get ignored.
; 401  : 		memzero(mf->buffer + mf->size, LZMA_MEMCMPLEN_EXTRA);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00057	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0005f	48 03 08	 add	 rcx, QWORD PTR [rax]
  00062	41 b8 08 00 00
	00		 mov	 r8d, 8
  00068	33 d2		 xor	 edx, edx
  0006a	e8 00 00 00 00	 call	 memset
$LN7@lz_encoder@2:

; 402  : 	}
; 403  : 
; 404  : 	// Use cyclic_size as initial mf->offset. This allows
; 405  : 	// avoiding a few branches in the match finders. The downside is
; 406  : 	// that match finder needs to be normalized more often, which may
; 407  : 	// hurt performance with huge dictionaries.
; 408  : 	mf->offset = mf->cyclic_size;

  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00079	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0007c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 409  : 	mf->read_pos = 0;

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00084	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 410  : 	mf->read_ahead = 0;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00090	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 411  : 	mf->read_limit = 0;

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0009c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 412  : 	mf->write_pos = 0;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000a8	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 413  : 	mf->pending = 0;

  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000b4	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 414  : 
; 415  : #if UINT32_MAX >= SIZE_MAX / 4
; 416  : 	// Check for integer overflow. (Huge dictionaries are not
; 417  : 	// possible on 32-bit CPU.)
; 418  : 	if (mf->hash_count > SIZE_MAX / sizeof(uint32_t)
; 419  : 			|| mf->sons_count > SIZE_MAX / sizeof(uint32_t))
; 420  : 		return true;
; 421  : #endif
; 422  : 
; 423  : 	// Allocate and initialize the hash table. Since EMPTY_HASH_VALUE
; 424  : 	// is zero, we can use lzma_alloc_zero() or memzero() for mf->hash.
; 425  : 	//
; 426  : 	// We don't need to initialize mf->son, but not doing that may
; 427  : 	// make Valgrind complain in normalization (see normalize() in
; 428  : 	// lz_encoder_mf.c). Skipping the initialization is *very* good
; 429  : 	// when big dictionary is used but only small amount of data gets
; 430  : 	// actually compressed: most of the mf->son won't get actually
; 431  : 	// allocated by the kernel, so we avoid wasting RAM and improve
; 432  : 	// initialization speed a lot.
; 433  : 	if (mf->hash == NULL) {

  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000c0	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000c5	0f 85 a5 00 00
	00		 jne	 $LN5@lz_encoder@2

; 434  : 		mf->hash = lzma_alloc_zero(mf->hash_count * sizeof(uint32_t),
; 435  : 				allocator);

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000d0	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  000d3	48 c1 e1 02	 shl	 rcx, 2
  000d7	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000dc	e8 00 00 00 00	 call	 lzma_alloc_zero
  000e1	4c 8b d8	 mov	 r11, rax
  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000e9	4c 89 58 40	 mov	 QWORD PTR [rax+64], r11

; 436  : 		mf->son = lzma_alloc(mf->sons_count * sizeof(uint32_t),
; 437  : 				allocator);

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  000f2	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000f5	48 c1 e1 02	 shl	 rcx, 2
  000f9	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000fe	e8 00 00 00 00	 call	 lzma_alloc
  00103	4c 8b d8	 mov	 r11, rax
  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0010b	4c 89 58 48	 mov	 QWORD PTR [rax+72], r11

; 438  : 
; 439  : 		if (mf->hash == NULL || mf->son == NULL) {

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00114	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00119	74 0c		 je	 SHORT $LN3@lz_encoder@2
  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00120	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00125	75 47		 jne	 SHORT $LN4@lz_encoder@2
$LN3@lz_encoder@2:

; 440  : 			lzma_free(mf->hash, allocator);

  00127	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0012c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  00131	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00135	e8 00 00 00 00	 call	 lzma_free

; 441  : 			mf->hash = NULL;

  0013a	4c 8b 5c 24 40	 mov	 r11, QWORD PTR mf$[rsp]
  0013f	49 c7 43 40 00
	00 00 00	 mov	 QWORD PTR [r11+64], 0

; 442  : 
; 443  : 			lzma_free(mf->son, allocator);

  00147	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0014c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  00151	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00155	e8 00 00 00 00	 call	 lzma_free

; 444  : 			mf->son = NULL;

  0015a	4c 8b 5c 24 40	 mov	 r11, QWORD PTR mf$[rsp]
  0015f	49 c7 43 48 00
	00 00 00	 mov	 QWORD PTR [r11+72], 0

; 445  : 
; 446  : 			return true;

  00167	b0 01		 mov	 al, 1
  00169	e9 e7 00 00 00	 jmp	 $LN8@lz_encoder@2
$LN4@lz_encoder@2:

; 447  : 		}
; 448  : 	} else {

  0016e	eb 1d		 jmp	 SHORT $LN2@lz_encoder@2
$LN5@lz_encoder@2:

; 449  : /*
; 450  : 		for (uint32_t i = 0; i < mf->hash_count; ++i)
; 451  : 			mf->hash[i] = EMPTY_HASH_VALUE;
; 452  : */
; 453  : 		memzero(mf->hash, mf->hash_count * sizeof(uint32_t));

  00170	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00175	44 8b 40 6c	 mov	 r8d, DWORD PTR [rax+108]
  00179	49 c1 e0 02	 shl	 r8, 2
  0017d	33 d2		 xor	 edx, edx
  0017f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  00184	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00188	e8 00 00 00 00	 call	 memset
$LN2@lz_encoder@2:

; 454  : 	}
; 455  : 
; 456  : 	mf->cyclic_pos = 0;

  0018d	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00192	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 457  : 
; 458  : 	// Handle preset dictionary.
; 459  : 	if (lz_options->preset_dict != NULL
; 460  : 			&& lz_options->preset_dict_size > 0) {

  00199	48 8b 44 24 50	 mov	 rax, QWORD PTR lz_options$[rsp]
  0019e	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  001a3	0f 84 9e 00 00
	00		 je	 $LN1@lz_encoder@2
  001a9	48 8b 44 24 50	 mov	 rax, QWORD PTR lz_options$[rsp]
  001ae	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  001b2	0f 86 8f 00 00
	00		 jbe	 $LN1@lz_encoder@2

; 461  : 		// If the preset dictionary is bigger than the actual
; 462  : 		// dictionary, use only the tail.
; 463  : 		mf->write_pos = my_min(lz_options->preset_dict_size, mf->size);

  001b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lz_options$[rsp]
  001bd	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  001c2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001c5	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  001c8	73 0e		 jae	 SHORT $LN10@lz_encoder@2
  001ca	48 8b 44 24 50	 mov	 rax, QWORD PTR lz_options$[rsp]
  001cf	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  001d2	89 44 24 20	 mov	 DWORD PTR tv163[rsp], eax
  001d6	eb 0c		 jmp	 SHORT $LN11@lz_encoder@2
$LN10@lz_encoder@2:
  001d8	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  001dd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001e0	89 44 24 20	 mov	 DWORD PTR tv163[rsp], eax
$LN11@lz_encoder@2:
  001e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  001e9	8b 44 24 20	 mov	 eax, DWORD PTR tv163[rsp]
  001ed	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 464  : 		memcpy(mf->buffer, lz_options->preset_dict
; 465  : 				+ lz_options->preset_dict_size - mf->write_pos,
; 466  : 				mf->write_pos);

  001f0	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  001f5	44 8b 40 24	 mov	 r8d, DWORD PTR [rax+36]
  001f9	48 8b 44 24 50	 mov	 rax, QWORD PTR lz_options$[rsp]
  001fe	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00201	48 8b 54 24 50	 mov	 rdx, QWORD PTR lz_options$[rsp]
  00206	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0020a	48 03 d0	 add	 rdx, rax
  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00212	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00215	48 2b d0	 sub	 rdx, rax
  00218	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  0021d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00220	e8 00 00 00 00	 call	 memcpy

; 467  : 		mf->action = LZMA_SYNC_FLUSH;

  00225	4c 8b 5c 24 40	 mov	 r11, QWORD PTR mf$[rsp]
  0022a	41 c7 43 68 01
	00 00 00	 mov	 DWORD PTR [r11+104], 1

; 468  : 		mf->skip(mf, mf->write_pos);

  00232	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00237	8b 50 24	 mov	 edx, DWORD PTR [rax+36]
  0023a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mf$[rsp]
  0023f	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  00244	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@lz_encoder@2:

; 469  : 	}
; 470  : 
; 471  : 	mf->action = LZMA_RUN;

  00247	48 8b 44 24 40	 mov	 rax, QWORD PTR mf$[rsp]
  0024c	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 472  : 
; 473  : 	return false;

  00253	32 c0		 xor	 al, al
$LN8@lz_encoder@2:

; 474  : }

  00255	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00259	c3		 ret	 0
lz_encoder_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+658
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fill_window
_TEXT	SEGMENT
write_pos$33098 = 80
ret$33099 = 88
pending$33109 = 92
tv86 = 96
coder$ = 128
allocator$ = 136
in$ = 144
in_pos$ = 152
in_size$ = 160
action$ = 168
fill_window PROC					; COMDAT

; 87   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 88   : 	assert(coder->mf.read_pos <= coder->mf.write_pos);
; 89   : 
; 90   : 	// Move the sliding window if needed.
; 91   : 	if (coder->mf.read_pos >= coder->mf.size - coder->mf.keep_size_after)

  00018	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00020	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00028	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0002b	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0002e	2b c8		 sub	 ecx, eax
  00030	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00038	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  0003b	72 11		 jb	 SHORT $LN7@fill_windo

; 92   : 		move_window(&coder->mf);

  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00045	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00049	e8 00 00 00 00	 call	 move_window
$LN7@fill_windo:

; 93   : 
; 94   : 	// Maybe this is ugly, but lzma_mf uses uint32_t for most things
; 95   : 	// (which I find cleanest), but we need size_t here when filling
; 96   : 	// the history window.
; 97   :   {
; 98   : 	size_t write_pos = coder->mf.write_pos;

  0004e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00056	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00059	48 89 44 24 50	 mov	 QWORD PTR write_pos$33098[rsp], rax

; 99   : 	lzma_ret ret;
; 100  : 	if (coder->next.code == NULL) {

  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00066	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0006e	75 7e		 jne	 SHORT $LN6@fill_windo

; 101  : 		// Not using a filter, simply memcpy() as much as possible.
; 102  : 		lzma_bufcpy(in, in_pos, in_size, coder->mf.buffer,
; 103  : 				&write_pos, coder->mf.size);

  00070	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00078	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0007b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00080	48 8d 44 24 50	 lea	 rax, QWORD PTR write_pos$33098[rsp]
  00085	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR coder$[rsp]
  00092	4d 8b 49 20	 mov	 r9, QWORD PTR [r9+32]
  00096	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  0009e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  000a6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  000ae	e8 00 00 00 00	 call	 lzma_bufcpy

; 104  : 
; 105  : 		ret = action != LZMA_RUN && *in_pos == in_size
; 106  : 				? LZMA_STREAM_END : LZMA_OK;

  000b3	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  000bb	74 1f		 je	 SHORT $LN10@fill_windo
  000bd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000cd	48 39 01	 cmp	 QWORD PTR [rcx], rax
  000d0	75 0a		 jne	 SHORT $LN10@fill_windo
  000d2	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000da	eb 08		 jmp	 SHORT $LN11@fill_windo
$LN10@fill_windo:
  000dc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN11@fill_windo:
  000e4	8b 44 24 60	 mov	 eax, DWORD PTR tv86[rsp]
  000e8	89 44 24 58	 mov	 DWORD PTR ret$33099[rsp], eax

; 107  : 
; 108  : 	} else {

  000ec	eb 7c		 jmp	 SHORT $LN5@fill_windo
$LN6@fill_windo:

; 109  : 		ret = coder->next.code(coder->next.coder, allocator,
; 110  : 				in, in_pos, in_size,
; 111  : 				coder->mf.buffer, &write_pos,
; 112  : 				coder->mf.size, action);

  000ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  000f9	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00100	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00104	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00109	48 8d 44 24 50	 lea	 rax, QWORD PTR write_pos$33098[rsp]
  0010e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00113	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0011b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0011f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0012c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00131	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00139	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00141	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00149	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00151	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00158	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00160	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00166	89 44 24 58	 mov	 DWORD PTR ret$33099[rsp], eax
$LN5@fill_windo:

; 113  : 	}
; 114  : 
; 115  : 	coder->mf.write_pos = (uint32_t)write_pos;

  0016a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00172	8b 44 24 50	 mov	 eax, DWORD PTR write_pos$33098[rsp]
  00176	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 116  : 
; 117  : 	// Silence Valgrind. lzma_memcmplen() can read extra bytes
; 118  : 	// and Valgrind will give warnings if those bytes are uninitialized
; 119  : 	// because Valgrind cannot see that the values of the uninitialized
; 120  : 	// bytes are eventually ignored.
; 121  : 	memzero(coder->mf.buffer + write_pos, LZMA_MEMCMPLEN_EXTRA);

  00179	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00181	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00185	48 03 4c 24 50	 add	 rcx, QWORD PTR write_pos$33098[rsp]
  0018a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00190	33 d2		 xor	 edx, edx
  00192	e8 00 00 00 00	 call	 memset

; 122  : 
; 123  : 	// If end of stream has been reached or flushing completed, we allow
; 124  : 	// the encoder to process all the input (that is, read_pos is allowed
; 125  : 	// to reach write_pos). Otherwise we keep keep_size_after bytes
; 126  : 	// available as prebuffer.
; 127  : 	if (ret == LZMA_STREAM_END) {

  00197	83 7c 24 58 01	 cmp	 DWORD PTR ret$33099[rsp], 1
  0019c	75 35		 jne	 SHORT $LN4@fill_windo

; 128  : 		assert(*in_pos == in_size);
; 129  : 		ret = LZMA_OK;

  0019e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR ret$33099[rsp], 0

; 130  : 		coder->mf.action = action;

  001a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001ae	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  001b5	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 131  : 		coder->mf.read_limit = coder->mf.write_pos;

  001bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001cb	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001ce	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  001d1	eb 3b		 jmp	 SHORT $LN3@fill_windo
$LN4@fill_windo:

; 132  : 
; 133  : 	} else if (coder->mf.write_pos > coder->mf.keep_size_after) {

  001d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001e3	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001e6	39 41 44	 cmp	 DWORD PTR [rcx+68], eax
  001e9	76 23		 jbe	 SHORT $LN2@fill_windo

; 134  : 		// This needs to be done conditionally, because if we got
; 135  : 		// only little new input, there may be too little input
; 136  : 		// to do any encoding yet.
; 137  : 		coder->mf.read_limit = coder->mf.write_pos
; 138  : 				- coder->mf.keep_size_after;

  001eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  001f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001fb	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001fe	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00201	2b c8		 sub	 ecx, eax
  00203	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0020b	89 48 40	 mov	 DWORD PTR [rax+64], ecx
$LN2@fill_windo:
$LN3@fill_windo:

; 139  : 	}
; 140  : 
; 141  : 	// Restart the match finder after finished LZMA_SYNC_FLUSH.
; 142  : 	if (coder->mf.pending > 0
; 143  : 			&& coder->mf.read_pos < coder->mf.read_limit) {

  0020e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00216	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0021a	76 6d		 jbe	 SHORT $LN1@fill_windo
  0021c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00224	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0022c	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0022f	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  00232	73 55		 jae	 SHORT $LN1@fill_windo

; 144  : 		// Match finder may update coder->pending and expects it to
; 145  : 		// start from zero, so use a temporary variable.
; 146  : 		const uint32_t pending = coder->mf.pending;

  00234	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0023c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0023f	89 44 24 5c	 mov	 DWORD PTR pending$33109[rsp], eax

; 147  : 		coder->mf.pending = 0;

  00243	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0024b	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 148  : 
; 149  : 		// Rewind read_pos so that the match finder can hash
; 150  : 		// the pending bytes.
; 151  : 		assert(coder->mf.read_pos >= pending);
; 152  : 		coder->mf.read_pos -= pending;

  00252	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0025a	8b 44 24 5c	 mov	 eax, DWORD PTR pending$33109[rsp]
  0025e	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00261	2b c8		 sub	 ecx, eax
  00263	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0026b	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 153  : 
; 154  : 		// Call the skip function directly instead of using
; 155  : 		// mf_skip(), since we don't want to touch mf->read_ahead.
; 156  : 		coder->mf.skip(&coder->mf, pending);

  0026e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00276	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0027a	8b 54 24 5c	 mov	 edx, DWORD PTR pending$33109[rsp]
  0027e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00286	ff 50 58	 call	 QWORD PTR [rax+88]
$LN1@fill_windo:

; 157  : 	}
; 158  : 
; 159  : 	return ret;

  00289	8b 44 24 58	 mov	 eax, DWORD PTR ret$33099[rsp]

; 160  :   }
; 161  : }

  0028d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00291	c3		 ret	 0
fill_window ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_encoder_end DD imagerel lz_encoder_end
	DD	imagerel lz_encoder_end+176
	DD	imagerel $unwind$lz_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_encoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_encoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
lz_encoder_end PROC					; COMDAT

; 531  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 532  : 	lzma_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 533  : 
; 534  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00024	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00029	e8 00 00 00 00	 call	 lzma_next_end

; 535  : 
; 536  : 	lzma_free(coder->mf.son, allocator);

  0002e	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00033	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00038	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0003c	e8 00 00 00 00	 call	 lzma_free

; 537  : 	lzma_free(coder->mf.hash, allocator);

  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0004b	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0004f	e8 00 00 00 00	 call	 lzma_free

; 538  : 	lzma_free(coder->mf.buffer, allocator);

  00054	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0005e	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00062	e8 00 00 00 00	 call	 lzma_free

; 539  : 
; 540  : 	if (coder->lz.end != NULL)

  00067	4c 8b 5c 24 20	 mov	 r11, QWORD PTR coder$[rsp]
  0006c	49 83 7b 10 00	 cmp	 QWORD PTR [r11+16], 0
  00071	74 17		 je	 SHORT $LN2@lz_encoder@3

; 541  : 		coder->lz.end(coder->lz.coder, allocator);

  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0007d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00085	ff 50 10	 call	 QWORD PTR [rax+16]

; 542  : 	else

  00088	eb 12		 jmp	 SHORT $LN1@lz_encoder@3
$LN2@lz_encoder@3:

; 543  : 		lzma_free(coder->lz.coder, allocator);

  0008a	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00094	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00097	e8 00 00 00 00	 call	 lzma_free
$LN1@lz_encoder@3:

; 544  : 
; 545  : 	lzma_free(coder, allocator);

  0009c	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000a6	e8 00 00 00 00	 call	 lzma_free

; 546  : 	return;
; 547  : }

  000ab	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000af	c3		 ret	 0
lz_encoder_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_encoder_prepare DD imagerel lz_encoder_prepare
	DD	imagerel lz_encoder_prepare+1195
	DD	imagerel $unwind$lz_encoder_prepare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_encoder_prepare DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_encoder_prepare
_TEXT	SEGMENT
reserve$33156 = 32
old_size$33160 = 36
hash_bytes$33177 = 40
hs$33180 = 44
is_bt$33179 = 48
old_hash_count$33189 = 52
old_sons_count$33190 = 56
tv146 = 60
tv169 = 64
mf$ = 96
allocator$ = 104
lz_options$ = 112
lz_encoder_prepare PROC					; COMDAT

; 202  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 203  : 	// For now, the dictionary size is limited to 1.5 GiB. This may grow
; 204  : 	// in the future if needed, but it needs a little more work than just
; 205  : 	// changing this check.
; 206  : 	if (lz_options->dict_size < LZMA_DICT_SIZE_MIN
; 207  : 			|| lz_options->dict_size
; 208  : 				> (UINT32_C(1) << 30) + (UINT32_C(1) << 29)
; 209  : 			|| lz_options->nice_len > lz_options->match_len_max)

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  00018	48 81 78 08 00
	10 00 00	 cmp	 QWORD PTR [rax+8], 4096	; 00001000H
  00020	72 23		 jb	 SHORT $LN25@lz_encoder@4
  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  00027	48 81 78 08 00
	00 00 60	 cmp	 QWORD PTR [rax+8], 1610612736 ; 60000000H
  0002f	77 14		 ja	 SHORT $LN25@lz_encoder@4
  00031	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0003b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003f	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00043	76 07		 jbe	 SHORT $LN26@lz_encoder@4
$LN25@lz_encoder@4:

; 210  : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	e9 5a 04 00 00	 jmp	 $LN27@lz_encoder@4
$LN26@lz_encoder@4:

; 211  : 
; 212  : 	mf->keep_size_before = (uint32_t)(lz_options->before_size + lz_options->dict_size);

  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  00059	48 03 48 08	 add	 rcx, QWORD PTR [rax+8]
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00062	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 213  : 
; 214  : 	mf->keep_size_after = (uint32_t)(lz_options->after_size
; 215  : 			+ lz_options->match_len_max);

  00065	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  0006a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  00073	48 03 48 18	 add	 rcx, QWORD PTR [rax+24]
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0007c	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 216  : 
; 217  : 	// To avoid constant memmove()s, allocate some extra space. Since
; 218  : 	// memmove()s become more expensive when the size of the buffer
; 219  : 	// increases, we reserve more space when a large dictionary is
; 220  : 	// used to make the memmove() calls rarer.
; 221  : 	//
; 222  : 	// This works with dictionaries up to about 3 GiB. If bigger
; 223  : 	// dictionary is wanted, some extra work is needed:
; 224  : 	//   - Several variables in lzma_mf have to be changed from uint32_t
; 225  : 	//     to size_t.
; 226  : 	//   - Memory usage calculation needs something too, e.g. use uint64_t
; 227  : 	//     for mf->size.
; 228  :   {
; 229  : 	uint32_t reserve = (uint32_t)(lz_options->dict_size / 2);

  0007f	33 d2		 xor	 edx, edx
  00081	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  00086	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008a	b9 02 00 00 00	 mov	 ecx, 2
  0008f	48 f7 f1	 div	 rcx
  00092	89 44 24 20	 mov	 DWORD PTR reserve$33156[rsp], eax

; 230  : 	if (reserve > (UINT32_C(1) << 30))

  00096	81 7c 24 20 00
	00 00 40	 cmp	 DWORD PTR reserve$33156[rsp], 1073741824 ; 40000000H
  0009e	76 11		 jbe	 SHORT $LN24@lz_encoder@4

; 231  : 		reserve /= 2;

  000a0	33 d2		 xor	 edx, edx
  000a2	8b 44 24 20	 mov	 eax, DWORD PTR reserve$33156[rsp]
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	f7 f1		 div	 ecx
  000ad	89 44 24 20	 mov	 DWORD PTR reserve$33156[rsp], eax
$LN24@lz_encoder@4:

; 232  : 
; 233  : //	reserve += (lz_options->before_size + lz_options->match_len_max
; 234  : //			+ lz_options->after_size) / 2 + (UINT32_C(1) << 19);
; 235  :     reserve = (uint32_t)(reserve + (lz_options->before_size + lz_options->match_len_max + lz_options->after_size) / 2 + (UINT32_C(1) << 19));

  000b1	44 8b 44 24 20	 mov	 r8d, DWORD PTR reserve$33156[rsp]
  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  000bb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  000c3	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  000cc	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000d0	33 d2		 xor	 edx, edx
  000d2	b9 02 00 00 00	 mov	 ecx, 2
  000d7	48 f7 f1	 div	 rcx
  000da	49 8d 84 00 00
	00 08 00	 lea	 rax, QWORD PTR [r8+rax+524288]
  000e2	89 44 24 20	 mov	 DWORD PTR reserve$33156[rsp], eax

; 236  : 
; 237  :   {
; 238  : 	const uint32_t old_size = mf->size;

  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  000eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ee	89 44 24 24	 mov	 DWORD PTR old_size$33160[rsp], eax

; 239  : 	mf->size = mf->keep_size_before + reserve + mf->keep_size_after;

  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  000f7	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  000fa	03 4c 24 20	 add	 ecx, DWORD PTR reserve$33156[rsp]
  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00103	03 48 10	 add	 ecx, DWORD PTR [rax+16]
  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0010b	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 240  : 
; 241  : 	// Deallocate the old history buffer if it exists but has different
; 242  : 	// size than what is needed now.
; 243  : 	if (mf->buffer != NULL && old_size != mf->size) {

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00113	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00117	74 2c		 je	 SHORT $LN23@lz_encoder@4
  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0011e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00121	39 44 24 24	 cmp	 DWORD PTR old_size$33160[rsp], eax
  00125	74 1e		 je	 SHORT $LN23@lz_encoder@4

; 244  : 		lzma_free(mf->buffer, allocator);

  00127	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  0012c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00131	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00134	e8 00 00 00 00	 call	 lzma_free

; 245  : 		mf->buffer = NULL;

  00139	4c 8b 5c 24 60	 mov	 r11, QWORD PTR mf$[rsp]
  0013e	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0
$LN23@lz_encoder@4:

; 246  : 	}
; 247  : 
; 248  : 	// Match finder options
; 249  : 	mf->match_len_max = (uint32_t)lz_options->match_len_max;

  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0014a	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0014f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00152	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 250  : 	mf->nice_len = (uint32_t)lz_options->nice_len;

  00155	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0015a	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0015f	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00162	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 251  : 
; 252  : 	// cyclic_size has to stay smaller than 2 Gi. Note that this doesn't
; 253  : 	// mean limiting dictionary size to less than 2 GiB. With a match
; 254  : 	// finder that uses multibyte resolution (hashes start at e.g. every
; 255  : 	// fourth byte), cyclic_size would stay below 2 Gi even when
; 256  : 	// dictionary size is greater than 2 GiB.
; 257  : 	//
; 258  : 	// It would be possible to allow cyclic_size >= 2 Gi, but then we
; 259  : 	// would need to be careful to use 64-bit types in various places
; 260  : 	// (size_t could do since we would need bigger than 32-bit address
; 261  : 	// space anyway). It would also require either zeroing a multigigabyte
; 262  : 	// buffer at initialization (waste of time and RAM) or allow
; 263  : 	// normalization in lz_encoder_mf.c to access uninitialized
; 264  : 	// memory to keep the code simpler. The current way is simple and
; 265  : 	// still allows pretty big dictionaries, so I don't expect these
; 266  : 	// limits to change.
; 267  : 	mf->cyclic_size = (uint32_t)(lz_options->dict_size + 1);

  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz_options$[rsp]
  0016a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0016e	48 83 c1 01	 add	 rcx, 1
  00172	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00177	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 268  : 
; 269  : 	// Validate the match finder ID and setup the function pointers.
; 270  : 	switch (lz_options->match_finder) {

  0017a	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0017f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00182	89 44 24 3c	 mov	 DWORD PTR tv146[rsp], eax
  00186	83 7c 24 3c 03	 cmp	 DWORD PTR tv146[rsp], 3
  0018b	74 25		 je	 SHORT $LN20@lz_encoder@4
  0018d	83 7c 24 3c 04	 cmp	 DWORD PTR tv146[rsp], 4
  00192	74 43		 je	 SHORT $LN19@lz_encoder@4
  00194	83 7c 24 3c 12	 cmp	 DWORD PTR tv146[rsp], 18
  00199	74 5e		 je	 SHORT $LN18@lz_encoder@4
  0019b	83 7c 24 3c 13	 cmp	 DWORD PTR tv146[rsp], 19
  001a0	74 79		 je	 SHORT $LN17@lz_encoder@4
  001a2	83 7c 24 3c 14	 cmp	 DWORD PTR tv146[rsp], 20
  001a7	0f 84 90 00 00
	00		 je	 $LN16@lz_encoder@4
  001ad	e9 ad 00 00 00	 jmp	 $LN15@lz_encoder@4
$LN20@lz_encoder@4:

; 271  : #ifdef HAVE_MF_HC3
; 272  : 	case LZMA_MF_HC3:
; 273  : 		mf->find = &lzma_mf_hc3_find;

  001b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_hc3_find
  001be	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 274  : 		mf->skip = &lzma_mf_hc3_skip;

  001c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  001c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_hc3_skip
  001ce	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 275  : 		break;

  001d2	e9 8f 00 00 00	 jmp	 $LN21@lz_encoder@4
$LN19@lz_encoder@4:

; 276  : #endif
; 277  : #ifdef HAVE_MF_HC4
; 278  : 	case LZMA_MF_HC4:
; 279  : 		mf->find = &lzma_mf_hc4_find;

  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  001dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_hc4_find
  001e3	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 280  : 		mf->skip = &lzma_mf_hc4_skip;

  001e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_hc4_skip
  001f3	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 281  : 		break;

  001f7	eb 6d		 jmp	 SHORT $LN21@lz_encoder@4
$LN18@lz_encoder@4:

; 282  : #endif
; 283  : #ifdef HAVE_MF_BT2
; 284  : 	case LZMA_MF_BT2:
; 285  : 		mf->find = &lzma_mf_bt2_find;

  001f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  001fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt2_find
  00205	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 286  : 		mf->skip = &lzma_mf_bt2_skip;

  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0020e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt2_skip
  00215	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 287  : 		break;

  00219	eb 4b		 jmp	 SHORT $LN21@lz_encoder@4
$LN17@lz_encoder@4:

; 288  : #endif
; 289  : #ifdef HAVE_MF_BT3
; 290  : 	case LZMA_MF_BT3:
; 291  : 		mf->find = &lzma_mf_bt3_find;

  0021b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00220	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt3_find
  00227	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 292  : 		mf->skip = &lzma_mf_bt3_skip;

  0022b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00230	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt3_skip
  00237	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 293  : 		break;

  0023b	eb 29		 jmp	 SHORT $LN21@lz_encoder@4
$LN16@lz_encoder@4:

; 294  : #endif
; 295  : #ifdef HAVE_MF_BT4
; 296  : 	case LZMA_MF_BT4:
; 297  : 		mf->find = &lzma_mf_bt4_find;

  0023d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00242	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt4_find
  00249	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 298  : 		mf->skip = &lzma_mf_bt4_skip;

  0024d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00252	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_mf_bt4_skip
  00259	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 299  : 		break;

  0025d	eb 07		 jmp	 SHORT $LN21@lz_encoder@4
$LN15@lz_encoder@4:

; 300  : #endif
; 301  : 
; 302  : 	default:
; 303  : 		return true;

  0025f	b0 01		 mov	 al, 1
  00261	e9 40 02 00 00	 jmp	 $LN27@lz_encoder@4
$LN21@lz_encoder@4:

; 304  : 	}
; 305  : 
; 306  : 	// Calculate the sizes of mf->hash and mf->son and check that
; 307  : 	// nice_len is big enough for the selected match finder.
; 308  :   {
; 309  : 	const uint32_t hash_bytes = lz_options->match_finder & 0x0F;

  00266	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0026b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0026e	83 e0 0f	 and	 eax, 15
  00271	89 44 24 28	 mov	 DWORD PTR hash_bytes$33177[rsp], eax

; 310  : 	if (hash_bytes > mf->nice_len)

  00275	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0027a	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0027d	39 44 24 28	 cmp	 DWORD PTR hash_bytes$33177[rsp], eax
  00281	76 07		 jbe	 SHORT $LN14@lz_encoder@4

; 311  : 		return true;

  00283	b0 01		 mov	 al, 1
  00285	e9 1c 02 00 00	 jmp	 $LN27@lz_encoder@4
$LN14@lz_encoder@4:

; 312  : 
; 313  :   {
; 314  : 	const bool is_bt = (lz_options->match_finder & 0x10) != 0;

  0028a	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0028f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00292	83 e0 10	 and	 eax, 16
  00295	85 c0		 test	 eax, eax
  00297	74 0a		 je	 SHORT $LN29@lz_encoder@4
  00299	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  002a1	eb 08		 jmp	 SHORT $LN30@lz_encoder@4
$LN29@lz_encoder@4:
  002a3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN30@lz_encoder@4:
  002ab	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv169[rsp]
  002b0	88 44 24 30	 mov	 BYTE PTR is_bt$33179[rsp], al

; 315  : 	uint32_t hs;
; 316  : 
; 317  : 	if (hash_bytes == 2) {

  002b4	83 7c 24 28 02	 cmp	 DWORD PTR hash_bytes$33177[rsp], 2
  002b9	75 0d		 jne	 SHORT $LN13@lz_encoder@4

; 318  : 		hs = 0xFFFF;

  002bb	c7 44 24 2c ff
	ff 00 00	 mov	 DWORD PTR hs$33180[rsp], 65535 ; 0000ffffH

; 319  : 	} else {

  002c3	e9 90 00 00 00	 jmp	 $LN12@lz_encoder@4
$LN13@lz_encoder@4:

; 320  : 		// Round dictionary size up to the next 2^n - 1 so it can
; 321  : 		// be used as a hash mask.
; 322  : 		hs = (uint32_t)(lz_options->dict_size - 1);

  002c8	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  002cd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002d1	48 83 e8 01	 sub	 rax, 1
  002d5	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 323  : 		hs |= hs >> 1;

  002d9	8b 4c 24 2c	 mov	 ecx, DWORD PTR hs$33180[rsp]
  002dd	d1 e9		 shr	 ecx, 1
  002df	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  002e3	0b c1		 or	 eax, ecx
  002e5	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 324  : 		hs |= hs >> 2;

  002e9	8b 4c 24 2c	 mov	 ecx, DWORD PTR hs$33180[rsp]
  002ed	c1 e9 02	 shr	 ecx, 2
  002f0	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  002f4	0b c1		 or	 eax, ecx
  002f6	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 325  : 		hs |= hs >> 4;

  002fa	8b 4c 24 2c	 mov	 ecx, DWORD PTR hs$33180[rsp]
  002fe	c1 e9 04	 shr	 ecx, 4
  00301	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00305	0b c1		 or	 eax, ecx
  00307	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 326  : 		hs |= hs >> 8;

  0030b	8b 4c 24 2c	 mov	 ecx, DWORD PTR hs$33180[rsp]
  0030f	c1 e9 08	 shr	 ecx, 8
  00312	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00316	0b c1		 or	 eax, ecx
  00318	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 327  : 		hs >>= 1;

  0031c	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00320	d1 e8		 shr	 eax, 1
  00322	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 328  : 		hs |= 0xFFFF;

  00326	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  0032a	0d ff ff 00 00	 or	 eax, 65535		; 0000ffffH
  0032f	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 329  : 
; 330  : 		if (hs > (UINT32_C(1) << 24)) {

  00333	81 7c 24 2c 00
	00 00 01	 cmp	 DWORD PTR hs$33180[rsp], 16777216 ; 01000000H
  0033b	76 1b		 jbe	 SHORT $LN11@lz_encoder@4

; 331  : 			if (hash_bytes == 3)

  0033d	83 7c 24 28 03	 cmp	 DWORD PTR hash_bytes$33177[rsp], 3
  00342	75 0a		 jne	 SHORT $LN10@lz_encoder@4

; 332  : 				hs = (UINT32_C(1) << 24) - 1;

  00344	c7 44 24 2c ff
	ff ff 00	 mov	 DWORD PTR hs$33180[rsp], 16777215 ; 00ffffffH

; 333  : 			else

  0034c	eb 0a		 jmp	 SHORT $LN9@lz_encoder@4
$LN10@lz_encoder@4:

; 334  : 				hs >>= 1;

  0034e	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00352	d1 e8		 shr	 eax, 1
  00354	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax
$LN9@lz_encoder@4:
$LN11@lz_encoder@4:
$LN12@lz_encoder@4:

; 335  : 		}
; 336  : 	}
; 337  : 
; 338  : 	mf->hash_mask = hs;

  00358	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0035d	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00361	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 339  : 
; 340  : 	++hs;

  00364	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  00368	83 c0 01	 add	 eax, 1
  0036b	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax

; 341  : 	if (hash_bytes > 2)

  0036f	83 7c 24 28 02	 cmp	 DWORD PTR hash_bytes$33177[rsp], 2
  00374	76 0d		 jbe	 SHORT $LN8@lz_encoder@4

; 342  : 		hs += HASH_2_SIZE;

  00376	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  0037a	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0037f	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax
$LN8@lz_encoder@4:

; 343  : 	if (hash_bytes > 3)

  00383	83 7c 24 28 03	 cmp	 DWORD PTR hash_bytes$33177[rsp], 3
  00388	76 0d		 jbe	 SHORT $LN7@lz_encoder@4

; 344  : 		hs += HASH_3_SIZE;

  0038a	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  0038e	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00393	89 44 24 2c	 mov	 DWORD PTR hs$33180[rsp], eax
$LN7@lz_encoder@4:

; 345  : /*
; 346  : 	No match finder uses this at the moment.
; 347  : 	if (mf->hash_bytes > 4)
; 348  : 		hs += HASH_4_SIZE;
; 349  : */
; 350  :   {
; 351  : 
; 352  : 	const uint32_t old_hash_count = mf->hash_count;

  00397	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0039c	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0039f	89 44 24 34	 mov	 DWORD PTR old_hash_count$33189[rsp], eax

; 353  : 	const uint32_t old_sons_count = mf->sons_count;

  003a3	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003ab	89 44 24 38	 mov	 DWORD PTR old_sons_count$33190[rsp], eax

; 354  : 	mf->hash_count = hs;

  003af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  003b4	8b 44 24 2c	 mov	 eax, DWORD PTR hs$33180[rsp]
  003b8	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 355  : 	mf->sons_count = mf->cyclic_size;

  003bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  003c0	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003c5	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  003c8	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 356  : 	if (is_bt)

  003cb	0f b6 44 24 30	 movzx	 eax, BYTE PTR is_bt$33179[rsp]
  003d0	85 c0		 test	 eax, eax
  003d2	74 12		 je	 SHORT $LN6@lz_encoder@4

; 357  : 		mf->sons_count *= 2;

  003d4	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003d9	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  003dc	d1 e1		 shl	 ecx, 1
  003de	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003e3	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN6@lz_encoder@4:

; 358  : 
; 359  : 	// Deallocate the old hash array if it exists and has different size
; 360  : 	// than what is needed now.
; 361  : 	if (old_hash_count != mf->hash_count
; 362  : 			|| old_sons_count != mf->sons_count) {

  003e6	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003eb	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  003ee	39 44 24 34	 cmp	 DWORD PTR old_hash_count$33189[rsp], eax
  003f2	75 0e		 jne	 SHORT $LN4@lz_encoder@4
  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  003f9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003fc	39 44 24 38	 cmp	 DWORD PTR old_sons_count$33190[rsp], eax
  00400	74 40		 je	 SHORT $LN5@lz_encoder@4
$LN4@lz_encoder@4:

; 363  : 		lzma_free(mf->hash, allocator);

  00402	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  00407	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0040c	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00410	e8 00 00 00 00	 call	 lzma_free

; 364  : 		mf->hash = NULL;

  00415	4c 8b 5c 24 60	 mov	 r11, QWORD PTR mf$[rsp]
  0041a	49 c7 43 40 00
	00 00 00	 mov	 QWORD PTR [r11+64], 0

; 365  : 
; 366  : 		lzma_free(mf->son, allocator);

  00422	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  00427	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  0042c	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00430	e8 00 00 00 00	 call	 lzma_free

; 367  : 		mf->son = NULL;

  00435	4c 8b 5c 24 60	 mov	 r11, QWORD PTR mf$[rsp]
  0043a	49 c7 43 48 00
	00 00 00	 mov	 QWORD PTR [r11+72], 0
$LN5@lz_encoder@4:

; 368  : 	}
; 369  : 
; 370  : 	// Maximum number of match finder cycles
; 371  : 	mf->depth = lz_options->depth;

  00442	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mf$[rsp]
  00447	48 8b 44 24 70	 mov	 rax, QWORD PTR lz_options$[rsp]
  0044c	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0044f	89 41 5c	 mov	 DWORD PTR [rcx+92], eax

; 372  : 	if (mf->depth == 0) {

  00452	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00457	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  0045b	75 47		 jne	 SHORT $LN3@lz_encoder@4

; 373  : 		if (is_bt)

  0045d	0f b6 44 24 30	 movzx	 eax, BYTE PTR is_bt$33179[rsp]
  00462	85 c0		 test	 eax, eax
  00464	74 20		 je	 SHORT $LN2@lz_encoder@4

; 374  : 			mf->depth = 16 + mf->nice_len / 2;

  00466	33 d2		 xor	 edx, edx
  00468	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0046d	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00470	b9 02 00 00 00	 mov	 ecx, 2
  00475	f7 f1		 div	 ecx
  00477	8b c8		 mov	 ecx, eax
  00479	83 c1 10	 add	 ecx, 16
  0047c	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  00481	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 375  : 		else

  00484	eb 1e		 jmp	 SHORT $LN1@lz_encoder@4
$LN2@lz_encoder@4:

; 376  : 			mf->depth = 4 + mf->nice_len / 4;

  00486	33 d2		 xor	 edx, edx
  00488	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  0048d	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00490	b9 04 00 00 00	 mov	 ecx, 4
  00495	f7 f1		 div	 ecx
  00497	8b c8		 mov	 ecx, eax
  00499	83 c1 04	 add	 ecx, 4
  0049c	48 8b 44 24 60	 mov	 rax, QWORD PTR mf$[rsp]
  004a1	89 48 5c	 mov	 DWORD PTR [rax+92], ecx
$LN1@lz_encoder@4:
$LN3@lz_encoder@4:

; 377  : 	}
; 378  :   }}}}}
; 379  : 
; 380  : 	return false;

  004a4	32 c0		 xor	 al, al
$LN27@lz_encoder@4:

; 381  : }

  004a6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  004aa	c3		 ret	 0
lz_encoder_prepare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_encode DD imagerel lz_encode
	DD	imagerel lz_encode+284
	DD	imagerel $unwind$lz_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_encode DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_encode
_TEXT	SEGMENT
coder$ = 48
ret_$33140 = 56
ret$33142 = 60
coder_ptr$ = 80
allocator$ = 88
in$ = 96
in_pos$ = 104
in_size$ = 112
out$ = 120
out_pos$ = 128
out_size$ = 136
action$ = 144
lz_encode PROC						; COMDAT

; 170  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 171  : 	lzma_coder *coder = coder_ptr;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 30	 mov	 QWORD PTR coder$[rsp], rax
$LN9@lz_encode:

; 172  : 
; 173  : 	while (*out_pos < out_size
; 174  : 			&& (*in_pos < in_size || action != LZMA_RUN)) {

  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0002a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00032	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00035	0f 83 da 00 00
	00		 jae	 $LN8@lz_encode
  0003b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR in_size$[rsp]
  00045	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00048	72 0e		 jb	 SHORT $LN7@lz_encode
  0004a	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  00052	0f 84 bd 00 00
	00		 je	 $LN8@lz_encode
$LN7@lz_encode:

; 175  : 		// Read more data to coder->mf.buffer if needed.
; 176  : 		if (coder->mf.action == LZMA_RUN && coder->mf.read_pos
; 177  : 				>= coder->mf.read_limit)

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0005d	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00064	75 57		 jne	 SHORT $LN6@lz_encode
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00070	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00073	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  00076	72 45		 jb	 SHORT $LN6@lz_encode
$LN5@lz_encode:

; 178  : 			return_if_error(fill_window(coder, allocator,
; 179  : 					in, in_pos, in_size, action));

  00078	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  0007f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR in_size$[rsp]
  00088	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR in_pos$[rsp]
  00092	4c 8b 44 24 60	 mov	 r8, QWORD PTR in$[rsp]
  00097	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  000a1	e8 00 00 00 00	 call	 fill_window
  000a6	89 44 24 38	 mov	 DWORD PTR ret_$33140[rsp], eax
  000aa	83 7c 24 38 00	 cmp	 DWORD PTR ret_$33140[rsp], 0
  000af	74 06		 je	 SHORT $LN2@lz_encode
  000b1	8b 44 24 38	 mov	 eax, DWORD PTR ret_$33140[rsp]
  000b5	eb 60		 jmp	 SHORT $LN10@lz_encode
$LN2@lz_encode:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 bb		 jne	 SHORT $LN5@lz_encode
$LN6@lz_encode:

; 180  : 
; 181  : 		// Encode
; 182  : 	  {
; 183  : 		const lzma_ret ret = coder->lz.code(coder->lz.coder,
; 184  : 				&coder->mf, out, out_pos, out_size);

  000bd	48 8b 54 24 30	 mov	 rdx, QWORD PTR coder$[rsp]
  000c2	48 83 c2 20	 add	 rdx, 32			; 00000020H
  000c6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR out_pos$[rsp]
  000db	4c 8b 44 24 78	 mov	 r8, QWORD PTR out$[rsp]
  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  000e5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000ed	ff 50 08	 call	 QWORD PTR [rax+8]
  000f0	89 44 24 3c	 mov	 DWORD PTR ret$33142[rsp], eax

; 185  : 		if (ret != LZMA_OK) {

  000f4	83 7c 24 3c 00	 cmp	 DWORD PTR ret$33142[rsp], 0
  000f9	74 15		 je	 SHORT $LN1@lz_encode

; 186  : 			// Setting this to LZMA_RUN for cases when we are
; 187  : 			// flushing. It doesn't matter when finishing or if
; 188  : 			// an error occurred.
; 189  : 			coder->mf.action = LZMA_RUN;

  000fb	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00100	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 190  : 			return ret;

  0010a	8b 44 24 3c	 mov	 eax, DWORD PTR ret$33142[rsp]
  0010e	eb 07		 jmp	 SHORT $LN10@lz_encode
$LN1@lz_encode:

; 191  : 		}
; 192  : 	  }
; 193  : 	}

  00110	e9 0d ff ff ff	 jmp	 $LN9@lz_encode
$LN8@lz_encode:

; 194  : 
; 195  : 	return LZMA_OK;

  00115	33 c0		 xor	 eax, eax
$LN10@lz_encode:

; 196  : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
lz_encode ENDP
PUBLIC	lzma_lz_encoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lz_encoder_init DD imagerel $LN11
	DD	imagerel $LN11+505
	DD	imagerel $unwind$lzma_lz_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lz_encoder_init DD 041d01H
	DD	011011dH
	DD	060157016H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lz_encoder_init
_TEXT	SEGMENT
coder$ = 32
lz_options$33291 = 48
ret_$33295 = 112
next$ = 160
allocator$ = 168
filters$ = 176
lz_init$ = 184
lzma_lz_encoder_init PROC				; COMDAT

; 574  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 575  : #ifdef HAVE_SMALL
; 576  : 	// We need that the CRC32 table has been initialized.
; 577  : 	lzma_crc32_init();
; 578  : #endif
; 579  : 
; 580  : 	// Allocate and initialize the base data structure.
; 581  : 	lzma_coder *coder = next->coder;

  0001d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 582  : 	if (coder == NULL) {

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00033	0f 85 03 01 00
	00		 jne	 $LN8@lzma_lz_en

; 583  : 		coder = lzma_alloc(sizeof(lzma_coder), allocator);

  00039	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00041	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  00046	e8 00 00 00 00	 call	 lzma_alloc
  0004b	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 584  : 		if (coder == NULL)

  00050	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00056	75 0a		 jne	 SHORT $LN7@lzma_lz_en

; 585  : 			return LZMA_MEM_ERROR;

  00058	b8 05 00 00 00	 mov	 eax, 5
  0005d	e9 8d 01 00 00	 jmp	 $LN9@lzma_lz_en
$LN7@lzma_lz_en:

; 586  : 
; 587  : 		next->coder = coder;

  00062	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0006f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 588  : 		next->code = &lz_encode;

  00072	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lz_encode
  00081	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 589  : 		next->end = &lz_encoder_end;

  00085	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lz_encoder_end
  00094	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 590  : 		next->update = &lz_encoder_update;

  00098	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lz_encoder_update
  000a7	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 591  : 
; 592  : 		coder->lz.coder = NULL;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000b0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 593  : 		coder->lz.code = NULL;

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000bc	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 594  : 		coder->lz.end = NULL;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000c9	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 595  : 
; 596  : 		// mf.size is initialized to silence Valgrind
; 597  : 		// when used on optimized binaries (GCC may reorder
; 598  : 		// code in a way that Valgrind gets unhappy).
; 599  : 		coder->mf.buffer = NULL;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000d6	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 600  : 		coder->mf.size = 0;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000e3	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 601  : 		coder->mf.hash = NULL;

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000ef	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 602  : 		coder->mf.son = NULL;

  000f7	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000fc	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 603  : 		coder->mf.hash_count = 0;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00109	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+140], 0

; 604  : 		coder->mf.sons_count = 0;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00118	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 605  : 
; 606  : 		coder->next = LZMA_NEXT_CODER_INIT;

  00122	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  00127	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  0012e	48 81 c7 98 00
	00 00		 add	 rdi, 152		; 00000098H
  00135	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0013a	f3 a4		 rep movsb
$LN8@lzma_lz_en:
$LN6@lzma_lz_en:

; 607  : 	}
; 608  : 
; 609  : 	// Initialize the LZ-based encoder.
; 610  :   {
; 611  : 	lzma_lz_options lz_options;
; 612  : 	return_if_error(lz_init(&coder->lz, allocator,
; 613  : 			filters[0].options, &lz_options));

  0013c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR lz_options$33291[rsp]
  00141	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  00149	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  0014d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00155	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0015a	ff 94 24 b8 00
	00 00		 call	 QWORD PTR lz_init$[rsp]
  00161	89 44 24 70	 mov	 DWORD PTR ret_$33295[rsp], eax
  00165	83 7c 24 70 00	 cmp	 DWORD PTR ret_$33295[rsp], 0
  0016a	74 06		 je	 SHORT $LN3@lzma_lz_en
  0016c	8b 44 24 70	 mov	 eax, DWORD PTR ret_$33295[rsp]
  00170	eb 7d		 jmp	 SHORT $LN9@lzma_lz_en
$LN3@lzma_lz_en:
  00172	33 c0		 xor	 eax, eax
  00174	85 c0		 test	 eax, eax
  00176	75 c4		 jne	 SHORT $LN6@lzma_lz_en

; 614  : 
; 615  : 	// Setup the size information into coder->mf and deallocate
; 616  : 	// old buffers if they have wrong size.
; 617  : 	if (lz_encoder_prepare(&coder->mf, allocator, &lz_options))

  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0017d	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00181	4c 8d 44 24 30	 lea	 r8, QWORD PTR lz_options$33291[rsp]
  00186	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0018e	e8 00 00 00 00	 call	 lz_encoder_prepare
  00193	0f b6 c0	 movzx	 eax, al
  00196	85 c0		 test	 eax, eax
  00198	74 07		 je	 SHORT $LN2@lzma_lz_en

; 618  : 		return LZMA_OPTIONS_ERROR;

  0019a	b8 08 00 00 00	 mov	 eax, 8
  0019f	eb 4e		 jmp	 SHORT $LN9@lzma_lz_en
$LN2@lzma_lz_en:

; 619  : 
; 620  : 	// Allocate new buffers if needed, and do the rest of
; 621  : 	// the initialization.
; 622  : 	if (lz_encoder_init(&coder->mf, allocator, &lz_options))

  001a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  001a6	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001aa	4c 8d 44 24 30	 lea	 r8, QWORD PTR lz_options$33291[rsp]
  001af	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001b7	e8 00 00 00 00	 call	 lz_encoder_init
  001bc	0f b6 c0	 movzx	 eax, al
  001bf	85 c0		 test	 eax, eax
  001c1	74 07		 je	 SHORT $LN1@lzma_lz_en

; 623  : 		return LZMA_MEM_ERROR;

  001c3	b8 05 00 00 00	 mov	 eax, 5
  001c8	eb 25		 jmp	 SHORT $LN9@lzma_lz_en
$LN1@lzma_lz_en:

; 624  :   }
; 625  : 
; 626  : 	// Initialize the next filter in the chain, if any.
; 627  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  001ca	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  001d2	49 83 c0 18	 add	 r8, 24
  001d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  001db	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  001e2	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001ea	e8 00 00 00 00	 call	 lzma_next_filter_init
$LN9@lzma_lz_en:

; 628  : }

  001ef	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001f6	5f		 pop	 rdi
  001f7	5e		 pop	 rsi
  001f8	c3		 ret	 0
lzma_lz_encoder_init ENDP
_TEXT	ENDS
PUBLIC	lzma_lz_encoder_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lz_encoder_memusage DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$lzma_lz_encoder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lz_encoder_memusage DD 030d01H
	DD	014010dH
	DD	07006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lz_encoder_memusage
_TEXT	SEGMENT
mf$ = 32
lz_options$ = 176
lzma_lz_encoder_memusage PROC				; COMDAT

; 479  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 480  : 	// Old buffers must not exist when calling lz_encoder_prepare().
; 481  : 	/*
; 482  : 	lzma_mf mf = {
; 483  : 		.buffer = NULL,
; 484  : 		.hash = NULL,
; 485  : 		.son = NULL,
; 486  : 		.hash_count = 0,
; 487  : 		.sons_count = 0,
; 488  : 	};
; 489  : 	*/
; 490  : 	/*
; 491  : 	lzma_mf mf = {
; 492  : 		NULL,   //uint8_t *buffer;
; 493  : 		0,      //uint32_t size;
; 494  : 		0,      //uint32_t keep_size_before;
; 495  : 		0,      //uint32_t keep_size_after;
; 496  : 		0,      //uint32_t offset;
; 497  : 		0,      //uint32_t read_pos;
; 498  : 		0,      //uint32_t read_ahead;
; 499  : 		0,      //uint32_t read_limit;
; 500  : 		0,      //uint32_t write_pos;
; 501  : 		0,      //uint32_t pending;
; 502  : 		NULL,   //uint32_t (*find)(lzma_mf *mf, lzma_match *matches);
; 503  : 		NULL,   //void (*skip)(lzma_mf *mf, uint32_t num);
; 504  : 		NULL,   //uint32_t *hash;
; 505  : 		NULL,   //uint32_t *son;
; 506  : 		NULL,   //uint32_t cyclic_pos;
; 507  : 		0,      //uint32_t cyclic_size; // Must be dictionary size + 1.
; 508  : 		0,      //uint32_t hash_mask;
; 509  : 		0,      //uint32_t depth;
; 510  : 		0,      //uint32_t nice_len;
; 511  : 		0,      //uint32_t match_len_max;
; 512  : 		{0},    //lzma_action action;
; 513  : 		0,      //uint32_t hash_size_sum;
; 514  : 		0,      //uint32_t sons_count;
; 515  : 	};
; 516  : 	*/
; 517  : 	lzma_mf mf = {0};

  0000d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR mf$[rsp], 0
  00016	48 8d 7c 24 28	 lea	 rdi, QWORD PTR mf$[rsp+8]
  0001b	33 c0		 xor	 eax, eax
  0001d	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00022	f3 aa		 rep stosb

; 518  : 
; 519  : 	// Setup the size information into mf.
; 520  : 	if (lz_encoder_prepare(&mf, NULL, lz_options))

  00024	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR lz_options$[rsp]
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mf$[rsp]
  00033	e8 00 00 00 00	 call	 lz_encoder_prepare
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	74 09		 je	 SHORT $LN1@lzma_lz_en@2

; 521  : 		return UINT64_MAX;

  0003f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00046	eb 1d		 jmp	 SHORT $LN2@lzma_lz_en@2
$LN1@lzma_lz_en@2:

; 522  : 
; 523  : 	// Calculate the memory usage.
; 524  : 	return ((uint64_t)(mf.hash_count) + mf.sons_count) * sizeof(uint32_t)
; 525  : 			+ mf.size + sizeof(lzma_coder);

  00048	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR mf$[rsp+108]
  0004f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR mf$[rsp+112]
  00056	48 03 c8	 add	 rcx, rax
  00059	8b 44 24 28	 mov	 eax, DWORD PTR mf$[rsp+8]
  0005d	48 8d 84 88 e0
	00 00 00	 lea	 rax, QWORD PTR [rax+rcx*4+224]
$LN2@lzma_lz_en@2:

; 526  : }

  00065	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
lzma_lz_encoder_memusage ENDP
END
