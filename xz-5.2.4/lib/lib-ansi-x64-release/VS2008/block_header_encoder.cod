; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
;	COMDAT write32ne
_TEXT	SEGMENT
buf$ = 8
num$ = 16
write32ne PROC						; COMDAT

; 266  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  : 	*(uint32_t *)buf = num;

  00009	48 8b 4c 24 08	 mov	 rcx, QWORD PTR buf$[rsp]
  0000e	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00012	89 01		 mov	 DWORD PTR [rcx], eax

; 268  : 	return;
; 269  : }

  00014	c3		 ret	 0
write32ne ENDP
PUBLIC	lzma_block_header_encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_header_encode DD imagerel $LN27
	DD	imagerel $LN27+601
	DD	imagerel $unwind$lzma_block_header_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_header_encode DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_header_encoder.c
xdata	ENDS
;	COMDAT lzma_block_header_encode
_TEXT	SEGMENT
out_size$32889 = 48
out_pos$32891 = 56
ret_$32896 = 64
ret_$32903 = 68
filter_count$32909 = 72
ret_$32917 = 80
$T82554 = 84
block$ = 112
out$ = 120
lzma_block_header_encode PROC				; COMDAT

; 81   : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 82   : 	// Validate everything but filters.
; 83   : 	if (lzma_block_unpadded_size(block) == 0
; 84   : 			|| !lzma_vli_is_valid(block->uncompressed_size))

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  00018	48 85 c0	 test	 rax, rax
  0001b	74 21		 je	 SHORT $LN21@lzma_block@4
  0001d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  00022	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002c	48 39 41 18	 cmp	 QWORD PTR [rcx+24], rax
  00030	76 16		 jbe	 SHORT $LN22@lzma_block@4
  00032	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00037	48 83 78 18 ff	 cmp	 QWORD PTR [rax+24], -1
  0003c	74 0a		 je	 SHORT $LN22@lzma_block@4
$LN21@lzma_block@4:

; 85   : 		return LZMA_PROG_ERROR;

  0003e	b8 0b 00 00 00	 mov	 eax, 11
  00043	e9 0c 02 00 00	 jmp	 $LN23@lzma_block@4
$LN22@lzma_block@4:

; 86   : 
; 87   : 	// Indicate the size of the buffer _excluding_ the CRC32 field.
; 88   :   {
; 89   : 	const size_t out_size = block->header_size - 4;

  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00050	83 e8 04	 sub	 eax, 4
  00053	8b c0		 mov	 eax, eax
  00055	48 89 44 24 30	 mov	 QWORD PTR out_size$32889[rsp], rax

; 90   : 
; 91   : 	// Store the Block Header Size.
; 92   : 	out[0] = (uint8_t)(out_size / 4);

  0005a	33 d2		 xor	 edx, edx
  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR out_size$32889[rsp]
  00061	b9 04 00 00 00	 mov	 ecx, 4
  00066	48 f7 f1	 div	 rcx
  00069	48 8b c8	 mov	 rcx, rax
  0006c	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  00071	88 08		 mov	 BYTE PTR [rax], cl

; 93   : 
; 94   : 	// We write Block Flags in pieces.
; 95   : 	out[1] = 0x00;

  00073	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  00078	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 96   :   {
; 97   : 	size_t out_pos = 2;

  0007c	48 c7 44 24 38
	02 00 00 00	 mov	 QWORD PTR out_pos$32891[rsp], 2

; 98   : 
; 99   : 	// Compressed Size
; 100  : 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {

  00085	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0008a	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  0008f	74 52		 je	 SHORT $LN20@lzma_block@4
$LN19@lzma_block@4:

; 101  : 		return_if_error(lzma_vli_encode(block->compressed_size, NULL,
; 102  : 				out, &out_pos, out_size));

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR out_size$32889[rsp]
  00096	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009b	4c 8d 4c 24 38	 lea	 r9, QWORD PTR out_pos$32891[rsp]
  000a0	4c 8b 44 24 78	 mov	 r8, QWORD PTR out$[rsp]
  000a5	33 d2		 xor	 edx, edx
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  000ac	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b0	e8 00 00 00 00	 call	 lzma_vli_encode
  000b5	89 44 24 40	 mov	 DWORD PTR ret_$32896[rsp], eax
  000b9	83 7c 24 40 00	 cmp	 DWORD PTR ret_$32896[rsp], 0
  000be	74 09		 je	 SHORT $LN16@lzma_block@4
  000c0	8b 44 24 40	 mov	 eax, DWORD PTR ret_$32896[rsp]
  000c4	e9 8b 01 00 00	 jmp	 $LN23@lzma_block@4
$LN16@lzma_block@4:
  000c9	33 c0		 xor	 eax, eax
  000cb	85 c0		 test	 eax, eax
  000cd	75 c2		 jne	 SHORT $LN19@lzma_block@4

; 103  : 
; 104  : 		out[1] |= 0x40;

  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  000d4	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d8	83 c9 40	 or	 ecx, 64			; 00000040H
  000db	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  000e0	88 48 01	 mov	 BYTE PTR [rax+1], cl
$LN20@lzma_block@4:

; 105  : 	}
; 106  : 
; 107  : 	// Uncompressed Size
; 108  : 	if (block->uncompressed_size != LZMA_VLI_UNKNOWN) {

  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  000e8	48 83 78 18 ff	 cmp	 QWORD PTR [rax+24], -1
  000ed	74 55		 je	 SHORT $LN15@lzma_block@4
$LN14@lzma_block@4:

; 109  : 		return_if_error(lzma_vli_encode(block->uncompressed_size, NULL,
; 110  : 				out, &out_pos, out_size));

  000ef	48 8b 44 24 30	 mov	 rax, QWORD PTR out_size$32889[rsp]
  000f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f9	4c 8d 4c 24 38	 lea	 r9, QWORD PTR out_pos$32891[rsp]
  000fe	4c 8b 44 24 78	 mov	 r8, QWORD PTR out$[rsp]
  00103	33 d2		 xor	 edx, edx
  00105	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  0010a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0010e	e8 00 00 00 00	 call	 lzma_vli_encode
  00113	89 44 24 44	 mov	 DWORD PTR ret_$32903[rsp], eax
  00117	83 7c 24 44 00	 cmp	 DWORD PTR ret_$32903[rsp], 0
  0011c	74 09		 je	 SHORT $LN11@lzma_block@4
  0011e	8b 44 24 44	 mov	 eax, DWORD PTR ret_$32903[rsp]
  00122	e9 2d 01 00 00	 jmp	 $LN23@lzma_block@4
$LN11@lzma_block@4:
  00127	33 c0		 xor	 eax, eax
  00129	85 c0		 test	 eax, eax
  0012b	75 c2		 jne	 SHORT $LN14@lzma_block@4

; 111  : 
; 112  : 		out[1] |= 0x80;

  0012d	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  00132	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00136	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0013c	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  00141	88 48 01	 mov	 BYTE PTR [rax+1], cl
$LN15@lzma_block@4:

; 113  : 	}
; 114  : 
; 115  : 	// Filter Flags
; 116  : 	if (block->filters == NULL || block->filters[0].id == LZMA_VLI_UNKNOWN)

  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00149	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0014e	74 0f		 je	 SHORT $LN9@lzma_block@4
  00150	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00155	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00159	48 83 38 ff	 cmp	 QWORD PTR [rax], -1
  0015d	75 0a		 jne	 SHORT $LN10@lzma_block@4
$LN9@lzma_block@4:

; 117  : 		return LZMA_PROG_ERROR;

  0015f	b8 0b 00 00 00	 mov	 eax, 11
  00164	e9 eb 00 00 00	 jmp	 $LN23@lzma_block@4
$LN10@lzma_block@4:

; 118  : 
; 119  :   {
; 120  : 	size_t filter_count = 0;

  00169	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR filter_count$32909[rsp], 0
$LN8@lzma_block@4:

; 121  : 	do {
; 122  : 		// There can be a maximum of four filters.
; 123  : 		if (filter_count == LZMA_FILTERS_MAX)

  00172	48 83 7c 24 48
	04		 cmp	 QWORD PTR filter_count$32909[rsp], 4
  00178	75 0a		 jne	 SHORT $LN5@lzma_block@4

; 124  : 			return LZMA_PROG_ERROR;

  0017a	b8 0b 00 00 00	 mov	 eax, 11
  0017f	e9 d0 00 00 00	 jmp	 $LN23@lzma_block@4
$LN5@lzma_block@4:
$LN4@lzma_block@4:

; 125  : 
; 126  : 		return_if_error(lzma_filter_flags_encode(
; 127  : 				block->filters + filter_count,
; 128  : 				out, &out_pos, out_size));

  00184	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filter_count$32909[rsp]
  00189	48 6b c9 10	 imul	 rcx, 16
  0018d	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00192	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00196	4c 8b 4c 24 30	 mov	 r9, QWORD PTR out_size$32889[rsp]
  0019b	4c 8d 44 24 38	 lea	 r8, QWORD PTR out_pos$32891[rsp]
  001a0	48 8b 54 24 78	 mov	 rdx, QWORD PTR out$[rsp]
  001a5	e8 00 00 00 00	 call	 lzma_filter_flags_encode
  001aa	89 44 24 50	 mov	 DWORD PTR ret_$32917[rsp], eax
  001ae	83 7c 24 50 00	 cmp	 DWORD PTR ret_$32917[rsp], 0
  001b3	74 09		 je	 SHORT $LN1@lzma_block@4
  001b5	8b 44 24 50	 mov	 eax, DWORD PTR ret_$32917[rsp]
  001b9	e9 96 00 00 00	 jmp	 $LN23@lzma_block@4
$LN1@lzma_block@4:
  001be	33 c0		 xor	 eax, eax
  001c0	85 c0		 test	 eax, eax
  001c2	75 c0		 jne	 SHORT $LN4@lzma_block@4

; 129  : 
; 130  : 	} while (block->filters[++filter_count].id != LZMA_VLI_UNKNOWN);

  001c4	48 8b 44 24 48	 mov	 rax, QWORD PTR filter_count$32909[rsp]
  001c9	48 83 c0 01	 add	 rax, 1
  001cd	48 89 44 24 48	 mov	 QWORD PTR filter_count$32909[rsp], rax
  001d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filter_count$32909[rsp]
  001d7	48 6b c9 10	 imul	 rcx, 16
  001db	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  001e0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e4	48 83 3c 01 ff	 cmp	 QWORD PTR [rcx+rax], -1
  001e9	75 87		 jne	 SHORT $LN8@lzma_block@4

; 131  : 
; 132  : 	out[1] |= filter_count - 1;

  001eb	48 8b 54 24 48	 mov	 rdx, QWORD PTR filter_count$32909[rsp]
  001f0	48 83 ea 01	 sub	 rdx, 1
  001f4	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  001f9	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  001fd	48 0b ca	 or	 rcx, rdx
  00200	48 8b 44 24 78	 mov	 rax, QWORD PTR out$[rsp]
  00205	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 133  : 
; 134  : 	// Padding
; 135  : 	memzero(out + out_pos, out_size - out_pos);

  00208	48 8b 44 24 38	 mov	 rax, QWORD PTR out_pos$32891[rsp]
  0020d	4c 8b 44 24 30	 mov	 r8, QWORD PTR out_size$32889[rsp]
  00212	4c 2b c0	 sub	 r8, rax
  00215	48 8b 44 24 38	 mov	 rax, QWORD PTR out_pos$32891[rsp]
  0021a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR out$[rsp]
  0021f	48 03 c8	 add	 rcx, rax
  00222	33 d2		 xor	 edx, edx
  00224	e8 00 00 00 00	 call	 memset

; 136  : 
; 137  : 	// CRC32
; 138  : 	unaligned_write32le(out + out_size, lzma_crc32(out, out_size, 0));

  00229	45 33 c0	 xor	 r8d, r8d
  0022c	48 8b 54 24 30	 mov	 rdx, QWORD PTR out_size$32889[rsp]
  00231	48 8b 4c 24 78	 mov	 rcx, QWORD PTR out$[rsp]
  00236	e8 00 00 00 00	 call	 lzma_crc32
  0023b	89 44 24 54	 mov	 DWORD PTR $T82554[rsp], eax
  0023f	48 8b 44 24 30	 mov	 rax, QWORD PTR out_size$32889[rsp]
  00244	48 8b 4c 24 78	 mov	 rcx, QWORD PTR out$[rsp]
  00249	48 03 c8	 add	 rcx, rax
  0024c	8b 44 24 54	 mov	 eax, DWORD PTR $T82554[rsp]
  00250	89 01		 mov	 DWORD PTR [rcx], eax

; 139  :   }}}
; 140  : 
; 141  : 	return LZMA_OK;

  00252	33 c0		 xor	 eax, eax
$LN23@lzma_block@4:

; 142  : }

  00254	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00258	c3		 ret	 0
lzma_block_header_encode ENDP
_TEXT	ENDS
PUBLIC	lzma_block_header_size
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_header_size DD imagerel $LN19
	DD	imagerel $LN19+365
	DD	imagerel $unwind$lzma_block_header_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_header_size DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_header_size
_TEXT	SEGMENT
size$32860 = 32
add$32862 = 36
add$32866 = 40
i$32871 = 48
add$32876 = 56
ret_$32880 = 60
block$ = 80
lzma_block_header_size PROC				; COMDAT

; 19   : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 20   : 	if (block->version > 1)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  0000e	83 38 01	 cmp	 DWORD PTR [rax], 1
  00011	76 0a		 jbe	 SHORT $LN16@lzma_block@5

; 21   : 		return LZMA_OPTIONS_ERROR;

  00013	b8 08 00 00 00	 mov	 eax, 8
  00018	e9 4b 01 00 00	 jmp	 $LN17@lzma_block@5
$LN16@lzma_block@5:

; 22   : 
; 23   : 	// Block Header Size + Block Flags + CRC32.
; 24   :   {
; 25   :   uint32_t size = 1 + 1 + 4;

  0001d	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR size$32860[rsp], 6

; 26   : 
; 27   : 	// Compressed Size
; 28   : 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  0002a	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  0002f	74 3d		 je	 SHORT $LN15@lzma_block@5

; 29   : 		const uint32_t add = lzma_vli_size(block->compressed_size);

  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR block$[rsp]
  00036	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003a	e8 00 00 00 00	 call	 lzma_vli_size
  0003f	89 44 24 24	 mov	 DWORD PTR add$32862[rsp], eax

; 30   : 		if (add == 0 || block->compressed_size == 0)

  00043	83 7c 24 24 00	 cmp	 DWORD PTR add$32862[rsp], 0
  00048	74 0c		 je	 SHORT $LN13@lzma_block@5
  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  0004f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00054	75 0a		 jne	 SHORT $LN14@lzma_block@5
$LN13@lzma_block@5:

; 31   : 			return LZMA_PROG_ERROR;

  00056	b8 0b 00 00 00	 mov	 eax, 11
  0005b	e9 08 01 00 00	 jmp	 $LN17@lzma_block@5
$LN14@lzma_block@5:

; 32   : 
; 33   : 		size += add;

  00060	8b 4c 24 24	 mov	 ecx, DWORD PTR add$32862[rsp]
  00064	8b 44 24 20	 mov	 eax, DWORD PTR size$32860[rsp]
  00068	03 c1		 add	 eax, ecx
  0006a	89 44 24 20	 mov	 DWORD PTR size$32860[rsp], eax
$LN15@lzma_block@5:

; 34   : 	}
; 35   : 
; 36   : 	// Uncompressed Size
; 37   : 	if (block->uncompressed_size != LZMA_VLI_UNKNOWN) {

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  00073	48 83 78 18 ff	 cmp	 QWORD PTR [rax+24], -1
  00078	74 31		 je	 SHORT $LN12@lzma_block@5

; 38   : 		const uint32_t add = lzma_vli_size(block->uncompressed_size);

  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR block$[rsp]
  0007f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00083	e8 00 00 00 00	 call	 lzma_vli_size
  00088	89 44 24 28	 mov	 DWORD PTR add$32866[rsp], eax

; 39   : 		if (add == 0)

  0008c	83 7c 24 28 00	 cmp	 DWORD PTR add$32866[rsp], 0
  00091	75 0a		 jne	 SHORT $LN11@lzma_block@5

; 40   : 			return LZMA_PROG_ERROR;

  00093	b8 0b 00 00 00	 mov	 eax, 11
  00098	e9 cb 00 00 00	 jmp	 $LN17@lzma_block@5
$LN11@lzma_block@5:

; 41   : 
; 42   : 		size += add;

  0009d	8b 4c 24 28	 mov	 ecx, DWORD PTR add$32866[rsp]
  000a1	8b 44 24 20	 mov	 eax, DWORD PTR size$32860[rsp]
  000a5	03 c1		 add	 eax, ecx
  000a7	89 44 24 20	 mov	 DWORD PTR size$32860[rsp], eax
$LN12@lzma_block@5:

; 43   : 	}
; 44   : 
; 45   : 	// List of Filter Flags
; 46   : 	if (block->filters == NULL || block->filters[0].id == LZMA_VLI_UNKNOWN)

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  000b0	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000b5	74 0f		 je	 SHORT $LN9@lzma_block@5
  000b7	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  000bc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c0	48 83 38 ff	 cmp	 QWORD PTR [rax], -1
  000c4	75 0a		 jne	 SHORT $LN10@lzma_block@5
$LN9@lzma_block@5:

; 47   : 		return LZMA_PROG_ERROR;

  000c6	b8 0b 00 00 00	 mov	 eax, 11
  000cb	e9 98 00 00 00	 jmp	 $LN17@lzma_block@5
$LN10@lzma_block@5:

; 48   : 
; 49   :   { size_t i;
; 50   : 
; 51   : 	for (i = 0; block->filters[i].id != LZMA_VLI_UNKNOWN; ++i) {

  000d0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$32871[rsp], 0
  000d9	eb 0e		 jmp	 SHORT $LN8@lzma_block@5
$LN7@lzma_block@5:
  000db	48 8b 44 24 30	 mov	 rax, QWORD PTR i$32871[rsp]
  000e0	48 83 c0 01	 add	 rax, 1
  000e4	48 89 44 24 30	 mov	 QWORD PTR i$32871[rsp], rax
$LN8@lzma_block@5:
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$32871[rsp]
  000ee	48 6b c9 10	 imul	 rcx, 16
  000f2	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  000f7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000fb	48 83 3c 01 ff	 cmp	 QWORD PTR [rcx+rax], -1
  00100	74 52		 je	 SHORT $LN6@lzma_block@5

; 52   : 		// Don't allow too many filters.
; 53   : 		if (i == LZMA_FILTERS_MAX)

  00102	48 83 7c 24 30
	04		 cmp	 QWORD PTR i$32871[rsp], 4
  00108	75 07		 jne	 SHORT $LN5@lzma_block@5

; 54   : 			return LZMA_PROG_ERROR;

  0010a	b8 0b 00 00 00	 mov	 eax, 11
  0010f	eb 57		 jmp	 SHORT $LN17@lzma_block@5
$LN5@lzma_block@5:
$LN4@lzma_block@5:

; 55   : 
; 56   : 	  { uint32_t add;
; 57   : 		return_if_error(lzma_filter_flags_size(&add,
; 58   : 				block->filters + i));

  00111	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$32871[rsp]
  00116	48 6b d2 10	 imul	 rdx, 16
  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  0011f	48 03 50 20	 add	 rdx, QWORD PTR [rax+32]
  00123	48 8d 4c 24 38	 lea	 rcx, QWORD PTR add$32876[rsp]
  00128	e8 00 00 00 00	 call	 lzma_filter_flags_size
  0012d	89 44 24 3c	 mov	 DWORD PTR ret_$32880[rsp], eax
  00131	83 7c 24 3c 00	 cmp	 DWORD PTR ret_$32880[rsp], 0
  00136	74 06		 je	 SHORT $LN1@lzma_block@5
  00138	8b 44 24 3c	 mov	 eax, DWORD PTR ret_$32880[rsp]
  0013c	eb 2a		 jmp	 SHORT $LN17@lzma_block@5
$LN1@lzma_block@5:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	75 cd		 jne	 SHORT $LN4@lzma_block@5

; 59   : 
; 60   : 		size += add;

  00144	8b 4c 24 38	 mov	 ecx, DWORD PTR add$32876[rsp]
  00148	8b 44 24 20	 mov	 eax, DWORD PTR size$32860[rsp]
  0014c	03 c1		 add	 eax, ecx
  0014e	89 44 24 20	 mov	 DWORD PTR size$32860[rsp], eax

; 61   : 	  }
; 62   : 	}

  00152	eb 87		 jmp	 SHORT $LN7@lzma_block@5
$LN6@lzma_block@5:

; 63   :   }
; 64   : 
; 65   : 	// Pad to a multiple of four bytes.
; 66   : 	block->header_size = (size + 3) & ~UINT32_C(3);

  00154	8b 4c 24 20	 mov	 ecx, DWORD PTR size$32860[rsp]
  00158	83 c1 03	 add	 ecx, 3
  0015b	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0015e	48 8b 44 24 50	 mov	 rax, QWORD PTR block$[rsp]
  00163	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 67   :   }
; 68   : 
; 69   : 	// NOTE: We don't verify that the encoded size of the Block stays
; 70   : 	// within limits. This is because it is possible that we are called
; 71   : 	// with exaggerated Compressed Size (e.g. LZMA_VLI_MAX) to reserve
; 72   : 	// space for Block Header, and later called again with lower,
; 73   : 	// real values.
; 74   : 
; 75   : 	return LZMA_OK;

  00166	33 c0		 xor	 eax, eax
$LN17@lzma_block@5:

; 76   : }

  00168	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016c	c3		 ret	 0
lzma_block_header_size ENDP
END
