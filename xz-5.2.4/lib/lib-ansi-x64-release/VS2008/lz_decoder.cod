; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	LZMA_LZ_DECODER_INIT
LZMA_LZ_DECODER_INIT DB 028H DUP (?)
PUBLIC	lzma_lz_decoder_memusage
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\lz\lz_decoder.c
;	COMDAT lzma_lz_decoder_memusage
_TEXT	SEGMENT
dictionary_size$ = 8
lzma_lz_decoder_memusage PROC				; COMDAT

; 316  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 317  : 	return sizeof(lzma_coder) + (uint64_t)(dictionary_size);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dictionary_size$[rsp]
  0000a	48 05 b8 10 00
	00		 add	 rax, 4280		; 000010b8H

; 318  : }

  00010	c3		 ret	 0
lzma_lz_decoder_memusage ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT lz_decoder_reset
_TEXT	SEGMENT
coder$ = 8
lz_decoder_reset PROC					; COMDAT

; 67   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 68   : 	coder->dict.pos = 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  0000a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 69   : 	coder->dict.full = 0;

  00012	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  00017	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 70   : 	coder->dict.buf[coder->dict.size - 1] = '\0';

  0001f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR coder$[rsp]
  00024	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00028	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 71   : 	coder->dict.need_reset = false;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR coder$[rsp]
  0003a	c6 40 28 00	 mov	 BYTE PTR [rax+40], 0

; 72   : 	return;
; 73   : }

  0003e	c3		 ret	 0
lz_decoder_reset ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_buffer DD imagerel decode_buffer
	DD	imagerel decode_buffer+471
	DD	imagerel $unwind$decode_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_buffer DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT decode_buffer
_TEXT	SEGMENT
dict_start$32983 = 48
ret$32984 = 56
copy_size$32985 = 64
tv81 = 72
coder$ = 96
in$ = 104
in_pos$ = 112
in_size$ = 120
out$ = 128
out_pos$ = 136
out_size$ = 144
decode_buffer PROC					; COMDAT

; 81   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN9@decode_buf@2:

; 82   : 	while (true) {

  00018	33 c0		 xor	 eax, eax
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 84 af 01 00
	00		 je	 $LN8@decode_buf@2

; 83   : 		// Wrap the dictionary if needed.
; 84   : 		if (coder->dict.pos == coder->dict.size)

  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00035	75 0d		 jne	 SHORT $LN7@decode_buf@2

; 85   : 			coder->dict.pos = 0;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0003c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN7@decode_buf@2:

; 86   : 
; 87   : 		// Store the current dictionary position. It is needed to know
; 88   : 		// where to start copying to the out[] buffer.
; 89   : 	  {
; 90   : 		const size_t dict_start = coder->dict.pos;

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 89 44 24 30	 mov	 QWORD PTR dict_start$32983[rsp], rax

; 91   : 
; 92   : 		// Calculate how much we allow coder->lz.code() to decode.
; 93   : 		// It must not decode past the end of the dictionary
; 94   : 		// buffer, and we don't want it to decode more than is
; 95   : 		// actually needed to fill the out[] buffer.
; 96   : 		coder->dict.limit = coder->dict.pos
; 97   : 				+ my_min(out_size - *out_pos,
; 98   : 					coder->dict.size - coder->dict.pos);

  00052	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR out_size$[rsp]
  00065	48 2b d0	 sub	 rdx, rax
  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007a	48 2b c1	 sub	 rax, rcx
  0007d	48 3b d0	 cmp	 rdx, rax
  00080	73 1d		 jae	 SHORT $LN12@decode_buf@2
  00082	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0008a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00095	48 2b c1	 sub	 rax, rcx
  00098	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  0009d	eb 1a		 jmp	 SHORT $LN13@decode_buf@2
$LN12@decode_buf@2:
  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  000a9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ad	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000b1	48 2b c1	 sub	 rax, rcx
  000b4	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
$LN13@decode_buf@2:
  000b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  000be	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000c2	48 03 4c 24 48	 add	 rcx, QWORD PTR tv81[rsp]
  000c7	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000cc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 99   : 
; 100  : 		// Call the coder->lz.code() to do the actual decoding.
; 101  : 	  {
; 102  : 		const lzma_ret ret = coder->lz.code(
; 103  : 				coder->lz.coder, &coder->dict,
; 104  : 				in, in_pos, in_size);

  000d0	48 8b 44 24 78	 mov	 rax, QWORD PTR in_size$[rsp]
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	4c 8b 4c 24 70	 mov	 r9, QWORD PTR in_pos$[rsp]
  000df	4c 8b 44 24 68	 mov	 r8, QWORD PTR in$[rsp]
  000e4	48 8b 54 24 60	 mov	 rdx, QWORD PTR coder$[rsp]
  000e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  000ee	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  000f7	ff 50 38	 call	 QWORD PTR [rax+56]
  000fa	89 44 24 38	 mov	 DWORD PTR ret$32984[rsp], eax

; 105  : 
; 106  : 		// Copy the decoded data from the dictionary to the out[]
; 107  : 		// buffer.
; 108  : 		const size_t copy_size = coder->dict.pos - dict_start;

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00103	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dict_start$32983[rsp]
  00108	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0010c	48 2b c1	 sub	 rax, rcx
  0010f	48 89 44 24 40	 mov	 QWORD PTR copy_size$32985[rsp], rax

; 109  : 		assert(copy_size <= out_size - *out_pos);
; 110  : 		memcpy(out + *out_pos, coder->dict.buf + dict_start,
; 111  : 				copy_size);

  00114	48 8b 54 24 60	 mov	 rdx, QWORD PTR coder$[rsp]
  00119	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0011c	48 03 54 24 30	 add	 rdx, QWORD PTR dict_start$32983[rsp]
  00121	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00129	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00134	48 03 c8	 add	 rcx, rax
  00137	4c 8b 44 24 40	 mov	 r8, QWORD PTR copy_size$32985[rsp]
  0013c	e8 00 00 00 00	 call	 memcpy

; 112  : 		*out_pos += copy_size;

  00141	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00149	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014c	48 03 4c 24 40	 add	 rcx, QWORD PTR copy_size$32985[rsp]
  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00159	48 89 08	 mov	 QWORD PTR [rax], rcx

; 113  : 
; 114  : 		// Reset the dictionary if so requested by coder->lz.code().
; 115  : 		if (coder->dict.need_reset) {

  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  00161	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  00165	85 c0		 test	 eax, eax
  00167	74 2e		 je	 SHORT $LN6@decode_buf@2

; 116  : 			lz_decoder_reset(coder);

  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  0016e	e8 00 00 00 00	 call	 lz_decoder_reset

; 117  : 
; 118  : 			// Since we reset dictionary, we don't check if
; 119  : 			// dictionary became full.
; 120  : 			if (ret != LZMA_OK || *out_pos == out_size)

  00173	83 7c 24 38 00	 cmp	 DWORD PTR ret$32984[rsp], 0
  00178	75 15		 jne	 SHORT $LN4@decode_buf@2
  0017a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00182	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0018a	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0018d	75 06		 jne	 SHORT $LN5@decode_buf@2
$LN4@decode_buf@2:

; 121  : 				return ret;

  0018f	8b 44 24 38	 mov	 eax, DWORD PTR ret$32984[rsp]
  00193	eb 3d		 jmp	 SHORT $LN10@decode_buf@2
$LN5@decode_buf@2:

; 122  : 		} else {

  00195	eb 36		 jmp	 SHORT $LN3@decode_buf@2
$LN6@decode_buf@2:

; 123  : 			// Return if everything got decoded or an error
; 124  : 			// occurred, or if there's no more data to decode.
; 125  : 			//
; 126  : 			// Note that detecting if there's something to decode
; 127  : 			// is done by looking if dictionary become full
; 128  : 			// instead of looking if *in_pos == in_size. This
; 129  : 			// is because it is possible that all the input was
; 130  : 			// consumed already but some data is pending to be
; 131  : 			// written to the dictionary.
; 132  : 			if (ret != LZMA_OK || *out_pos == out_size
; 133  : 					|| coder->dict.pos < coder->dict.size)

  00197	83 7c 24 38 00	 cmp	 DWORD PTR ret$32984[rsp], 0
  0019c	75 29		 jne	 SHORT $LN1@decode_buf@2
  0019e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  001a6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  001ae	48 39 01	 cmp	 QWORD PTR [rcx], rax
  001b1	74 14		 je	 SHORT $LN1@decode_buf@2
  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR coder$[rsp]
  001b8	48 8b 44 24 60	 mov	 rax, QWORD PTR coder$[rsp]
  001bd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001c1	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  001c5	73 06		 jae	 SHORT $LN2@decode_buf@2
$LN1@decode_buf@2:

; 134  : 				return ret;

  001c7	8b 44 24 38	 mov	 eax, DWORD PTR ret$32984[rsp]
  001cb	eb 05		 jmp	 SHORT $LN10@decode_buf@2
$LN2@decode_buf@2:
$LN3@decode_buf@2:

; 135  : 		}
; 136  : 	  }}
; 137  : 	}

  001cd	e9 46 fe ff ff	 jmp	 $LN9@decode_buf@2
$LN8@decode_buf@2:
$LN10@decode_buf@2:

; 138  : }

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
decode_buffer ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_decoder_end DD imagerel lz_decoder_end
	DD	imagerel lz_decoder_end+136
	DD	imagerel $unwind$lz_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
lz_decoder_end PROC					; COMDAT

; 208  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 209  : 	lzma_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 210  : 
; 211  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00021	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00026	e8 00 00 00 00	 call	 lzma_next_end

; 212  : 	lzma_free(coder->dict.buf, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	e8 00 00 00 00	 call	 lzma_free

; 213  : 
; 214  : 	if (coder->lz.end != NULL)

  0003d	4c 8b 5c 24 20	 mov	 r11, QWORD PTR coder$[rsp]
  00042	49 83 7b 50 00	 cmp	 QWORD PTR [r11+80], 0
  00047	74 18		 je	 SHORT $LN2@lz_decoder

; 215  : 		coder->lz.end(coder->lz.coder, allocator);

  00049	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00053	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0005c	ff 50 50	 call	 QWORD PTR [rax+80]

; 216  : 	else

  0005f	eb 13		 jmp	 SHORT $LN1@lz_decoder
$LN2@lz_decoder:

; 217  : 		lzma_free(coder->lz.coder, allocator);

  00061	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0006b	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0006f	e8 00 00 00 00	 call	 lzma_free
$LN1@lz_decoder:

; 218  : 
; 219  : 	lzma_free(coder, allocator);

  00074	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0007e	e8 00 00 00 00	 call	 lzma_free

; 220  : 	return;
; 221  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
lz_decoder_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lz_decode DD imagerel lz_decode
	DD	imagerel lz_decode+647
	DD	imagerel $unwind$lz_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lz_decode DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lz_decode
_TEXT	SEGMENT
coder$ = 80
ret$33020 = 88
ret$33028 = 92
coder_ptr$ = 112
allocator$ = 120
in$ = 128
in_pos$ = 136
in_size$ = 144
out$ = 152
out_pos$ = 160
out_size$ = 168
action$ = 176
lz_decode PROC						; COMDAT

; 148  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 149  : 	lzma_coder *coder = coder_ptr;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 150  : 
; 151  : 	if (coder->next.code == NULL)

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00027	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0002c	75 4e		 jne	 SHORT $LN16@lz_decode

; 152  : 		return decode_buffer(coder, in, in_pos, in_size,
; 153  : 				out, out_pos, out_size);

  0002e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00036	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00043	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00048	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR in_size$[rsp]
  0005d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR in_pos$[rsp]
  00065	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR in$[rsp]
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00072	e8 00 00 00 00	 call	 decode_buffer
  00077	e9 06 02 00 00	 jmp	 $LN17@lz_decode
$LN16@lz_decode:
$LN15@lz_decode:

; 154  : 
; 155  : 	// We aren't the last coder in the chain, we need to decode
; 156  : 	// our input to a temporary buffer.
; 157  : 	while (*out_pos < out_size) {

  0007c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00084	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0008c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0008f	0f 83 eb 01 00
	00		 jae	 $LN14@lz_decode

; 158  : 		// Fill the temporary buffer if it is empty.
; 159  : 		if (!coder->next_finished
; 160  : 				&& coder->temp.pos == coder->temp.size) {

  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0009a	0f b6 80 a0 00
	00 00		 movzx	 eax, BYTE PTR [rax+160]
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 df 00 00
	00		 jne	 $LN13@lz_decode
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000b3	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  000ba	48 39 81 a8 00
	00 00		 cmp	 QWORD PTR [rcx+168], rax
  000c1	0f 85 c1 00 00
	00		 jne	 $LN13@lz_decode

; 161  : 			coder->temp.pos = 0;

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000cc	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 162  : 			coder->temp.size = 0;

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000dc	48 c7 80 b0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+176], 0

; 163  : 
; 164  : 		  {
; 165  : 			const lzma_ret ret = coder->next.code(
; 166  : 					coder->next.coder,
; 167  : 					allocator, in, in_pos, in_size,
; 168  : 					coder->temp.buffer, &coder->temp.size,
; 169  : 					LZMA_BUFFER_SIZE, action);

  000e7	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  000ec	48 81 c2 b0 00
	00 00		 add	 rdx, 176		; 000000b0H
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000f8	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  000ff	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00106	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0010a	48 c7 44 24 38
	00 10 00 00	 mov	 QWORD PTR [rsp+56], 4096 ; 00001000H
  00113	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  00118	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00125	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00132	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0013a	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  0013f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00144	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0014d	ff 50 70	 call	 QWORD PTR [rax+112]
  00150	89 44 24 58	 mov	 DWORD PTR ret$33020[rsp], eax

; 170  : 
; 171  : 			if (ret == LZMA_STREAM_END)

  00154	83 7c 24 58 01	 cmp	 DWORD PTR ret$33020[rsp], 1
  00159	75 0e		 jne	 SHORT $LN12@lz_decode

; 172  : 				coder->next_finished = true;

  0015b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00160	c6 80 a0 00 00
	00 01		 mov	 BYTE PTR [rax+160], 1
  00167	eb 1f		 jmp	 SHORT $LN11@lz_decode
$LN12@lz_decode:

; 173  : 			else if (ret != LZMA_OK || coder->temp.size == 0)

  00169	83 7c 24 58 00	 cmp	 DWORD PTR ret$33020[rsp], 0
  0016e	75 0f		 jne	 SHORT $LN9@lz_decode
  00170	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00175	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0017d	75 09		 jne	 SHORT $LN10@lz_decode
$LN9@lz_decode:

; 174  : 				return ret;

  0017f	8b 44 24 58	 mov	 eax, DWORD PTR ret$33020[rsp]
  00183	e9 fa 00 00 00	 jmp	 $LN17@lz_decode
$LN10@lz_decode:
$LN11@lz_decode:
$LN13@lz_decode:

; 175  : 		  }
; 176  : 		}
; 177  : 
; 178  : 		if (coder->this_finished) {

  00188	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0018d	0f b6 80 a1 00
	00 00		 movzx	 eax, BYTE PTR [rax+161]
  00194	85 c0		 test	 eax, eax
  00196	74 3a		 je	 SHORT $LN8@lz_decode

; 179  : 			if (coder->temp.size != 0)

  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0019d	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  001a5	74 0a		 je	 SHORT $LN7@lz_decode

; 180  : 				return LZMA_DATA_ERROR;

  001a7	b8 09 00 00 00	 mov	 eax, 9
  001ac	e9 d1 00 00 00	 jmp	 $LN17@lz_decode
$LN7@lz_decode:

; 181  : 
; 182  : 			if (coder->next_finished)

  001b1	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001b6	0f b6 80 a0 00
	00 00		 movzx	 eax, BYTE PTR [rax+160]
  001bd	85 c0		 test	 eax, eax
  001bf	74 0a		 je	 SHORT $LN6@lz_decode

; 183  : 				return LZMA_STREAM_END;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	e9 b7 00 00 00	 jmp	 $LN17@lz_decode
$LN6@lz_decode:

; 184  : 
; 185  : 			return LZMA_OK;

  001cb	33 c0		 xor	 eax, eax
  001cd	e9 b0 00 00 00	 jmp	 $LN17@lz_decode
$LN8@lz_decode:

; 186  : 		}
; 187  : 
; 188  : 	  {
; 189  : 		const lzma_ret ret = decode_buffer(coder, coder->temp.buffer,
; 190  : 				&coder->temp.pos, coder->temp.size,
; 191  : 				out, out_pos, out_size);

  001d2	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  001d7	49 81 c0 a8 00
	00 00		 add	 r8, 168			; 000000a8H
  001de	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  001e3	48 81 c2 b8 00
	00 00		 add	 rdx, 184		; 000000b8H
  001ea	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  001f2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  001ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00204	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0020c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00211	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  00216	4d 8b 89 b0 00
	00 00		 mov	 r9, QWORD PTR [r9+176]
  0021d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00222	e8 00 00 00 00	 call	 decode_buffer
  00227	89 44 24 5c	 mov	 DWORD PTR ret$33028[rsp], eax

; 192  : 
; 193  : 		if (ret == LZMA_STREAM_END)

  0022b	83 7c 24 5c 01	 cmp	 DWORD PTR ret$33028[rsp], 1
  00230	75 0e		 jne	 SHORT $LN5@lz_decode

; 194  : 			coder->this_finished = true;

  00232	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00237	c6 80 a1 00 00
	00 01		 mov	 BYTE PTR [rax+161], 1
  0023e	eb 3b		 jmp	 SHORT $LN4@lz_decode
$LN5@lz_decode:

; 195  : 		else if (ret != LZMA_OK)

  00240	83 7c 24 5c 00	 cmp	 DWORD PTR ret$33028[rsp], 0
  00245	74 08		 je	 SHORT $LN3@lz_decode

; 196  : 			return ret;

  00247	8b 44 24 5c	 mov	 eax, DWORD PTR ret$33028[rsp]
  0024b	eb 35		 jmp	 SHORT $LN17@lz_decode
  0024d	eb 2c		 jmp	 SHORT $LN2@lz_decode
$LN3@lz_decode:

; 197  : 		else if (coder->next_finished && *out_pos < out_size)

  0024f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00254	0f b6 80 a0 00
	00 00		 movzx	 eax, BYTE PTR [rax+160]
  0025b	85 c0		 test	 eax, eax
  0025d	74 1c		 je	 SHORT $LN1@lz_decode
  0025f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00267	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0026f	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00272	73 07		 jae	 SHORT $LN1@lz_decode

; 198  : 			return LZMA_DATA_ERROR;

  00274	b8 09 00 00 00	 mov	 eax, 9
  00279	eb 07		 jmp	 SHORT $LN17@lz_decode
$LN1@lz_decode:
$LN2@lz_decode:
$LN4@lz_decode:

; 199  : 	  }
; 200  : 	}

  0027b	e9 fc fd ff ff	 jmp	 $LN15@lz_decode
$LN14@lz_decode:

; 201  : 
; 202  : 	return LZMA_OK;

  00280	33 c0		 xor	 eax, eax
$LN17@lz_decode:

; 203  : }

  00282	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00286	c3		 ret	 0
lz_decode ENDP
PUBLIC	lzma_lz_decoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_lz_decoder_init DD imagerel $LN16
	DD	imagerel $LN16+698
	DD	imagerel $unwind$lzma_lz_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_lz_decoder_init DD 031a01H
	DD	07016c21aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_lz_decoder_init
_TEXT	SEGMENT
coder$ = 32
lz_options$33068 = 40
ret_$33072 = 64
offset$33083 = 72
copy_size$33082 = 80
tv132 = 88
next$ = 128
allocator$ = 136
filters$ = 144
lz_init$ = 152
lzma_lz_decoder_init PROC				; COMDAT

; 230  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 231  : 	// Allocate the base structure if it isn't already allocated.
; 232  : 	lzma_coder *coder = next->coder;

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 233  : 	if (coder == NULL) {

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00030	0f 85 a6 00 00
	00		 jne	 $LN11@lzma_lz_de

; 234  : 		coder = lzma_alloc(sizeof(lzma_coder), allocator);

  00036	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0003e	b9 b8 10 00 00	 mov	 ecx, 4280		; 000010b8H
  00043	e8 00 00 00 00	 call	 lzma_alloc
  00048	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 235  : 		if (coder == NULL)

  0004d	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00053	75 0a		 jne	 SHORT $LN10@lzma_lz_de

; 236  : 			return LZMA_MEM_ERROR;

  00055	b8 05 00 00 00	 mov	 eax, 5
  0005a	e9 54 02 00 00	 jmp	 $LN12@lzma_lz_de
$LN10@lzma_lz_de:

; 237  : 
; 238  : 		next->coder = coder;

  0005f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0006c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 239  : 		next->code = &lz_decode;

  0006f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lz_decode
  0007e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 240  : 		next->end = &lz_decoder_end;

  00082	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lz_decoder_end
  00091	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 241  : 
; 242  : 		coder->dict.buf = NULL;

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0009a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 243  : 		coder->dict.size = 0;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000a6	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 244  : 		coder->lz = LZMA_LZ_DECODER_INIT;

  000ae	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  000b3	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_LZ_DECODER_INIT
  000ba	48 83 c7 30	 add	 rdi, 48			; 00000030H
  000be	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000c3	f3 a4		 rep movsb

; 245  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000c5	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  000ca	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000d1	48 83 c7 58	 add	 rdi, 88			; 00000058H
  000d5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000da	f3 a4		 rep movsb
$LN11@lzma_lz_de:
$LN9@lzma_lz_de:

; 246  : 	}
; 247  : 
; 248  : 	// Allocate and initialize the LZ-based decoder. It will also give
; 249  : 	// us the dictionary size.
; 250  :   {
; 251  : 	lzma_lz_options lz_options;
; 252  : 	return_if_error(lz_init(&coder->lz, allocator,
; 253  : 			filters[0].options, &lz_options));

  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000e1	48 83 c1 30	 add	 rcx, 48			; 00000030H
  000e5	4c 8d 4c 24 28	 lea	 r9, QWORD PTR lz_options$33068[rsp]
  000ea	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  000f2	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  000f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  000fe	ff 94 24 98 00
	00 00		 call	 QWORD PTR lz_init$[rsp]
  00105	89 44 24 40	 mov	 DWORD PTR ret_$33072[rsp], eax
  00109	83 7c 24 40 00	 cmp	 DWORD PTR ret_$33072[rsp], 0
  0010e	74 09		 je	 SHORT $LN6@lzma_lz_de
  00110	8b 44 24 40	 mov	 eax, DWORD PTR ret_$33072[rsp]
  00114	e9 9a 01 00 00	 jmp	 $LN12@lzma_lz_de
$LN6@lzma_lz_de:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 bd		 jne	 SHORT $LN9@lzma_lz_de

; 254  : 
; 255  : 	// If the dictionary size is very small, increase it to 4096 bytes.
; 256  : 	// This is to prevent constant wrapping of the dictionary, which
; 257  : 	// would slow things down. The downside is that since we don't check
; 258  : 	// separately for the real dictionary size, we may happily accept
; 259  : 	// corrupt files.
; 260  : 	if (lz_options.dict_size < 4096)

  0011f	48 81 7c 24 28
	00 10 00 00	 cmp	 QWORD PTR lz_options$33068[rsp], 4096 ; 00001000H
  00128	73 09		 jae	 SHORT $LN5@lzma_lz_de

; 261  : 		lz_options.dict_size = 4096;

  0012a	48 c7 44 24 28
	00 10 00 00	 mov	 QWORD PTR lz_options$33068[rsp], 4096 ; 00001000H
$LN5@lzma_lz_de:

; 262  : 
; 263  : 	// Make dictionary size a multipe of 16. Some LZ-based decoders like
; 264  : 	// LZMA use the lowest bits lzma_dict.pos to know the alignment of the
; 265  : 	// data. Aligned buffer is also good when memcpying from the
; 266  : 	// dictionary to the output buffer, since applications are
; 267  : 	// recommended to give aligned buffers to liblzma.
; 268  : 	//
; 269  : 	// Avoid integer overflow.
; 270  : 	if (lz_options.dict_size > SIZE_MAX - 15)

  00133	48 83 7c 24 28
	f0		 cmp	 QWORD PTR lz_options$33068[rsp], -16
  00139	76 0a		 jbe	 SHORT $LN4@lzma_lz_de

; 271  : 		return LZMA_MEM_ERROR;

  0013b	b8 05 00 00 00	 mov	 eax, 5
  00140	e9 6e 01 00 00	 jmp	 $LN12@lzma_lz_de
$LN4@lzma_lz_de:

; 272  : 
; 273  : 	lz_options.dict_size = (lz_options.dict_size + 15) & ~((size_t)(15));

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR lz_options$33068[rsp]
  0014a	48 83 c0 0f	 add	 rax, 15
  0014e	48 83 e0 f0	 and	 rax, -16
  00152	48 89 44 24 28	 mov	 QWORD PTR lz_options$33068[rsp], rax

; 274  : 
; 275  : 	// Allocate and initialize the dictionary.
; 276  : 	if (coder->dict.size != lz_options.dict_size) {

  00157	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0015c	48 8b 44 24 28	 mov	 rax, QWORD PTR lz_options$33068[rsp]
  00161	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00165	74 55		 je	 SHORT $LN3@lzma_lz_de

; 277  : 		lzma_free(coder->dict.buf, allocator);

  00167	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0016f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00174	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00177	e8 00 00 00 00	 call	 lzma_free

; 278  : 		coder->dict.buf
; 279  : 				= lzma_alloc(lz_options.dict_size, allocator);

  0017c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00184	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lz_options$33068[rsp]
  00189	e8 00 00 00 00	 call	 lzma_alloc
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00196	48 89 10	 mov	 QWORD PTR [rax], rdx

; 280  : 		if (coder->dict.buf == NULL)

  00199	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0019e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001a2	75 0a		 jne	 SHORT $LN2@lzma_lz_de

; 281  : 			return LZMA_MEM_ERROR;

  001a4	b8 05 00 00 00	 mov	 eax, 5
  001a9	e9 05 01 00 00	 jmp	 $LN12@lzma_lz_de
$LN2@lzma_lz_de:

; 282  : 
; 283  : 		coder->dict.size = lz_options.dict_size;

  001ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  001b3	48 8b 44 24 28	 mov	 rax, QWORD PTR lz_options$33068[rsp]
  001b8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN3@lzma_lz_de:

; 284  : 	}
; 285  : 
; 286  : 	lz_decoder_reset(next->coder);

  001bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  001c4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001c7	e8 00 00 00 00	 call	 lz_decoder_reset

; 287  : 
; 288  : 	// Use the preset dictionary if it was given to us.
; 289  : 	if (lz_options.preset_dict != NULL
; 290  : 			&& lz_options.preset_dict_size > 0) {

  001cc	48 83 7c 24 30
	00		 cmp	 QWORD PTR lz_options$33068[rsp+8], 0
  001d2	0f 84 81 00 00
	00		 je	 $LN1@lzma_lz_de
  001d8	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz_options$33068[rsp+16], 0
  001de	76 79		 jbe	 SHORT $LN1@lzma_lz_de

; 291  : 		// If the preset dictionary is bigger than the actual
; 292  : 		// dictionary, copy only the tail.
; 293  : 		const size_t copy_size = my_min(lz_options.preset_dict_size,
; 294  : 				lz_options.dict_size);

  001e0	48 8b 44 24 28	 mov	 rax, QWORD PTR lz_options$33068[rsp]
  001e5	48 39 44 24 38	 cmp	 QWORD PTR lz_options$33068[rsp+16], rax
  001ea	73 0c		 jae	 SHORT $LN14@lzma_lz_de
  001ec	48 8b 44 24 38	 mov	 rax, QWORD PTR lz_options$33068[rsp+16]
  001f1	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
  001f6	eb 0a		 jmp	 SHORT $LN15@lzma_lz_de
$LN14@lzma_lz_de:
  001f8	48 8b 44 24 28	 mov	 rax, QWORD PTR lz_options$33068[rsp]
  001fd	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
$LN15@lzma_lz_de:
  00202	48 8b 44 24 58	 mov	 rax, QWORD PTR tv132[rsp]
  00207	48 89 44 24 50	 mov	 QWORD PTR copy_size$33082[rsp], rax

; 295  : 		const size_t offset = lz_options.preset_dict_size - copy_size;

  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR copy_size$33082[rsp]
  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR lz_options$33068[rsp+16]
  00216	48 2b c1	 sub	 rax, rcx
  00219	48 89 44 24 48	 mov	 QWORD PTR offset$33083[rsp], rax

; 296  : 		memcpy(coder->dict.buf, lz_options.preset_dict + offset,
; 297  : 				copy_size);

  0021e	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$33083[rsp]
  00223	48 8b 54 24 30	 mov	 rdx, QWORD PTR lz_options$33068[rsp+8]
  00228	48 03 d0	 add	 rdx, rax
  0022b	4c 8b 44 24 50	 mov	 r8, QWORD PTR copy_size$33082[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00235	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00238	e8 00 00 00 00	 call	 memcpy

; 298  : 		coder->dict.pos = copy_size;

  0023d	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$[rsp]
  00242	48 8b 44 24 50	 mov	 rax, QWORD PTR copy_size$33082[rsp]
  00247	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 299  : 		coder->dict.full = copy_size;

  0024b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00250	48 8b 44 24 50	 mov	 rax, QWORD PTR copy_size$33082[rsp]
  00255	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN1@lzma_lz_de:

; 300  : 	}
; 301  : 
; 302  : 	// Miscellaneous initializations
; 303  : 	coder->next_finished = false;

  00259	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0025e	c6 80 a0 00 00
	00 00		 mov	 BYTE PTR [rax+160], 0

; 304  : 	coder->this_finished = false;

  00265	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0026a	c6 80 a1 00 00
	00 00		 mov	 BYTE PTR [rax+161], 0

; 305  : 	coder->temp.pos = 0;

  00271	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00276	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 306  : 	coder->temp.size = 0;

  00281	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00286	48 c7 80 b0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+176], 0

; 307  :   }
; 308  : 
; 309  : 	// Initialize the next filter in the chain, if any.
; 310  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  00291	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR filters$[rsp]
  00299	49 83 c0 18	 add	 r8, 24
  0029d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  002a2	48 83 c1 58	 add	 rcx, 88			; 00000058H
  002a6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002ae	e8 00 00 00 00	 call	 lzma_next_filter_init
$LN12@lzma_lz_de:

; 311  : }

  002b3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b7	5f		 pop	 rdi
  002b8	5e		 pop	 rsi
  002b9	c3		 ret	 0
lzma_lz_decoder_init ENDP
END
