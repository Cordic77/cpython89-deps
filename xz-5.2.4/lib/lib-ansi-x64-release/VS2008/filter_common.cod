; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

features DQ	4000000000000001H
	DQ	0000000000000070H
	DB	00H
	DB	01H
	DB	01H
	ORG $+5
	DQ	0000000000000021H
	DQ	0000000000000070H
	DB	00H
	DB	01H
	DB	01H
	ORG $+5
	DQ	0000000000000004H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000005H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000006H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000007H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000008H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000009H
	DQ	0000000000000004H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	0000000000000003H
	DQ	0000000000000028H
	DB	01H
	DB	00H
	DB	00H
	ORG $+5
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DB	00H
	DB	00H
	DB	00H
	ORG $+5
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\filter_common.c
pdata	SEGMENT
$pdata$validate_chain DD imagerel validate_chain
	DD	imagerel validate_chain+362
	DD	imagerel $unwind$validate_chain
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_chain DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT validate_chain
_TEXT	SEGMENT
last_ok$32894 = 0
i$32895 = 8
non_last_ok$32893 = 16
changes_size_count$32892 = 24
j$32899 = 32
filters$ = 64
count$ = 72
validate_chain PROC					; COMDAT

; 295  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 296  : 	// There must be at least one filter.
; 297  : 	if (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR filters$[rsp], 0
  00014	74 0b		 je	 SHORT $LN11@validate_c
  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR filters$[rsp]
  0001b	48 83 38 ff	 cmp	 QWORD PTR [rax], -1
  0001f	75 0a		 jne	 SHORT $LN12@validate_c
$LN11@validate_c:

; 298  : 		return LZMA_PROG_ERROR;

  00021	b8 0b 00 00 00	 mov	 eax, 11
  00026	e9 3a 01 00 00	 jmp	 $LN13@validate_c
$LN12@validate_c:

; 299  : 
; 300  : 	// Number of non-last filters that may change the size of the data
; 301  : 	// significantly (that is, more than 1-2 % or so).
; 302  :   {
; 303  : 	size_t changes_size_count = 0;

  0002b	48 c7 44 24 18
	00 00 00 00	 mov	 QWORD PTR changes_size_count$32892[rsp], 0

; 304  : 
; 305  : 	// True if it is OK to add a new filter after the current filter.
; 306  : 	bool non_last_ok = true;

  00034	c6 44 24 10 01	 mov	 BYTE PTR non_last_ok$32893[rsp], 1

; 307  : 
; 308  : 	// True if the last filter in the given chain is actually usable as
; 309  : 	// the last filter. Only filters that support embedding End of Payload
; 310  : 	// Marker can be used as the last filter in the chain.
; 311  : 	bool last_ok = false;

  00039	c6 04 24 00	 mov	 BYTE PTR last_ok$32894[rsp], 0

; 312  : 
; 313  : 	size_t i = 0;

  0003d	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR i$32895[rsp], 0
$LN10@validate_c:

; 314  : 	do {
; 315  : 		size_t j;
; 316  : 		for (j = 0; filters[i].id != features[j].id; ++j)

  00046	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR j$32899[rsp], 0
  0004f	eb 0e		 jmp	 SHORT $LN7@validate_c
$LN6@validate_c:
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR j$32899[rsp]
  00056	48 83 c0 01	 add	 rax, 1
  0005a	48 89 44 24 20	 mov	 QWORD PTR j$32899[rsp], rax
$LN7@validate_c:
  0005f	4c 8b 44 24 08	 mov	 r8, QWORD PTR i$32895[rsp]
  00064	4d 6b c0 10	 imul	 r8, 16
  00068	48 8b 54 24 20	 mov	 rdx, QWORD PTR j$32899[rsp]
  0006d	48 6b d2 18	 imul	 rdx, 24
  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:features
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filters$[rsp]
  0007d	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  00081	4a 39 04 01	 cmp	 QWORD PTR [rcx+r8], rax
  00085	74 23		 je	 SHORT $LN5@validate_c

; 317  : 			if (features[j].id == LZMA_VLI_UNKNOWN)

  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$32899[rsp]
  0008c	48 6b c9 18	 imul	 rcx, 24
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:features
  00097	48 83 3c 08 ff	 cmp	 QWORD PTR [rax+rcx], -1
  0009c	75 0a		 jne	 SHORT $LN4@validate_c

; 318  : 				return LZMA_OPTIONS_ERROR;

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	e9 bd 00 00 00	 jmp	 $LN13@validate_c
$LN4@validate_c:

; 319  : 
; 320  : 		// If the previous filter in the chain cannot be a non-last
; 321  : 		// filter, the chain is invalid.
; 322  : 		if (!non_last_ok)

  000a8	eb a7		 jmp	 SHORT $LN6@validate_c
$LN5@validate_c:
  000aa	0f b6 44 24 10	 movzx	 eax, BYTE PTR non_last_ok$32893[rsp]
  000af	85 c0		 test	 eax, eax
  000b1	75 0a		 jne	 SHORT $LN3@validate_c

; 323  : 			return LZMA_OPTIONS_ERROR;

  000b3	b8 08 00 00 00	 mov	 eax, 8
  000b8	e9 a8 00 00 00	 jmp	 $LN13@validate_c
$LN3@validate_c:

; 324  : 
; 325  : 		non_last_ok = features[j].non_last_ok;

  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$32899[rsp]
  000c2	48 6b c9 18	 imul	 rcx, 24
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:features
  000cd	0f b6 44 08 10	 movzx	 eax, BYTE PTR [rax+rcx+16]
  000d2	88 44 24 10	 mov	 BYTE PTR non_last_ok$32893[rsp], al

; 326  : 		last_ok = features[j].last_ok;

  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$32899[rsp]
  000db	48 6b c9 18	 imul	 rcx, 24
  000df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:features
  000e6	0f b6 44 08 11	 movzx	 eax, BYTE PTR [rax+rcx+17]
  000eb	88 04 24	 mov	 BYTE PTR last_ok$32894[rsp], al

; 327  : 		changes_size_count += features[j].changes_size;

  000ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$32899[rsp]
  000f3	48 6b c9 18	 imul	 rcx, 24
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:features
  000fe	0f b6 4c 08 12	 movzx	 ecx, BYTE PTR [rax+rcx+18]
  00103	48 8b 44 24 18	 mov	 rax, QWORD PTR changes_size_count$32892[rsp]
  00108	48 03 c1	 add	 rax, rcx
  0010b	48 89 44 24 18	 mov	 QWORD PTR changes_size_count$32892[rsp], rax

; 328  : 
; 329  : 	} while (filters[++i].id != LZMA_VLI_UNKNOWN);

  00110	48 8b 44 24 08	 mov	 rax, QWORD PTR i$32895[rsp]
  00115	48 83 c0 01	 add	 rax, 1
  00119	48 89 44 24 08	 mov	 QWORD PTR i$32895[rsp], rax
  0011e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$32895[rsp]
  00123	48 6b c9 10	 imul	 rcx, 16
  00127	48 8b 44 24 40	 mov	 rax, QWORD PTR filters$[rsp]
  0012c	48 83 3c 08 ff	 cmp	 QWORD PTR [rax+rcx], -1
  00131	0f 85 0f ff ff
	ff		 jne	 $LN10@validate_c

; 330  : 
; 331  : 	// There must be 1-4 filters. The last filter must be usable as
; 332  : 	// the last filter in the chain. A maximum of three filters are
; 333  : 	// allowed to change the size of the data.
; 334  : 	if (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)

  00137	48 83 7c 24 08
	04		 cmp	 QWORD PTR i$32895[rsp], 4
  0013d	77 10		 ja	 SHORT $LN1@validate_c
  0013f	0f b6 04 24	 movzx	 eax, BYTE PTR last_ok$32894[rsp]
  00143	85 c0		 test	 eax, eax
  00145	74 08		 je	 SHORT $LN1@validate_c
  00147	48 83 7c 24 18
	03		 cmp	 QWORD PTR changes_size_count$32892[rsp], 3
  0014d	76 07		 jbe	 SHORT $LN2@validate_c
$LN1@validate_c:

; 335  : 		return LZMA_OPTIONS_ERROR;

  0014f	b8 08 00 00 00	 mov	 eax, 8
  00154	eb 0f		 jmp	 SHORT $LN13@validate_c
$LN2@validate_c:

; 336  : 
; 337  : 	*count = i;

  00156	48 8b 4c 24 48	 mov	 rcx, QWORD PTR count$[rsp]
  0015b	48 8b 44 24 08	 mov	 rax, QWORD PTR i$32895[rsp]
  00160	48 89 01	 mov	 QWORD PTR [rcx], rax

; 338  :   }
; 339  : 
; 340  : 	return LZMA_OK;

  00163	33 c0		 xor	 eax, eax
$LN13@validate_c:

; 341  : }

  00165	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00169	c3		 ret	 0
validate_chain ENDP
PUBLIC	lzma_raw_coder_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_raw_coder_memusage DD imagerel $LN11
	DD	imagerel $LN11+262
	DD	imagerel $unwind$lzma_raw_coder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_raw_coder_memusage DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_raw_coder_memusage
_TEXT	SEGMENT
tmp$32954 = 32
i$32957 = 40
total$32956 = 48
fc$32961 = 56
usage$32967 = 64
coder_find$ = 96
filters$ = 104
lzma_raw_coder_memusage PROC				; COMDAT

; 407  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 408  : 	// The chain has to have at least one filter.
; 409  : 	{
; 410  : 		size_t tmp;
; 411  : 		if (validate_chain(filters, &tmp) != LZMA_OK)

  0000e	48 8d 54 24 20	 lea	 rdx, QWORD PTR tmp$32954[rsp]
  00013	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filters$[rsp]
  00018	e8 00 00 00 00	 call	 validate_chain
  0001d	85 c0		 test	 eax, eax
  0001f	74 0c		 je	 SHORT $LN8@lzma_raw_c

; 412  : 			return UINT64_MAX;

  00021	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00028	e9 d4 00 00 00	 jmp	 $LN9@lzma_raw_c
$LN8@lzma_raw_c:

; 413  : 	}
; 414  : 
; 415  :   {
; 416  : 	uint64_t total = 0;

  0002d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR total$32956[rsp], 0

; 417  : 	size_t i = 0;

  00036	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$32957[rsp], 0
$LN7@lzma_raw_c:

; 418  : 
; 419  : 	do {
; 420  : 		const lzma_filter_coder *const fc
; 421  : 				 = coder_find(filters[i].id);

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$32957[rsp]
  00044	48 6b c0 10	 imul	 rax, 16
  00048	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filters$[rsp]
  0004d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00051	ff 54 24 60	 call	 QWORD PTR coder_find$[rsp]
  00055	48 89 44 24 38	 mov	 QWORD PTR fc$32961[rsp], rax

; 422  : 		if (fc == NULL)

  0005a	48 83 7c 24 38
	00		 cmp	 QWORD PTR fc$32961[rsp], 0
  00060	75 0c		 jne	 SHORT $LN4@lzma_raw_c

; 423  : 			return UINT64_MAX; // Unsupported Filter ID

  00062	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00069	e9 93 00 00 00	 jmp	 $LN9@lzma_raw_c
$LN4@lzma_raw_c:

; 424  : 
; 425  : 		if (fc->memusage == NULL) {

  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR fc$32961[rsp]
  00073	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00078	75 12		 jne	 SHORT $LN3@lzma_raw_c

; 426  : 			// This filter doesn't have a function to calculate
; 427  : 			// the memory usage and validate the options. Such
; 428  : 			// filters need only little memory, so we use 1 KiB
; 429  : 			// as a good estimate. They also accept all possible
; 430  : 			// options, so there's no need to worry about lack
; 431  : 			// of validation.
; 432  : 			total += 1024;

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR total$32956[rsp]
  0007f	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00085	48 89 44 24 30	 mov	 QWORD PTR total$32956[rsp], rax

; 433  : 		} else {

  0008a	eb 43		 jmp	 SHORT $LN2@lzma_raw_c
$LN3@lzma_raw_c:

; 434  : 			// Call the filter-specific memory usage calculation
; 435  : 			// function.
; 436  : 			const uint64_t usage
; 437  : 					= fc->memusage(filters[i].options);

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$32957[rsp]
  00091	48 6b c0 10	 imul	 rax, 16
  00095	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filters$[rsp]
  0009a	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR fc$32961[rsp]
  000a4	ff 50 10	 call	 QWORD PTR [rax+16]
  000a7	48 89 44 24 40	 mov	 QWORD PTR usage$32967[rsp], rax

; 438  : 			if (usage == UINT64_MAX)

  000ac	48 83 7c 24 40
	ff		 cmp	 QWORD PTR usage$32967[rsp], -1
  000b2	75 09		 jne	 SHORT $LN1@lzma_raw_c

; 439  : 				return UINT64_MAX; // Invalid options

  000b4	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000bb	eb 44		 jmp	 SHORT $LN9@lzma_raw_c
$LN1@lzma_raw_c:

; 440  : 
; 441  : 			total += usage;

  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR usage$32967[rsp]
  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR total$32956[rsp]
  000c7	48 03 c1	 add	 rax, rcx
  000ca	48 89 44 24 30	 mov	 QWORD PTR total$32956[rsp], rax
$LN2@lzma_raw_c:

; 442  : 		}
; 443  : 	} while (filters[++i].id != LZMA_VLI_UNKNOWN);

  000cf	48 8b 44 24 28	 mov	 rax, QWORD PTR i$32957[rsp]
  000d4	48 83 c0 01	 add	 rax, 1
  000d8	48 89 44 24 28	 mov	 QWORD PTR i$32957[rsp], rax
  000dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$32957[rsp]
  000e2	48 6b c9 10	 imul	 rcx, 16
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR filters$[rsp]
  000eb	48 83 3c 08 ff	 cmp	 QWORD PTR [rax+rcx], -1
  000f0	0f 85 49 ff ff
	ff		 jne	 $LN7@lzma_raw_c

; 444  : 
; 445  : 	// Add some fixed amount of extra. It's to compensate memory usage
; 446  : 	// of Stream, Block etc. coders, malloc() overhead, stack etc.
; 447  : 	return total + LZMA_MEMUSAGE_BASE;

  000f6	48 8b 44 24 30	 mov	 rax, QWORD PTR total$32956[rsp]
  000fb	48 05 00 80 00
	00		 add	 rax, 32768		; 00008000H
$LN9@lzma_raw_c:

; 448  :   }
; 449  : }

  00101	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00105	c3		 ret	 0
lzma_raw_coder_memusage ENDP
PUBLIC	lzma_raw_coder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_raw_coder_init DD imagerel $LN20
	DD	imagerel $LN20+725
	DD	imagerel $unwind$lzma_raw_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_raw_coder_init DD 021b01H
	DD	01d011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_raw_coder_init
_TEXT	SEGMENT
count$ = 32
ret_$32922 = 40
filters$32924 = 48
i$32926 = 176
fc$32931 = 184
j$32930 = 192
i$32937 = 200
fc$32941 = 208
ret$32947 = 216
next$ = 240
allocator$ = 248
options$ = 256
coder_find$ = 264
is_encoder$ = 272
lzma_raw_coder_init PROC				; COMDAT

; 348  : {

$LN20:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
$LN17@lzma_raw_c@2:

; 349  : 	// Do some basic validation and get the number of filters.
; 350  : 	size_t count;
; 351  : 	return_if_error(validate_chain(options, &count));

  0001b	48 8d 54 24 20	 lea	 rdx, QWORD PTR count$[rsp]
  00020	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  00028	e8 00 00 00 00	 call	 validate_chain
  0002d	89 44 24 28	 mov	 DWORD PTR ret_$32922[rsp], eax
  00031	83 7c 24 28 00	 cmp	 DWORD PTR ret_$32922[rsp], 0
  00036	74 09		 je	 SHORT $LN14@lzma_raw_c@2
  00038	8b 44 24 28	 mov	 eax, DWORD PTR ret_$32922[rsp]
  0003c	e9 8c 02 00 00	 jmp	 $LN18@lzma_raw_c@2
$LN14@lzma_raw_c@2:
  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 d4		 jne	 SHORT $LN17@lzma_raw_c@2

; 352  : 
; 353  : 	// Set the filter functions and copy the options pointer.
; 354  :   {
; 355  : 	lzma_filter_info filters[LZMA_FILTERS_MAX + 1];
; 356  : 	if (is_encoder) {

  00047	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0004f	85 c0		 test	 eax, eax
  00051	0f 84 16 01 00
	00		 je	 $LN13@lzma_raw_c@2

; 357  : 		size_t i;
; 358  : 
; 359  : 		for (i = 0; i < count; ++i) {

  00057	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$32926[rsp], 0
  00063	eb 14		 jmp	 SHORT $LN12@lzma_raw_c@2
$LN11@lzma_raw_c@2:
  00065	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i$32926[rsp]
  0006d	48 83 c0 01	 add	 rax, 1
  00071	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i$32926[rsp], rax
$LN12@lzma_raw_c@2:
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  0007e	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i$32926[rsp], rax
  00086	0f 83 dc 00 00
	00		 jae	 $LN10@lzma_raw_c@2

; 360  : 			// The order of the filters is reversed in the
; 361  : 			// encoder. It allows more efficient handling
; 362  : 			// of the uncompressed data.
; 363  : 			const size_t j = count - i - 1;

  0008c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i$32926[rsp]
  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00099	48 2b c1	 sub	 rax, rcx
  0009c	48 83 e8 01	 sub	 rax, 1
  000a0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR j$32930[rsp], rax

; 364  : 
; 365  : 			const lzma_filter_coder *const fc
; 366  : 					= coder_find(options[i].id);

  000a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i$32926[rsp]
  000b0	48 6b c0 10	 imul	 rax, 16
  000b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  000bc	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000c0	ff 94 24 08 01
	00 00		 call	 QWORD PTR coder_find$[rsp]
  000c7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fc$32931[rsp], rax

; 367  : 			if (fc == NULL || fc->init == NULL)

  000cf	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR fc$32931[rsp], 0
  000d8	74 0f		 je	 SHORT $LN8@lzma_raw_c@2
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR fc$32931[rsp]
  000e2	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000e7	75 0a		 jne	 SHORT $LN9@lzma_raw_c@2
$LN8@lzma_raw_c@2:

; 368  : 				return LZMA_OPTIONS_ERROR;

  000e9	b8 08 00 00 00	 mov	 eax, 8
  000ee	e9 da 01 00 00	 jmp	 $LN18@lzma_raw_c@2
$LN9@lzma_raw_c@2:

; 369  : 
; 370  : 			filters[j].id = options[i].id;

  000f3	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR i$32926[rsp]
  000fb	48 6b d2 10	 imul	 rdx, 16
  000ff	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR j$32930[rsp]
  00107	48 6b c9 18	 imul	 rcx, 24
  0010b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00113	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  00117	48 89 44 0c 30	 mov	 QWORD PTR filters$32924[rsp+rcx], rax

; 371  : 			filters[j].init = fc->init;

  0011c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR j$32930[rsp]
  00124	48 6b c9 18	 imul	 rcx, 24
  00128	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR fc$32931[rsp]
  00130	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00134	48 89 44 0c 38	 mov	 QWORD PTR filters$32924[rsp+rcx+8], rax

; 372  : 			filters[j].options = options[i].options;

  00139	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR i$32926[rsp]
  00141	48 6b d2 10	 imul	 rdx, 16
  00145	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR j$32930[rsp]
  0014d	48 6b c9 18	 imul	 rcx, 24
  00151	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00159	48 8b 44 10 08	 mov	 rax, QWORD PTR [rax+rdx+8]
  0015e	48 89 44 0c 40	 mov	 QWORD PTR filters$32924[rsp+rcx+16], rax

; 373  : 		}

  00163	e9 fd fe ff ff	 jmp	 $LN11@lzma_raw_c@2
$LN10@lzma_raw_c@2:

; 374  : 	} else {

  00168	e9 f5 00 00 00	 jmp	 $LN7@lzma_raw_c@2
$LN13@lzma_raw_c@2:

; 375  : 		size_t i;
; 376  : 
; 377  : 		for (i = 0; i < count; ++i) {

  0016d	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$32937[rsp], 0
  00179	eb 14		 jmp	 SHORT $LN6@lzma_raw_c@2
$LN5@lzma_raw_c@2:
  0017b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR i$32937[rsp]
  00183	48 83 c0 01	 add	 rax, 1
  00187	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR i$32937[rsp], rax
$LN6@lzma_raw_c@2:
  0018f	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00194	48 39 84 24 c8
	00 00 00	 cmp	 QWORD PTR i$32937[rsp], rax
  0019c	0f 83 c0 00 00
	00		 jae	 $LN4@lzma_raw_c@2

; 378  : 			const lzma_filter_coder *const fc
; 379  : 					= coder_find(options[i].id);

  001a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR i$32937[rsp]
  001aa	48 6b c0 10	 imul	 rax, 16
  001ae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  001b6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001ba	ff 94 24 08 01
	00 00		 call	 QWORD PTR coder_find$[rsp]
  001c1	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR fc$32941[rsp], rax

; 380  : 			if (fc == NULL || fc->init == NULL)

  001c9	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR fc$32941[rsp], 0
  001d2	74 0f		 je	 SHORT $LN2@lzma_raw_c@2
  001d4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fc$32941[rsp]
  001dc	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001e1	75 0a		 jne	 SHORT $LN3@lzma_raw_c@2
$LN2@lzma_raw_c@2:

; 381  : 				return LZMA_OPTIONS_ERROR;

  001e3	b8 08 00 00 00	 mov	 eax, 8
  001e8	e9 e0 00 00 00	 jmp	 $LN18@lzma_raw_c@2
$LN3@lzma_raw_c@2:

; 382  : 
; 383  : 			filters[i].id = options[i].id;

  001ed	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR i$32937[rsp]
  001f5	48 6b d2 10	 imul	 rdx, 16
  001f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR i$32937[rsp]
  00201	48 6b c9 18	 imul	 rcx, 24
  00205	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  0020d	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  00211	48 89 44 0c 30	 mov	 QWORD PTR filters$32924[rsp+rcx], rax

; 384  : 			filters[i].init = fc->init;

  00216	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR i$32937[rsp]
  0021e	48 6b c9 18	 imul	 rcx, 24
  00222	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fc$32941[rsp]
  0022a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0022e	48 89 44 0c 38	 mov	 QWORD PTR filters$32924[rsp+rcx+8], rax

; 385  : 			filters[i].options = options[i].options;

  00233	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR i$32937[rsp]
  0023b	48 6b d2 10	 imul	 rdx, 16
  0023f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR i$32937[rsp]
  00247	48 6b c9 18	 imul	 rcx, 24
  0024b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00253	48 8b 44 10 08	 mov	 rax, QWORD PTR [rax+rdx+8]
  00258	48 89 44 0c 40	 mov	 QWORD PTR filters$32924[rsp+rcx+16], rax

; 386  : 		}

  0025d	e9 19 ff ff ff	 jmp	 $LN5@lzma_raw_c@2
$LN4@lzma_raw_c@2:
$LN7@lzma_raw_c@2:

; 387  : 	}
; 388  : 
; 389  : 	// Terminate the array.
; 390  : 	filters[count].id = LZMA_VLI_UNKNOWN;

  00262	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00267	48 6b c0 18	 imul	 rax, 24
  0026b	48 c7 44 04 30
	ff ff ff ff	 mov	 QWORD PTR filters$32924[rsp+rax], -1

; 391  : 	filters[count].init = NULL;

  00274	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00279	48 6b c0 18	 imul	 rax, 24
  0027d	48 c7 44 04 38
	00 00 00 00	 mov	 QWORD PTR filters$32924[rsp+rax+8], 0

; 392  : 
; 393  : 	// Initialize the filters.
; 394  :   {
; 395  : 	const lzma_ret ret = lzma_next_filter_init(next, allocator, filters);

  00286	4c 8d 44 24 30	 lea	 r8, QWORD PTR filters$32924[rsp]
  0028b	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00293	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0029b	e8 00 00 00 00	 call	 lzma_next_filter_init
  002a0	89 84 24 d8 00
	00 00		 mov	 DWORD PTR ret$32947[rsp], eax

; 396  : 	if (ret != LZMA_OK)

  002a7	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR ret$32947[rsp], 0
  002af	74 15		 je	 SHORT $LN1@lzma_raw_c@2

; 397  : 		lzma_next_end(next, allocator);

  002b1	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002b9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  002c1	e8 00 00 00 00	 call	 lzma_next_end
$LN1@lzma_raw_c@2:

; 398  : 
; 399  : 	return ret;

  002c6	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR ret$32947[rsp]
$LN18@lzma_raw_c@2:

; 400  :   }}
; 401  : }

  002cd	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002d4	c3		 ret	 0
lzma_raw_coder_init ENDP
END
