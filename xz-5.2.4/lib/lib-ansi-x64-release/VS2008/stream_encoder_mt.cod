; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	_beginthreadex:PROC
EXTRN	__imp_InitializeConditionVariable:PROC
EXTRN	__imp_SleepConditionVariableCS:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_WakeConditionVariable:PROC
?in_chunk_max@?9??worker_encode@@9@9 DQ 0000000000004000H ; `worker_encode'::`10'::in_chunk_max
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\outqueue.h
pdata	SEGMENT
$pdata$lzma_outq_is_empty DD imagerel lzma_outq_is_empty
	DD	imagerel lzma_outq_is_empty+44
	DD	imagerel $unwind$lzma_outq_is_empty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_is_empty DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_is_empty
_TEXT	SEGMENT
tv66 = 0
outq$ = 32
lzma_outq_is_empty PROC					; COMDAT

; 154  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 155  : 	return outq->bufs_used == 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  0000e	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00012	75 09		 jne	 SHORT $LN3@lzma_outq_@3
  00014	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  0001b	eb 07		 jmp	 SHORT $LN4@lzma_outq_@3
$LN3@lzma_outq_@3:
  0001d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@lzma_outq_@3:
  00024	8a 04 24	 mov	 al, BYTE PTR tv66[rsp]

; 156  : }

  00027	48 83 c4 18	 add	 rsp, 24
  0002b	c3		 ret	 0
lzma_outq_is_empty ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_outq_has_buf DD imagerel lzma_outq_has_buf
	DD	imagerel lzma_outq_has_buf+51
	DD	imagerel $unwind$lzma_outq_has_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_outq_has_buf DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_outq_has_buf
_TEXT	SEGMENT
tv67 = 0
outq$ = 32
lzma_outq_has_buf PROC					; COMDAT

; 146  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 147  : 	return outq->bufs_used < outq->bufs_allocated;

  00009	48 8b 4c 24 20	 mov	 rcx, QWORD PTR outq$[rsp]
  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR outq$[rsp]
  00013	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00016	39 41 20	 cmp	 DWORD PTR [rcx+32], eax
  00019	73 09		 jae	 SHORT $LN3@lzma_outq_@4
  0001b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00022	eb 07		 jmp	 SHORT $LN4@lzma_outq_@4
$LN3@lzma_outq_@4:
  00024	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@lzma_outq_@4:
  0002b	8a 04 24	 mov	 al, BYTE PTR tv67[rsp]

; 148  : }

  0002e	48 83 c4 18	 add	 rsp, 24
  00032	c3		 ret	 0
lzma_outq_has_buf ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$mythread_condtime_set DD imagerel mythread_condtime_set
	DD	imagerel mythread_condtime_set+53
	DD	imagerel $unwind$mythread_condtime_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_condtime_set DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_condtime_set
_TEXT	SEGMENT
condtime$ = 48
cond$ = 56
timeout$ = 64
mythread_condtime_set PROC				; COMDAT

; 517  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 518  : 	(void)cond;
; 519  : 	condtime->start = GetTickCount();

  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00019	44 8b d8	 mov	 r11d, eax
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR condtime$[rsp]
  00021	44 89 18	 mov	 DWORD PTR [rax], r11d

; 520  : 	condtime->timeout = timeout;

  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR condtime$[rsp]
  00029	8b 44 24 40	 mov	 eax, DWORD PTR timeout$[rsp]
  0002d	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 521  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
mythread_condtime_set ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_cond_timedwait DD imagerel mythread_cond_timedwait
	DD	imagerel mythread_cond_timedwait+145
	DD	imagerel $unwind$mythread_cond_timedwait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_cond_timedwait DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_cond_timedwait
_TEXT	SEGMENT
elapsed$31721 = 32
ret$31723 = 36
timeout$31722 = 40
tv70 = 44
tv76 = 48
cond$ = 80
mutex$ = 88
condtime$ = 96
mythread_cond_timedwait PROC				; COMDAT

; 489  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 490  : #ifdef MYTHREAD_WIN95
; 491  : 	LeaveCriticalSection(mutex);
; 492  : #endif
; 493  : 
; 494  :   {
; 495  : 	DWORD elapsed = GetTickCount() - condtime->start;

  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR condtime$[rsp]
  0001e	2b 01		 sub	 eax, DWORD PTR [rcx]
  00020	89 44 24 20	 mov	 DWORD PTR elapsed$31721[rsp], eax

; 496  : 	DWORD timeout = elapsed >= condtime->timeout
; 497  : 			? 0 : condtime->timeout - elapsed;

  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR condtime$[rsp]
  00029	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0002c	39 44 24 20	 cmp	 DWORD PTR elapsed$31721[rsp], eax
  00030	72 0a		 jb	 SHORT $LN3@mythread_c
  00032	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0003a	eb 12		 jmp	 SHORT $LN4@mythread_c
$LN3@mythread_c:
  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR condtime$[rsp]
  00041	8b 4c 24 20	 mov	 ecx, DWORD PTR elapsed$31721[rsp]
  00045	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00048	2b c1		 sub	 eax, ecx
  0004a	89 44 24 2c	 mov	 DWORD PTR tv70[rsp], eax
$LN4@mythread_c:
  0004e	8b 44 24 2c	 mov	 eax, DWORD PTR tv70[rsp]
  00052	89 44 24 28	 mov	 DWORD PTR timeout$31722[rsp], eax

; 498  : 
; 499  : #ifdef MYTHREAD_WIN95
; 500  : 	DWORD ret = WaitForSingleObject(*cond, timeout);
; 501  : 	assert(ret == WAIT_OBJECT_0 || ret == WAIT_TIMEOUT);
; 502  : 
; 503  : 	EnterCriticalSection(mutex);
; 504  : 
; 505  : 	return ret == WAIT_TIMEOUT;
; 506  : #else
; 507  : 	BOOL ret = SleepConditionVariableCS(cond, mutex, timeout);

  00056	44 8b 44 24 28	 mov	 r8d, DWORD PTR timeout$31722[rsp]
  0005b	48 8b 54 24 58	 mov	 rdx, QWORD PTR mutex$[rsp]
  00060	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cond$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  0006b	89 44 24 24	 mov	 DWORD PTR ret$31723[rsp], eax

; 508  : 	assert(ret || GetLastError() == ERROR_TIMEOUT);
; 509  : 	return !ret;

  0006f	83 7c 24 24 00	 cmp	 DWORD PTR ret$31723[rsp], 0
  00074	75 0a		 jne	 SHORT $LN5@mythread_c
  00076	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0007e	eb 08		 jmp	 SHORT $LN6@mythread_c
$LN5@mythread_c:
  00080	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN6@mythread_c:
  00088	8b 44 24 30	 mov	 eax, DWORD PTR tv76[rsp]

; 510  : #endif
; 511  :   }
; 512  : }

  0008c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00090	c3		 ret	 0
mythread_cond_timedwait ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_cond_wait DD imagerel mythread_cond_wait
	DD	imagerel mythread_cond_wait+45
	DD	imagerel $unwind$mythread_cond_wait
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_cond_wait DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_cond_wait
_TEXT	SEGMENT
ret$ = 32
cond$ = 64
mutex$ = 72
mythread_cond_wait PROC					; COMDAT

; 474  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 475  : #ifdef MYTHREAD_WIN95
; 476  : 	LeaveCriticalSection(mutex);
; 477  : 	WaitForSingleObject(*cond, INFINITE);
; 478  : 	EnterCriticalSection(mutex);
; 479  : #else
; 480  : 	BOOL ret = SleepConditionVariableCS(cond, mutex, INFINITE);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR mutex$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cond$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  00024	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 481  : 	assert(ret);
; 482  : 	(void)ret;
; 483  : #endif
; 484  : }

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
mythread_cond_wait ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_cond_signal DD imagerel mythread_cond_signal
	DD	imagerel mythread_cond_signal+25
	DD	imagerel $unwind$mythread_cond_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_cond_signal DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_cond_signal
_TEXT	SEGMENT
cond$ = 48
mythread_cond_signal PROC				; COMDAT

; 464  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 465  : #ifdef MYTHREAD_WIN95
; 466  : 	SetEvent(*cond);
; 467  : #else
; 468  : 	WakeConditionVariable(cond);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cond$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 469  : #endif
; 470  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
mythread_cond_signal ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mythread_cond_destroy
_TEXT	SEGMENT
cond$ = 8
mythread_cond_destroy PROC				; COMDAT

; 454  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 455  : #ifdef MYTHREAD_WIN95
; 456  : 	CloseHandle(*cond);
; 457  : #else
; 458  : 	(void)cond;
; 459  : #endif
; 460  : }

  00005	c3		 ret	 0
mythread_cond_destroy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_cond_init DD imagerel mythread_cond_init
	DD	imagerel mythread_cond_init+27
	DD	imagerel $unwind$mythread_cond_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_cond_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_cond_init
_TEXT	SEGMENT
cond$ = 48
mythread_cond_init PROC					; COMDAT

; 442  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 443  : #ifdef MYTHREAD_WIN95
; 444  : 	*cond = CreateEvent(NULL, FALSE, FALSE, NULL);
; 445  : 	return *cond == NULL ? -1 : 0;
; 446  : #else
; 447  : 	InitializeConditionVariable(cond);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cond$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeConditionVariable

; 448  : 	return 0;

  00014	33 c0		 xor	 eax, eax

; 449  : #endif
; 450  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
mythread_cond_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_mutex_unlock DD imagerel mythread_mutex_unlock
	DD	imagerel mythread_mutex_unlock+25
	DD	imagerel $unwind$mythread_mutex_unlock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_mutex_unlock DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_mutex_unlock
_TEXT	SEGMENT
mutex$ = 48
mythread_mutex_unlock PROC				; COMDAT

; 435  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 436  : 	LeaveCriticalSection(mutex);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 437  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
mythread_mutex_unlock ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_mutex_lock DD imagerel mythread_mutex_lock
	DD	imagerel mythread_mutex_lock+25
	DD	imagerel $unwind$mythread_mutex_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_mutex_lock DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_mutex_lock
_TEXT	SEGMENT
mutex$ = 48
mythread_mutex_lock PROC				; COMDAT

; 429  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 430  : 	EnterCriticalSection(mutex);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 431  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
mythread_mutex_lock ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_mutex_destroy DD imagerel mythread_mutex_destroy
	DD	imagerel mythread_mutex_destroy+25
	DD	imagerel $unwind$mythread_mutex_destroy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_mutex_destroy DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_mutex_destroy
_TEXT	SEGMENT
mutex$ = 48
mythread_mutex_destroy PROC				; COMDAT

; 423  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 424  : 	DeleteCriticalSection(mutex);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 425  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
mythread_mutex_destroy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_mutex_init DD imagerel mythread_mutex_init
	DD	imagerel mythread_mutex_init+27
	DD	imagerel $unwind$mythread_mutex_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_mutex_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_mutex_init
_TEXT	SEGMENT
mutex$ = 48
mythread_mutex_init PROC				; COMDAT

; 416  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 417  : 	InitializeCriticalSection(mutex);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 418  : 	return 0;

  00014	33 c0		 xor	 eax, eax

; 419  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
mythread_mutex_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_join DD imagerel mythread_join
	DD	imagerel mythread_join+77
	DD	imagerel $unwind$mythread_join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_join DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_join
_TEXT	SEGMENT
ret$ = 32
thread$ = 64
mythread_join PROC					; COMDAT

; 401  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 402  : 	int ret = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 403  : 
; 404  : 	if (WaitForSingleObject(thread, INFINITE) != WAIT_OBJECT_0)

  00011	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR thread$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00021	85 c0		 test	 eax, eax
  00023	74 08		 je	 SHORT $LN2@mythread_j

; 405  : 		ret = -1;

  00025	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -1
$LN2@mythread_j:

; 406  : 
; 407  : 	if (!CloseHandle(thread))

  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR thread$[rsp]
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00038	85 c0		 test	 eax, eax
  0003a	75 08		 jne	 SHORT $LN1@mythread_j

; 408  : 		ret = -1;

  0003c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -1
$LN1@mythread_j:

; 409  : 
; 410  : 	return ret;

  00044	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]

; 411  : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
mythread_join ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mythread_create DD imagerel mythread_create
	DD	imagerel mythread_create+95
	DD	imagerel $unwind$mythread_create
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mythread_create DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mythread_create
_TEXT	SEGMENT
ret$ = 48
thread$ = 80
func$ = 88
arg$ = 96
mythread_create PROC					; COMDAT

; 390  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 391  : 	uintptr_t ret = _beginthreadex(NULL, 0, func, arg, 0, NULL);

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00024	4c 8b 4c 24 60	 mov	 r9, QWORD PTR arg$[rsp]
  00029	4c 8b 44 24 58	 mov	 r8, QWORD PTR func$[rsp]
  0002e	33 d2		 xor	 edx, edx
  00030	33 c9		 xor	 ecx, ecx
  00032	e8 00 00 00 00	 call	 _beginthreadex
  00037	48 89 44 24 30	 mov	 QWORD PTR ret$[rsp], rax

; 392  : 	if (ret == 0)

  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR ret$[rsp], 0
  00042	75 07		 jne	 SHORT $LN1@mythread_c@2

; 393  : 		return -1;

  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	eb 0f		 jmp	 SHORT $LN2@mythread_c@2
$LN1@mythread_c@2:

; 394  : 
; 395  : 	*thread = (HANDLE)ret;

  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR thread$[rsp]
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR ret$[rsp]
  00055	48 89 01	 mov	 QWORD PTR [rcx], rax

; 396  : 	return 0;

  00058	33 c0		 xor	 eax, eax
$LN2@mythread_c@2:

; 397  : }

  0005a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005e	c3		 ret	 0
mythread_create ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_progress DD imagerel get_progress
	DD	imagerel get_progress+536
	DD	imagerel $unwind$get_progress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_progress DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT get_progress
_TEXT	SEGMENT
mythread_j_964$ = 32
mythread_i_964$ = 36
coder$ = 40
i$33385 = 48
mythread_i_970$33389 = 56
mythread_j_970$33390 = 60
$T81873 = 64
$T81877 = 72
tv69 = 80
tv89 = 84
coder_ptr$ = 112
progress_in$ = 120
progress_out$ = 128
get_progress PROC					; COMDAT

; 959  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 960  : 	lzma_stream_coder *coder = coder_ptr;

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR coder$[rsp], rax

; 961  : 
; 962  : 	// Lock coder->mutex to prevent finishing threads from moving their
; 963  : 	// progress info from the worker_thread structure to lzma_stream_coder.
; 964  : 	mythread_sync(coder->mutex) {

  0001d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_i_964$[rsp], 0
  00025	eb 08		 jmp	 SHORT $LN15@get_progre
$LN14@get_progre:
  00027	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_i_964$[rsp], 1
$LN15@get_progre:
  0002f	83 7c 24 24 00	 cmp	 DWORD PTR mythread_i_964$[rsp], 0
  00034	74 1c		 je	 SHORT $LN18@get_progre
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR coder$[rsp]
  0003b	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00048	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00050	eb 1a		 jmp	 SHORT $LN19@get_progre
$LN18@get_progre:
  00052	48 8b 4c 24 28	 mov	 rcx, QWORD PTR coder$[rsp]
  00057	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00064	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN19@get_progre:
  0006c	83 7c 24 50 00	 cmp	 DWORD PTR tv69[rsp], 0
  00071	0f 84 9c 01 00
	00		 je	 $LN13@get_progre
  00077	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR mythread_j_964$[rsp], 0
  0007f	eb 08		 jmp	 SHORT $LN12@get_progre
$LN11@get_progre:
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR mythread_j_964$[rsp], 1
$LN12@get_progre:
  00089	83 7c 24 20 00	 cmp	 DWORD PTR mythread_j_964$[rsp], 0
  0008e	0f 85 7a 01 00
	00		 jne	 $LN10@get_progre

; 965  : 		*progress_in = coder->progress_in;

  00094	48 8b 4c 24 78	 mov	 rcx, QWORD PTR progress_in$[rsp]
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  0009e	48 8b 80 58 01
	00 00		 mov	 rax, QWORD PTR [rax+344]
  000a5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 966  : 		*progress_out = coder->progress_out;

  000a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR progress_out$[rsp]
  000b0	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  000b5	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  000bc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 967  : 
; 968  :       { size_t i;
; 969  : 		for (i = 0; i < coder->threads_initialized; ++i) {

  000bf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$33385[rsp], 0
  000c8	eb 0e		 jmp	 SHORT $LN9@get_progre
$LN8@get_progre:
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR i$33385[rsp]
  000cf	48 83 c0 01	 add	 rax, 1
  000d3	48 89 44 24 30	 mov	 QWORD PTR i$33385[rsp], rax
$LN9@get_progre:
  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  000dd	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  000e3	48 39 44 24 30	 cmp	 QWORD PTR i$33385[rsp], rax
  000e8	0f 83 1b 01 00
	00		 jae	 $LN7@get_progre

; 970  : 			mythread_sync(coder->threads[i].mutex) {

  000ee	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR mythread_i_970$33389[rsp], 0
  000f6	eb 08		 jmp	 SHORT $LN6@get_progre
$LN5@get_progre:
  000f8	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR mythread_i_970$33389[rsp], 1
$LN6@get_progre:
  00100	83 7c 24 38 00	 cmp	 DWORD PTR mythread_i_970$33389[rsp], 0
  00105	74 3a		 je	 SHORT $LN20@get_progre
  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$33385[rsp]
  0010c	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  00118	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  0011f	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00127	48 89 44 24 40	 mov	 QWORD PTR $T81873[rsp], rax
  0012c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T81873[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00137	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
  0013f	eb 38		 jmp	 SHORT $LN21@get_progre
$LN20@get_progre:
  00141	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$33385[rsp]
  00146	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0014d	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  00152	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00159	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00161	48 89 44 24 48	 mov	 QWORD PTR $T81877[rsp], rax
  00166	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T81877[rsp]
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00171	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
$LN21@get_progre:
  00179	83 7c 24 54 00	 cmp	 DWORD PTR tv89[rsp], 0
  0017e	0f 84 80 00 00
	00		 je	 $LN4@get_progre
  00184	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR mythread_j_970$33390[rsp], 0
  0018c	eb 08		 jmp	 SHORT $LN3@get_progre
$LN2@get_progre:
  0018e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR mythread_j_970$33390[rsp], 1
$LN3@get_progre:
  00196	83 7c 24 3c 00	 cmp	 DWORD PTR mythread_j_970$33390[rsp], 0
  0019b	75 62		 jne	 SHORT $LN1@get_progre

; 971  : 				*progress_in += coder->threads[i].progress_in;

  0019d	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$33385[rsp]
  001a2	48 69 d2 98 01
	00 00		 imul	 rdx, 408		; 00000198H
  001a9	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  001ae	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  001b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR progress_in$[rsp]
  001ba	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001bd	48 03 4c 10 30	 add	 rcx, QWORD PTR [rax+rdx+48]
  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR progress_in$[rsp]
  001c7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 972  : 				*progress_out += coder->threads[i]
; 973  : 						.progress_out;

  001ca	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$33385[rsp]
  001cf	48 69 d2 98 01
	00 00		 imul	 rdx, 408		; 00000198H
  001d6	48 8b 44 24 28	 mov	 rax, QWORD PTR coder$[rsp]
  001db	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  001e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR progress_out$[rsp]
  001ea	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ed	48 03 4c 10 38	 add	 rcx, QWORD PTR [rax+rdx+56]
  001f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR progress_out$[rsp]
  001fa	48 89 08	 mov	 QWORD PTR [rax], rcx
  001fd	eb 8f		 jmp	 SHORT $LN2@get_progre
$LN1@get_progre:

; 974  : 			}

  001ff	e9 f4 fe ff ff	 jmp	 $LN5@get_progre
$LN4@get_progre:

; 975  :         }

  00204	e9 c1 fe ff ff	 jmp	 $LN8@get_progre
$LN7@get_progre:

; 976  :       }
; 977  : 	}

  00209	e9 73 fe ff ff	 jmp	 $LN11@get_progre
$LN10@get_progre:
  0020e	e9 14 fe ff ff	 jmp	 $LN14@get_progre
$LN13@get_progre:

; 978  : 
; 979  : 	return;
; 980  : }

  00213	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00217	c3		 ret	 0
get_progress ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_options DD imagerel get_options
	DD	imagerel get_options+316
	DD	imagerel $unwind$get_options
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_options DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_options
_TEXT	SEGMENT
options$ = 48
opt_easy$ = 56
filters$ = 64
block_size$ = 72
outbuf_size_max$ = 80
get_options PROC					; COMDAT

; 911  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 912  : 	// Validate some of the options.
; 913  : 	if (options == NULL)

  00018	48 83 7c 24 30
	00		 cmp	 QWORD PTR options$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN11@get_option@2

; 914  : 		return LZMA_PROG_ERROR;

  00020	b8 0b 00 00 00	 mov	 eax, 11
  00025	e9 0d 01 00 00	 jmp	 $LN12@get_option@2
$LN11@get_option@2:

; 915  : 
; 916  : 	if (options->flags != 0 || options->threads == 0
; 917  : 			|| options->threads > LZMA_THREADS_MAX)

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  0002f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00032	75 19		 jne	 SHORT $LN9@get_option@2
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  00039	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0003d	74 0e		 je	 SHORT $LN9@get_option@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  00044	81 78 04 00 40
	00 00		 cmp	 DWORD PTR [rax+4], 16384 ; 00004000H
  0004b	76 0a		 jbe	 SHORT $LN10@get_option@2
$LN9@get_option@2:

; 918  : 		return LZMA_OPTIONS_ERROR;

  0004d	b8 08 00 00 00	 mov	 eax, 8
  00052	e9 e0 00 00 00	 jmp	 $LN12@get_option@2
$LN10@get_option@2:

; 919  : 
; 920  : 	if (options->filters != NULL) {

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  0005c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00061	74 13		 je	 SHORT $LN8@get_option@2

; 921  : 		// Filter chain was given, use it as is.
; 922  : 		*filters = options->filters;

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filters$[rsp]
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  0006d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00071	48 89 01	 mov	 QWORD PTR [rcx], rax

; 923  : 	} else {

  00074	eb 30		 jmp	 SHORT $LN7@get_option@2
$LN8@get_option@2:

; 924  : 		// Use a preset.
; 925  : 		if (lzma_easy_preset(opt_easy, options->preset))

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  0007b	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR opt_easy$[rsp]
  00083	e8 00 00 00 00	 call	 lzma_easy_preset
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	74 0a		 je	 SHORT $LN6@get_option@2

; 926  : 			return LZMA_OPTIONS_ERROR;

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	e9 9e 00 00 00	 jmp	 $LN12@get_option@2
$LN6@get_option@2:

; 927  : 
; 928  : 		*filters = opt_easy->filters;

  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filters$[rsp]
  0009e	48 8b 44 24 38	 mov	 rax, QWORD PTR opt_easy$[rsp]
  000a3	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN7@get_option@2:

; 929  : 	}
; 930  : 
; 931  : 	// Block size
; 932  : 	if (options->block_size > 0) {

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  000ab	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b0	76 2f		 jbe	 SHORT $LN5@get_option@2

; 933  : 		if (options->block_size > BLOCK_SIZE_MAX)

  000b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR options$[rsp]
  000b7	48 b8 ff ff ff
	ff ff ff 03 00	 mov	 rax, 1125899906842623	; 0003ffffffffffffH
  000c1	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000c5	76 07		 jbe	 SHORT $LN4@get_option@2

; 934  : 			return LZMA_OPTIONS_ERROR;

  000c7	b8 08 00 00 00	 mov	 eax, 8
  000cc	eb 69		 jmp	 SHORT $LN12@get_option@2
$LN4@get_option@2:

; 935  : 
; 936  : 		*block_size = options->block_size;

  000ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR block_size$[rsp]
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR options$[rsp]
  000d8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000dc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 937  : 	} else {

  000df	eb 2a		 jmp	 SHORT $LN3@get_option@2
$LN5@get_option@2:

; 938  : 		// Determine the Block size from the filter chain.
; 939  : 		*block_size = lzma_mt_block_size(*filters);

  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filters$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	e8 00 00 00 00	 call	 lzma_mt_block_size
  000ee	4c 8b d8	 mov	 r11, rax
  000f1	48 8b 44 24 48	 mov	 rax, QWORD PTR block_size$[rsp]
  000f6	4c 89 18	 mov	 QWORD PTR [rax], r11

; 940  : 		if (*block_size == 0)

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR block_size$[rsp]
  000fe	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00102	75 07		 jne	 SHORT $LN2@get_option@2

; 941  : 			return LZMA_OPTIONS_ERROR;

  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	eb 2c		 jmp	 SHORT $LN12@get_option@2
$LN2@get_option@2:
$LN3@get_option@2:

; 942  : 
; 943  : 		assert(*block_size <= BLOCK_SIZE_MAX);
; 944  : 	}
; 945  : 
; 946  : 	// Calculate the maximum amount output that a single output buffer
; 947  : 	// may need to hold. This is the same as the maximum total size of
; 948  : 	// a Block.
; 949  : 	*outbuf_size_max = lzma_block_buffer_bound64(*block_size);

  0010b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR block_size$[rsp]
  00110	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00113	e8 00 00 00 00	 call	 lzma_block_buffer_bound64
  00118	4c 8b d8	 mov	 r11, rax
  0011b	48 8b 44 24 50	 mov	 rax, QWORD PTR outbuf_size_max$[rsp]
  00120	4c 89 18	 mov	 QWORD PTR [rax], r11

; 950  : 	if (*outbuf_size_max == 0)

  00123	48 8b 44 24 50	 mov	 rax, QWORD PTR outbuf_size_max$[rsp]
  00128	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0012c	75 07		 jne	 SHORT $LN1@get_option@2

; 951  : 		return LZMA_MEM_ERROR;

  0012e	b8 05 00 00 00	 mov	 eax, 5
  00133	eb 02		 jmp	 SHORT $LN12@get_option@2
$LN1@get_option@2:

; 952  : 
; 953  : 	return LZMA_OK;

  00135	33 c0		 xor	 eax, eax
$LN12@get_option@2:

; 954  : }

  00137	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0013b	c3		 ret	 0
get_options ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$wait_for_work DD imagerel wait_for_work
	DD	imagerel wait_for_work+524
	DD	imagerel $unwind$wait_for_work
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wait_for_work DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT wait_for_work
_TEXT	SEGMENT
timed_out$33244 = 32
mythread_i_676$33245 = 36
mythread_j_676$33246 = 40
$T81895 = 44
$T81909 = 48
ret$81917 = 68
tv78 = 72
tv72 = 76
tv140 = 80
coder$ = 112
wait_abs$ = 120
has_blocked$ = 128
has_input$ = 136
wait_for_work PROC					; COMDAT

; 658  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 659  : 	if (coder->timeout != 0 && !*has_blocked) {

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0001d	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [rax+304], 0
  00024	74 46		 je	 SHORT $LN12@wait_for_w
  00026	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR has_blocked$[rsp]
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	85 c0		 test	 eax, eax
  00033	75 37		 jne	 SHORT $LN12@wait_for_w

; 660  : 		// Every time when stream_encode_mt() is called via
; 661  : 		// lzma_code(), *has_blocked starts as false. We set it
; 662  : 		// to true here and calculate the absolute time when
; 663  : 		// we must return if there's nothing to do.
; 664  : 		//
; 665  : 		// The idea of *has_blocked is to avoid unneeded calls
; 666  : 		// to mythread_condtime_set(), which may do a syscall
; 667  : 		// depending on the operating system.
; 668  : 		*has_blocked = true;

  00035	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR has_blocked$[rsp]
  0003d	c6 00 01	 mov	 BYTE PTR [rax], 1

; 669  : 		mythread_condtime_set(wait_abs, &coder->cond, coder->timeout);

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00045	8b 80 30 01 00
	00		 mov	 eax, DWORD PTR [rax+304]
  0004b	89 44 24 2c	 mov	 DWORD PTR $T81895[rsp], eax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00055	44 8b d8	 mov	 r11d, eax
  00058	48 8b 44 24 78	 mov	 rax, QWORD PTR wait_abs$[rsp]
  0005d	44 89 18	 mov	 DWORD PTR [rax], r11d
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR wait_abs$[rsp]
  00065	8b 44 24 2c	 mov	 eax, DWORD PTR $T81895[rsp]
  00069	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN12@wait_for_w:

; 670  : 	}
; 671  : 
; 672  :   {
; 673  : 	bool timed_out = false;

  0006c	c6 44 24 20 00	 mov	 BYTE PTR timed_out$33244[rsp], 0

; 674  : 
; 675  :   {
; 676  : 	mythread_sync(coder->mutex) {

  00071	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_i_676$33245[rsp], 0
  00079	eb 08		 jmp	 SHORT $LN11@wait_for_w
$LN10@wait_for_w:
  0007b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_i_676$33245[rsp], 1
$LN11@wait_for_w:
  00083	83 7c 24 24 00	 cmp	 DWORD PTR mythread_i_676$33245[rsp], 0
  00088	74 1c		 je	 SHORT $LN15@wait_for_w
  0008a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  0008f	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0009c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  000a4	eb 1a		 jmp	 SHORT $LN16@wait_for_w
$LN15@wait_for_w:
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  000ab	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000b8	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN16@wait_for_w:
  000c0	83 7c 24 48 00	 cmp	 DWORD PTR tv78[rsp], 0
  000c5	0f 84 38 01 00
	00		 je	 $LN9@wait_for_w
  000cb	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR mythread_j_676$33246[rsp], 0
  000d3	eb 08		 jmp	 SHORT $LN8@wait_for_w
$LN7@wait_for_w:
  000d5	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR mythread_j_676$33246[rsp], 1
$LN8@wait_for_w:
  000dd	83 7c 24 28 00	 cmp	 DWORD PTR mythread_j_676$33246[rsp], 0
  000e2	0f 85 16 01 00
	00		 jne	 $LN6@wait_for_w
$LN5@wait_for_w:

; 677  : 		// There are four things that we wait. If one of them
; 678  : 		// becomes possible, we return.
; 679  : 		//  - If there is input left, we need to get a free
; 680  : 		//    worker thread and an output buffer for it.
; 681  : 		//  - Data ready to be read from the output queue.
; 682  : 		//  - A worker thread indicates an error.
; 683  : 		//  - Time out occurs.
; 684  : 		while ((!has_input || coder->threads_free == NULL
; 685  : 					|| !lzma_outq_has_buf(&coder->outq))
; 686  : 				&& !lzma_outq_is_readable(&coder->outq)
; 687  : 				&& coder->thread_error == LZMA_OK
; 688  : 				&& !timed_out) {

  000e8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR has_input$[rsp]
  000f0	85 c0		 test	 eax, eax
  000f2	74 50		 je	 SHORT $LN3@wait_for_w
  000f4	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  000f9	48 83 b8 48 01
	00 00 00	 cmp	 QWORD PTR [rax+328], 0
  00101	74 41		 je	 SHORT $LN3@wait_for_w
  00103	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00108	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0010e	48 89 44 24 30	 mov	 QWORD PTR $T81909[rsp], rax
  00113	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T81909[rsp]
  00118	48 8b 44 24 30	 mov	 rax, QWORD PTR $T81909[rsp]
  0011d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00120	39 41 20	 cmp	 DWORD PTR [rcx+32], eax
  00123	73 0a		 jae	 SHORT $LN27@wait_for_w
  00125	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0012d	eb 08		 jmp	 SHORT $LN28@wait_for_w
$LN27@wait_for_w:
  0012f	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN28@wait_for_w:
  00137	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv72[rsp]
  0013c	85 c0		 test	 eax, eax
  0013e	0f 85 b5 00 00
	00		 jne	 $LN4@wait_for_w
$LN3@wait_for_w:
  00144	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00149	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  00150	e8 00 00 00 00	 call	 lzma_outq_is_readable
  00155	0f b6 c0	 movzx	 eax, al
  00158	85 c0		 test	 eax, eax
  0015a	0f 85 99 00 00
	00		 jne	 $LN4@wait_for_w
  00160	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00165	83 b8 34 01 00
	00 00		 cmp	 DWORD PTR [rax+308], 0
  0016c	0f 85 87 00 00
	00		 jne	 $LN4@wait_for_w
  00172	0f b6 44 24 20	 movzx	 eax, BYTE PTR timed_out$33244[rsp]
  00177	85 c0		 test	 eax, eax
  00179	75 7e		 jne	 SHORT $LN4@wait_for_w

; 689  : 			if (coder->timeout != 0)

  0017b	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00180	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [rax+304], 0
  00187	74 43		 je	 SHORT $LN2@wait_for_w

; 690  : 				timed_out = mythread_cond_timedwait(
; 691  : 						&coder->cond, &coder->mutex,
; 692  : 						wait_abs) != 0;

  00189	48 8b 54 24 70	 mov	 rdx, QWORD PTR coder$[rsp]
  0018e	48 81 c2 68 01
	00 00		 add	 rdx, 360		; 00000168H
  00195	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  0019a	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  001a1	4c 8b 44 24 78	 mov	 r8, QWORD PTR wait_abs$[rsp]
  001a6	e8 00 00 00 00	 call	 mythread_cond_timedwait
  001ab	85 c0		 test	 eax, eax
  001ad	74 0a		 je	 SHORT $LN17@wait_for_w
  001af	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  001b7	eb 08		 jmp	 SHORT $LN18@wait_for_w
$LN17@wait_for_w:
  001b9	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN18@wait_for_w:
  001c1	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv140[rsp]
  001c6	88 44 24 20	 mov	 BYTE PTR timed_out$33244[rsp], al

; 693  : 			else

  001ca	eb 28		 jmp	 SHORT $LN1@wait_for_w
$LN2@wait_for_w:

; 694  : 				mythread_cond_wait(&coder->cond,
; 695  : 						&coder->mutex);

  001cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR coder$[rsp]
  001d1	48 81 c2 68 01
	00 00		 add	 rdx, 360		; 00000168H
  001d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  001dd	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  001e4	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  001f0	89 44 24 44	 mov	 DWORD PTR ret$81917[rsp], eax
$LN1@wait_for_w:

; 696  : 		}

  001f4	e9 ef fe ff ff	 jmp	 $LN5@wait_for_w
$LN4@wait_for_w:

; 697  : 	}

  001f9	e9 d7 fe ff ff	 jmp	 $LN7@wait_for_w
$LN6@wait_for_w:
  001fe	e9 78 fe ff ff	 jmp	 $LN10@wait_for_w
$LN9@wait_for_w:

; 698  :   }
; 699  : 
; 700  : 	return timed_out;

  00203	8a 44 24 20	 mov	 al, BYTE PTR timed_out$33244[rsp]

; 701  :   }
; 702  : }

  00207	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0020b	c3		 ret	 0
wait_for_work ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$threads_end DD imagerel threads_end
	DD	imagerel threads_end+487
	DD	imagerel $unwind$threads_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threads_end DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT threads_end
_TEXT	SEGMENT
i$ = 32
mythread_i_477$33121 = 36
mythread_j_477$33122 = 40
ret$33132 = 44
$T81929 = 48
$T81933 = 56
$T81937 = 64
ret$81941 = 72
$T81944 = 80
tv80 = 88
coder$ = 112
allocator$ = 120
threads_end PROC					; COMDAT

; 474  : { uint32_t i;

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 475  : 
; 476  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0b		 jmp	 SHORT $LN12@threads_en
$LN11@threads_en:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN12@threads_en:
  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00028	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0002e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00032	0f 83 02 01 00
	00		 jae	 $LN10@threads_en

; 477  : 		mythread_sync(coder->threads[i].mutex) {

  00038	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_i_477$33121[rsp], 0
  00040	eb 08		 jmp	 SHORT $LN9@threads_en
$LN8@threads_en:
  00042	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_i_477$33121[rsp], 1
$LN9@threads_en:
  0004a	83 7c 24 24 00	 cmp	 DWORD PTR mythread_i_477$33121[rsp], 0
  0004f	74 39		 je	 SHORT $LN15@threads_en
  00051	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00055	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00061	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00068	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00070	48 89 44 24 30	 mov	 QWORD PTR $T81929[rsp], rax
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T81929[rsp]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00080	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00088	eb 37		 jmp	 SHORT $LN16@threads_en
$LN15@threads_en:
  0008a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0008e	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  00095	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0009a	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  000a1	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  000a9	48 89 44 24 38	 mov	 QWORD PTR $T81933[rsp], rax
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T81933[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000b9	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN16@threads_en:
  000c1	83 7c 24 58 00	 cmp	 DWORD PTR tv80[rsp], 0
  000c6	74 6d		 je	 SHORT $LN7@threads_en
  000c8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR mythread_j_477$33122[rsp], 0
  000d0	eb 08		 jmp	 SHORT $LN6@threads_en
$LN5@threads_en:
  000d2	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR mythread_j_477$33122[rsp], 1
$LN6@threads_en:
  000da	83 7c 24 28 00	 cmp	 DWORD PTR mythread_j_477$33122[rsp], 0
  000df	75 4f		 jne	 SHORT $LN4@threads_en

; 478  : 			coder->threads[i].state = THR_EXIT;

  000e1	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000e5	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  000f1	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  000f8	c7 04 01 04 00
	00 00		 mov	 DWORD PTR [rcx+rax], 4

; 479  : 			mythread_cond_signal(&coder->threads[i].cond);

  000ff	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00103	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0010a	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0010f	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00116	48 8d 84 08 88
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+392]
  0011e	48 89 44 24 40	 mov	 QWORD PTR $T81937[rsp], rax
  00123	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T81937[rsp]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 480  : 		}

  0012e	eb a2		 jmp	 SHORT $LN5@threads_en
$LN4@threads_en:
  00130	e9 0d ff ff ff	 jmp	 $LN8@threads_en
$LN7@threads_en:

; 481  : 	}

  00135	e9 de fe ff ff	 jmp	 $LN11@threads_en
$LN10@threads_en:

; 482  : 
; 483  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  0013a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00142	eb 0b		 jmp	 SHORT $LN3@threads_en
$LN2@threads_en:
  00144	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@threads_en:
  0014f	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00154	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0015a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0015e	73 6c		 jae	 SHORT $LN1@threads_en

; 484  : 		int ret = mythread_join(coder->threads[i].thread_id);

  00160	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00164	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0016b	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00170	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00177	48 8b 84 08 90
	01 00 00	 mov	 rax, QWORD PTR [rax+rcx+400]
  0017f	48 89 44 24 50	 mov	 QWORD PTR $T81944[rsp], rax
  00184	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR ret$81941[rsp], 0
  0018c	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T81944[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0019c	85 c0		 test	 eax, eax
  0019e	74 08		 je	 SHORT $LN24@threads_en
  001a0	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR ret$81941[rsp], -1
$LN24@threads_en:
  001a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T81944[rsp]
  001ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  001b3	85 c0		 test	 eax, eax
  001b5	75 08		 jne	 SHORT $LN23@threads_en
  001b7	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR ret$81941[rsp], -1
$LN23@threads_en:
  001bf	8b 44 24 48	 mov	 eax, DWORD PTR ret$81941[rsp]
  001c3	89 44 24 2c	 mov	 DWORD PTR ret$33132[rsp], eax

; 485  : 		assert(ret == 0);
; 486  : 		(void)ret;
; 487  : 	}

  001c7	e9 78 ff ff ff	 jmp	 $LN2@threads_en
$LN1@threads_en:

; 488  : 
; 489  : 	lzma_free(coder->threads, allocator);

  001cc	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  001d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  001d6	48 8b 89 38 01
	00 00		 mov	 rcx, QWORD PTR [rcx+312]
  001dd	e8 00 00 00 00	 call	 lzma_free

; 490  : 	return;
; 491  : }

  001e2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001e6	c3		 ret	 0
threads_end ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$threads_stop DD imagerel threads_stop
	DD	imagerel threads_stop+740
	DD	imagerel $unwind$threads_stop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threads_stop DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT threads_stop
_TEXT	SEGMENT
i$ = 32
mythread_j_448$33089 = 36
mythread_i_448$33088 = 40
mythread_j_459$33101 = 44
mythread_i_459$33100 = 48
$T81957 = 56
$T81961 = 64
$T81965 = 72
$T81969 = 80
$T81973 = 88
ret$81977 = 96
$T81978 = 104
$T81979 = 112
tv80 = 120
tv143 = 124
coder$ = 144
wait_for_threads$ = 152
threads_stop PROC					; COMDAT

; 444  : { uint32_t i;

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 445  : 
; 446  : 	// Tell the threads to stop.
; 447  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  00010	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00018	eb 0b		 jmp	 SHORT $LN21@threads_st
$LN20@threads_st:
  0001a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN21@threads_st:
  00025	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00033	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00037	0f 83 0e 01 00
	00		 jae	 $LN19@threads_st

; 448  : 		mythread_sync(coder->threads[i].mutex) {

  0003d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR mythread_i_448$33088[rsp], 0
  00045	eb 08		 jmp	 SHORT $LN18@threads_st
$LN17@threads_st:
  00047	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR mythread_i_448$33088[rsp], 1
$LN18@threads_st:
  0004f	83 7c 24 28 00	 cmp	 DWORD PTR mythread_i_448$33088[rsp], 0
  00054	74 3c		 je	 SHORT $LN24@threads_st
  00056	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0005a	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  00061	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00069	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00070	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00078	48 89 44 24 38	 mov	 QWORD PTR $T81957[rsp], rax
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T81957[rsp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00088	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00090	eb 3a		 jmp	 SHORT $LN25@threads_st
$LN24@threads_st:
  00092	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00096	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0009d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000a5	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  000ac	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  000b4	48 89 44 24 40	 mov	 QWORD PTR $T81961[rsp], rax
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T81961[rsp]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000c4	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN25@threads_st:
  000cc	83 7c 24 78 00	 cmp	 DWORD PTR tv80[rsp], 0
  000d1	74 73		 je	 SHORT $LN16@threads_st
  000d3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_j_448$33089[rsp], 0
  000db	eb 08		 jmp	 SHORT $LN15@threads_st
$LN14@threads_st:
  000dd	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_j_448$33089[rsp], 1
$LN15@threads_st:
  000e5	83 7c 24 24 00	 cmp	 DWORD PTR mythread_j_448$33089[rsp], 0
  000ea	75 55		 jne	 SHORT $LN13@threads_st

; 449  : 			coder->threads[i].state = THR_STOP;

  000ec	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000f0	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  000f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000ff	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00106	c7 04 01 03 00
	00 00		 mov	 DWORD PTR [rcx+rax], 3

; 450  : 			mythread_cond_signal(&coder->threads[i].cond);

  0010d	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00111	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  00118	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00120	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00127	48 8d 84 08 88
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+392]
  0012f	48 89 44 24 48	 mov	 QWORD PTR $T81965[rsp], rax
  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T81965[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 451  : 		}

  0013f	eb 9c		 jmp	 SHORT $LN14@threads_st
$LN13@threads_st:
  00141	e9 01 ff ff ff	 jmp	 $LN17@threads_st
$LN16@threads_st:

; 452  : 	}

  00146	e9 cf fe ff ff	 jmp	 $LN20@threads_st
$LN19@threads_st:

; 453  : 
; 454  : 	if (!wait_for_threads)

  0014b	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR wait_for_threads$[rsp]
  00153	85 c0		 test	 eax, eax
  00155	75 05		 jne	 SHORT $LN12@threads_st

; 455  : 		return;

  00157	e9 80 01 00 00	 jmp	 $LN22@threads_st
$LN12@threads_st:

; 456  : 
; 457  : 	// Wait for the threads to settle in the idle state.
; 458  : 	for (i = 0; i < coder->threads_initialized; ++i) {

  0015c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00164	eb 0b		 jmp	 SHORT $LN11@threads_st
$LN10@threads_st:
  00166	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN11@threads_st:
  00171	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00179	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0017f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00183	0f 83 53 01 00
	00		 jae	 $LN9@threads_st

; 459  : 		mythread_sync(coder->threads[i].mutex) {

  00189	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR mythread_i_459$33100[rsp], 0
  00191	eb 08		 jmp	 SHORT $LN8@threads_st
$LN7@threads_st:
  00193	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR mythread_i_459$33100[rsp], 1
$LN8@threads_st:
  0019b	83 7c 24 30 00	 cmp	 DWORD PTR mythread_i_459$33100[rsp], 0
  001a0	74 3c		 je	 SHORT $LN26@threads_st
  001a2	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001a6	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  001ad	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001b5	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  001bc	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  001c4	48 89 44 24 50	 mov	 QWORD PTR $T81969[rsp], rax
  001c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T81969[rsp]
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  001d4	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
  001dc	eb 3a		 jmp	 SHORT $LN27@threads_st
$LN26@threads_st:
  001de	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001e2	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  001e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001f1	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  001f8	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00200	48 89 44 24 58	 mov	 QWORD PTR $T81973[rsp], rax
  00205	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T81973[rsp]
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00210	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
$LN27@threads_st:
  00218	83 7c 24 7c 00	 cmp	 DWORD PTR tv143[rsp], 0
  0021d	0f 84 b4 00 00
	00		 je	 $LN6@threads_st
  00223	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR mythread_j_459$33101[rsp], 0
  0022b	eb 08		 jmp	 SHORT $LN5@threads_st
$LN4@threads_st:
  0022d	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR mythread_j_459$33101[rsp], 1
$LN5@threads_st:
  00235	83 7c 24 2c 00	 cmp	 DWORD PTR mythread_j_459$33101[rsp], 0
  0023a	0f 85 92 00 00
	00		 jne	 $LN3@threads_st
$LN2@threads_st:

; 460  : 			while (coder->threads[i].state != THR_IDLE)

  00240	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00244	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0024b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00253	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  0025a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0025e	74 6d		 je	 SHORT $LN1@threads_st

; 461  : 				mythread_cond_wait(&coder->threads[i].cond,
; 462  : 						&coder->threads[i].mutex);

  00260	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00264	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0026b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00273	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  0027a	48 8d 84 08 60
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+352]
  00282	48 89 44 24 70	 mov	 QWORD PTR $T81979[rsp], rax
  00287	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0028b	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  00292	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0029a	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  002a1	48 8d 84 08 88
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+392]
  002a9	48 89 44 24 68	 mov	 QWORD PTR $T81978[rsp], rax
  002ae	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  002b4	48 8b 54 24 70	 mov	 rdx, QWORD PTR $T81979[rsp]
  002b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T81978[rsp]
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  002c4	89 44 24 60	 mov	 DWORD PTR ret$81977[rsp], eax
  002c8	e9 73 ff ff ff	 jmp	 $LN2@threads_st
$LN1@threads_st:

; 463  : 		}

  002cd	e9 5b ff ff ff	 jmp	 $LN4@threads_st
$LN3@threads_st:
  002d2	e9 bc fe ff ff	 jmp	 $LN7@threads_st
$LN6@threads_st:

; 464  : 	}

  002d7	e9 8a fe ff ff	 jmp	 $LN10@threads_st
$LN9@threads_st:
$LN22@threads_st:

; 465  : 
; 466  : 	return;
; 467  : }

  002dc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002e3	c3		 ret	 0
threads_stop ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$worker_error DD imagerel worker_error
	DD	imagerel worker_error+230
	DD	imagerel $unwind$worker_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$worker_error DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT worker_error
_TEXT	SEGMENT
mythread_i_188$32967 = 32
mythread_j_188$32968 = 36
$T81990 = 40
$T81994 = 48
$T81998 = 56
tv71 = 64
thr$ = 96
ret$ = 104
worker_error PROC					; COMDAT

; 183  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 184  : 	assert(ret != LZMA_OK);
; 185  : 	assert(ret != LZMA_STREAM_END);
; 186  : 
; 187  :   {
; 188  : 	mythread_sync(thr->coder->mutex) {

  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR mythread_i_188$32967[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN7@worker_err
$LN6@worker_err:
  00017	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR mythread_i_188$32967[rsp], 1
$LN7@worker_err:
  0001f	83 7c 24 20 00	 cmp	 DWORD PTR mythread_i_188$32967[rsp], 0
  00024	74 29		 je	 SHORT $LN10@worker_err
  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR thr$[rsp]
  0002b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002f	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  00035	48 89 44 24 28	 mov	 QWORD PTR $T81990[rsp], rax
  0003a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T81990[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00045	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004d	eb 27		 jmp	 SHORT $LN11@worker_err
$LN10@worker_err:
  0004f	48 8b 44 24 60	 mov	 rax, QWORD PTR thr$[rsp]
  00054	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00058	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  0005e	48 89 44 24 30	 mov	 QWORD PTR $T81994[rsp], rax
  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T81994[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  0006e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN11@worker_err:
  00076	83 7c 24 40 00	 cmp	 DWORD PTR tv71[rsp], 0
  0007b	74 64		 je	 SHORT $LN5@worker_err
  0007d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_j_188$32968[rsp], 0
  00085	eb 08		 jmp	 SHORT $LN4@worker_err
$LN3@worker_err:
  00087	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_j_188$32968[rsp], 1
$LN4@worker_err:
  0008f	83 7c 24 24 00	 cmp	 DWORD PTR mythread_j_188$32968[rsp], 0
  00094	75 46		 jne	 SHORT $LN2@worker_err

; 189  : 		if (thr->coder->thread_error == LZMA_OK)

  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR thr$[rsp]
  0009b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0009f	83 b8 34 01 00
	00 00		 cmp	 DWORD PTR [rax+308], 0
  000a6	75 13		 jne	 SHORT $LN1@worker_err

; 190  : 			thr->coder->thread_error = ret;

  000a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR thr$[rsp]
  000ad	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000b1	8b 44 24 68	 mov	 eax, DWORD PTR ret$[rsp]
  000b5	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN1@worker_err:

; 191  : 
; 192  : 		mythread_cond_signal(&thr->coder->cond);

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR thr$[rsp]
  000c0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c4	48 05 90 01 00
	00		 add	 rax, 400		; 00000190H
  000ca	48 89 44 24 38	 mov	 QWORD PTR $T81998[rsp], rax
  000cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T81998[rsp]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 193  : 	}

  000da	eb ab		 jmp	 SHORT $LN3@worker_err
$LN2@worker_err:
  000dc	e9 36 ff ff ff	 jmp	 $LN6@worker_err
$LN5@worker_err:

; 194  :   }
; 195  : 
; 196  : 	return;
; 197  : }

  000e1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e5	c3		 ret	 0
worker_error ENDP
PUBLIC	lzma_stream_encoder_mt_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_encoder_mt_memusage DD imagerel $LN9
	DD	imagerel $LN9+433
	DD	imagerel $unwind$lzma_stream_encoder_mt_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_encoder_mt_memusage DD 020c01H
	DD	027010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_stream_encoder_mt_memusage
_TEXT	SEGMENT
filters$ = 48
outbuf_size_max$ = 56
block_size$ = 64
easy$ = 80
inbuf_memusage$33490 = 272
filters_memusage$33491 = 280
outq_memusage$33493 = 288
total_memusage$33495 = 296
options$ = 320
lzma_stream_encoder_mt_memusage PROC			; COMDAT

; 1147 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 1148 : 	lzma_options_easy easy;
; 1149 : 	const lzma_filter *filters;
; 1150 : 	uint64_t block_size;
; 1151 : 	uint64_t outbuf_size_max;
; 1152 : 
; 1153 : 	if (get_options(options, &easy, &filters, &block_size,
; 1154 : 			&outbuf_size_max) != LZMA_OK)

  0000c	48 8d 44 24 38	 lea	 rax, QWORD PTR outbuf_size_max$[rsp]
  00011	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00016	4c 8d 4c 24 40	 lea	 r9, QWORD PTR block_size$[rsp]
  0001b	4c 8d 44 24 30	 lea	 r8, QWORD PTR filters$[rsp]
  00020	48 8d 54 24 50	 lea	 rdx, QWORD PTR easy$[rsp]
  00025	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  0002d	e8 00 00 00 00	 call	 get_options
  00032	85 c0		 test	 eax, eax
  00034	74 0c		 je	 SHORT $LN6@lzma_strea@6

; 1155 : 		return UINT64_MAX;

  00036	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0003d	e9 67 01 00 00	 jmp	 $LN7@lzma_strea@6
$LN6@lzma_strea@6:

; 1156 : 
; 1157 : 	// Memory usage of the input buffers
; 1158 :   {
; 1159 : 	const uint64_t inbuf_memusage = options->threads * block_size;

  00042	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  0004a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0004d	48 0f af 44 24
	40		 imul	 rax, QWORD PTR block_size$[rsp]
  00053	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR inbuf_memusage$33490[rsp], rax

; 1160 : 
; 1161 : 	// Memory usage of the filter encoders
; 1162 : 	uint64_t filters_memusage = lzma_raw_encoder_memusage(filters);

  0005b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filters$[rsp]
  00060	e8 00 00 00 00	 call	 lzma_raw_encoder_memusage
  00065	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR filters_memusage$33491[rsp], rax

; 1163 : 	if (filters_memusage == UINT64_MAX)

  0006d	48 83 bc 24 18
	01 00 00 ff	 cmp	 QWORD PTR filters_memusage$33491[rsp], -1
  00076	75 0c		 jne	 SHORT $LN5@lzma_strea@6

; 1164 : 		return UINT64_MAX;

  00078	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007f	e9 25 01 00 00	 jmp	 $LN7@lzma_strea@6
$LN5@lzma_strea@6:

; 1165 : 
; 1166 : 	filters_memusage *= options->threads;

  00084	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  0008c	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0008f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR filters_memusage$33491[rsp]
  00097	48 0f af c1	 imul	 rax, rcx
  0009b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR filters_memusage$33491[rsp], rax

; 1167 : 
; 1168 : 	// Memory usage of the output queue
; 1169 :   {
; 1170 : 	const uint64_t outq_memusage = lzma_outq_memusage(
; 1171 : 			outbuf_size_max, options->threads);

  000a3	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR outbuf_size_max$[rsp]
  000b3	e8 00 00 00 00	 call	 lzma_outq_memusage
  000b8	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR outq_memusage$33493[rsp], rax

; 1172 : 	if (outq_memusage == UINT64_MAX)

  000c0	48 83 bc 24 20
	01 00 00 ff	 cmp	 QWORD PTR outq_memusage$33493[rsp], -1
  000c9	75 0c		 jne	 SHORT $LN4@lzma_strea@6

; 1173 : 		return UINT64_MAX;

  000cb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000d2	e9 d2 00 00 00	 jmp	 $LN7@lzma_strea@6
$LN4@lzma_strea@6:

; 1174 : 
; 1175 : 	// Sum them with overflow checking.
; 1176 :   {
; 1177 : 	uint64_t total_memusage = LZMA_MEMUSAGE_BASE
; 1178 : 			+ sizeof(lzma_stream_coder)
; 1179 : 			+ options->threads * sizeof(worker_thread);

  000d7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  000df	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000e2	48 69 c0 98 01
	00 00		 imul	 rax, 408		; 00000198H
  000e9	48 05 98 81 00
	00		 add	 rax, 33176		; 00008198H
  000ef	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR total_memusage$33495[rsp], rax

; 1180 : 
; 1181 : 	if (UINT64_MAX - total_memusage < inbuf_memusage)

  000f7	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000fe	48 2b 84 24 28
	01 00 00	 sub	 rax, QWORD PTR total_memusage$33495[rsp]
  00106	48 3b 84 24 10
	01 00 00	 cmp	 rax, QWORD PTR inbuf_memusage$33490[rsp]
  0010e	73 0c		 jae	 SHORT $LN3@lzma_strea@6

; 1182 : 		return UINT64_MAX;

  00110	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00117	e9 8d 00 00 00	 jmp	 $LN7@lzma_strea@6
$LN3@lzma_strea@6:

; 1183 : 
; 1184 : 	total_memusage += inbuf_memusage;

  0011c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inbuf_memusage$33490[rsp]
  00124	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR total_memusage$33495[rsp]
  0012c	48 03 c1	 add	 rax, rcx
  0012f	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR total_memusage$33495[rsp], rax

; 1185 : 
; 1186 : 	if (UINT64_MAX - total_memusage < filters_memusage)

  00137	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0013e	48 2b 84 24 28
	01 00 00	 sub	 rax, QWORD PTR total_memusage$33495[rsp]
  00146	48 3b 84 24 18
	01 00 00	 cmp	 rax, QWORD PTR filters_memusage$33491[rsp]
  0014e	73 09		 jae	 SHORT $LN2@lzma_strea@6

; 1187 : 		return UINT64_MAX;

  00150	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00157	eb 50		 jmp	 SHORT $LN7@lzma_strea@6
$LN2@lzma_strea@6:

; 1188 : 
; 1189 : 	total_memusage += filters_memusage;

  00159	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR filters_memusage$33491[rsp]
  00161	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR total_memusage$33495[rsp]
  00169	48 03 c1	 add	 rax, rcx
  0016c	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR total_memusage$33495[rsp], rax

; 1190 : 
; 1191 : 	if (UINT64_MAX - total_memusage < outq_memusage)

  00174	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0017b	48 2b 84 24 28
	01 00 00	 sub	 rax, QWORD PTR total_memusage$33495[rsp]
  00183	48 3b 84 24 20
	01 00 00	 cmp	 rax, QWORD PTR outq_memusage$33493[rsp]
  0018b	73 09		 jae	 SHORT $LN1@lzma_strea@6

; 1192 : 		return UINT64_MAX;

  0018d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00194	eb 13		 jmp	 SHORT $LN7@lzma_strea@6
$LN1@lzma_strea@6:

; 1193 : 
; 1194 : 	return total_memusage + outq_memusage;

  00196	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR outq_memusage$33493[rsp]
  0019e	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR total_memusage$33495[rsp]
  001a6	48 03 c1	 add	 rax, rcx
$LN7@lzma_strea@6:

; 1195 :   }}}
; 1196 : }

  001a9	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  001b0	c3		 ret	 0
lzma_stream_encoder_mt_memusage ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$stream_encoder_mt_end DD imagerel stream_encoder_mt_end
	DD	imagerel stream_encoder_mt_end+215
	DD	imagerel $unwind$stream_encoder_mt_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encoder_mt_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT stream_encoder_mt_end
_TEXT	SEGMENT
coder$ = 32
i$33338 = 40
coder_ptr$ = 64
allocator$ = 72
stream_encoder_mt_end PROC				; COMDAT

; 881  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 882  : 	lzma_stream_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 883  : 
; 884  : 	// Threads must be killed before the output queue can be freed.
; 885  : 	threads_end(coder, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 threads_end

; 886  : 	lzma_outq_end(&coder->outq, allocator);

  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0002c	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  00033	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00038	e8 00 00 00 00	 call	 lzma_outq_end

; 887  : 
; 888  :   { size_t i;
; 889  : 
; 890  : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$33338[rsp], 0
  00046	eb 0e		 jmp	 SHORT $LN3@stream_enc@2
$LN2@stream_enc@2:
  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR i$33338[rsp]
  0004d	48 83 c0 01	 add	 rax, 1
  00051	48 89 44 24 28	 mov	 QWORD PTR i$33338[rsp], rax
$LN3@stream_enc@2:
  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$33338[rsp]
  0005b	48 6b c9 10	 imul	 rcx, 16
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00064	48 83 7c 08 10
	ff		 cmp	 QWORD PTR [rax+rcx+16], -1
  0006a	74 1f		 je	 SHORT $LN1@stream_enc@2

; 891  : 		lzma_free(coder->filters[i].options, allocator);

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$33338[rsp]
  00071	48 6b c0 10	 imul	 rax, 16
  00075	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0007f	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  00084	e8 00 00 00 00	 call	 lzma_free
  00089	eb bd		 jmp	 SHORT $LN2@stream_enc@2
$LN1@stream_enc@2:

; 892  :   }
; 893  : 
; 894  : 	lzma_next_end(&coder->index_encoder, allocator);

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00090	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00094	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00099	e8 00 00 00 00	 call	 lzma_next_end

; 895  : 	lzma_index_end(coder->index, allocator);

  0009e	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000a8	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ac	e8 00 00 00 00	 call	 lzma_index_end

; 896  : 
; 897  : 	mythread_cond_destroy(&coder->cond);
; 898  : 	mythread_mutex_destroy(&coder->mutex);

  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000b6	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 899  : 
; 900  : 	lzma_free(coder, allocator);

  000c3	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  000c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000cd	e8 00 00 00 00	 call	 lzma_free

; 901  : 	return;
; 902  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
stream_encoder_mt_end ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$worker_encode DD imagerel worker_encode
	DD	imagerel worker_encode+1641
	DD	imagerel $unwind$worker_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$worker_encode DD 021001H
	DD	0170110H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT worker_encode
_TEXT	SEGMENT
ret$32985 = 80
in_size$32989 = 88
in_pos$32988 = 96
out_size$32990 = 104
mythread_j_254$32995 = 112
mythread_i_254$32994 = 116
action$33006 = 120
in_limit$33009 = 128
mythread_i_320$33020 = 136
mythread_j_320$33021 = 140
ret$84149 = 144
ret$84159 = 148
tv140 = 152
tv157 = 156
tv183 = 160
tv198 = 164
thr$ = 192
state$ = 200
worker_encode PROC					; COMDAT

; 202  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 203  : 	assert(thr->progress_in == 0);
; 204  : 	assert(thr->progress_out == 0);
; 205  : 
; 206  : 	// Set the Block options.
; 207  :   /*
; 208  : 	thr->block_options = (lzma_block){
; 209  : 		.version = 0,
; 210  : 		.check = thr->coder->stream_flags.check,
; 211  : 		.compressed_size = thr->coder->outq.buf_size_max,
; 212  : 		.uncompressed_size = thr->coder->block_size,
; 213  : 
; 214  : 		// TODO: To allow changing the filter chain, the filters
; 215  : 		// array must be copied to each worker_thread.
; 216  : 		.filters = thr->coder->filters,
; 217  : 	};
; 218  :   */
; 219  :   memset (&thr->block_options, 0, sizeof(lzma_block));

  00010	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00018	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  0001f	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  00025	33 d2		 xor	 edx, edx
  00027	e8 00 00 00 00	 call	 memset

; 220  :   thr->block_options.version = 0;

  0002c	4c 8b 9c 24 c0
	00 00 00	 mov	 r11, QWORD PTR thr$[rsp]
  00034	41 c7 83 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r11+136], 0

; 221  :   thr->block_options.check = thr->coder->stream_flags.check;

  0003f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00047	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00053	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [rax+192]
  00059	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 222  :   thr->block_options.compressed_size = thr->coder->outq.buf_size_max;

  0005f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00067	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00073	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  0007a	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 223  :   thr->block_options.uncompressed_size = thr->coder->block_size;

  00081	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00089	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00095	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00099	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 224  :   thr->block_options.filters = thr->coder->filters;

  000a0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  000a8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ac	48 83 c1 10	 add	 rcx, 16
  000b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  000b8	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 225  : 
; 226  : 	// Calculate maximum size of the Block Header. This amount is
; 227  : 	// reserved in the beginning of the buffer so that Block Header
; 228  : 	// along with Compressed Size and Uncompressed Size can be
; 229  : 	// written there.
; 230  :   {
; 231  : 	lzma_ret ret = lzma_block_header_size(&thr->block_options);

  000bf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  000c7	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  000ce	e8 00 00 00 00	 call	 lzma_block_header_size
  000d3	89 44 24 50	 mov	 DWORD PTR ret$32985[rsp], eax

; 232  : 	if (ret != LZMA_OK) {

  000d7	83 7c 24 50 00	 cmp	 DWORD PTR ret$32985[rsp], 0
  000dc	74 1b		 je	 SHORT $LN32@worker_enc@2

; 233  : 		worker_error(thr, ret);

  000de	8b 54 24 50	 mov	 edx, DWORD PTR ret$32985[rsp]
  000e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  000ea	e8 00 00 00 00	 call	 worker_error

; 234  : 		return THR_STOP;

  000ef	b8 03 00 00 00	 mov	 eax, 3
  000f4	e9 68 05 00 00	 jmp	 $LN33@worker_enc@2
$LN32@worker_enc@2:

; 235  : 	}
; 236  : 
; 237  : 	// Initialize the Block encoder.
; 238  : 	ret = lzma_block_encoder_init(&thr->block_encoder,
; 239  : 			thr->allocator, &thr->block_options);

  000f9	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR thr$[rsp]
  00101	49 81 c0 88 00
	00 00		 add	 r8, 136			; 00000088H
  00108	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00110	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00114	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  0011c	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00120	e8 00 00 00 00	 call	 lzma_block_encoder_init
  00125	89 44 24 50	 mov	 DWORD PTR ret$32985[rsp], eax

; 240  : 	if (ret != LZMA_OK) {

  00129	83 7c 24 50 00	 cmp	 DWORD PTR ret$32985[rsp], 0
  0012e	74 1b		 je	 SHORT $LN31@worker_enc@2

; 241  : 		worker_error(thr, ret);

  00130	8b 54 24 50	 mov	 edx, DWORD PTR ret$32985[rsp]
  00134	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0013c	e8 00 00 00 00	 call	 worker_error

; 242  : 		return THR_STOP;

  00141	b8 03 00 00 00	 mov	 eax, 3
  00146	e9 16 05 00 00	 jmp	 $LN33@worker_enc@2
$LN31@worker_enc@2:

; 243  : 	}
; 244  : 
; 245  :   {
; 246  : 	size_t in_pos = 0;

  0014b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR in_pos$32988[rsp], 0

; 247  : 	size_t in_size = 0;

  00154	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR in_size$32989[rsp], 0

; 248  : 
; 249  : 	thr->outbuf->size = thr->block_options.header_size;

  0015d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00165	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00169	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00171	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [rax+140]
  00177	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 250  :   {
; 251  : 	const size_t out_size = thr->coder->outq.buf_size_max;

  0017b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00183	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00187	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  0018e	48 89 44 24 68	 mov	 QWORD PTR out_size$32990[rsp], rax
$LN30@worker_enc@2:

; 252  : 
; 253  : 	do {
; 254  : 		mythread_sync(thr->mutex) {

  00193	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR mythread_i_254$32994[rsp], 0
  0019b	eb 08		 jmp	 SHORT $LN27@worker_enc@2
$LN26@worker_enc@2:
  0019d	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR mythread_i_254$32994[rsp], 1
$LN27@worker_enc@2:
  001a5	83 7c 24 74 00	 cmp	 DWORD PTR mythread_i_254$32994[rsp], 0
  001aa	74 22		 je	 SHORT $LN35@worker_enc@2
  001ac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  001b4	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  001c1	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
  001cc	eb 20		 jmp	 SHORT $LN36@worker_enc@2
$LN35@worker_enc@2:
  001ce	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  001d6	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  001e3	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv140[rsp], 1
$LN36@worker_enc@2:
  001ee	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv140[rsp], 0
  001f6	0f 84 c9 00 00
	00		 je	 $LN25@worker_enc@2
  001fc	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR mythread_j_254$32995[rsp], 0
  00204	eb 08		 jmp	 SHORT $LN24@worker_enc@2
$LN23@worker_enc@2:
  00206	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR mythread_j_254$32995[rsp], 1
$LN24@worker_enc@2:
  0020e	83 7c 24 70 00	 cmp	 DWORD PTR mythread_j_254$32995[rsp], 0
  00213	0f 85 a7 00 00
	00		 jne	 $LN22@worker_enc@2

; 255  : 			// Store in_pos and out_pos into *thr so that
; 256  : 			// an application may read them via
; 257  : 			// lzma_get_progress() to get progress information.
; 258  : 			//
; 259  : 			// NOTE: These aren't updated when the encoding
; 260  : 			// finishes. Instead, the final values are taken
; 261  : 			// later from thr->outbuf.
; 262  : 			thr->progress_in = in_pos;

  00219	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR in_pos$32988[rsp]
  00226	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 263  : 			thr->progress_out = thr->outbuf->size;

  0022a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00232	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00236	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0023e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00242	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN21@worker_enc@2:

; 264  : 
; 265  : 			while (in_size == thr->in_size
; 266  : 					&& thr->state == THR_RUN)

  00246	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  0024e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00252	48 39 44 24 58	 cmp	 QWORD PTR in_size$32989[rsp], rax
  00257	75 40		 jne	 SHORT $LN20@worker_enc@2
  00259	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00261	83 38 01	 cmp	 DWORD PTR [rax], 1
  00264	75 33		 jne	 SHORT $LN20@worker_enc@2

; 267  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  00266	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  0026e	48 81 c2 60 01
	00 00		 add	 rdx, 352		; 00000160H
  00275	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0027d	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  00284	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  00290	89 84 24 90 00
	00 00		 mov	 DWORD PTR ret$84149[rsp], eax
  00297	eb ad		 jmp	 SHORT $LN21@worker_enc@2
$LN20@worker_enc@2:

; 268  : 
; 269  : 			state = thr->state;

  00299	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  002a1	8b 00		 mov	 eax, DWORD PTR [rax]
  002a3	89 84 24 c8 00
	00 00		 mov	 DWORD PTR state$[rsp], eax

; 270  : 			in_size = thr->in_size;

  002aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  002b2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002b6	48 89 44 24 58	 mov	 QWORD PTR in_size$32989[rsp], rax
  002bb	e9 46 ff ff ff	 jmp	 $LN23@worker_enc@2
$LN22@worker_enc@2:

; 271  : 		}

  002c0	e9 d8 fe ff ff	 jmp	 $LN26@worker_enc@2
$LN25@worker_enc@2:

; 272  : 
; 273  : 		// Return if we were asked to stop or exit.
; 274  : 		if (state >= THR_STOP)

  002c5	83 bc 24 c8 00
	00 00 03	 cmp	 DWORD PTR state$[rsp], 3
  002cd	7c 0c		 jl	 SHORT $LN19@worker_enc@2

; 275  : 			return state;

  002cf	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR state$[rsp]
  002d6	e9 86 03 00 00	 jmp	 $LN33@worker_enc@2
$LN19@worker_enc@2:

; 276  : 
; 277  :     {
; 278  : 		lzma_action action = state == THR_FINISH
; 279  : 				? LZMA_FINISH : LZMA_RUN;

  002db	83 bc 24 c8 00
	00 00 02	 cmp	 DWORD PTR state$[rsp], 2
  002e3	75 0d		 jne	 SHORT $LN37@worker_enc@2
  002e5	c7 84 24 9c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv157[rsp], 3
  002f0	eb 0b		 jmp	 SHORT $LN38@worker_enc@2
$LN37@worker_enc@2:
  002f2	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv157[rsp], 0
$LN38@worker_enc@2:
  002fd	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv157[rsp]
  00304	89 44 24 78	 mov	 DWORD PTR action$33006[rsp], eax

; 280  : 
; 281  : 		// Limit the amount of input given to the Block encoder
; 282  : 		// at once. This way this thread can react fairly quickly
; 283  : 		// if the main thread wants us to stop or exit.
; 284  : 		static const size_t in_chunk_max = 16384;
; 285  : 		size_t in_limit = in_size;

  00308	48 8b 44 24 58	 mov	 rax, QWORD PTR in_size$32989[rsp]
  0030d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR in_limit$33009[rsp], rax

; 286  : 		if (in_size - in_pos > in_chunk_max) {

  00315	48 8b 4c 24 60	 mov	 rcx, QWORD PTR in_pos$32988[rsp]
  0031a	48 8b 44 24 58	 mov	 rax, QWORD PTR in_size$32989[rsp]
  0031f	48 2b c1	 sub	 rax, rcx
  00322	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ?in_chunk_max@?9??worker_encode@@9@9
  00329	76 1f		 jbe	 SHORT $LN18@worker_enc@2

; 287  : 			in_limit = in_pos + in_chunk_max;

  0032b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?in_chunk_max@?9??worker_encode@@9@9
  00332	48 8b 44 24 60	 mov	 rax, QWORD PTR in_pos$32988[rsp]
  00337	48 03 c1	 add	 rax, rcx
  0033a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR in_limit$33009[rsp], rax

; 288  : 			action = LZMA_RUN;

  00342	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR action$33006[rsp], 0
$LN18@worker_enc@2:

; 289  : 		}
; 290  : 
; 291  : 		ret = thr->block_encoder.code(
; 292  : 				thr->block_encoder.coder, thr->allocator,
; 293  : 				thr->in, &in_pos, in_limit, thr->outbuf->buf,
; 294  : 				&thr->outbuf->size, out_size, action);

  0034a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  00352	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00356	48 83 c2 08	 add	 rdx, 8
  0035a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00362	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00366	8b 44 24 78	 mov	 eax, DWORD PTR action$33006[rsp]
  0036a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0036e	48 8b 44 24 68	 mov	 rax, QWORD PTR out_size$32990[rsp]
  00373	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00378	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  0037d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00380	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00385	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR in_limit$33009[rsp]
  0038d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00392	4c 8d 4c 24 60	 lea	 r9, QWORD PTR in_pos$32988[rsp]
  00397	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR thr$[rsp]
  0039f	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  003a3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  003ab	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  003af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  003b7	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  003bb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  003c3	ff 50 58	 call	 QWORD PTR [rax+88]
  003c6	89 44 24 50	 mov	 DWORD PTR ret$32985[rsp], eax

; 295  :     }
; 296  : 	} while (ret == LZMA_OK && thr->outbuf->size < out_size);

  003ca	83 7c 24 50 00	 cmp	 DWORD PTR ret$32985[rsp], 0
  003cf	75 1b		 jne	 SHORT $LN17@worker_enc@2
  003d1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  003d9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  003dd	48 8b 44 24 68	 mov	 rax, QWORD PTR out_size$32990[rsp]
  003e2	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  003e6	0f 82 a7 fd ff
	ff		 jb	 $LN30@worker_enc@2
$LN17@worker_enc@2:

; 297  : 
; 298  : 	switch (ret) {

  003ec	8b 44 24 50	 mov	 eax, DWORD PTR ret$32985[rsp]
  003f0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  003f7	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv183[rsp], 0
  003ff	74 5d		 je	 SHORT $LN12@worker_enc@2
  00401	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR tv183[rsp], 1
  00409	74 05		 je	 SHORT $LN14@worker_enc@2
  0040b	e9 ee 01 00 00	 jmp	 $LN1@worker_enc@2
$LN14@worker_enc@2:

; 299  : 	case LZMA_STREAM_END:
; 300  : 		assert(state == THR_FINISH);
; 301  : 
; 302  : 		// Encode the Block Header. By doing it after
; 303  : 		// the compression, we can store the Compressed Size
; 304  : 		// and Uncompressed Size fields.
; 305  : 		ret = lzma_block_header_encode(&thr->block_options,
; 306  : 				thr->outbuf->buf);

  00410	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  00418	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0041c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00424	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  0042b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0042e	e8 00 00 00 00	 call	 lzma_block_header_encode
  00433	89 44 24 50	 mov	 DWORD PTR ret$32985[rsp], eax

; 307  : 		if (ret != LZMA_OK) {

  00437	83 7c 24 50 00	 cmp	 DWORD PTR ret$32985[rsp], 0
  0043c	74 1b		 je	 SHORT $LN13@worker_enc@2

; 308  : 			worker_error(thr, ret);

  0043e	8b 54 24 50	 mov	 edx, DWORD PTR ret$32985[rsp]
  00442	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0044a	e8 00 00 00 00	 call	 worker_error

; 309  : 			return THR_STOP;

  0044f	b8 03 00 00 00	 mov	 eax, 3
  00454	e9 08 02 00 00	 jmp	 $LN33@worker_enc@2
$LN13@worker_enc@2:

; 310  : 		}
; 311  : 
; 312  : 		break;

  00459	e9 b8 01 00 00	 jmp	 $LN15@worker_enc@2
$LN12@worker_enc@2:

; 313  : 
; 314  : 	case LZMA_OK:
; 315  : 		// The data was incompressible. Encode it using uncompressed
; 316  : 		// LZMA2 chunks.
; 317  : 		//
; 318  : 		// First wait that we have gotten all the input.
; 319  :     {
; 320  : 		mythread_sync(thr->mutex) {

  0045e	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR mythread_i_320$33020[rsp], 0
  00469	eb 0b		 jmp	 SHORT $LN11@worker_enc@2
$LN10@worker_enc@2:
  0046b	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mythread_i_320$33020[rsp], 1
$LN11@worker_enc@2:
  00476	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR mythread_i_320$33020[rsp], 0
  0047e	74 22		 je	 SHORT $LN39@worker_enc@2
  00480	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00488	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  0048f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00495	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv198[rsp], 0
  004a0	eb 20		 jmp	 SHORT $LN40@worker_enc@2
$LN39@worker_enc@2:
  004a2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  004aa	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  004b7	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv198[rsp], 1
$LN40@worker_enc@2:
  004c2	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv198[rsp], 0
  004ca	0f 84 8b 00 00
	00		 je	 $LN9@worker_enc@2
  004d0	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR mythread_j_320$33021[rsp], 0
  004db	eb 0b		 jmp	 SHORT $LN8@worker_enc@2
$LN7@worker_enc@2:
  004dd	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mythread_j_320$33021[rsp], 1
$LN8@worker_enc@2:
  004e8	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR mythread_j_320$33021[rsp], 0
  004f0	75 64		 jne	 SHORT $LN6@worker_enc@2
$LN5@worker_enc@2:

; 321  : 			while (thr->state == THR_RUN)

  004f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  004fa	83 38 01	 cmp	 DWORD PTR [rax], 1
  004fd	75 33		 jne	 SHORT $LN4@worker_enc@2

; 322  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  004ff	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  00507	48 81 c2 60 01
	00 00		 add	 rdx, 352		; 00000160H
  0050e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00516	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  0051d	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  00529	89 84 24 94 00
	00 00		 mov	 DWORD PTR ret$84159[rsp], eax
  00530	eb c0		 jmp	 SHORT $LN5@worker_enc@2
$LN4@worker_enc@2:

; 323  : 
; 324  : 			state = thr->state;

  00532	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  0053a	8b 00		 mov	 eax, DWORD PTR [rax]
  0053c	89 84 24 c8 00
	00 00		 mov	 DWORD PTR state$[rsp], eax

; 325  : 			in_size = thr->in_size;

  00543	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  0054b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0054f	48 89 44 24 58	 mov	 QWORD PTR in_size$32989[rsp], rax
  00554	eb 87		 jmp	 SHORT $LN7@worker_enc@2
$LN6@worker_enc@2:

; 326  : 		}

  00556	e9 10 ff ff ff	 jmp	 $LN10@worker_enc@2
$LN9@worker_enc@2:

; 327  :     }
; 328  : 
; 329  : 		if (state >= THR_STOP)

  0055b	83 bc 24 c8 00
	00 00 03	 cmp	 DWORD PTR state$[rsp], 3
  00563	7c 0c		 jl	 SHORT $LN3@worker_enc@2

; 330  : 			return state;

  00565	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR state$[rsp]
  0056c	e9 f0 00 00 00	 jmp	 $LN33@worker_enc@2
$LN3@worker_enc@2:

; 331  : 
; 332  : 		// Do the encoding. This takes care of the Block Header too.
; 333  : 		thr->outbuf->size = 0;

  00571	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00579	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0057d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 334  : 		ret = lzma_block_uncomp_encode(&thr->block_options,
; 335  : 				thr->in, in_size, thr->outbuf->buf,
; 336  : 				&thr->outbuf->size, out_size);

  00585	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  0058d	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00591	48 83 c2 08	 add	 rdx, 8
  00595	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR thr$[rsp]
  0059d	4d 8b 49 18	 mov	 r9, QWORD PTR [r9+24]
  005a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  005a9	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  005b0	48 8b 44 24 68	 mov	 rax, QWORD PTR out_size$32990[rsp]
  005b5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005ba	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  005bf	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  005c2	4c 8b 44 24 58	 mov	 r8, QWORD PTR in_size$32989[rsp]
  005c7	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thr$[rsp]
  005cf	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  005d3	e8 00 00 00 00	 call	 lzma_block_uncomp_encode
  005d8	89 44 24 50	 mov	 DWORD PTR ret$32985[rsp], eax

; 337  : 
; 338  : 		// It shouldn't fail.
; 339  : 		if (ret != LZMA_OK) {

  005dc	83 7c 24 50 00	 cmp	 DWORD PTR ret$32985[rsp], 0
  005e1	74 19		 je	 SHORT $LN2@worker_enc@2

; 340  : 			worker_error(thr, LZMA_PROG_ERROR);

  005e3	ba 0b 00 00 00	 mov	 edx, 11
  005e8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  005f0	e8 00 00 00 00	 call	 worker_error

; 341  : 			return THR_STOP;

  005f5	b8 03 00 00 00	 mov	 eax, 3
  005fa	eb 65		 jmp	 SHORT $LN33@worker_enc@2
$LN2@worker_enc@2:

; 342  : 		}
; 343  : 
; 344  : 		break;

  005fc	eb 18		 jmp	 SHORT $LN15@worker_enc@2
$LN1@worker_enc@2:

; 345  : 
; 346  : 	default:
; 347  : 		worker_error(thr, ret);

  005fe	8b 54 24 50	 mov	 edx, DWORD PTR ret$32985[rsp]
  00602	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0060a	e8 00 00 00 00	 call	 worker_error

; 348  : 		return THR_STOP;

  0060f	b8 03 00 00 00	 mov	 eax, 3
  00614	eb 4b		 jmp	 SHORT $LN33@worker_enc@2
$LN15@worker_enc@2:

; 349  :   }
; 350  :   }}}
; 351  : 
; 352  : 	// Set the size information that will be read by the main thread
; 353  : 	// to write the Index field.
; 354  : 	thr->outbuf->unpadded_size
; 355  : 			= lzma_block_unpadded_size(&thr->block_options);

  00616	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  0061e	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00625	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  0062a	4c 8b d8	 mov	 r11, rax
  0062d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00635	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00639	4c 89 58 10	 mov	 QWORD PTR [rax+16], r11

; 356  : 	assert(thr->outbuf->unpadded_size != 0);
; 357  : 	thr->outbuf->uncompressed_size = thr->block_options.uncompressed_size;

  0063d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR thr$[rsp]
  00645	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00649	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR thr$[rsp]
  00651	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00658	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 358  : 
; 359  : 	return THR_FINISH;

  0065c	b8 02 00 00 00	 mov	 eax, 2
$LN33@worker_enc@2:

; 360  : }

  00661	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00668	c3		 ret	 0
worker_encode ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$worker_start DD imagerel worker_start
	DD	imagerel worker_start+934
	DD	imagerel $unwind$worker_start
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$worker_start DD 010901H
	DD	0e209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT worker_start
_TEXT	SEGMENT
thr$ = 32
state$ = 40
mythread_i_371$33044 = 44
mythread_j_371$33045 = 48
mythread_j_401$33062 = 52
mythread_i_401$33061 = 56
mythread_i_410$33070 = 60
mythread_j_410$33071 = 64
ret$84339 = 68
$T84352 = 72
$T84356 = 80
$T84360 = 88
tv70 = 96
tv92 = 100
tv137 = 104
tv143 = 108
thr_ptr$ = 128
worker_start PROC					; COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 366  : 	worker_thread *thr = thr_ptr;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR thr_ptr$[rsp]
  00011	48 89 44 24 20	 mov	 QWORD PTR thr$[rsp], rax

; 367  : 	worker_state state = THR_IDLE; // Init to silence a warning

  00016	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR state$[rsp], 0
$LN27@worker_sta:

; 368  : 
; 369  : 	while (true) {

  0001e	33 c0		 xor	 eax, eax
  00020	83 f8 01	 cmp	 eax, 1
  00023	0f 84 36 03 00
	00		 je	 $LN26@worker_sta

; 370  : 		// Wait for work.
; 371  : 		mythread_sync(thr->mutex) {

  00029	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR mythread_i_371$33044[rsp], 0
  00031	eb 08		 jmp	 SHORT $LN25@worker_sta
$LN24@worker_sta:
  00033	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR mythread_i_371$33044[rsp], 1
$LN25@worker_sta:
  0003b	83 7c 24 2c 00	 cmp	 DWORD PTR mythread_i_371$33044[rsp], 0
  00040	74 1c		 je	 SHORT $LN30@worker_sta
  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00047	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00054	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0005c	eb 1a		 jmp	 SHORT $LN31@worker_sta
$LN30@worker_sta:
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00063	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00070	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN31@worker_sta:
  00078	83 7c 24 60 00	 cmp	 DWORD PTR tv70[rsp], 0
  0007d	0f 84 8c 00 00
	00		 je	 $LN23@worker_sta
  00083	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR mythread_j_371$33045[rsp], 0
  0008b	eb 08		 jmp	 SHORT $LN22@worker_sta
$LN21@worker_sta:
  0008d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR mythread_j_371$33045[rsp], 1
$LN22@worker_sta:
  00095	83 7c 24 30 00	 cmp	 DWORD PTR mythread_j_371$33045[rsp], 0
  0009a	75 6e		 jne	 SHORT $LN20@worker_sta
$LN19@worker_sta:

; 372  : 			while (true) {

  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 01	 cmp	 eax, 1
  000a1	74 65		 je	 SHORT $LN18@worker_sta

; 373  : 				// The thread is already idle so if we are
; 374  : 				// requested to stop, just set the state.
; 375  : 				if (thr->state == THR_STOP) {

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  000a8	83 38 03	 cmp	 DWORD PTR [rax], 3
  000ab	75 1d		 jne	 SHORT $LN17@worker_sta

; 376  : 					thr->state = THR_IDLE;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 377  : 					mythread_cond_signal(&thr->cond);

  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  000bd	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable
$LN17@worker_sta:

; 378  : 				}
; 379  : 
; 380  : 				state = thr->state;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  000cf	8b 00		 mov	 eax, DWORD PTR [rax]
  000d1	89 44 24 28	 mov	 DWORD PTR state$[rsp], eax

; 381  : 				if (state != THR_IDLE)

  000d5	83 7c 24 28 00	 cmp	 DWORD PTR state$[rsp], 0
  000da	74 02		 je	 SHORT $LN16@worker_sta

; 382  : 					break;

  000dc	eb 2a		 jmp	 SHORT $LN18@worker_sta
$LN16@worker_sta:

; 383  : 
; 384  : 				mythread_cond_wait(&thr->cond, &thr->mutex);

  000de	48 8b 54 24 20	 mov	 rdx, QWORD PTR thr$[rsp]
  000e3	48 81 c2 60 01
	00 00		 add	 rdx, 352		; 00000160H
  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  000ef	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  000f6	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SleepConditionVariableCS
  00102	89 44 24 44	 mov	 DWORD PTR ret$84339[rsp], eax

; 385  : 			}

  00106	eb 94		 jmp	 SHORT $LN19@worker_sta
$LN18@worker_sta:

; 386  : 		}

  00108	eb 83		 jmp	 SHORT $LN21@worker_sta
$LN20@worker_sta:
  0010a	e9 24 ff ff ff	 jmp	 $LN24@worker_sta
$LN23@worker_sta:

; 387  : 
; 388  : 		assert(state != THR_IDLE);
; 389  : 		assert(state != THR_STOP);
; 390  : 
; 391  : 		if (state <= THR_FINISH)

  0010f	83 7c 24 28 02	 cmp	 DWORD PTR state$[rsp], 2
  00114	7f 12		 jg	 SHORT $LN15@worker_sta

; 392  : 			state = worker_encode(thr, state);

  00116	8b 54 24 28	 mov	 edx, DWORD PTR state$[rsp]
  0011a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  0011f	e8 00 00 00 00	 call	 worker_encode
  00124	89 44 24 28	 mov	 DWORD PTR state$[rsp], eax
$LN15@worker_sta:

; 393  : 
; 394  : 		if (state == THR_EXIT)

  00128	83 7c 24 28 04	 cmp	 DWORD PTR state$[rsp], 4
  0012d	75 05		 jne	 SHORT $LN14@worker_sta

; 395  : 			break;

  0012f	e9 2b 02 00 00	 jmp	 $LN26@worker_sta
$LN14@worker_sta:

; 396  : 
; 397  : 		// Mark the thread as idle unless the main thread has
; 398  : 		// told us to exit. Signal is needed for the case
; 399  : 		// where the main thread is waiting for the threads to stop.
; 400  :     {
; 401  : 		mythread_sync(thr->mutex) {

  00134	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR mythread_i_401$33061[rsp], 0
  0013c	eb 08		 jmp	 SHORT $LN13@worker_sta
$LN12@worker_sta:
  0013e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR mythread_i_401$33061[rsp], 1
$LN13@worker_sta:
  00146	83 7c 24 38 00	 cmp	 DWORD PTR mythread_i_401$33061[rsp], 0
  0014b	74 1c		 je	 SHORT $LN32@worker_sta
  0014d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00152	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0015f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
  00167	eb 1a		 jmp	 SHORT $LN33@worker_sta
$LN32@worker_sta:
  00169	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  0016e	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  0017b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
$LN33@worker_sta:
  00183	83 7c 24 64 00	 cmp	 DWORD PTR tv92[rsp], 0
  00188	74 47		 je	 SHORT $LN11@worker_sta
  0018a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR mythread_j_401$33062[rsp], 0
  00192	eb 08		 jmp	 SHORT $LN10@worker_sta
$LN9@worker_sta:
  00194	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR mythread_j_401$33062[rsp], 1
$LN10@worker_sta:
  0019c	83 7c 24 34 00	 cmp	 DWORD PTR mythread_j_401$33062[rsp], 0
  001a1	75 29		 jne	 SHORT $LN8@worker_sta

; 402  : 			if (thr->state != THR_EXIT) {

  001a3	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  001a8	83 38 04	 cmp	 DWORD PTR [rax], 4
  001ab	74 1d		 je	 SHORT $LN7@worker_sta

; 403  : 				thr->state = THR_IDLE;

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  001b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 404  : 				mythread_cond_signal(&thr->cond);

  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  001bd	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable
$LN7@worker_sta:

; 405  : 			}

  001ca	eb c8		 jmp	 SHORT $LN9@worker_sta
$LN8@worker_sta:

; 406  : 		}

  001cc	e9 6d ff ff ff	 jmp	 $LN12@worker_sta
$LN11@worker_sta:

; 407  :     }
; 408  : 
; 409  :     {
; 410  : 		mythread_sync(thr->coder->mutex) {

  001d1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR mythread_i_410$33070[rsp], 0
  001d9	eb 08		 jmp	 SHORT $LN6@worker_sta
$LN5@worker_sta:
  001db	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR mythread_i_410$33070[rsp], 1
$LN6@worker_sta:
  001e3	83 7c 24 3c 00	 cmp	 DWORD PTR mythread_i_410$33070[rsp], 0
  001e8	74 29		 je	 SHORT $LN34@worker_sta
  001ea	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  001ef	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001f3	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  001f9	48 89 44 24 48	 mov	 QWORD PTR $T84352[rsp], rax
  001fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T84352[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00209	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
  00211	eb 27		 jmp	 SHORT $LN35@worker_sta
$LN34@worker_sta:
  00213	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  00218	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0021c	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  00222	48 89 44 24 50	 mov	 QWORD PTR $T84356[rsp], rax
  00227	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T84356[rsp]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00232	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
$LN35@worker_sta:
  0023a	83 7c 24 68 00	 cmp	 DWORD PTR tv137[rsp], 0
  0023f	0f 84 15 01 00
	00		 je	 $LN4@worker_sta
  00245	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR mythread_j_410$33071[rsp], 0
  0024d	eb 08		 jmp	 SHORT $LN3@worker_sta
$LN2@worker_sta:
  0024f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR mythread_j_410$33071[rsp], 1
$LN3@worker_sta:
  00257	83 7c 24 40 00	 cmp	 DWORD PTR mythread_j_410$33071[rsp], 0
  0025c	0f 85 f3 00 00
	00		 jne	 $LN1@worker_sta

; 411  : 			// Mark the output buffer as finished if
; 412  : 			// no errors occurred.
; 413  : 			thr->outbuf->finished = state == THR_FINISH;

  00262	83 7c 24 28 02	 cmp	 DWORD PTR state$[rsp], 2
  00267	75 0a		 jne	 SHORT $LN36@worker_sta
  00269	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  00271	eb 08		 jmp	 SHORT $LN37@worker_sta
$LN36@worker_sta:
  00273	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN37@worker_sta:
  0027b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00280	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00284	0f b6 44 24 6c	 movzx	 eax, BYTE PTR tv143[rsp]
  00289	88 41 20	 mov	 BYTE PTR [rcx+32], al

; 414  : 
; 415  : 			// Update the main progress info.
; 416  : 			thr->coder->progress_in
; 417  : 					+= thr->outbuf->uncompressed_size;

  0028c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00291	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00295	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  0029a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0029e	48 8b 89 58 01
	00 00		 mov	 rcx, QWORD PTR [rcx+344]
  002a5	48 03 48 18	 add	 rcx, QWORD PTR [rax+24]
  002a9	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  002ae	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002b2	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 418  : 			thr->coder->progress_out += thr->outbuf->size;

  002b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  002be	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002c2	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  002c7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002cb	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  002d2	48 03 48 08	 add	 rcx, QWORD PTR [rax+8]
  002d6	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  002db	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002df	48 89 88 60 01
	00 00		 mov	 QWORD PTR [rax+352], rcx

; 419  : 			thr->progress_in = 0;

  002e6	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  002eb	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 420  : 			thr->progress_out = 0;

  002f3	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  002f8	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 421  : 
; 422  : 			// Return this thread to the stack of free threads.
; 423  : 			thr->next = thr->coder->threads_free;

  00300	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  00305	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00309	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  0030e	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  00315	48 89 81 58 01
	00 00		 mov	 QWORD PTR [rcx+344], rax

; 424  : 			thr->coder->threads_free = thr;

  0031c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00321	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00325	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  0032a	48 89 81 48 01
	00 00		 mov	 QWORD PTR [rcx+328], rax

; 425  : 
; 426  : 			mythread_cond_signal(&thr->coder->cond);

  00331	48 8b 44 24 20	 mov	 rax, QWORD PTR thr$[rsp]
  00336	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0033a	48 05 90 01 00
	00		 add	 rax, 400		; 00000190H
  00340	48 89 44 24 58	 mov	 QWORD PTR $T84360[rsp], rax
  00345	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T84360[rsp]
  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 427  : 		}

  00350	e9 fa fe ff ff	 jmp	 $LN2@worker_sta
$LN1@worker_sta:
  00355	e9 81 fe ff ff	 jmp	 $LN5@worker_sta
$LN4@worker_sta:

; 428  :     }
; 429  : 	}

  0035a	e9 bf fc ff ff	 jmp	 $LN27@worker_sta
$LN26@worker_sta:

; 430  : 
; 431  : 	// Exiting, free the resources.
; 432  : 	mythread_mutex_destroy(&thr->mutex);

  0035f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00364	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  0036b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 433  : 	mythread_cond_destroy(&thr->cond);
; 434  : 
; 435  : 	lzma_next_end(&thr->block_encoder, thr->allocator);

  00371	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00376	48 83 c1 40	 add	 rcx, 64			; 00000040H
  0037a	48 8b 54 24 20	 mov	 rdx, QWORD PTR thr$[rsp]
  0037f	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00383	e8 00 00 00 00	 call	 lzma_next_end

; 436  : 	lzma_free(thr->in, thr->allocator);

  00388	48 8b 54 24 20	 mov	 rdx, QWORD PTR thr$[rsp]
  0038d	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00391	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thr$[rsp]
  00396	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0039a	e8 00 00 00 00	 call	 lzma_free

; 437  : 	return MYTHREAD_RET_VALUE;

  0039f	33 c0		 xor	 eax, eax

; 438  : }

  003a1	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003a5	c3		 ret	 0
worker_start ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$initialize_new_thread DD imagerel initialize_new_thread
	DD	imagerel initialize_new_thread+440
	DD	imagerel $unwind$initialize_new_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initialize_new_thread DD 031001H
	DD	0700ca210H
	DD	0600bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT initialize_new_thread
_TEXT	SEGMENT
thr$ = 48
ret$84482 = 56
$T84484 = 64
coder$ = 112
allocator$ = 120
initialize_new_thread PROC				; COMDAT

; 498  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 499  : 	worker_thread *thr = &coder->threads[coder->threads_initialized];

  00010	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00015	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0001b	48 69 c0 98 01
	00 00		 imul	 rax, 408		; 00000198H
  00022	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00027	48 03 81 38 01
	00 00		 add	 rax, QWORD PTR [rcx+312]
  0002e	48 89 44 24 30	 mov	 QWORD PTR thr$[rsp], rax

; 500  : 
; 501  : 	thr->in = lzma_alloc(coder->block_size, allocator);

  00033	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  0003d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00041	e8 00 00 00 00	 call	 lzma_alloc
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  0004e	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx

; 502  : 	if (thr->in == NULL)

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  00057	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0005c	75 0a		 jne	 SHORT $LN4@initialize

; 503  : 		return LZMA_MEM_ERROR;

  0005e	b8 05 00 00 00	 mov	 eax, 5
  00063	e9 49 01 00 00	 jmp	 $LN5@initialize
$LN4@initialize:

; 504  : 
; 505  : 	if (mythread_mutex_init(&thr->mutex))

  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  0006d	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection
  0007a	33 c0		 xor	 eax, eax
  0007c	85 c0		 test	 eax, eax
  0007e	74 05		 je	 SHORT $LN3@initialize

; 506  : 		goto error_mutex;

  00080	e9 14 01 00 00	 jmp	 $error_mutex$33145
$LN3@initialize:

; 507  : 
; 508  : 	if (mythread_cond_init(&thr->cond))

  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  0008a	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeConditionVariable
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	74 05		 je	 SHORT $LN2@initialize

; 509  : 		goto error_cond;

  0009d	e9 e5 00 00 00	 jmp	 $error_cond$33147
$LN2@initialize:

; 510  : 
; 511  : 	thr->state = THR_IDLE;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  000a7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 512  : 	thr->allocator = allocator;

  000ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  000b2	48 8b 44 24 78	 mov	 rax, QWORD PTR allocator$[rsp]
  000b7	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 513  : 	thr->coder = coder;

  000bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  000c0	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  000c5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 514  : 	thr->progress_in = 0;

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  000ce	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 515  : 	thr->progress_out = 0;

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  000db	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 516  : 	thr->block_encoder = LZMA_NEXT_CODER_INIT;

  000e3	48 8b 7c 24 30	 mov	 rdi, QWORD PTR thr$[rsp]
  000e8	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000ef	48 83 c7 40	 add	 rdi, 64			; 00000040H
  000f3	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000f8	f3 a4		 rep movsb

; 517  : 
; 518  : 	if (mythread_create(&thr->thread_id, &worker_start, thr))

  000fa	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00103	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0010b	4c 8b 4c 24 30	 mov	 r9, QWORD PTR thr$[rsp]
  00110	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:worker_start
  00117	33 d2		 xor	 edx, edx
  00119	33 c9		 xor	 ecx, ecx
  0011b	e8 00 00 00 00	 call	 _beginthreadex
  00120	48 89 44 24 38	 mov	 QWORD PTR ret$84482[rsp], rax
  00125	48 83 7c 24 38
	00		 cmp	 QWORD PTR ret$84482[rsp], 0
  0012b	75 0a		 jne	 SHORT $LN11@initialize
  0012d	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR $T84484[rsp], -1
  00135	eb 19		 jmp	 SHORT $LN12@initialize
$LN11@initialize:
  00137	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  0013c	48 8b 44 24 38	 mov	 rax, QWORD PTR ret$84482[rsp]
  00141	48 89 81 90 01
	00 00		 mov	 QWORD PTR [rcx+400], rax
  00148	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR $T84484[rsp], 0
$LN12@initialize:
  00150	83 7c 24 40 00	 cmp	 DWORD PTR $T84484[rsp], 0
  00155	74 02		 je	 SHORT $LN1@initialize

; 519  : 		goto error_thread;

  00157	eb 2e		 jmp	 SHORT $error_thread$33149
$LN1@initialize:

; 520  : 
; 521  : 	++coder->threads_initialized;

  00159	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0015e	8b 88 44 01 00
	00		 mov	 ecx, DWORD PTR [rax+324]
  00164	83 c1 01	 add	 ecx, 1
  00167	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0016c	89 88 44 01 00
	00		 mov	 DWORD PTR [rax+324], ecx

; 522  : 	coder->thr = thr;

  00172	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR thr$[rsp]
  0017c	48 89 81 50 01
	00 00		 mov	 QWORD PTR [rcx+336], rax

; 523  : 
; 524  : 	return LZMA_OK;

  00183	33 c0		 xor	 eax, eax
  00185	eb 2a		 jmp	 SHORT $LN5@initialize
$error_thread$33149:
$error_cond$33147:

; 525  : 
; 526  : error_thread:
; 527  : 	mythread_cond_destroy(&thr->cond);
; 528  : 
; 529  : error_cond:
; 530  : 	mythread_mutex_destroy(&thr->mutex);

  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  0018c	48 81 c1 60 01
	00 00		 add	 rcx, 352		; 00000160H
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection
$error_mutex$33145:

; 531  : 
; 532  : error_mutex:
; 533  : 	lzma_free(thr->in, allocator);

  00199	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  0019e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR thr$[rsp]
  001a3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001a7	e8 00 00 00 00	 call	 lzma_free

; 534  : 	return LZMA_MEM_ERROR;

  001ac	b8 05 00 00 00	 mov	 eax, 5
$LN5@initialize:

; 535  : }

  001b1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b5	5f		 pop	 rdi
  001b6	5e		 pop	 rsi
  001b7	c3		 ret	 0
initialize_new_thread ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$get_thread DD imagerel get_thread
	DD	imagerel get_thread+693
	DD	imagerel $unwind$get_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_thread DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT get_thread
_TEXT	SEGMENT
mythread_j_548$33158 = 32
mythread_i_548$33157 = 36
ret_$33173 = 40
mythread_i_568$33175 = 44
mythread_j_568$33176 = 48
$T84565 = 56
$T84575 = 64
$T84579 = 72
$T84583 = 80
tv151 = 88
tv74 = 92
tv133 = 96
coder$ = 128
allocator$ = 136
get_thread PROC						; COMDAT

; 540  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 541  : 	// If there are no free output subqueues, there is no
; 542  : 	// point to try getting a thread.
; 543  : 	if (!lzma_outq_has_buf(&coder->outq))

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00016	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0001c	48 89 44 24 38	 mov	 QWORD PTR $T84565[rsp], rax
  00021	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T84565[rsp]
  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR $T84565[rsp]
  0002b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002e	39 41 20	 cmp	 DWORD PTR [rcx+32], eax
  00031	73 0a		 jae	 SHORT $LN29@get_thread
  00033	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN30@get_thread
$LN29@get_thread:
  0003d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN30@get_thread:
  00045	0f b6 44 24 58	 movzx	 eax, BYTE PTR tv151[rsp]
  0004a	85 c0		 test	 eax, eax
  0004c	75 07		 jne	 SHORT $LN20@get_thread

; 544  : 		return LZMA_OK;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 5b 02 00 00	 jmp	 $LN21@get_thread
$LN20@get_thread:

; 545  : 
; 546  : 	// If there is a free structure on the stack, use it.
; 547  :   {
; 548  : 	mythread_sync(coder->mutex) {

  00055	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mythread_i_548$33157[rsp], 0
  0005d	eb 08		 jmp	 SHORT $LN19@get_thread
$LN18@get_thread:
  0005f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR mythread_i_548$33157[rsp], 1
$LN19@get_thread:
  00067	83 7c 24 24 00	 cmp	 DWORD PTR mythread_i_548$33157[rsp], 0
  0006c	74 1f		 je	 SHORT $LN23@get_thread
  0006e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00076	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00083	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  0008b	eb 1d		 jmp	 SHORT $LN24@get_thread
$LN23@get_thread:
  0008d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00095	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000a2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
$LN24@get_thread:
  000aa	83 7c 24 5c 00	 cmp	 DWORD PTR tv74[rsp], 0
  000af	74 75		 je	 SHORT $LN17@get_thread
  000b1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR mythread_j_548$33158[rsp], 0
  000b9	eb 08		 jmp	 SHORT $LN16@get_thread
$LN15@get_thread:
  000bb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR mythread_j_548$33158[rsp], 1
$LN16@get_thread:
  000c3	83 7c 24 20 00	 cmp	 DWORD PTR mythread_j_548$33158[rsp], 0
  000c8	75 57		 jne	 SHORT $LN14@get_thread

; 549  : 		if (coder->threads_free != NULL) {

  000ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000d2	48 83 b8 48 01
	00 00 00	 cmp	 QWORD PTR [rax+328], 0
  000da	74 43		 je	 SHORT $LN13@get_thread

; 550  : 			coder->thr = coder->threads_free;

  000dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  000e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000ec	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  000f3	48 89 81 50 01
	00 00		 mov	 QWORD PTR [rcx+336], rax

; 551  : 			coder->threads_free = coder->threads_free->next;

  000fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00102	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  00109	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00111	48 8b 80 58 01
	00 00		 mov	 rax, QWORD PTR [rax+344]
  00118	48 89 81 48 01
	00 00		 mov	 QWORD PTR [rcx+328], rax
$LN13@get_thread:

; 552  : 		}

  0011f	eb 9a		 jmp	 SHORT $LN15@get_thread
$LN14@get_thread:

; 553  : 	}

  00121	e9 39 ff ff ff	 jmp	 $LN18@get_thread
$LN17@get_thread:

; 554  :   }
; 555  : 
; 556  : 	if (coder->thr == NULL) {

  00126	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0012e	48 83 b8 50 01
	00 00 00	 cmp	 QWORD PTR [rax+336], 0
  00136	75 54		 jne	 SHORT $LN12@get_thread

; 557  : 		// If there are no uninitialized structures left, return.
; 558  : 		if (coder->threads_initialized == coder->threads_max)

  00138	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00140	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00148	8b 80 40 01 00
	00		 mov	 eax, DWORD PTR [rax+320]
  0014e	39 81 44 01 00
	00		 cmp	 DWORD PTR [rcx+324], eax
  00154	75 07		 jne	 SHORT $LN11@get_thread

; 559  : 			return LZMA_OK;

  00156	33 c0		 xor	 eax, eax
  00158	e9 53 01 00 00	 jmp	 $LN21@get_thread
$LN11@get_thread:
$LN10@get_thread:

; 560  : 
; 561  : 		// Initialize a new thread.
; 562  : 		return_if_error(initialize_new_thread(coder, allocator));

  0015d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00165	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0016d	e8 00 00 00 00	 call	 initialize_new_thread
  00172	89 44 24 28	 mov	 DWORD PTR ret_$33173[rsp], eax
  00176	83 7c 24 28 00	 cmp	 DWORD PTR ret_$33173[rsp], 0
  0017b	74 09		 je	 SHORT $LN7@get_thread
  0017d	8b 44 24 28	 mov	 eax, DWORD PTR ret_$33173[rsp]
  00181	e9 2a 01 00 00	 jmp	 $LN21@get_thread
$LN7@get_thread:
  00186	33 c0		 xor	 eax, eax
  00188	85 c0		 test	 eax, eax
  0018a	75 d1		 jne	 SHORT $LN10@get_thread
$LN12@get_thread:

; 563  : 	}
; 564  : 
; 565  : 	// Reset the parts of the thread state that have to be done
; 566  : 	// in the main thread.
; 567  :   {
; 568  : 	mythread_sync(coder->thr->mutex) {

  0018c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR mythread_i_568$33175[rsp], 0
  00194	eb 08		 jmp	 SHORT $LN6@get_thread
$LN5@get_thread:
  00196	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR mythread_i_568$33175[rsp], 1
$LN6@get_thread:
  0019e	83 7c 24 2c 00	 cmp	 DWORD PTR mythread_i_568$33175[rsp], 0
  001a3	74 2f		 je	 SHORT $LN25@get_thread
  001a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001ad	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  001b4	48 05 60 01 00
	00		 add	 rax, 352		; 00000160H
  001ba	48 89 44 24 40	 mov	 QWORD PTR $T84575[rsp], rax
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T84575[rsp]
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  001ca	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
  001d2	eb 2d		 jmp	 SHORT $LN26@get_thread
$LN25@get_thread:
  001d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001dc	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  001e3	48 05 60 01 00
	00		 add	 rax, 352		; 00000160H
  001e9	48 89 44 24 48	 mov	 QWORD PTR $T84579[rsp], rax
  001ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T84579[rsp]
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  001f9	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
$LN26@get_thread:
  00201	83 7c 24 60 00	 cmp	 DWORD PTR tv133[rsp], 0
  00206	0f 84 a2 00 00
	00		 je	 $LN4@get_thread
  0020c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR mythread_j_568$33176[rsp], 0
  00214	eb 08		 jmp	 SHORT $LN3@get_thread
$LN2@get_thread:
  00216	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR mythread_j_568$33176[rsp], 1
$LN3@get_thread:
  0021e	83 7c 24 30 00	 cmp	 DWORD PTR mythread_j_568$33176[rsp], 0
  00223	0f 85 80 00 00
	00		 jne	 $LN1@get_thread

; 569  : 		coder->thr->state = THR_RUN;

  00229	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00231	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00238	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 570  : 		coder->thr->in_size = 0;

  0023e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00246	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  0024d	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 571  : 		coder->thr->outbuf = lzma_outq_get_buf(&coder->outq);

  00255	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0025d	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  00264	e8 00 00 00 00	 call	 lzma_outq_get_buf
  00269	4c 8b d8	 mov	 r11, rax
  0026c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00274	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  0027b	4c 89 58 18	 mov	 QWORD PTR [rax+24], r11

; 572  : 		mythread_cond_signal(&coder->thr->cond);

  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00287	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  0028e	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  00294	48 89 44 24 50	 mov	 QWORD PTR $T84583[rsp], rax
  00299	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T84583[rsp]
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable

; 573  : 	}

  002a4	e9 6d ff ff ff	 jmp	 $LN2@get_thread
$LN1@get_thread:
  002a9	e9 e8 fe ff ff	 jmp	 $LN5@get_thread
$LN4@get_thread:

; 574  :   }
; 575  : 
; 576  : 	return LZMA_OK;

  002ae	33 c0		 xor	 eax, eax
$LN21@get_thread:

; 577  : }

  002b0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002b4	c3		 ret	 0
get_thread ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$stream_encode_in DD imagerel stream_encode_in
	DD	imagerel stream_encode_in+820
	DD	imagerel $unwind$stream_encode_in
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encode_in DD 021b01H
	DD	011011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT stream_encode_in
_TEXT	SEGMENT
ret$33204 = 48
thr_in_size$33207 = 56
finish$33208 = 64
block_error$33209 = 65
mythread_i_613$33210 = 68
mythread_j_613$33211 = 72
ret$33222 = 76
mythread_i_636$33223 = 80
mythread_j_636$33224 = 84
$T84642 = 88
$T84646 = 96
$T84650 = 104
tv90 = 112
tv131 = 116
tv153 = 120
coder$ = 144
allocator$ = 152
in$ = 160
in_pos$ = 168
in_size$ = 176
action$ = 184
stream_encode_in PROC					; COMDAT

; 584  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN22@stream_enc@6:

; 585  : 	while (*in_pos < in_size
; 586  : 			|| (coder->thr != NULL && action != LZMA_RUN)) {

  0001b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00023	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0002b	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0002e	72 24		 jb	 SHORT $LN20@stream_enc@6
  00030	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00038	48 83 b8 50 01
	00 00 00	 cmp	 QWORD PTR [rax+336], 0
  00040	0f 84 e4 02 00
	00		 je	 $LN21@stream_enc@6
  00046	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  0004e	0f 84 d6 02 00
	00		 je	 $LN21@stream_enc@6
$LN20@stream_enc@6:

; 587  : 		if (coder->thr == NULL) {

  00054	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0005c	48 83 b8 50 01
	00 00 00	 cmp	 QWORD PTR [rax+336], 0
  00064	75 34		 jne	 SHORT $LN19@stream_enc@6

; 588  : 			// Get a new thread.
; 589  : 			const lzma_ret ret = get_thread(coder, allocator);

  00066	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0006e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00076	e8 00 00 00 00	 call	 get_thread
  0007b	89 44 24 30	 mov	 DWORD PTR ret$33204[rsp], eax

; 590  : 			if (coder->thr == NULL)

  0007f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00087	48 83 b8 50 01
	00 00 00	 cmp	 QWORD PTR [rax+336], 0
  0008f	75 09		 jne	 SHORT $LN18@stream_enc@6

; 591  : 				return ret;

  00091	8b 44 24 30	 mov	 eax, DWORD PTR ret$33204[rsp]
  00095	e9 92 02 00 00	 jmp	 $LN23@stream_enc@6
$LN18@stream_enc@6:
$LN19@stream_enc@6:

; 592  : 		}
; 593  : 
; 594  : 		// Copy the input data to thread's buffer.
; 595  :     {
; 596  : 		size_t thr_in_size = coder->thr->in_size;

  0009a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000a2	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  000a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ad	48 89 44 24 38	 mov	 QWORD PTR thr_in_size$33207[rsp], rax

; 597  : 		lzma_bufcpy(in, in_pos, in_size, coder->thr->in,
; 598  : 				&thr_in_size, coder->block_size);

  000b2	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR coder$[rsp]
  000ba	4d 8b 89 50 01
	00 00		 mov	 r9, QWORD PTR [r9+336]
  000c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  000c9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d2	48 8d 44 24 38	 lea	 rax, QWORD PTR thr_in_size$33207[rsp]
  000d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dc	4d 8b 49 08	 mov	 r9, QWORD PTR [r9+8]
  000e0	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  000e8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  000f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  000f8	e8 00 00 00 00	 call	 lzma_bufcpy

; 599  : 
; 600  : 		// Tell the Block encoder to finish if
; 601  : 		//  - it has got block_size bytes of input; or
; 602  : 		//  - all input was used and LZMA_FINISH, LZMA_FULL_FLUSH,
; 603  : 		//    or LZMA_FULL_BARRIER was used.
; 604  : 		//
; 605  : 		// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
; 606  :     {
; 607  : 		const bool finish = thr_in_size == coder->block_size
; 608  : 				|| (*in_pos == in_size && action != LZMA_RUN);

  000fd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00105	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00109	48 39 44 24 38	 cmp	 QWORD PTR thr_in_size$33207[rsp], rax
  0010e	74 29		 je	 SHORT $LN26@stream_enc@6
  00110	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00118	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00120	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00123	75 0a		 jne	 SHORT $LN25@stream_enc@6
  00125	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  0012d	75 0a		 jne	 SHORT $LN26@stream_enc@6
$LN25@stream_enc@6:
  0012f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
  00137	eb 08		 jmp	 SHORT $LN27@stream_enc@6
$LN26@stream_enc@6:
  00139	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
$LN27@stream_enc@6:
  00141	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv90[rsp]
  00146	88 44 24 40	 mov	 BYTE PTR finish$33208[rsp], al

; 609  : 
; 610  : 		bool block_error = false;

  0014a	c6 44 24 41 00	 mov	 BYTE PTR block_error$33209[rsp], 0

; 611  : 
; 612  :     {
; 613  : 		mythread_sync(coder->thr->mutex) {

  0014f	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR mythread_i_613$33210[rsp], 0
  00157	eb 08		 jmp	 SHORT $LN17@stream_enc@6
$LN16@stream_enc@6:
  00159	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR mythread_i_613$33210[rsp], 1
$LN17@stream_enc@6:
  00161	83 7c 24 44 00	 cmp	 DWORD PTR mythread_i_613$33210[rsp], 0
  00166	74 2f		 je	 SHORT $LN28@stream_enc@6
  00168	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00170	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00177	48 05 60 01 00
	00		 add	 rax, 352		; 00000160H
  0017d	48 89 44 24 58	 mov	 QWORD PTR $T84642[rsp], rax
  00182	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T84642[rsp]
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0018d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
  00195	eb 2d		 jmp	 SHORT $LN29@stream_enc@6
$LN28@stream_enc@6:
  00197	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0019f	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  001a6	48 05 60 01 00
	00		 add	 rax, 352		; 00000160H
  001ac	48 89 44 24 60	 mov	 QWORD PTR $T84646[rsp], rax
  001b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T84646[rsp]
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  001bc	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
$LN29@stream_enc@6:
  001c4	83 7c 24 74 00	 cmp	 DWORD PTR tv131[rsp], 0
  001c9	0f 84 99 00 00
	00		 je	 $LN15@stream_enc@6
  001cf	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR mythread_j_613$33211[rsp], 0
  001d7	eb 08		 jmp	 SHORT $LN14@stream_enc@6
$LN13@stream_enc@6:
  001d9	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR mythread_j_613$33211[rsp], 1
$LN14@stream_enc@6:
  001e1	83 7c 24 48 00	 cmp	 DWORD PTR mythread_j_613$33211[rsp], 0
  001e6	75 7b		 jne	 SHORT $LN12@stream_enc@6

; 614  : 			if (coder->thr->state == THR_IDLE) {

  001e8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  001f0	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  001f7	83 38 00	 cmp	 DWORD PTR [rax], 0
  001fa	75 07		 jne	 SHORT $LN11@stream_enc@6

; 615  : 				// Something has gone wrong with the Block
; 616  : 				// encoder. It has set coder->thread_error
; 617  : 				// which we will read a few lines later.
; 618  : 				block_error = true;

  001fc	c6 44 24 41 01	 mov	 BYTE PTR block_error$33209[rsp], 1

; 619  : 			} else {

  00201	eb 5b		 jmp	 SHORT $LN10@stream_enc@6
$LN11@stream_enc@6:

; 620  : 				// Tell the Block encoder its new amount
; 621  : 				// of input and update the state if needed.
; 622  : 				coder->thr->in_size = thr_in_size;

  00203	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  0020b	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  00212	48 8b 44 24 38	 mov	 rax, QWORD PTR thr_in_size$33207[rsp]
  00217	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 623  : 
; 624  : 				if (finish)

  0021b	0f b6 44 24 40	 movzx	 eax, BYTE PTR finish$33208[rsp]
  00220	85 c0		 test	 eax, eax
  00222	74 15		 je	 SHORT $LN9@stream_enc@6

; 625  : 					coder->thr->state = THR_FINISH;

  00224	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0022c	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00233	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN9@stream_enc@6:

; 626  : 
; 627  : 				mythread_cond_signal(&coder->thr->cond);

  00239	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  00241	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00248	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  0024e	48 89 44 24 68	 mov	 QWORD PTR $T84650[rsp], rax
  00253	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T84650[rsp]
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WakeConditionVariable
$LN10@stream_enc@6:

; 628  : 			}

  0025e	e9 76 ff ff ff	 jmp	 $LN13@stream_enc@6
$LN12@stream_enc@6:

; 629  : 		}

  00263	e9 f1 fe ff ff	 jmp	 $LN16@stream_enc@6
$LN15@stream_enc@6:

; 630  :     }
; 631  : 
; 632  : 		if (block_error) {

  00268	0f b6 44 24 41	 movzx	 eax, BYTE PTR block_error$33209[rsp]
  0026d	85 c0		 test	 eax, eax
  0026f	0f 84 94 00 00
	00		 je	 $LN8@stream_enc@6

; 633  : 			lzma_ret ret;
; 634  : 
; 635  :       {
; 636  : 			mythread_sync(coder->mutex) {

  00275	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR mythread_i_636$33223[rsp], 0
  0027d	eb 08		 jmp	 SHORT $LN7@stream_enc@6
$LN6@stream_enc@6:
  0027f	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR mythread_i_636$33223[rsp], 1
$LN7@stream_enc@6:
  00287	83 7c 24 50 00	 cmp	 DWORD PTR mythread_i_636$33223[rsp], 0
  0028c	74 1f		 je	 SHORT $LN30@stream_enc@6
  0028e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  00296	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  002a3	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
  002ab	eb 1d		 jmp	 SHORT $LN31@stream_enc@6
$LN30@stream_enc@6:
  002ad	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coder$[rsp]
  002b5	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  002c2	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
$LN31@stream_enc@6:
  002ca	83 7c 24 78 00	 cmp	 DWORD PTR tv153[rsp], 0
  002cf	74 32		 je	 SHORT $LN5@stream_enc@6
  002d1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR mythread_j_636$33224[rsp], 0
  002d9	eb 08		 jmp	 SHORT $LN4@stream_enc@6
$LN3@stream_enc@6:
  002db	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR mythread_j_636$33224[rsp], 1
$LN4@stream_enc@6:
  002e3	83 7c 24 54 00	 cmp	 DWORD PTR mythread_j_636$33224[rsp], 0
  002e8	75 14		 jne	 SHORT $LN2@stream_enc@6

; 637  : 				ret = coder->thread_error;

  002ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  002f2	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  002f8	89 44 24 4c	 mov	 DWORD PTR ret$33222[rsp], eax
  002fc	eb dd		 jmp	 SHORT $LN3@stream_enc@6
$LN2@stream_enc@6:

; 638  : 			}

  002fe	e9 7c ff ff ff	 jmp	 $LN6@stream_enc@6
$LN5@stream_enc@6:

; 639  :       }
; 640  : 
; 641  : 			return ret;

  00303	8b 44 24 4c	 mov	 eax, DWORD PTR ret$33222[rsp]
  00307	eb 23		 jmp	 SHORT $LN23@stream_enc@6
$LN8@stream_enc@6:

; 642  : 		}
; 643  : 
; 644  : 		if (finish)

  00309	0f b6 44 24 40	 movzx	 eax, BYTE PTR finish$33208[rsp]
  0030e	85 c0		 test	 eax, eax
  00310	74 13		 je	 SHORT $LN1@stream_enc@6

; 645  : 			coder->thr = NULL;

  00312	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coder$[rsp]
  0031a	48 c7 80 50 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+336], 0
$LN1@stream_enc@6:

; 646  :     }}
; 647  :   }

  00325	e9 f1 fc ff ff	 jmp	 $LN22@stream_enc@6
$LN21@stream_enc@6:

; 648  : 
; 649  : 	return LZMA_OK;

  0032a	33 c0		 xor	 eax, eax
$LN23@stream_enc@6:

; 650  : }

  0032c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00333	c3		 ret	 0
stream_encode_in ENDP
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\outqueue.h
pdata	SEGMENT
$pdata$stream_encode_mt DD imagerel stream_encode_mt
	DD	imagerel stream_encode_mt+1409
	DD	imagerel $unwind$stream_encode_mt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encode_mt DD 021b01H
	DD	015011bH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT stream_encode_mt
_TEXT	SEGMENT
coder$ = 80
has_blocked$33291 = 88
wait_abs$33292 = 96
unpadded_size$33288 = 104
uncompressed_size$33289 = 112
ret$33290 = 120
mythread_i_737$33296 = 124
mythread_j_737$33297 = 128
ret_$33321 = 132
ret$33324 = 136
tv64 = 140
tv82 = 144
tv224 = 148
tv161 = 152
tv217 = 156
coder_ptr$ = 176
allocator$ = 184
in$ = 192
in_pos$ = 200
in_size$ = 208
out$ = 216
out_pos$ = 224
out_size$ = 232
action$ = 240
stream_encode_mt PROC					; COMDAT

; 710  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 711  : 	lzma_stream_coder *coder = coder_ptr;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 712  : 
; 713  : 	switch (coder->sequence) {

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	8b 00		 mov	 eax, DWORD PTR [rax]
  0002f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv64[rsp], eax
  00036	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 0
  0003e	74 2f		 je	 SHORT $LN32@stream_enc@7
  00040	83 bc 24 8c 00
	00 00 01	 cmp	 DWORD PTR tv64[rsp], 1
  00048	0f 84 97 00 00
	00		 je	 $LN30@stream_enc@7
  0004e	83 bc 24 8c 00
	00 00 02	 cmp	 DWORD PTR tv64[rsp], 2
  00056	0f 84 d9 03 00
	00		 je	 $LN4@stream_enc@7
  0005c	83 bc 24 8c 00
	00 00 03	 cmp	 DWORD PTR tv64[rsp], 3
  00064	0f 84 95 04 00
	00		 je	 $LN1@stream_enc@7
  0006a	e9 05 05 00 00	 jmp	 $LN33@stream_enc@7
$LN32@stream_enc@7:

; 714  : 	case SEQ_STREAM_HEADER:
; 715  : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 716  : 				sizeof(coder->header),
; 717  : 				out, out_pos, out_size);

  0006f	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00074	48 81 c2 f8 00
	00 00		 add	 rdx, 248		; 000000f8H
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00080	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  00087	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0008f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00094	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0009c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a1	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  000a9	41 b8 0c 00 00
	00		 mov	 r8d, 12
  000af	e8 00 00 00 00	 call	 lzma_bufcpy

; 718  : 		if (coder->header_pos < sizeof(coder->header))

  000b4	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  000b9	49 83 bb f8 00
	00 00 0c	 cmp	 QWORD PTR [r11+248], 12
  000c1	73 07		 jae	 SHORT $LN31@stream_enc@7

; 719  : 			return LZMA_OK;

  000c3	33 c0		 xor	 eax, eax
  000c5	e9 af 04 00 00	 jmp	 $LN35@stream_enc@7
$LN31@stream_enc@7:

; 720  : 
; 721  : 		coder->header_pos = 0;

  000ca	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000cf	48 c7 80 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+248], 0

; 722  : 		coder->sequence = SEQ_BLOCK;

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000df	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN30@stream_enc@7:

; 723  : 
; 724  : 	// Fall through
; 725  : 
; 726  : 	case SEQ_BLOCK: {
; 727  : 		// Initialized to silence warnings.
; 728  : 		lzma_vli unpadded_size = 0;

  000e5	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR unpadded_size$33288[rsp], 0

; 729  : 		lzma_vli uncompressed_size = 0;

  000ee	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR uncompressed_size$33289[rsp], 0

; 730  : 		lzma_ret ret = LZMA_OK;

  000f7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR ret$33290[rsp], 0

; 731  : 
; 732  : 		// These are for wait_for_work().
; 733  : 		bool has_blocked = false;

  000ff	c6 44 24 58 00	 mov	 BYTE PTR has_blocked$33291[rsp], 0
$LN51@stream_enc@7:
$LN29@stream_enc@7:

; 734  : 		mythread_condtime wait_abs;
; 735  : 
; 736  : 		while (true) {

  00104	33 c0		 xor	 eax, eax
  00106	83 f8 01	 cmp	 eax, 1
  00109	0f 84 ab 02 00
	00		 je	 $LN28@stream_enc@7

; 737  : 			mythread_sync(coder->mutex) {

  0010f	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR mythread_i_737$33296[rsp], 0
  00117	eb 08		 jmp	 SHORT $LN27@stream_enc@7
$LN26@stream_enc@7:
  00119	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR mythread_i_737$33296[rsp], 1
$LN27@stream_enc@7:
  00121	83 7c 24 7c 00	 cmp	 DWORD PTR mythread_i_737$33296[rsp], 0
  00126	74 1f		 je	 SHORT $LN37@stream_enc@7
  00128	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0012d	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0013a	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv82[rsp], 0
  00145	eb 1d		 jmp	 SHORT $LN38@stream_enc@7
$LN37@stream_enc@7:
  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0014c	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00159	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv82[rsp], 1
$LN38@stream_enc@7:
  00164	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv82[rsp], 0
  0016c	0f 84 82 00 00
	00		 je	 $LN25@stream_enc@7
  00172	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR mythread_j_737$33297[rsp], 0
  0017d	eb 0b		 jmp	 SHORT $LN24@stream_enc@7
$LN23@stream_enc@7:
  0017f	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mythread_j_737$33297[rsp], 1
$LN24@stream_enc@7:
  0018a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR mythread_j_737$33297[rsp], 0
  00192	75 5b		 jne	 SHORT $LN22@stream_enc@7

; 738  : 				// Check for Block encoder errors.
; 739  : 				ret = coder->thread_error;

  00194	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00199	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0019f	89 44 24 78	 mov	 DWORD PTR ret$33290[rsp], eax

; 740  : 				if (ret != LZMA_OK) {

  001a3	83 7c 24 78 00	 cmp	 DWORD PTR ret$33290[rsp], 0
  001a8	74 02		 je	 SHORT $LN21@stream_enc@7

; 741  : 					assert(ret != LZMA_STREAM_END);
; 742  : 					break;

  001aa	eb 43		 jmp	 SHORT $LN22@stream_enc@7
$LN21@stream_enc@7:

; 743  : 				}
; 744  : 
; 745  : 				// Try to read compressed data to out[].
; 746  : 				ret = lzma_outq_read(&coder->outq,
; 747  : 						out, out_pos, out_size,
; 748  : 						&unpadded_size,
; 749  : 						&uncompressed_size);

  001ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  001b1	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  001b8	48 8d 44 24 70	 lea	 rax, QWORD PTR uncompressed_size$33289[rsp]
  001bd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c2	48 8d 44 24 68	 lea	 rax, QWORD PTR unpadded_size$33288[rsp]
  001c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cc	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR out_size$[rsp]
  001d4	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR out_pos$[rsp]
  001dc	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001e4	e8 00 00 00 00	 call	 lzma_outq_read
  001e9	89 44 24 78	 mov	 DWORD PTR ret$33290[rsp], eax
  001ed	eb 90		 jmp	 SHORT $LN23@stream_enc@7
$LN22@stream_enc@7:

; 750  : 			}

  001ef	e9 25 ff ff ff	 jmp	 $LN26@stream_enc@7
$LN25@stream_enc@7:

; 751  : 
; 752  : 			if (ret == LZMA_STREAM_END) {

  001f4	83 7c 24 78 01	 cmp	 DWORD PTR ret$33290[rsp], 1
  001f9	75 3e		 jne	 SHORT $LN20@stream_enc@7

; 753  : 				// End of Block. Add it to the Index.
; 754  : 				ret = lzma_index_append(coder->index,
; 755  : 						allocator, unpadded_size,
; 756  : 						uncompressed_size);

  001fb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR uncompressed_size$33289[rsp]
  00200	4c 8b 44 24 68	 mov	 r8, QWORD PTR unpadded_size$33288[rsp]
  00205	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00212	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00216	e8 00 00 00 00	 call	 lzma_index_append
  0021b	89 44 24 78	 mov	 DWORD PTR ret$33290[rsp], eax

; 757  : 
; 758  : 				// If we didn't fill the output buffer yet,
; 759  : 				// try to read more data. Maybe the next
; 760  : 				// outbuf has been finished already too.
; 761  : 				if (*out_pos < out_size)

  0021f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00227	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0022f	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00232	73 05		 jae	 SHORT $LN19@stream_enc@7

; 762  : 					continue;

  00234	e9 cb fe ff ff	 jmp	 $LN29@stream_enc@7
$LN19@stream_enc@7:
$LN20@stream_enc@7:

; 763  : 			}
; 764  : 
; 765  : 			if (ret != LZMA_OK) {

  00239	83 7c 24 78 00	 cmp	 DWORD PTR ret$33290[rsp], 0
  0023e	74 15		 je	 SHORT $LN18@stream_enc@7

; 766  : 				// coder->thread_error was set or
; 767  : 				// lzma_index_append() failed.
; 768  : 				threads_stop(coder, false);

  00240	33 d2		 xor	 edx, edx
  00242	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00247	e8 00 00 00 00	 call	 threads_stop

; 769  : 				return ret;

  0024c	8b 44 24 78	 mov	 eax, DWORD PTR ret$33290[rsp]
  00250	e9 24 03 00 00	 jmp	 $LN35@stream_enc@7
$LN18@stream_enc@7:

; 770  : 			}
; 771  : 
; 772  : 			// Try to give uncompressed data to a worker thread.
; 773  : 			ret = stream_encode_in(coder, allocator,
; 774  : 					in, in_pos, in_size, action);

  00255	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  0025c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00260	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  00268	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00275	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  0027d	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00285	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0028a	e8 00 00 00 00	 call	 stream_encode_in
  0028f	89 44 24 78	 mov	 DWORD PTR ret$33290[rsp], eax

; 775  : 			if (ret != LZMA_OK) {

  00293	83 7c 24 78 00	 cmp	 DWORD PTR ret$33290[rsp], 0
  00298	74 15		 je	 SHORT $LN17@stream_enc@7

; 776  : 				threads_stop(coder, false);

  0029a	33 d2		 xor	 edx, edx
  0029c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002a1	e8 00 00 00 00	 call	 threads_stop

; 777  : 				return ret;

  002a6	8b 44 24 78	 mov	 eax, DWORD PTR ret$33290[rsp]
  002aa	e9 ca 02 00 00	 jmp	 $LN35@stream_enc@7
$LN17@stream_enc@7:

; 778  : 			}
; 779  : 
; 780  : 			// See if we should wait or return.
; 781  : 			//
; 782  : 			// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
; 783  : 			if (*in_pos == in_size) {

  002af	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  002b7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  002bf	48 39 01	 cmp	 QWORD PTR [rcx], rax
  002c2	75 7a		 jne	 SHORT $LN16@stream_enc@7

; 784  : 				// LZMA_RUN: More data is probably coming
; 785  : 				// so return to let the caller fill the
; 786  : 				// input buffer.
; 787  : 				if (action == LZMA_RUN)

  002c4	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  002cc	75 07		 jne	 SHORT $LN15@stream_enc@7

; 788  : 					return LZMA_OK;

  002ce	33 c0		 xor	 eax, eax
  002d0	e9 a4 02 00 00	 jmp	 $LN35@stream_enc@7
$LN15@stream_enc@7:

; 789  : 
; 790  : 				// LZMA_FULL_BARRIER: The same as with
; 791  : 				// LZMA_RUN but tell the caller that the
; 792  : 				// barrier was completed.
; 793  : 				if (action == LZMA_FULL_BARRIER)

  002d5	83 bc 24 f0 00
	00 00 04	 cmp	 DWORD PTR action$[rsp], 4
  002dd	75 0a		 jne	 SHORT $LN14@stream_enc@7

; 794  : 					return LZMA_STREAM_END;

  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	e9 90 02 00 00	 jmp	 $LN35@stream_enc@7
$LN14@stream_enc@7:

; 795  : 
; 796  : 				// Finishing or flushing isn't completed until
; 797  : 				// all input data has been encoded and copied
; 798  : 				// to the output buffer.
; 799  : 				if (lzma_outq_is_empty(&coder->outq)) {

  002e9	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002ee	83 b8 20 01 00
	00 00		 cmp	 DWORD PTR [rax+288], 0
  002f5	75 0d		 jne	 SHORT $LN49@stream_enc@7
  002f7	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv224[rsp], 1
  00302	eb 0b		 jmp	 SHORT $LN50@stream_enc@7
$LN49@stream_enc@7:
  00304	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
$LN50@stream_enc@7:
  0030f	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR tv224[rsp]
  00317	85 c0		 test	 eax, eax
  00319	74 23		 je	 SHORT $LN13@stream_enc@7

; 800  : 					// LZMA_FINISH: Continue to encode
; 801  : 					// the Index field.
; 802  : 					if (action == LZMA_FINISH)

  0031b	83 bc 24 f0 00
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  00323	75 05		 jne	 SHORT $LN12@stream_enc@7

; 803  : 						break;

  00325	e9 90 00 00 00	 jmp	 $LN28@stream_enc@7
$LN12@stream_enc@7:

; 804  : 
; 805  : 					// LZMA_FULL_FLUSH: Return to tell
; 806  : 					// the caller that flushing was
; 807  : 					// completed.
; 808  : 					if (action == LZMA_FULL_FLUSH)

  0032a	83 bc 24 f0 00
	00 00 02	 cmp	 DWORD PTR action$[rsp], 2
  00332	75 0a		 jne	 SHORT $LN11@stream_enc@7

; 809  : 						return LZMA_STREAM_END;

  00334	b8 01 00 00 00	 mov	 eax, 1
  00339	e9 3b 02 00 00	 jmp	 $LN35@stream_enc@7
$LN11@stream_enc@7:
$LN13@stream_enc@7:
$LN16@stream_enc@7:

; 810  : 				}
; 811  : 			}
; 812  : 
; 813  : 			// Return if there is no output space left.
; 814  : 			// This check must be done after testing the input
; 815  : 			// buffer, because we might want to use a different
; 816  : 			// return code.
; 817  : 			if (*out_pos == out_size)

  0033e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00346	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0034e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00351	75 07		 jne	 SHORT $LN10@stream_enc@7

; 818  : 				return LZMA_OK;

  00353	33 c0		 xor	 eax, eax
  00355	e9 1f 02 00 00	 jmp	 $LN35@stream_enc@7
$LN10@stream_enc@7:

; 819  : 
; 820  : 			// Neither in nor out has been used completely.
; 821  : 			// Wait until there's something we can do.
; 822  : 			if (wait_for_work(coder, &wait_abs, &has_blocked,
; 823  : 					*in_pos < in_size))

  0035a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00362	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0036a	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0036d	73 0d		 jae	 SHORT $LN39@stream_enc@7
  0036f	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv161[rsp], 1
  0037a	eb 0b		 jmp	 SHORT $LN40@stream_enc@7
$LN39@stream_enc@7:
  0037c	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv161[rsp], 0
$LN40@stream_enc@7:
  00387	44 0f b6 8c 24
	98 00 00 00	 movzx	 r9d, BYTE PTR tv161[rsp]
  00390	4c 8d 44 24 58	 lea	 r8, QWORD PTR has_blocked$33291[rsp]
  00395	48 8d 54 24 60	 lea	 rdx, QWORD PTR wait_abs$33292[rsp]
  0039a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0039f	e8 00 00 00 00	 call	 wait_for_work
  003a4	0f b6 c0	 movzx	 eax, al
  003a7	85 c0		 test	 eax, eax
  003a9	74 0a		 je	 SHORT $LN9@stream_enc@7

; 824  : 				return LZMA_TIMED_OUT;

  003ab	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  003b0	e9 c4 01 00 00	 jmp	 $LN35@stream_enc@7
$LN9@stream_enc@7:

; 825  : 		}

  003b5	e9 4a fd ff ff	 jmp	 $LN51@stream_enc@7
$LN28@stream_enc@7:
$LN8@stream_enc@7:

; 826  : 
; 827  : 		// All Blocks have been encoded and the threads have stopped.
; 828  : 		// Prepare to encode the Index field.
; 829  : 		return_if_error(lzma_index_encoder_init(
; 830  : 				&coder->index_encoder, allocator,
; 831  : 				coder->index));

  003ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003bf	48 83 c1 68	 add	 rcx, 104		; 00000068H
  003c3	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  003c8	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  003cc	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003d4	e8 00 00 00 00	 call	 lzma_index_encoder_init
  003d9	89 84 24 84 00
	00 00		 mov	 DWORD PTR ret_$33321[rsp], eax
  003e0	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR ret_$33321[rsp], 0
  003e8	74 0c		 je	 SHORT $LN5@stream_enc@7
  003ea	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR ret_$33321[rsp]
  003f1	e9 83 01 00 00	 jmp	 $LN35@stream_enc@7
$LN5@stream_enc@7:
  003f6	33 c0		 xor	 eax, eax
  003f8	85 c0		 test	 eax, eax
  003fa	75 be		 jne	 SHORT $LN8@stream_enc@7

; 832  : 		coder->sequence = SEQ_INDEX;

  003fc	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00401	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 833  : 
; 834  : 		// Update the progress info to take the Index and
; 835  : 		// Stream Footer into account. Those are very fast to encode
; 836  : 		// so in terms of progress information they can be thought
; 837  : 		// to be ready to be copied out.
; 838  : 		coder->progress_out += lzma_index_size(coder->index)
; 839  : 				+ LZMA_STREAM_HEADER_SIZE;

  00407	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0040c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00410	e8 00 00 00 00	 call	 lzma_index_size
  00415	4c 8b d8	 mov	 r11, rax
  00418	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0041d	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  00424	49 8d 4c 03 0c	 lea	 rcx, QWORD PTR [r11+rax+12]
  00429	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0042e	48 89 88 60 01
	00 00		 mov	 QWORD PTR [rax+352], rcx
$LN4@stream_enc@7:

; 840  : 	}
; 841  : 
; 842  : 	// Fall through
; 843  : 
; 844  : 	case SEQ_INDEX: {
; 845  : 		// Call the Index encoder. It doesn't take any input, so
; 846  : 		// those pointers can be NULL.
; 847  : 		const lzma_ret ret = coder->index_encoder.code(
; 848  : 				coder->index_encoder.coder, allocator,
; 849  : 				NULL, NULL, 0,
; 850  : 				out, out_pos, out_size, LZMA_RUN);

  00435	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  0043d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00445	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0044a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00452	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00457	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0045f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00464	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0046d	45 33 c9	 xor	 r9d, r9d
  00470	45 33 c0	 xor	 r8d, r8d
  00473	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0047b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00480	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00484	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00489	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0048f	89 84 24 88 00
	00 00		 mov	 DWORD PTR ret$33324[rsp], eax

; 851  : 		if (ret != LZMA_STREAM_END)

  00496	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR ret$33324[rsp], 1
  0049e	74 0c		 je	 SHORT $LN3@stream_enc@7

; 852  : 			return ret;

  004a0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ret$33324[rsp]
  004a7	e9 cd 00 00 00	 jmp	 $LN35@stream_enc@7
$LN3@stream_enc@7:

; 853  : 
; 854  : 		// Encode the Stream Footer into coder->buffer.
; 855  : 		coder->stream_flags.backward_size
; 856  : 				= lzma_index_size(coder->index);

  004ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  004b1	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  004b5	e8 00 00 00 00	 call	 lzma_index_size
  004ba	4c 8b d8	 mov	 r11, rax
  004bd	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  004c2	4c 89 98 b8 00
	00 00		 mov	 QWORD PTR [rax+184], r11

; 857  : 		if (lzma_stream_footer_encode(&coder->stream_flags,
; 858  : 				coder->header) != LZMA_OK)

  004c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  004ce	48 81 c2 e8 00
	00 00		 add	 rdx, 232		; 000000e8H
  004d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  004da	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  004e1	e8 00 00 00 00	 call	 lzma_stream_footer_encode
  004e6	85 c0		 test	 eax, eax
  004e8	74 0a		 je	 SHORT $LN2@stream_enc@7

; 859  : 			return LZMA_PROG_ERROR;

  004ea	b8 0b 00 00 00	 mov	 eax, 11
  004ef	e9 85 00 00 00	 jmp	 $LN35@stream_enc@7
$LN2@stream_enc@7:

; 860  : 
; 861  : 		coder->sequence = SEQ_STREAM_FOOTER;

  004f4	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  004f9	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN1@stream_enc@7:

; 862  : 	}
; 863  : 
; 864  : 	// Fall through
; 865  : 
; 866  : 	case SEQ_STREAM_FOOTER:
; 867  : 		lzma_bufcpy(coder->header, &coder->header_pos,
; 868  : 				sizeof(coder->header),
; 869  : 				out, out_pos, out_size);

  004ff	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00504	48 81 c2 f8 00
	00 00		 add	 rdx, 248		; 000000f8H
  0050b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00510	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  00517	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0051f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00524	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0052c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00531	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  00539	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0053f	e8 00 00 00 00	 call	 lzma_bufcpy

; 870  : 		return coder->header_pos < sizeof(coder->header)
; 871  : 				? LZMA_OK : LZMA_STREAM_END;

  00544	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  00549	49 83 bb f8 00
	00 00 0c	 cmp	 QWORD PTR [r11+248], 12
  00551	73 0d		 jae	 SHORT $LN41@stream_enc@7
  00553	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv217[rsp], 0
  0055e	eb 0b		 jmp	 SHORT $LN42@stream_enc@7
$LN41@stream_enc@7:
  00560	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv217[rsp], 1
$LN42@stream_enc@7:
  0056b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv217[rsp]
  00572	eb 05		 jmp	 SHORT $LN35@stream_enc@7
$LN33@stream_enc@7:

; 872  : 	}
; 873  : 
; 874  : 	assert(0);
; 875  : 	return LZMA_PROG_ERROR;

  00574	b8 0b 00 00 00	 mov	 eax, 11
$LN35@stream_enc@7:

; 876  : }

  00579	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00580	c3		 ret	 0
stream_encode_mt ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\mythread.h
pdata	SEGMENT
$pdata$stream_encoder_mt_init DD imagerel stream_encoder_mt_init
	DD	imagerel stream_encoder_mt_init+1554
	DD	imagerel $unwind$stream_encoder_mt_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stream_encoder_mt_init DD 041801H
	DD	0290118H
	DD	060107011H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_encoder_mt.c
xdata	ENDS
;	COMDAT stream_encoder_mt_init
_TEXT	SEGMENT
filters$33412 = 48
outbuf_size_max$33414 = 56
block_size$33413 = 64
easy$33411 = 80
ret_$33418 = 272
coder$33424 = 280
ret_$33449 = 288
i$33451 = 296
ret_$33458 = 304
ret_$33465 = 308
next$ = 352
allocator$ = 360
options$ = 368
stream_encoder_mt_init PROC				; COMDAT

; 986  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
$LN34@stream_enc@8:

; 987  : 	lzma_next_coder_init(&stream_encoder_mt_init, next, allocator);

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stream_encoder_mt_init
  0001f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR next$[rsp]
  00027	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0002b	74 15		 je	 SHORT $LN31@stream_enc@8
  0002d	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00035	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0003d	e8 00 00 00 00	 call	 lzma_next_end
$LN31@stream_enc@8:
  00042	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encoder_mt_init
  00051	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 bd		 jne	 SHORT $LN34@stream_enc@8
$LN30@stream_enc@8:

; 988  : 
; 989  : 	// Get the filter chain.
; 990  :   {
; 991  : 	lzma_options_easy easy;
; 992  : 	const lzma_filter *filters;
; 993  : 	uint64_t block_size;
; 994  : 	uint64_t outbuf_size_max;
; 995  : 	return_if_error(get_options(options, &easy, &filters,
; 996  : 			&block_size, &outbuf_size_max));

  0005b	48 8d 44 24 38	 lea	 rax, QWORD PTR outbuf_size_max$33414[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	4c 8d 4c 24 40	 lea	 r9, QWORD PTR block_size$33413[rsp]
  0006a	4c 8d 44 24 30	 lea	 r8, QWORD PTR filters$33412[rsp]
  0006f	48 8d 54 24 50	 lea	 rdx, QWORD PTR easy$33411[rsp]
  00074	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR options$[rsp]
  0007c	e8 00 00 00 00	 call	 get_options
  00081	89 84 24 10 01
	00 00		 mov	 DWORD PTR ret_$33418[rsp], eax
  00088	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR ret_$33418[rsp], 0
  00090	74 0c		 je	 SHORT $LN27@stream_enc@8
  00092	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR ret_$33418[rsp]
  00099	e9 6a 05 00 00	 jmp	 $LN35@stream_enc@8
$LN27@stream_enc@8:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b7		 jne	 SHORT $LN30@stream_enc@8

; 997  : 
; 998  : #if SIZE_MAX < UINT64_MAX
; 999  : 	if (block_size > SIZE_MAX)
; 1000 : 		return LZMA_MEM_ERROR;
; 1001 : #endif
; 1002 : 
; 1003 : 	// Validate the filter chain so that we can give an error in this
; 1004 : 	// function instead of delaying it to the first call to lzma_code().
; 1005 : 	// The memory usage calculation verifies the filter chain as
; 1006 : 	// a side effect so we take advatange of that.
; 1007 : 	if (lzma_raw_encoder_memusage(filters) == UINT64_MAX)

  000a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filters$33412[rsp]
  000a9	e8 00 00 00 00	 call	 lzma_raw_encoder_memusage
  000ae	48 83 f8 ff	 cmp	 rax, -1
  000b2	75 0a		 jne	 SHORT $LN26@stream_enc@8

; 1008 : 		return LZMA_OPTIONS_ERROR;

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	e9 4a 05 00 00	 jmp	 $LN35@stream_enc@8
$LN26@stream_enc@8:

; 1009 : 
; 1010 : 	// Validate the Check ID.
; 1011 : 	if ((unsigned int)(options->check) > LZMA_CHECK_ID_MAX)

  000be	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  000c6	83 78 20 0f	 cmp	 DWORD PTR [rax+32], 15
  000ca	76 0a		 jbe	 SHORT $LN25@stream_enc@8

; 1012 : 		return LZMA_PROG_ERROR;

  000cc	b8 0b 00 00 00	 mov	 eax, 11
  000d1	e9 32 05 00 00	 jmp	 $LN35@stream_enc@8
$LN25@stream_enc@8:

; 1013 : 
; 1014 : 	if (!lzma_check_is_supported(options->check))

  000d6	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  000de	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  000e1	e8 00 00 00 00	 call	 lzma_check_is_supported
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	85 c0		 test	 eax, eax
  000eb	75 0a		 jne	 SHORT $LN24@stream_enc@8

; 1015 : 		return LZMA_UNSUPPORTED_CHECK;

  000ed	b8 03 00 00 00	 mov	 eax, 3
  000f2	e9 11 05 00 00	 jmp	 $LN35@stream_enc@8
$LN24@stream_enc@8:

; 1016 : 
; 1017 : 	// Allocate and initialize the base structure if needed.
; 1018 :   { lzma_stream_coder *coder = next->coder;

  000f7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR next$[rsp]
  000ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00102	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR coder$33424[rsp], rax

; 1019 : 	if (coder == NULL) {

  0010a	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR coder$33424[rsp], 0
  00113	0f 85 af 01 00
	00		 jne	 $LN23@stream_enc@8

; 1020 : 		coder = lzma_alloc(sizeof(lzma_stream_coder), allocator);

  00119	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00121	b9 98 01 00 00	 mov	 ecx, 408		; 00000198H
  00126	e8 00 00 00 00	 call	 lzma_alloc
  0012b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR coder$33424[rsp], rax

; 1021 : 		if (coder == NULL)

  00133	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR coder$33424[rsp], 0
  0013c	75 0a		 jne	 SHORT $LN22@stream_enc@8

; 1022 : 			return LZMA_MEM_ERROR;

  0013e	b8 05 00 00 00	 mov	 eax, 5
  00143	e9 c0 04 00 00	 jmp	 $LN35@stream_enc@8
$LN22@stream_enc@8:

; 1023 : 
; 1024 : 		next->coder = coder;

  00148	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  00150	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  00158	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1025 : 
; 1026 : 		// For the mutex and condition variable initializations
; 1027 : 		// the error handling has to be done here because
; 1028 : 		// stream_encoder_mt_end() doesn't know if they have
; 1029 : 		// already been initialized or not.
; 1030 : 		if (mythread_mutex_init(&coder->mutex)) {

  0015b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00163	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	74 2e		 je	 SHORT $LN21@stream_enc@8

; 1031 : 			lzma_free(coder, allocator);

  00176	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  0017e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00186	e8 00 00 00 00	 call	 lzma_free

; 1032 : 			next->coder = NULL;

  0018b	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR next$[rsp]
  00193	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0

; 1033 : 			return LZMA_MEM_ERROR;

  0019a	b8 05 00 00 00	 mov	 eax, 5
  0019f	e9 64 04 00 00	 jmp	 $LN35@stream_enc@8
$LN21@stream_enc@8:

; 1034 : 		}
; 1035 : 
; 1036 : 		if (mythread_cond_init(&coder->cond)) {

  001a4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  001ac	48 81 c1 90 01
	00 00		 add	 rcx, 400		; 00000190H
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeConditionVariable
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	74 43		 je	 SHORT $LN20@stream_enc@8

; 1037 : 			mythread_mutex_destroy(&coder->mutex);

  001bf	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  001c7	48 81 c1 68 01
	00 00		 add	 rcx, 360		; 00000168H
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 1038 : 			lzma_free(coder, allocator);

  001d4	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001dc	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  001e4	e8 00 00 00 00	 call	 lzma_free

; 1039 : 			next->coder = NULL;

  001e9	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR next$[rsp]
  001f1	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0

; 1040 : 			return LZMA_MEM_ERROR;

  001f8	b8 05 00 00 00	 mov	 eax, 5
  001fd	e9 06 04 00 00	 jmp	 $LN35@stream_enc@8
$LN20@stream_enc@8:

; 1041 : 		}
; 1042 : 
; 1043 : 		next->code = &stream_encode_mt;

  00202	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0020a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encode_mt
  00211	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1044 : 		next->end = &stream_encoder_mt_end;

  00215	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  0021d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:stream_encoder_mt_end
  00224	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1045 : 		next->get_progress = &get_progress;

  00228	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR next$[rsp]
  00230	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:get_progress
  00237	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1046 : // 		next->update = &stream_encoder_mt_update;
; 1047 : 
; 1048 : 		coder->filters[0].id = LZMA_VLI_UNKNOWN;

  0023b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  00243	48 c7 40 10 ff
	ff ff ff	 mov	 QWORD PTR [rax+16], -1

; 1049 : 		coder->index_encoder = LZMA_NEXT_CODER_INIT;

  0024b	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR coder$33424[rsp]
  00253	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  0025a	48 83 c7 68	 add	 rdi, 104		; 00000068H
  0025e	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00263	f3 a4		 rep movsb

; 1050 : 		coder->index = NULL;

  00265	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  0026d	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 1051 : 		memzero(&coder->outq, sizeof(coder->outq));

  00275	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  0027d	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  00284	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  0028a	33 d2		 xor	 edx, edx
  0028c	e8 00 00 00 00	 call	 memset

; 1052 : 		coder->threads = NULL;

  00291	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR coder$33424[rsp]
  00299	48 c7 82 38 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdx+312], 0

; 1053 : 		coder->threads_max = 0;

  002a4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  002ac	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 1054 : 		coder->threads_initialized = 0;

  002b6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  002be	c7 80 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+324], 0
$LN23@stream_enc@8:

; 1055 : 	}
; 1056 : 
; 1057 : 	// Basic initializations
; 1058 : 	coder->sequence = SEQ_STREAM_HEADER;

  002c8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  002d0	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1059 : 	coder->block_size = (size_t)(block_size);

  002d6	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  002de	48 8b 44 24 40	 mov	 rax, QWORD PTR block_size$33413[rsp]
  002e3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1060 : 	coder->thread_error = LZMA_OK;

  002e7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  002ef	c7 80 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+308], 0

; 1061 : 	coder->thr = NULL;

  002f9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  00301	48 c7 80 50 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+336], 0

; 1062 : 
; 1063 : 	// Allocate the thread-specific base structures.
; 1064 : 	assert(options->threads > 0);
; 1065 : 	if (coder->threads_max != options->threads) {

  0030c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00314	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  0031c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0031f	39 81 40 01 00
	00		 cmp	 DWORD PTR [rcx+320], eax
  00325	0f 84 c7 00 00
	00		 je	 $LN19@stream_enc@8

; 1066 : 		threads_end(coder, allocator);

  0032b	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00333	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  0033b	e8 00 00 00 00	 call	 threads_end

; 1067 : 
; 1068 : 		coder->threads = NULL;

  00340	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR coder$33424[rsp]
  00348	48 c7 82 38 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdx+312], 0

; 1069 : 		coder->threads_max = 0;

  00353	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  0035b	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 1070 : 
; 1071 : 		coder->threads_initialized = 0;

  00365	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  0036d	c7 80 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+324], 0

; 1072 : 		coder->threads_free = NULL;

  00377	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  0037f	48 c7 80 48 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+328], 0

; 1073 : 
; 1074 : 		coder->threads = lzma_alloc(
; 1075 : 				options->threads * sizeof(worker_thread),
; 1076 : 				allocator);

  0038a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00392	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00395	48 69 c9 98 01
	00 00		 imul	 rcx, 408		; 00000198H
  0039c	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003a4	e8 00 00 00 00	 call	 lzma_alloc
  003a9	48 8b d0	 mov	 rdx, rax
  003ac	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  003b4	48 89 90 38 01
	00 00		 mov	 QWORD PTR [rax+312], rdx

; 1077 : 		if (coder->threads == NULL)

  003bb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  003c3	48 83 b8 38 01
	00 00 00	 cmp	 QWORD PTR [rax+312], 0
  003cb	75 0a		 jne	 SHORT $LN18@stream_enc@8

; 1078 : 			return LZMA_MEM_ERROR;

  003cd	b8 05 00 00 00	 mov	 eax, 5
  003d2	e9 31 02 00 00	 jmp	 $LN35@stream_enc@8
$LN18@stream_enc@8:

; 1079 : 
; 1080 : 		coder->threads_max = options->threads;

  003d7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  003df	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  003e7	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003ea	89 81 40 01 00
	00		 mov	 DWORD PTR [rcx+320], eax

; 1081 : 	} else {

  003f0	eb 0f		 jmp	 SHORT $LN17@stream_enc@8
$LN19@stream_enc@8:

; 1082 : 		// Reuse the old structures and threads. Tell the running
; 1083 : 		// threads to stop and wait until they have stopped.
; 1084 : 		threads_stop(coder, true);

  003f2	b2 01		 mov	 dl, 1
  003f4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  003fc	e8 00 00 00 00	 call	 threads_stop
$LN17@stream_enc@8:
$LN16@stream_enc@8:

; 1085 : 	}
; 1086 : 
; 1087 : 	// Output queue
; 1088 : 	return_if_error(lzma_outq_init(&coder->outq, allocator,
; 1089 : 			outbuf_size_max, options->threads));

  00401	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00409	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  00410	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00418	44 8b 48 04	 mov	 r9d, DWORD PTR [rax+4]
  0041c	4c 8b 44 24 38	 mov	 r8, QWORD PTR outbuf_size_max$33414[rsp]
  00421	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00429	e8 00 00 00 00	 call	 lzma_outq_init
  0042e	89 84 24 20 01
	00 00		 mov	 DWORD PTR ret_$33449[rsp], eax
  00435	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR ret_$33449[rsp], 0
  0043d	74 0c		 je	 SHORT $LN13@stream_enc@8
  0043f	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR ret_$33449[rsp]
  00446	e9 bd 01 00 00	 jmp	 $LN35@stream_enc@8
$LN13@stream_enc@8:
  0044b	33 c0		 xor	 eax, eax
  0044d	85 c0		 test	 eax, eax
  0044f	75 b0		 jne	 SHORT $LN16@stream_enc@8

; 1090 : 
; 1091 : 	// Timeout
; 1092 : 	coder->timeout = options->timeout;

  00451	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00459	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00461	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00464	89 81 30 01 00
	00		 mov	 DWORD PTR [rcx+304], eax

; 1093 : 
; 1094 : 	// Free the old filter chain and copy the new one.
; 1095 :   { size_t i;
; 1096 : 
; 1097 : 	for (i = 0; coder->filters[i].id != LZMA_VLI_UNKNOWN; ++i)

  0046a	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR i$33451[rsp], 0
  00476	eb 14		 jmp	 SHORT $LN12@stream_enc@8
$LN11@stream_enc@8:
  00478	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR i$33451[rsp]
  00480	48 83 c0 01	 add	 rax, 1
  00484	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR i$33451[rsp], rax
$LN12@stream_enc@8:
  0048c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR i$33451[rsp]
  00494	48 6b c9 10	 imul	 rcx, 16
  00498	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  004a0	48 83 7c 08 10
	ff		 cmp	 QWORD PTR [rax+rcx+16], -1
  004a6	74 28		 je	 SHORT $LN10@stream_enc@8

; 1098 : 		lzma_free(coder->filters[i].options, allocator);

  004a8	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR i$33451[rsp]
  004b0	48 6b c0 10	 imul	 rax, 16
  004b4	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  004bc	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  004c4	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  004c9	e8 00 00 00 00	 call	 lzma_free
  004ce	eb a8		 jmp	 SHORT $LN11@stream_enc@8
$LN10@stream_enc@8:
$LN9@stream_enc@8:

; 1099 :   }
; 1100 : 
; 1101 : 	return_if_error(lzma_filters_copy(
; 1102 : 			filters, coder->filters, allocator));

  004d0	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR coder$33424[rsp]
  004d8	48 83 c2 10	 add	 rdx, 16
  004dc	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR allocator$[rsp]
  004e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filters$33412[rsp]
  004e9	e8 00 00 00 00	 call	 lzma_filters_copy
  004ee	89 84 24 30 01
	00 00		 mov	 DWORD PTR ret_$33458[rsp], eax
  004f5	83 bc 24 30 01
	00 00 00	 cmp	 DWORD PTR ret_$33458[rsp], 0
  004fd	74 0c		 je	 SHORT $LN6@stream_enc@8
  004ff	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR ret_$33458[rsp]
  00506	e9 fd 00 00 00	 jmp	 $LN35@stream_enc@8
$LN6@stream_enc@8:
  0050b	33 c0		 xor	 eax, eax
  0050d	85 c0		 test	 eax, eax
  0050f	75 bf		 jne	 SHORT $LN9@stream_enc@8

; 1103 : 
; 1104 : 	// Index
; 1105 : 	lzma_index_end(coder->index, allocator);

  00511	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00519	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00521	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00525	e8 00 00 00 00	 call	 lzma_index_end

; 1106 : 	coder->index = lzma_index_init(allocator);

  0052a	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR allocator$[rsp]
  00532	e8 00 00 00 00	 call	 lzma_index_init
  00537	48 8b d0	 mov	 rdx, rax
  0053a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  00542	48 89 50 60	 mov	 QWORD PTR [rax+96], rdx

; 1107 : 	if (coder->index == NULL)

  00546	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  0054e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00553	75 0a		 jne	 SHORT $LN5@stream_enc@8

; 1108 : 		return LZMA_MEM_ERROR;

  00555	b8 05 00 00 00	 mov	 eax, 5
  0055a	e9 a9 00 00 00	 jmp	 $LN35@stream_enc@8
$LN5@stream_enc@8:

; 1109 : 
; 1110 : 	// Stream Header
; 1111 : 	coder->stream_flags.version = 0;

  0055f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  00567	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+176], 0

; 1112 : 	coder->stream_flags.check = options->check;

  00571	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  00579	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR options$[rsp]
  00581	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00584	89 81 c0 00 00
	00		 mov	 DWORD PTR [rcx+192], eax
$LN4@stream_enc@8:

; 1113 : 	return_if_error(lzma_stream_header_encode(
; 1114 : 			&coder->stream_flags, coder->header));

  0058a	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR coder$33424[rsp]
  00592	48 81 c2 e8 00
	00 00		 add	 rdx, 232		; 000000e8H
  00599	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR coder$33424[rsp]
  005a1	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  005a8	e8 00 00 00 00	 call	 lzma_stream_header_encode
  005ad	89 84 24 34 01
	00 00		 mov	 DWORD PTR ret_$33465[rsp], eax
  005b4	83 bc 24 34 01
	00 00 00	 cmp	 DWORD PTR ret_$33465[rsp], 0
  005bc	74 09		 je	 SHORT $LN1@stream_enc@8
  005be	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR ret_$33465[rsp]
  005c5	eb 41		 jmp	 SHORT $LN35@stream_enc@8
$LN1@stream_enc@8:
  005c7	33 c0		 xor	 eax, eax
  005c9	85 c0		 test	 eax, eax
  005cb	75 bd		 jne	 SHORT $LN4@stream_enc@8

; 1115 : 
; 1116 : 	coder->header_pos = 0;

  005cd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  005d5	48 c7 80 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+248], 0

; 1117 : 
; 1118 : 	// Progress info
; 1119 : 	coder->progress_in = 0;

  005e0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  005e8	48 c7 80 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+344], 0

; 1120 : 	coder->progress_out = LZMA_STREAM_HEADER_SIZE;

  005f3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR coder$33424[rsp]
  005fb	48 c7 80 60 01
	00 00 0c 00 00
	00		 mov	 QWORD PTR [rax+352], 12

; 1121 :   }}
; 1122 : 
; 1123 : 	return LZMA_OK;

  00606	33 c0		 xor	 eax, eax
$LN35@stream_enc@8:

; 1124 : }

  00608	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0060f	5f		 pop	 rdi
  00610	5e		 pop	 rsi
  00611	c3		 ret	 0
stream_encoder_mt_init ENDP
_TEXT	ENDS
PUBLIC	lzma_stream_encoder_mt
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_encoder_mt DD imagerel $LN11
	DD	imagerel $LN11+167
	DD	imagerel $unwind$lzma_stream_encoder_mt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_encoder_mt DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_stream_encoder_mt
_TEXT	SEGMENT
ret_$33478 = 32
ret_$33480 = 36
strm$ = 64
options$ = 72
lzma_stream_encoder_mt PROC				; COMDAT

; 1129 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@lzma_strea@10:
$LN5@lzma_strea@10:

; 1130 : 	lzma_next_strm_init(stream_encoder_mt_init, strm, options);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_strm_init
  00018	89 44 24 20	 mov	 DWORD PTR ret_$33478[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33478[rsp], 0
  00021	74 06		 je	 SHORT $LN2@lzma_strea@10
  00023	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33478[rsp]
  00027	eb 79		 jmp	 SHORT $LN9@lzma_strea@10
$LN2@lzma_strea@10:
  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 df		 jne	 SHORT $LN5@lzma_strea@10
  0002f	4c 8b 44 24 48	 mov	 r8, QWORD PTR options$[rsp]
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00039	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00042	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00046	e8 00 00 00 00	 call	 stream_encoder_mt_init
  0004b	89 44 24 24	 mov	 DWORD PTR ret_$33480[rsp], eax
  0004f	83 7c 24 24 00	 cmp	 DWORD PTR ret_$33480[rsp], 0
  00054	74 10		 je	 SHORT $LN1@lzma_strea@10
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0005b	e8 00 00 00 00	 call	 lzma_end
  00060	8b 44 24 24	 mov	 eax, DWORD PTR ret_$33480[rsp]
  00064	eb 3c		 jmp	 SHORT $LN9@lzma_strea@10
$LN1@lzma_strea@10:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 a2		 jne	 SHORT $LN8@lzma_strea@10

; 1131 : 
; 1132 : 	strm->internal->supported_actions[LZMA_RUN] = true;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00075	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 1133 : // 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;
; 1134 : 	strm->internal->supported_actions[LZMA_FULL_FLUSH] = true;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00082	c6 40 5a 01	 mov	 BYTE PTR [rax+90], 1

; 1135 : 	strm->internal->supported_actions[LZMA_FULL_BARRIER] = true;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008f	c6 40 5c 01	 mov	 BYTE PTR [rax+92], 1

; 1136 : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00098	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009c	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 1137 : 
; 1138 : 	return LZMA_OK;

  000a0	33 c0		 xor	 eax, eax
$LN9@lzma_strea@10:

; 1139 : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
lzma_stream_encoder_mt ENDP
_TEXT	ENDS
END
