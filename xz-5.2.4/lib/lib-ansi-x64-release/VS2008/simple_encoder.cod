; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_simple_props_encode
PUBLIC	lzma_simple_props_size
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\simple_encoder.c
pdata	SEGMENT
$pdata$lzma_simple_props_size DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$lzma_simple_props_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_props_size DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_props_size
_TEXT	SEGMENT
opt$ = 0
tv66 = 8
size$ = 32
options$ = 40
lzma_simple_props_size PROC				; COMDAT

; 18   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 19   : 	const lzma_options_bcj *const opt = options;

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR options$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR opt$[rsp], rax

; 20   : 	*size = (opt == NULL || opt->start_offset == 0) ? 0 : 4;

  00017	48 83 3c 24 00	 cmp	 QWORD PTR opt$[rsp], 0
  0001c	74 13		 je	 SHORT $LN3@lzma_simpl
  0001e	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00022	83 38 00	 cmp	 DWORD PTR [rax], 0
  00025	74 0a		 je	 SHORT $LN3@lzma_simpl
  00027	c7 44 24 08 04
	00 00 00	 mov	 DWORD PTR tv66[rsp], 4
  0002f	eb 08		 jmp	 SHORT $LN4@lzma_simpl
$LN3@lzma_simpl:
  00031	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN4@lzma_simpl:
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$[rsp]
  0003e	8b 44 24 08	 mov	 eax, DWORD PTR tv66[rsp]
  00042	89 01		 mov	 DWORD PTR [rcx], eax

; 21   : 	return LZMA_OK;

  00044	33 c0		 xor	 eax, eax

; 22   : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
lzma_simple_props_size ENDP
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
_TEXT	ENDS
;	COMDAT write32ne
_TEXT	SEGMENT
buf$ = 8
num$ = 16
write32ne PROC						; COMDAT

; 266  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  : 	*(uint32_t *)buf = num;

  00009	48 8b 4c 24 08	 mov	 rcx, QWORD PTR buf$[rsp]
  0000e	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00012	89 01		 mov	 DWORD PTR [rcx], eax

; 268  : 	return;
; 269  : }

  00014	c3		 ret	 0
write32ne ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_props_encode DD imagerel $LN7
	DD	imagerel $LN7+71
	DD	imagerel $unwind$lzma_simple_props_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_props_encode DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\simple_encoder.c
xdata	ENDS
;	COMDAT lzma_simple_props_encode
_TEXT	SEGMENT
opt$ = 0
$T80372 = 8
options$ = 32
out$ = 40
lzma_simple_props_encode PROC				; COMDAT

; 27   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 28   : 	const lzma_options_bcj *const opt = options;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR opt$[rsp], rax

; 29   : 
; 30   : 	// The default start offset is zero, so we don't need to store any
; 31   : 	// options unless the start offset is non-zero.
; 32   : 	if (opt == NULL || opt->start_offset == 0)

  00017	48 83 3c 24 00	 cmp	 QWORD PTR opt$[rsp], 0
  0001c	74 09		 je	 SHORT $LN1@lzma_simpl@2
  0001e	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00022	83 38 00	 cmp	 DWORD PTR [rax], 0
  00025	75 04		 jne	 SHORT $LN2@lzma_simpl@2
$LN1@lzma_simpl@2:

; 33   : 		return LZMA_OK;

  00027	33 c0		 xor	 eax, eax
  00029	eb 17		 jmp	 SHORT $LN3@lzma_simpl@2
$LN2@lzma_simpl@2:

; 34   : 
; 35   : 	unaligned_write32le(out, opt->start_offset);

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  0002f	8b 00		 mov	 eax, DWORD PTR [rax]
  00031	89 44 24 08	 mov	 DWORD PTR $T80372[rsp], eax
  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR out$[rsp]
  0003a	8b 44 24 08	 mov	 eax, DWORD PTR $T80372[rsp]
  0003e	89 01		 mov	 DWORD PTR [rcx], eax

; 36   : 
; 37   : 	return LZMA_OK;

  00040	33 c0		 xor	 eax, eax
$LN3@lzma_simpl@2:

; 38   : }

  00042	48 83 c4 18	 add	 rsp, 24
  00046	c3		 ret	 0
lzma_simple_props_encode ENDP
END
