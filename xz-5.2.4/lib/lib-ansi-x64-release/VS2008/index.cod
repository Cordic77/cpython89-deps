; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_index_iter_rewind
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
;	COMDAT lzma_index_iter_rewind
_TEXT	SEGMENT
iter$ = 8
lzma_index_iter_rewind PROC				; COMDAT

; 1126 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1127 : 	iter->internal[ITER_STREAM].p = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR iter$[rsp]
  0000a	48 c7 80 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+264], 0

; 1128 : 	iter->internal[ITER_GROUP].p = NULL;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR iter$[rsp]
  0001a	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0

; 1129 : 	iter->internal[ITER_RECORD].s = 0;

  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR iter$[rsp]
  0002a	48 c7 80 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+280], 0

; 1130 : 	iter->internal[ITER_METHOD].s = ITER_METHOD_NORMAL;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR iter$[rsp]
  0003a	48 c7 80 20 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+288], 0

; 1131 : 	return;
; 1132 : }

  00045	c3		 ret	 0
lzma_index_iter_rewind ENDP
_TEXT	ENDS
PUBLIC	lzma_index_iter_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_iter_init DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$lzma_index_iter_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_iter_init DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_iter_init
_TEXT	SEGMENT
iter$ = 48
i$ = 56
lzma_index_iter_init PROC				; COMDAT

; 1117 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1118 : 	iter->internal[ITER_INDEX].p = i;

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iter$[rsp]
  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00018	48 89 81 00 01
	00 00		 mov	 QWORD PTR [rcx+256], rax

; 1119 : 	lzma_index_iter_rewind(iter);

  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iter$[rsp]
  00024	e8 00 00 00 00	 call	 lzma_index_iter_rewind

; 1120 : 	return;
; 1121 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
lzma_index_iter_init ENDP
_TEXT	ENDS
PUBLIC	lzma_index_checks
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_checks DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$lzma_index_checks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_checks DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_checks
_TEXT	SEGMENT
s$ = 0
checks$ = 8
i$ = 32
lzma_index_checks PROC					; COMDAT

; 586  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 587  : 	uint32_t checks = i->checks;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0000e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00011	89 44 24 08	 mov	 DWORD PTR checks$[rsp], eax

; 588  : 
; 589  : 	// Get the type of the Check of the last Stream too.
; 590  : 	const index_stream *s = (const index_stream *)(i->streams.rightmost);

  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001e	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 591  : 	if (s->stream_flags.version != UINT32_MAX)

  00022	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00026	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1	; ffffffffH
  0002a	74 1a		 je	 SHORT $LN1@lzma_index

; 592  : 		checks |= UINT32_C(1) << s->stream_flags.check;

  0002c	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00030	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	d3 e0		 shl	 eax, cl
  0003a	8b c8		 mov	 ecx, eax
  0003c	8b 44 24 08	 mov	 eax, DWORD PTR checks$[rsp]
  00040	0b c1		 or	 eax, ecx
  00042	89 44 24 08	 mov	 DWORD PTR checks$[rsp], eax
$LN1@lzma_index:

; 593  : 
; 594  : 	return checks;

  00046	8b 44 24 08	 mov	 eax, DWORD PTR checks$[rsp]

; 595  : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
lzma_index_checks ENDP
_TEXT	ENDS
PUBLIC	lzma_index_uncompressed_size
; Function compile flags: /Odtp
;	COMDAT lzma_index_uncompressed_size
_TEXT	SEGMENT
i$ = 8
lzma_index_uncompressed_size PROC			; COMDAT

; 579  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 580  : 	return i->uncompressed_size;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0000a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]

; 581  : }

  0000e	c3		 ret	 0
lzma_index_uncompressed_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_total_size
; Function compile flags: /Odtp
;	COMDAT lzma_index_total_size
_TEXT	SEGMENT
i$ = 8
lzma_index_total_size PROC				; COMDAT

; 526  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 527  : 	return i->total_size;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0000a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 528  : }

  0000e	c3		 ret	 0
lzma_index_total_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_stream_count
; Function compile flags: /Odtp
;	COMDAT lzma_index_stream_count
_TEXT	SEGMENT
i$ = 8
lzma_index_stream_count PROC				; COMDAT

; 512  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 513  : 	return i->streams.count;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]

; 514  : }

  0000d	c3		 ret	 0
lzma_index_stream_count ENDP
_TEXT	ENDS
PUBLIC	lzma_index_block_count
; Function compile flags: /Odtp
;	COMDAT lzma_index_block_count
_TEXT	SEGMENT
i$ = 8
lzma_index_block_count PROC				; COMDAT

; 505  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 506  : 	return i->record_count;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0000a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]

; 507  : }

  0000e	c3		 ret	 0
lzma_index_block_count ENDP
_TEXT	ENDS
PUBLIC	lzma_index_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_memusage DD imagerel $LN5
	DD	imagerel $LN5+270
	DD	imagerel $unwind$lzma_index_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_memusage DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_memusage
_TEXT	SEGMENT
groups$ = 0
groups_mem$ = 8
streams_mem$ = 16
group_base$ = 24
stream_base$ = 32
index_base$ = 40
limit$ = 48
alloc_overhead$ = 56
streams$ = 80
blocks$ = 88
lzma_index_memusage PROC				; COMDAT

; 449  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 450  : 	// This calculates an upper bound that is only a little bit
; 451  : 	// bigger than the exact maximum memory usage with the given
; 452  : 	// parameters.
; 453  : 
; 454  : 	// Typical malloc() overhead is 2 * sizeof(void *) but we take
; 455  : 	// a little bit extra just in case. Using LZMA_MEMUSAGE_BASE
; 456  : 	// instead would give too inaccurate estimate.
; 457  : 	const size_t alloc_overhead = 4 * sizeof(void *);

  0000e	48 c7 44 24 38
	20 00 00 00	 mov	 QWORD PTR alloc_overhead$[rsp], 32 ; 00000020H

; 458  : 
; 459  : 	// Amount of memory needed for each Stream base structures.
; 460  : 	// We assume that every Stream has at least one Block and
; 461  : 	// thus at least one group.
; 462  : 	const size_t stream_base = sizeof(index_stream)
; 463  : 			+ sizeof(index_group) + 2 * alloc_overhead;

  00017	48 8b 44 24 38	 mov	 rax, QWORD PTR alloc_overhead$[rsp]
  0001c	48 8d 84 00 e8
	00 00 00	 lea	 rax, QWORD PTR [rax+rax+232]
  00024	48 89 44 24 20	 mov	 QWORD PTR stream_base$[rsp], rax

; 464  : 
; 465  : 	// Amount of memory needed per group.
; 466  : 	const size_t group_base = sizeof(index_group)
; 467  : 			+ INDEX_GROUP_SIZE * sizeof(index_record)
; 468  : 			+ alloc_overhead;

  00029	48 8b 44 24 38	 mov	 rax, QWORD PTR alloc_overhead$[rsp]
  0002e	48 05 40 20 00
	00		 add	 rax, 8256		; 00002040H
  00034	48 89 44 24 18	 mov	 QWORD PTR group_base$[rsp], rax

; 469  : 
; 470  : 	// Number of groups. There may actually be more, but that overhead
; 471  : 	// has been taken into account in stream_base already.
; 472  : 	const lzma_vli groups
; 473  : 			= (blocks + INDEX_GROUP_SIZE - 1) / INDEX_GROUP_SIZE;

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR blocks$[rsp]
  0003e	48 05 ff 01 00
	00		 add	 rax, 511		; 000001ffH
  00044	33 d2		 xor	 edx, edx
  00046	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0004b	48 f7 f1	 div	 rcx
  0004e	48 89 04 24	 mov	 QWORD PTR groups$[rsp], rax

; 474  : 
; 475  : 	// Memory used by index_stream and index_group structures.
; 476  : 	const uint64_t streams_mem = streams * stream_base;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR streams$[rsp]
  00057	48 0f af 44 24
	20		 imul	 rax, QWORD PTR stream_base$[rsp]
  0005d	48 89 44 24 10	 mov	 QWORD PTR streams_mem$[rsp], rax

; 477  : 	const uint64_t groups_mem = groups * group_base;

  00062	48 8b 04 24	 mov	 rax, QWORD PTR groups$[rsp]
  00066	48 0f af 44 24
	18		 imul	 rax, QWORD PTR group_base$[rsp]
  0006c	48 89 44 24 08	 mov	 QWORD PTR groups_mem$[rsp], rax

; 478  : 
; 479  : 	// Memory used by the base structure.
; 480  : 	const uint64_t index_base = sizeof(lzma_index) + alloc_overhead;

  00071	48 8b 44 24 38	 mov	 rax, QWORD PTR alloc_overhead$[rsp]
  00076	48 83 c0 50	 add	 rax, 80			; 00000050H
  0007a	48 89 44 24 28	 mov	 QWORD PTR index_base$[rsp], rax

; 481  : 
; 482  : 	// Validate the arguments and catch integer overflows.
; 483  : 	// Maximum number of Streams is "only" UINT32_MAX, because
; 484  : 	// that limit is used by the tree containing the Streams.
; 485  : 	const uint64_t limit = UINT64_MAX - index_base;

  0007f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00086	48 2b 44 24 28	 sub	 rax, QWORD PTR index_base$[rsp]
  0008b	48 89 44 24 30	 mov	 QWORD PTR limit$[rsp], rax

; 486  : 	if (streams == 0 || streams > UINT32_MAX || blocks > LZMA_VLI_MAX
; 487  : 			|| streams > limit / stream_base
; 488  : 			|| groups > limit / group_base
; 489  : 			|| limit - streams_mem < groups_mem)

  00090	48 83 7c 24 50
	00		 cmp	 QWORD PTR streams$[rsp], 0
  00096	74 56		 je	 SHORT $LN1@lzma_index@2
  00098	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0009d	48 39 44 24 50	 cmp	 QWORD PTR streams$[rsp], rax
  000a2	77 4a		 ja	 SHORT $LN1@lzma_index@2
  000a4	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000ae	48 39 44 24 58	 cmp	 QWORD PTR blocks$[rsp], rax
  000b3	77 39		 ja	 SHORT $LN1@lzma_index@2
  000b5	33 d2		 xor	 edx, edx
  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR limit$[rsp]
  000bc	48 f7 74 24 20	 div	 QWORD PTR stream_base$[rsp]
  000c1	48 39 44 24 50	 cmp	 QWORD PTR streams$[rsp], rax
  000c6	77 26		 ja	 SHORT $LN1@lzma_index@2
  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR limit$[rsp]
  000cf	48 f7 74 24 18	 div	 QWORD PTR group_base$[rsp]
  000d4	48 39 04 24	 cmp	 QWORD PTR groups$[rsp], rax
  000d8	77 14		 ja	 SHORT $LN1@lzma_index@2
  000da	48 8b 4c 24 10	 mov	 rcx, QWORD PTR streams_mem$[rsp]
  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR limit$[rsp]
  000e4	48 2b c1	 sub	 rax, rcx
  000e7	48 3b 44 24 08	 cmp	 rax, QWORD PTR groups_mem$[rsp]
  000ec	73 09		 jae	 SHORT $LN2@lzma_index@2
$LN1@lzma_index@2:

; 490  : 		return UINT64_MAX;

  000ee	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f5	eb 12		 jmp	 SHORT $LN3@lzma_index@2
$LN2@lzma_index@2:

; 491  : 
; 492  : 	return index_base + streams_mem + groups_mem;

  000f7	48 8b 4c 24 10	 mov	 rcx, QWORD PTR streams_mem$[rsp]
  000fc	48 8b 44 24 28	 mov	 rax, QWORD PTR index_base$[rsp]
  00101	48 03 c1	 add	 rax, rcx
  00104	48 03 44 24 08	 add	 rax, QWORD PTR groups_mem$[rsp]
$LN3@lzma_index@2:

; 493  : }

  00109	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010d	c3		 ret	 0
lzma_index_memusage ENDP
_TEXT	ENDS
PUBLIC	lzma_index_prealloc
; Function compile flags: /Odtp
;	COMDAT lzma_index_prealloc
_TEXT	SEGMENT
i$ = 8
records$ = 16
lzma_index_prealloc PROC				; COMDAT

; 438  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 439  : 	if (records > PREALLOC_MAX)

  0000a	48 b8 fb ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846971 ; 0ffffffffffffffbH
  00014	48 39 44 24 10	 cmp	 QWORD PTR records$[rsp], rax
  00019	76 0f		 jbe	 SHORT $LN1@lzma_index@3

; 440  : 		records = PREALLOC_MAX;

  0001b	48 b8 fb ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846971 ; 0ffffffffffffffbH
  00025	48 89 44 24 10	 mov	 QWORD PTR records$[rsp], rax
$LN1@lzma_index@3:

; 441  : 
; 442  : 	i->prealloc = (size_t)(records);

  0002a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  0002f	48 8b 44 24 10	 mov	 rax, QWORD PTR records$[rsp]
  00034	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 443  : 	return;
; 444  : }

  00038	c3		 ret	 0
lzma_index_prealloc ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT index_tree_next
_TEXT	SEGMENT
node$ = 8
index_tree_next PROC					; COMDAT

; 299  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 300  : 	if (node->right != NULL) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  0000a	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0000f	74 31		 je	 SHORT $LN5@index_tree

; 301  : 		node = node->right;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00016	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001a	48 89 44 24 08	 mov	 QWORD PTR node$[rsp], rax
$LN4@index_tree:

; 302  : 		while (node->left != NULL)

  0001f	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00024	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00029	74 10		 je	 SHORT $LN3@index_tree

; 303  : 			node = node->left;

  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00030	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00034	48 89 44 24 08	 mov	 QWORD PTR node$[rsp], rax
  00039	eb e4		 jmp	 SHORT $LN4@index_tree
$LN3@index_tree:

; 304  : 
; 305  : 		return (void *)(node);

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00040	eb 39		 jmp	 SHORT $LN6@index_tree
$LN5@index_tree:
$LN2@index_tree:

; 306  : 	}
; 307  : 
; 308  : 	while (node->parent != NULL && node->parent->right == node)

  00042	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00047	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0004c	74 24		 je	 SHORT $LN1@index_tree
  0004e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR node$[rsp]
  00053	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00057	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  0005c	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00060	75 10		 jne	 SHORT $LN1@index_tree

; 309  : 		node = node->parent;

  00062	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00067	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006b	48 89 44 24 08	 mov	 QWORD PTR node$[rsp], rax
  00070	eb d0		 jmp	 SHORT $LN2@index_tree
$LN1@index_tree:

; 310  : 
; 311  : 	return (void *)(node->parent);

  00072	48 8b 44 24 08	 mov	 rax, QWORD PTR node$[rsp]
  00077	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN6@index_tree:

; 312  : }

  0007b	f3 c3		 fatret	 0
index_tree_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_tree_node_end DD imagerel index_tree_node_end
	DD	imagerel index_tree_node_end+110
	DD	imagerel $unwind$index_tree_node_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_tree_node_end DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_tree_node_end
_TEXT	SEGMENT
node$ = 48
allocator$ = 56
free_func$ = 64
index_tree_node_end PROC				; COMDAT

; 196  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  : 	// The tree won't ever be very huge, so recursion should be fine.
; 198  : 	// 20 levels in the tree is likely quite a lot already in practice.
; 199  : 	if (node->left != NULL)

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR node$[rsp]
  00018	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0001d	74 18		 je	 SHORT $LN2@index_tree@2

; 200  : 		index_tree_node_end(node->left, allocator, free_func);

  0001f	4c 8b 44 24 40	 mov	 r8, QWORD PTR free_func$[rsp]
  00024	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR node$[rsp]
  0002e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00032	e8 00 00 00 00	 call	 index_tree_node_end
$LN2@index_tree@2:

; 201  : 
; 202  : 	if (node->right != NULL)

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR node$[rsp]
  0003c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00041	74 18		 je	 SHORT $LN1@index_tree@2

; 203  : 		index_tree_node_end(node->right, allocator, free_func);

  00043	4c 8b 44 24 40	 mov	 r8, QWORD PTR free_func$[rsp]
  00048	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR node$[rsp]
  00052	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00056	e8 00 00 00 00	 call	 index_tree_node_end
$LN1@index_tree@2:

; 204  : 
; 205  : 	free_func(node, allocator);

  0005b	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR node$[rsp]
  00065	ff 54 24 40	 call	 QWORD PTR free_func$[rsp]

; 206  : 	return;
; 207  : }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
index_tree_node_end ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT index_tree_init
_TEXT	SEGMENT
tree$ = 8
index_tree_init PROC					; COMDAT

; 183  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 184  : 	tree->root = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR tree$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 185  : 	tree->leftmost = NULL;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR tree$[rsp]
  00016	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 186  : 	tree->rightmost = NULL;

  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR tree$[rsp]
  00023	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 187  : 	tree->count = 0;

  0002b	48 8b 44 24 08	 mov	 rax, QWORD PTR tree$[rsp]
  00030	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 188  : 	return;
; 189  : }

  00037	c3		 ret	 0
index_tree_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_size_unpadded DD imagerel index_size_unpadded
	DD	imagerel index_size_unpadded+44
	DD	imagerel $unwind$index_size_unpadded
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_size_unpadded DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_size_unpadded
_TEXT	SEGMENT
count$ = 48
index_list_size$ = 56
index_size_unpadded PROC				; COMDAT

; 49   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 50   : 	// Index Indicator + Number of Records + List of Records + CRC32
; 51   : 	return 1 + lzma_vli_size(count) + index_list_size + 4;

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_vli_size
  00018	83 c0 01	 add	 eax, 1
  0001b	8b c8		 mov	 ecx, eax
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR index_list_size$[rsp]
  00022	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]

; 52   : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
index_size_unpadded ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT vli_ceil4
_TEXT	SEGMENT
vli$ = 8
vli_ceil4 PROC						; COMDAT

; 40   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 41   : 	assert(vli <= LZMA_VLI_MAX);
; 42   : 	return (vli + 3) & ~LZMA_VLI_C(3);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR vli$[rsp]
  0000a	48 83 c0 03	 add	 rax, 3
  0000e	48 83 e0 fc	 and	 rax, -4

; 43   : }

  00012	c3		 ret	 0
vli_ceil4 ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$ctz32 DD	imagerel ctz32
	DD	imagerel ctz32+26
	DD	imagerel $unwind$ctz32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ctz32 DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ctz32
_TEXT	SEGMENT
i$ = 0
n$ = 32
ctz32	PROC						; COMDAT

; 492  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 493  : #if defined(__INTEL_COMPILER)
; 494  : 	return _bit_scan_forward(n);
; 495  : 
; 496  : #elif TUKLIB_GNUC_REQ(3, 4) && UINT_MAX >= UINT32_MAX
; 497  : 	return __builtin_ctz(n);
; 498  : 
; 499  : #elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
; 500  : 	uint32_t i;
; 501  : 	__asm__("bsfl %1, %0" : "=r" (i) : "rm" (n));
; 502  : 	return i;
; 503  : 
; 504  : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 505  : 	uint32_t i;
; 506  : 	_BitScanForward((DWORD *)&i, n);

  00008	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0000c	0f bc c0	 bsf	 eax, eax
  0000f	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 507  : 	return i;

  00012	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]

; 508  : 
; 509  : #else
; 510  : 	uint32_t i = 0;
; 511  : 
; 512  : 	if ((n & UINT32_C(0x0000FFFF)) == 0) {
; 513  : 		n >>= 16;
; 514  : 		i = 16;
; 515  : 	}
; 516  : 
; 517  : 	if ((n & UINT32_C(0x000000FF)) == 0) {
; 518  : 		n >>= 8;
; 519  : 		i += 8;
; 520  : 	}
; 521  : 
; 522  : 	if ((n & UINT32_C(0x0000000F)) == 0) {
; 523  : 		n >>= 4;
; 524  : 		i += 4;
; 525  : 	}
; 526  : 
; 527  : 	if ((n & UINT32_C(0x00000003)) == 0) {
; 528  : 		n >>= 2;
; 529  : 		i += 2;
; 530  : 	}
; 531  : 
; 532  : 	if ((n & UINT32_C(0x00000001)) == 0)
; 533  : 		++i;
; 534  : 
; 535  : 	return i;
; 536  : #endif
; 537  : }

  00015	48 83 c4 18	 add	 rsp, 24
  00019	c3		 ret	 0
ctz32	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bsr32 DD	imagerel bsr32
	DD	imagerel bsr32+26
	DD	imagerel $unwind$bsr32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bsr32 DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bsr32
_TEXT	SEGMENT
i$ = 0
n$ = 32
bsr32	PROC						; COMDAT

; 383  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 384  : 	// Check for ICC first, since it tends to define __GNUC__ too.
; 385  : #if defined(__INTEL_COMPILER)
; 386  : 	return _bit_scan_reverse(n);
; 387  : 
; 388  : #elif TUKLIB_GNUC_REQ(3, 4) && UINT_MAX == UINT32_MAX
; 389  : 	// GCC >= 3.4 has __builtin_clz(), which gives good results on
; 390  : 	// multiple architectures. On x86, __builtin_clz() ^ 31U becomes
; 391  : 	// either plain BSR (so the XOR gets optimized away) or LZCNT and
; 392  : 	// XOR (if -march indicates that SSE4a instructions are supported).
; 393  : 	return __builtin_clz(n) ^ 31U;
; 394  : 
; 395  : #elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
; 396  : 	uint32_t i;
; 397  : 	__asm__("bsrl %1, %0" : "=r" (i) : "rm" (n));
; 398  : 	return i;
; 399  : 
; 400  : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 401  : 	// MSVC isn't supported by tuklib, but since this code exists,
; 402  : 	// it doesn't hurt to have it here anyway.
; 403  : 	uint32_t i;
; 404  : 	_BitScanReverse((DWORD *)&i, n);

  00008	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0000c	0f bd c0	 bsr	 eax, eax
  0000f	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 405  : 	return i;

  00012	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]

; 406  : 
; 407  : #else
; 408  : 	uint32_t i = 31;
; 409  : 
; 410  : 	if ((n & UINT32_C(0xFFFF0000)) == 0) {
; 411  : 		n <<= 16;
; 412  : 		i = 15;
; 413  : 	}
; 414  : 
; 415  : 	if ((n & UINT32_C(0xFF000000)) == 0) {
; 416  : 		n <<= 8;
; 417  : 		i -= 8;
; 418  : 	}
; 419  : 
; 420  : 	if ((n & UINT32_C(0xF0000000)) == 0) {
; 421  : 		n <<= 4;
; 422  : 		i -= 4;
; 423  : 	}
; 424  : 
; 425  : 	if ((n & UINT32_C(0xC0000000)) == 0) {
; 426  : 		n <<= 2;
; 427  : 		i -= 2;
; 428  : 	}
; 429  : 
; 430  : 	if ((n & UINT32_C(0x80000000)) == 0)
; 431  : 		--i;
; 432  : 
; 433  : 	return i;
; 434  : #endif
; 435  : }

  00015	48 83 c4 18	 add	 rsp, 24
  00019	c3		 ret	 0
bsr32	ENDP
PUBLIC	lzma_index_padding_size
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_padding_size DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$lzma_index_padding_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_padding_size DD 010901H
	DD	06209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT lzma_index_padding_size
_TEXT	SEGMENT
$T81734 = 32
$T81735 = 40
i$ = 64
lzma_index_padding_size PROC				; COMDAT

; 600  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 601  : 	return (LZMA_VLI_C(4) - index_size_unpadded(
; 602  : 			i->record_count, i->index_list_size)) & 3;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 89 44 24 28	 mov	 QWORD PTR $T81735[rsp], rax
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0001c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00020	48 89 44 24 20	 mov	 QWORD PTR $T81734[rsp], rax
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T81734[rsp]
  0002a	e8 00 00 00 00	 call	 lzma_vli_size
  0002f	83 c0 01	 add	 eax, 1
  00032	8b c8		 mov	 ecx, eax
  00034	48 8b 44 24 28	 mov	 rax, QWORD PTR $T81735[rsp]
  00039	48 8d 4c 01 04	 lea	 rcx, QWORD PTR [rcx+rax+4]
  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	48 2b c1	 sub	 rax, rcx
  00046	48 83 e0 03	 and	 rax, 3

; 603  : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
lzma_index_padding_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_memused
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_memused DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$lzma_index_memused
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_memused DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_memused
_TEXT	SEGMENT
i$ = 48
lzma_index_memused PROC					; COMDAT

; 498  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  : 	return lzma_index_memusage(i->streams.count, i->record_count);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0000e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00011	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  00016	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0001a	e8 00 00 00 00	 call	 lzma_index_memusage

; 500  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
lzma_index_memused ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_init_plain DD imagerel index_init_plain
	DD	imagerel index_init_plain+134
	DD	imagerel $unwind$index_init_plain
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_init_plain DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_init_plain
_TEXT	SEGMENT
i$ = 32
allocator$ = 64
index_init_plain PROC					; COMDAT

; 385  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 386  : 	lzma_index *i = lzma_alloc(sizeof(lzma_index), allocator);

  00009	48 8b 54 24 40	 mov	 rdx, QWORD PTR allocator$[rsp]
  0000e	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00013	e8 00 00 00 00	 call	 lzma_alloc
  00018	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 387  : 	if (i != NULL) {

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00023	74 57		 je	 SHORT $LN1@index_init

; 388  : 		index_tree_init(&i->streams);

  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0002a	e8 00 00 00 00	 call	 index_tree_init

; 389  : 		i->uncompressed_size = 0;

  0002f	4c 8b 5c 24 20	 mov	 r11, QWORD PTR i$[rsp]
  00034	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0

; 390  : 		i->total_size = 0;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00041	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 391  : 		i->record_count = 0;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0004e	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 392  : 		i->index_list_size = 0;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005b	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 393  : 		i->prealloc = INDEX_GROUP_SIZE;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00068	48 c7 40 40 00
	02 00 00	 mov	 QWORD PTR [rax+64], 512	; 00000200H

; 394  : 		i->checks = 0;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00075	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0
$LN1@index_init:

; 395  : 	}
; 396  : 
; 397  : 	return i;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]

; 398  : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
index_init_plain ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_stream_init DD imagerel index_stream_init
	DD	imagerel index_stream_init+229
	DD	imagerel $unwind$index_stream_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_stream_init DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_stream_init
_TEXT	SEGMENT
s$ = 32
compressed_base$ = 64
uncompressed_base$ = 72
stream_number$ = 80
block_number_base$ = 88
allocator$ = 96
index_stream_init PROC					; COMDAT

; 347  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 348  : 	index_stream *s = lzma_alloc(sizeof(index_stream), allocator);

  00018	48 8b 54 24 60	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00022	e8 00 00 00 00	 call	 lzma_alloc
  00027	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 349  : 	if (s == NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00032	75 07		 jne	 SHORT $LN1@index_stre

; 350  : 		return NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 a5 00 00 00	 jmp	 $LN2@index_stre
$LN1@index_stre:

; 351  : 
; 352  : 	s->node.uncompressed_base = uncompressed_base;

  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00040	48 8b 44 24 48	 mov	 rax, QWORD PTR uncompressed_base$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 353  : 	s->node.compressed_base = compressed_base;

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR compressed_base$[rsp]
  00052	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 354  : 	s->node.parent = NULL;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 355  : 	s->node.left = NULL;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00068	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 356  : 	s->node.right = NULL;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00075	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 357  : 
; 358  : 	s->number = stream_number;

  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00082	8b 44 24 50	 mov	 eax, DWORD PTR stream_number$[rsp]
  00086	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 359  : 	s->block_number_base = block_number_base;

  00089	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0008e	48 8b 44 24 58	 mov	 rax, QWORD PTR block_number_base$[rsp]
  00093	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 360  : 
; 361  : 	index_tree_init(&s->groups);

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0009c	48 83 c1 38	 add	 rcx, 56			; 00000038H
  000a0	e8 00 00 00 00	 call	 index_tree_init

; 362  : 
; 363  : 	s->record_count = 0;

  000a5	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  000aa	49 c7 43 58 00
	00 00 00	 mov	 QWORD PTR [r11+88], 0

; 364  : 	s->index_list_size = 0;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b7	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 365  : 	s->stream_flags.version = UINT32_MAX;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000c4	c7 40 68 ff ff
	ff ff		 mov	 DWORD PTR [rax+104], -1	; ffffffffH

; 366  : 	s->stream_padding = 0;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d0	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 367  : 
; 368  : 	return s;

  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
$LN2@index_stre:

; 369  : }

  000e0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e4	c3		 ret	 0
index_stream_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$index_tree_append DD imagerel index_tree_append
	DD	imagerel index_tree_append+445
	DD	imagerel $unwind$index_tree_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_tree_append DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT index_tree_append
_TEXT	SEGMENT
up$32937 = 0
pivot$32942 = 8
i$81760 = 16
$T81762 = 20
i$81765 = 24
$T81767 = 28
tree$ = 48
node$ = 56
index_tree_append PROC					; COMDAT

; 231  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 232  : 	node->parent = tree->rightmost;

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR node$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00018	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 233  : 	node->left = NULL;

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00025	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 234  : 	node->right = NULL;

  0002d	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00032	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 235  : 
; 236  : 	++tree->count;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0003f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00042	83 c1 01	 add	 ecx, 1
  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0004a	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 237  : 
; 238  : 	// Handle the special case of adding the first node.
; 239  : 	if (tree->root == NULL) {

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00052	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00056	75 2e		 jne	 SHORT $LN8@index_tree@3

; 240  : 		tree->root = node;

  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0005d	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00062	48 89 01	 mov	 QWORD PTR [rcx], rax

; 241  : 		tree->leftmost = node;

  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  0006f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 242  : 		tree->rightmost = node;

  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00078	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  0007d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 243  : 		return;

  00081	e9 32 01 00 00	 jmp	 $LN9@index_tree@3
$LN8@index_tree@3:

; 244  : 	}
; 245  : 
; 246  : 	// The tree is always filled sequentially.
; 247  : 	assert(tree->rightmost->uncompressed_base <= node->uncompressed_base);
; 248  : 	assert(tree->rightmost->compressed_base < node->compressed_base);
; 249  : 
; 250  : 	// Add the new node after the rightmost node. It's the correct
; 251  : 	// place due to the reason above.
; 252  : 	tree->rightmost->right = node;

  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0008b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0008f	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00094	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 253  : 	tree->rightmost = node;

  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0009d	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  000a2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 254  : 
; 255  : 	// Balance the AVL-tree if needed. We don't need to keep the balance
; 256  : 	// factors in nodes, because we always fill the tree sequentially,
; 257  : 	// and thus know the state of the tree just by looking at the node
; 258  : 	// count. From the node count we can calculate how many steps to go
; 259  : 	// up in the tree to find the rotation root.
; 260  :   {
; 261  : 	uint32_t up = tree->count ^ (UINT32_C(1) << bsr32(tree->count));

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000ab	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000ae	89 44 24 14	 mov	 DWORD PTR $T81762[rsp], eax
  000b2	8b 44 24 14	 mov	 eax, DWORD PTR $T81762[rsp]
  000b6	0f bd c0	 bsr	 eax, eax
  000b9	89 44 24 10	 mov	 DWORD PTR i$81760[rsp], eax
  000bd	8b 4c 24 10	 mov	 ecx, DWORD PTR i$81760[rsp]
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	d3 e0		 shl	 eax, cl
  000c8	8b c8		 mov	 ecx, eax
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000cf	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000d2	33 c1		 xor	 eax, ecx
  000d4	89 04 24	 mov	 DWORD PTR up$32937[rsp], eax

; 262  : 	if (up != 0) {

  000d7	83 3c 24 00	 cmp	 DWORD PTR up$32937[rsp], 0
  000db	0f 84 d7 00 00
	00		 je	 $LN7@index_tree@3

; 263  : 		// Locate the root node for the rotation.
; 264  : 		up = ctz32(tree->count) + 2;

  000e1	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000e6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000e9	89 44 24 1c	 mov	 DWORD PTR $T81767[rsp], eax
  000ed	8b 44 24 1c	 mov	 eax, DWORD PTR $T81767[rsp]
  000f1	0f bc c0	 bsf	 eax, eax
  000f4	89 44 24 18	 mov	 DWORD PTR i$81765[rsp], eax
  000f8	8b 44 24 18	 mov	 eax, DWORD PTR i$81765[rsp]
  000fc	83 c0 02	 add	 eax, 2
  000ff	89 04 24	 mov	 DWORD PTR up$32937[rsp], eax
$LN6@index_tree@3:

; 265  : 		do {
; 266  : 			node = node->parent;

  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 89 44 24 38	 mov	 QWORD PTR node$[rsp], rax

; 267  : 		} while (--up > 0);

  00110	8b 04 24	 mov	 eax, DWORD PTR up$32937[rsp]
  00113	83 e8 01	 sub	 eax, 1
  00116	89 04 24	 mov	 DWORD PTR up$32937[rsp], eax
  00119	83 3c 24 00	 cmp	 DWORD PTR up$32937[rsp], 0
  0011d	77 e3		 ja	 SHORT $LN6@index_tree@3

; 268  : 
; 269  : 		// Rotate left using node as the rotation root.
; 270  : 	  {
; 271  : 		index_tree_node *pivot = node->right;

  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00124	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00128	48 89 44 24 08	 mov	 QWORD PTR pivot$32942[rsp], rax

; 272  : 
; 273  : 		if (node->parent == NULL) {

  0012d	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00132	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00137	75 0f		 jne	 SHORT $LN3@index_tree@3

; 274  : 			tree->root = pivot;

  00139	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0013e	48 8b 44 24 08	 mov	 rax, QWORD PTR pivot$32942[rsp]
  00143	48 89 01	 mov	 QWORD PTR [rcx], rax

; 275  : 		} else {

  00146	eb 12		 jmp	 SHORT $LN2@index_tree@3
$LN3@index_tree@3:

; 276  : 			assert(node->parent->right == node);
; 277  : 			node->parent->right = pivot;

  00148	48 8b 4c 24 38	 mov	 rcx, QWORD PTR node$[rsp]
  0014d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00151	48 8b 44 24 08	 mov	 rax, QWORD PTR pivot$32942[rsp]
  00156	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN2@index_tree@3:

; 278  : 		}
; 279  : 
; 280  : 		pivot->parent = node->parent;

  0015a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pivot$32942[rsp]
  0015f	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00164	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00168	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 281  : 
; 282  : 		node->right = pivot->left;

  0016c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR node$[rsp]
  00171	48 8b 44 24 08	 mov	 rax, QWORD PTR pivot$32942[rsp]
  00176	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0017a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 283  : 		if (node->right != NULL)

  0017e	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00183	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00188	74 12		 je	 SHORT $LN1@index_tree@3

; 284  : 			node->right->parent = node;

  0018a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR node$[rsp]
  0018f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00193	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  00198	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN1@index_tree@3:

; 285  : 
; 286  : 		pivot->left = node;

  0019c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pivot$32942[rsp]
  001a1	48 8b 44 24 38	 mov	 rax, QWORD PTR node$[rsp]
  001a6	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 287  : 		node->parent = pivot;

  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR node$[rsp]
  001af	48 8b 44 24 08	 mov	 rax, QWORD PTR pivot$32942[rsp]
  001b4	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN7@index_tree@3:
$LN9@index_tree@3:

; 288  : 	  }
; 289  : 	}
; 290  :   }
; 291  : 
; 292  : 	return;
; 293  : }

  001b8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001bc	c3		 ret	 0
index_tree_append ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_tree_end DD imagerel index_tree_end
	DD	imagerel index_tree_end+58
	DD	imagerel $unwind$index_tree_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_tree_end DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_tree_end
_TEXT	SEGMENT
tree$ = 48
allocator$ = 56
free_func$ = 64
index_tree_end PROC					; COMDAT

; 217  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 218  : 	assert(free_func != NULL);
; 219  : 
; 220  : 	if (tree->root != NULL)

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00018	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001c	74 17		 je	 SHORT $LN1@index_tree@4

; 221  : 		index_tree_node_end(tree->root, allocator, free_func);

  0001e	4c 8b 44 24 40	 mov	 r8, QWORD PTR free_func$[rsp]
  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	e8 00 00 00 00	 call	 index_tree_node_end
$LN1@index_tree@4:

; 222  : 
; 223  : 	return;
; 224  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
index_tree_end ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_size DD imagerel index_size
	DD	imagerel index_size+62
	DD	imagerel $unwind$index_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_size DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_size
_TEXT	SEGMENT
$T81781 = 32
count$ = 64
index_list_size$ = 72
index_size PROC						; COMDAT

; 58   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 59   : 	return vli_ceil4(index_size_unpadded(count, index_list_size));

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR count$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_vli_size
  00018	83 c0 01	 add	 eax, 1
  0001b	8b c8		 mov	 ecx, eax
  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR index_list_size$[rsp]
  00022	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00027	48 89 44 24 20	 mov	 QWORD PTR $T81781[rsp], rax
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR $T81781[rsp]
  00031	48 83 c0 03	 add	 rax, 3
  00035	48 83 e0 fc	 and	 rax, -4

; 60   : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
index_size ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$iter_set_info DD imagerel iter_set_info
	DD	imagerel iter_set_info+1181
	DD	imagerel $unwind$iter_set_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iter_set_info DD 020c01H
	DD	011010cH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT iter_set_info
_TEXT	SEGMENT
stream$ = 32
i$ = 40
group$ = 48
record$ = 56
g$33324 = 64
$T82690 = 72
$T82704 = 80
$T82714 = 88
$T82715 = 96
tv145 = 104
tv195 = 112
tv202 = 120
iter$ = 144
iter_set_info PROC					; COMDAT

; 1012 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1013 : 	const lzma_index *i = iter->internal[ITER_INDEX].p;

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00014	48 8b 80 00 01
	00 00		 mov	 rax, QWORD PTR [rax+256]
  0001b	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1014 : 	const index_stream *stream = iter->internal[ITER_STREAM].p;

  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00028	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  0002f	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 1015 : 	const index_group *group = iter->internal[ITER_GROUP].p;

  00034	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  0003c	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00043	48 89 44 24 30	 mov	 QWORD PTR group$[rsp], rax

; 1016 : 	const size_t record = iter->internal[ITER_RECORD].s;

  00048	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00050	48 8b 80 18 01
	00 00		 mov	 rax, QWORD PTR [rax+280]
  00057	48 89 44 24 38	 mov	 QWORD PTR record$[rsp], rax

; 1017 : 
; 1018 : 	// lzma_index_iter.internal must not contain a pointer to the last
; 1019 : 	// group in the index, because that may be reallocated by
; 1020 : 	// lzma_index_cat().
; 1021 : 	if (group == NULL) {

  0005c	48 83 7c 24 30
	00		 cmp	 QWORD PTR group$[rsp], 0
  00062	75 18		 jne	 SHORT $LN10@iter_set_i

; 1022 : 		// There are no groups.
; 1023 : 		assert(stream->groups.root == NULL);
; 1024 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_LEFTMOST;

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  0006c	48 c7 80 20 01
	00 00 02 00 00
	00		 mov	 QWORD PTR [rax+288], 2

; 1025 : 
; 1026 : 	} else if (i->streams.rightmost != &stream->node

  00077	e9 98 00 00 00	 jmp	 $LN9@iter_set_i
$LN10@iter_set_i:

; 1027 : 			|| stream->groups.rightmost != &group->node) {

  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00086	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  0008a	75 10		 jne	 SHORT $LN7@iter_set_i
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  00096	48 39 41 48	 cmp	 QWORD PTR [rcx+72], rax
  0009a	74 15		 je	 SHORT $LN8@iter_set_i
$LN7@iter_set_i:

; 1028 : 		// The group is not not the last group in the index.
; 1029 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_NORMAL;

  0009c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  000a4	48 c7 80 20 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+288], 0
  000af	eb 63		 jmp	 SHORT $LN6@iter_set_i
$LN8@iter_set_i:

; 1030 : 
; 1031 : 	} else if (stream->groups.leftmost != &group->node) {

  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  000b6	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  000bb	48 39 41 40	 cmp	 QWORD PTR [rcx+64], rax
  000bf	74 2d		 je	 SHORT $LN5@iter_set_i

; 1032 : 		// The group isn't the only group in the Stream, thus we
; 1033 : 		// know that it must have a parent group i.e. it's not
; 1034 : 		// the root node.
; 1035 : 		assert(stream->groups.root != &group->node);
; 1036 : 		assert(group->node.parent->right == &group->node);
; 1037 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_NEXT;

  000c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  000c9	48 c7 80 20 01
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+288], 1

; 1038 : 		iter->internal[ITER_GROUP].p = group->node.parent;

  000d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  000e1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e5	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 1039 : 
; 1040 : 	} else {

  000ec	eb 26		 jmp	 SHORT $LN4@iter_set_i
$LN5@iter_set_i:

; 1041 : 		// The Stream has only one group.
; 1042 : 		assert(stream->groups.root == &group->node);
; 1043 : 		assert(group->node.parent == NULL);
; 1044 : 		iter->internal[ITER_METHOD].s = ITER_METHOD_LEFTMOST;

  000ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  000f6	48 c7 80 20 01
	00 00 02 00 00
	00		 mov	 QWORD PTR [rax+288], 2

; 1045 : 		iter->internal[ITER_GROUP].p = NULL;

  00101	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00109	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0
$LN4@iter_set_i:
$LN6@iter_set_i:
$LN9@iter_set_i:

; 1046 : 	}
; 1047 : 
; 1048 : 	// NOTE: lzma_index_iter.stream.number is lzma_vli but we use uint32_t
; 1049 : 	// internally.
; 1050 : 	iter->stream.number = stream->number;

  00114	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00119	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0011c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00124	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1051 : 	iter->stream.block_count = stream->record_count;

  00128	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00130	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00135	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00139	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1052 : 	iter->stream.compressed_offset = stream->node.compressed_base;

  0013d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0014a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0014e	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1053 : 	iter->stream.uncompressed_offset = stream->node.uncompressed_base;

  00152	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0015f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00162	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1054 : 
; 1055 : 	// iter->stream.flags will be NULL if the Stream Flags haven't been
; 1056 : 	// set with lzma_index_stream_flags().
; 1057 : 	iter->stream.flags = stream->stream_flags.version == UINT32_MAX
; 1058 : 			? NULL : &stream->stream_flags;

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0016b	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1	; ffffffffH
  0016f	75 0b		 jne	 SHORT $LN13@iter_set_i
  00171	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv145[rsp], 0
  0017a	eb 0e		 jmp	 SHORT $LN14@iter_set_i
$LN13@iter_set_i:
  0017c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00181	48 83 c0 68	 add	 rax, 104		; 00000068H
  00185	48 89 44 24 68	 mov	 QWORD PTR tv145[rsp], rax
$LN14@iter_set_i:
  0018a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00192	48 8b 44 24 68	 mov	 rax, QWORD PTR tv145[rsp]
  00197	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1059 : 	iter->stream.padding = stream->stream_padding;

  0019a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  001a2	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001a7	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001ae	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 1060 : 
; 1061 : 	if (stream->groups.rightmost == NULL) {

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001b7	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  001bc	75 47		 jne	 SHORT $LN3@iter_set_i

; 1062 : 		// Stream has no Blocks.
; 1063 : 		iter->stream.compressed_size = index_size(0, 0)
; 1064 : 				+ 2 * LZMA_STREAM_HEADER_SIZE;

  001be	33 c9		 xor	 ecx, ecx
  001c0	e8 00 00 00 00	 call	 lzma_vli_size
  001c5	83 c0 01	 add	 eax, 1
  001c8	8b c0		 mov	 eax, eax
  001ca	48 83 c0 04	 add	 rax, 4
  001ce	48 89 44 24 48	 mov	 QWORD PTR $T82690[rsp], rax
  001d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T82690[rsp]
  001d8	48 83 c1 03	 add	 rcx, 3
  001dc	48 83 e1 fc	 and	 rcx, -4
  001e0	48 83 c1 18	 add	 rcx, 24
  001e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  001ec	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1065 : 		iter->stream.uncompressed_size = 0;

  001f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  001f8	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 1066 : 	} else {

  00200	e9 a8 00 00 00	 jmp	 $LN2@iter_set_i
$LN3@iter_set_i:

; 1067 : 		const index_group *g = (const index_group *)(
; 1068 : 				stream->groups.rightmost);

  00205	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0020a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0020e	48 89 44 24 40	 mov	 QWORD PTR g$33324[rsp], rax

; 1069 : 
; 1070 : 		// Stream Header + Stream Footer + Index + Blocks
; 1071 : 		iter->stream.compressed_size = 2 * LZMA_STREAM_HEADER_SIZE
; 1072 : 				+ index_size(stream->record_count,
; 1073 : 					stream->index_list_size)
; 1074 : 				+ vli_ceil4(g->records[g->last].unpadded_sum);

  00213	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00218	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0021c	48 89 44 24 60	 mov	 QWORD PTR $T82715[rsp], rax
  00221	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00226	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0022a	48 89 44 24 58	 mov	 QWORD PTR $T82714[rsp], rax
  0022f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T82714[rsp]
  00234	e8 00 00 00 00	 call	 lzma_vli_size
  00239	83 c0 01	 add	 eax, 1
  0023c	8b c8		 mov	 ecx, eax
  0023e	48 8b 44 24 60	 mov	 rax, QWORD PTR $T82715[rsp]
  00243	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00248	48 89 44 24 50	 mov	 QWORD PTR $T82704[rsp], rax
  0024d	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T82704[rsp]
  00252	48 83 c2 03	 add	 rdx, 3
  00256	48 83 e2 fc	 and	 rdx, -4
  0025a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33324[rsp]
  0025f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00263	48 6b c9 10	 imul	 rcx, 16
  00267	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33324[rsp]
  0026c	48 8b 44 08 48	 mov	 rax, QWORD PTR [rax+rcx+72]
  00271	48 83 c0 03	 add	 rax, 3
  00275	48 83 e0 fc	 and	 rax, -4
  00279	48 8d 4c 02 18	 lea	 rcx, QWORD PTR [rdx+rax+24]
  0027e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00286	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1075 : 		iter->stream.uncompressed_size
; 1076 : 				= g->records[g->last].uncompressed_sum;

  0028a	48 8b 54 24 40	 mov	 rdx, QWORD PTR g$33324[rsp]
  0028f	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00293	48 6b d2 10	 imul	 rdx, 16
  00297	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0029f	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33324[rsp]
  002a4	48 8b 44 10 40	 mov	 rax, QWORD PTR [rax+rdx+64]
  002a9	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN2@iter_set_i:

; 1077 : 	}
; 1078 : 
; 1079 : 	if (group != NULL) {

  002ad	48 83 7c 24 30
	00		 cmp	 QWORD PTR group$[rsp], 0
  002b3	0f 84 dc 01 00
	00		 je	 $LN1@iter_set_i

; 1080 : 		iter->block.number_in_stream = group->number_base + record;

  002b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$[rsp]
  002be	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002c2	48 03 4c 24 38	 add	 rcx, QWORD PTR record$[rsp]
  002c7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  002cf	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 1081 : 		iter->block.number_in_file = iter->block.number_in_stream
; 1082 : 				+ stream->block_number_base;

  002d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  002de	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  002e5	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  002ea	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  002ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  002f6	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1083 : 
; 1084 : 		iter->block.compressed_stream_offset
; 1085 : 				= record == 0 ? group->node.compressed_base
; 1086 : 				: vli_ceil4(group->records[
; 1087 : 					record - 1].unpadded_sum);

  002fa	48 83 7c 24 38
	00		 cmp	 QWORD PTR record$[rsp], 0
  00300	75 10		 jne	 SHORT $LN15@iter_set_i
  00302	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  00307	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0030b	48 89 44 24 70	 mov	 QWORD PTR tv195[rsp], rax
  00310	eb 24		 jmp	 SHORT $LN16@iter_set_i
$LN15@iter_set_i:
  00312	48 8b 4c 24 38	 mov	 rcx, QWORD PTR record$[rsp]
  00317	48 83 e9 01	 sub	 rcx, 1
  0031b	48 6b c9 10	 imul	 rcx, 16
  0031f	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  00324	48 8b 44 08 48	 mov	 rax, QWORD PTR [rax+rcx+72]
  00329	48 83 c0 03	 add	 rax, 3
  0032d	48 83 e0 fc	 and	 rax, -4
  00331	48 89 44 24 70	 mov	 QWORD PTR tv195[rsp], rax
$LN16@iter_set_i:
  00336	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0033e	48 8b 44 24 70	 mov	 rax, QWORD PTR tv195[rsp]
  00343	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 1088 : 		iter->block.uncompressed_stream_offset
; 1089 : 				= record == 0 ? group->node.uncompressed_base
; 1090 : 				: group->records[record - 1].uncompressed_sum;

  0034a	48 83 7c 24 38
	00		 cmp	 QWORD PTR record$[rsp], 0
  00350	75 0f		 jne	 SHORT $LN17@iter_set_i
  00352	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  00357	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035a	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
  0035f	eb 1c		 jmp	 SHORT $LN18@iter_set_i
$LN17@iter_set_i:
  00361	48 8b 4c 24 38	 mov	 rcx, QWORD PTR record$[rsp]
  00366	48 83 e9 01	 sub	 rcx, 1
  0036a	48 6b c9 10	 imul	 rcx, 16
  0036e	48 8b 44 24 30	 mov	 rax, QWORD PTR group$[rsp]
  00373	48 8b 44 08 40	 mov	 rax, QWORD PTR [rax+rcx+64]
  00378	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
$LN18@iter_set_i:
  0037d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00385	48 8b 44 24 78	 mov	 rax, QWORD PTR tv202[rsp]
  0038a	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 1091 : 
; 1092 : 		iter->block.uncompressed_size
; 1093 : 				= group->records[record].uncompressed_sum
; 1094 : 				- iter->block.uncompressed_stream_offset;

  00391	48 8b 54 24 38	 mov	 rdx, QWORD PTR record$[rsp]
  00396	48 6b d2 10	 imul	 rdx, 16
  0039a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$[rsp]
  0039f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  003a7	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  003ae	48 8b 4c 11 40	 mov	 rcx, QWORD PTR [rcx+rdx+64]
  003b3	48 2b c8	 sub	 rcx, rax
  003b6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  003be	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 1095 : 		iter->block.unpadded_size
; 1096 : 				= group->records[record].unpadded_sum
; 1097 : 				- iter->block.compressed_stream_offset;

  003c5	48 8b 54 24 38	 mov	 rdx, QWORD PTR record$[rsp]
  003ca	48 6b d2 10	 imul	 rdx, 16
  003ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$[rsp]
  003d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  003db	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  003e2	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  003e7	48 2b c8	 sub	 rcx, rax
  003ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  003f2	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 1098 : 		iter->block.total_size = vli_ceil4(iter->block.unpadded_size);

  003f9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00401	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  00408	48 83 c1 03	 add	 rcx, 3
  0040c	48 83 e1 fc	 and	 rcx, -4
  00410	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00418	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 1099 : 
; 1100 : 		iter->block.compressed_stream_offset
; 1101 : 				+= LZMA_STREAM_HEADER_SIZE;

  0041f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00427	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0042e	48 83 c1 0c	 add	 rcx, 12
  00432	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  0043a	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 1102 : 
; 1103 : 		iter->block.compressed_file_offset
; 1104 : 				= iter->block.compressed_stream_offset
; 1105 : 				+ iter->stream.compressed_offset;

  00441	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00449	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00450	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00458	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  0045c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00464	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1106 : 		iter->block.uncompressed_file_offset
; 1107 : 				= iter->block.uncompressed_stream_offset
; 1108 : 				+ iter->stream.uncompressed_offset;

  0046b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00473	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  0047a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  00482	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  00486	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR iter$[rsp]
  0048e	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx
$LN1@iter_set_i:

; 1109 : 	}
; 1110 : 
; 1111 : 	return;
; 1112 : }

  00495	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0049c	c3		 ret	 0
iter_set_info ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_cat_helper DD imagerel index_cat_helper
	DD	imagerel index_cat_helper+214
	DD	imagerel $unwind$index_cat_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_cat_helper DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_cat_helper
_TEXT	SEGMENT
left$ = 32
right$ = 40
info$ = 64
this$ = 72
index_cat_helper PROC					; COMDAT

; 759  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 760  : 	index_stream *left = (index_stream *)(this->node.left);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 89 44 24 20	 mov	 QWORD PTR left$[rsp], rax

; 761  : 	index_stream *right = (index_stream *)(this->node.right);

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00021	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00025	48 89 44 24 28	 mov	 QWORD PTR right$[rsp], rax

; 762  : 
; 763  : 	if (left != NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR left$[rsp], 0
  00030	74 0f		 je	 SHORT $LN2@index_cat_

; 764  : 		index_cat_helper(info, left);

  00032	48 8b 54 24 20	 mov	 rdx, QWORD PTR left$[rsp]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0003c	e8 00 00 00 00	 call	 index_cat_helper
$LN2@index_cat_:

; 765  : 
; 766  : 	this->node.uncompressed_base += info->uncompressed_size;

  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR this$[rsp]
  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0004e	48 03 08	 add	 rcx, QWORD PTR [rax]
  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 89 08	 mov	 QWORD PTR [rax], rcx

; 767  : 	this->node.compressed_base += info->file_size;

  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR this$[rsp]
  0005e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00067	48 03 48 08	 add	 rcx, QWORD PTR [rax+8]
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00070	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 768  : 	this->number += info->stream_number_add;

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00079	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00081	03 48 18	 add	 ecx, DWORD PTR [rax+24]
  00084	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  00089	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 769  : 	this->block_number_base += info->block_number_add;

  0008c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR this$[rsp]
  00091	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0009a	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR this$[rsp]
  000a3	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 770  : 	index_tree_append(info->streams, &this->node);

  000a7	48 8b 54 24 48	 mov	 rdx, QWORD PTR this$[rsp]
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000b1	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000b5	e8 00 00 00 00	 call	 index_tree_append

; 771  : 
; 772  : 	if (right != NULL)

  000ba	48 83 7c 24 28
	00		 cmp	 QWORD PTR right$[rsp], 0
  000c0	74 0f		 je	 SHORT $LN1@index_cat_

; 773  : 		index_cat_helper(info, right);

  000c2	48 8b 54 24 28	 mov	 rdx, QWORD PTR right$[rsp]
  000c7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000cc	e8 00 00 00 00	 call	 index_cat_helper
$LN1@index_cat_:

; 774  : 
; 775  : 	return;
; 776  : }

  000d1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d5	c3		 ret	 0
index_cat_helper ENDP
_TEXT	ENDS
PUBLIC	$T82735
PUBLIC	lzma_index_stream_flags
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_stream_flags DD imagerel $LN9
	DD	imagerel $LN9+156
	DD	imagerel $unwind$lzma_index_stream_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_stream_flags DD 031001H
	DD	0700ce210H
	DD	0600bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_stream_flags
_TEXT	SEGMENT
ret_$33133 = 32
s$33135 = 40
$T82735 = 48
i$ = 144
stream_flags$ = 152
lzma_index_stream_flags PROC				; COMDAT

; 608  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 609  : 	if (i == NULL || stream_flags == NULL)

  00010	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  00019	74 0b		 je	 SHORT $LN5@lzma_index@5
  0001b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR stream_flags$[rsp], 0
  00024	75 07		 jne	 SHORT $LN6@lzma_index@5
$LN5@lzma_index@5:

; 610  : 		return LZMA_PROG_ERROR;

  00026	b8 0b 00 00 00	 mov	 eax, 11
  0002b	eb 68		 jmp	 SHORT $LN7@lzma_index@5
$LN6@lzma_index@5:
$LN4@lzma_index@5:

; 611  : 
; 612  : 	// Validate the Stream Flags.
; 613  : 	return_if_error(lzma_stream_flags_compare(
; 614  : 			stream_flags, stream_flags));

  0002d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR stream_flags$[rsp]
  00035	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR stream_flags$[rsp]
  0003d	e8 00 00 00 00	 call	 lzma_stream_flags_compare
  00042	89 44 24 20	 mov	 DWORD PTR ret_$33133[rsp], eax
  00046	83 7c 24 20 00	 cmp	 DWORD PTR ret_$33133[rsp], 0
  0004b	74 06		 je	 SHORT $LN1@lzma_index@5
  0004d	8b 44 24 20	 mov	 eax, DWORD PTR ret_$33133[rsp]
  00051	eb 42		 jmp	 SHORT $LN7@lzma_index@5
$LN1@lzma_index@5:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 d4		 jne	 SHORT $LN4@lzma_index@5

; 615  : 
; 616  :   {
; 617  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  00059	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00061	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00065	48 89 44 24 28	 mov	 QWORD PTR s$33135[rsp], rax

; 618  : 	s->stream_flags = *stream_flags;

  0006a	48 8d 7c 24 30	 lea	 rdi, QWORD PTR $T82735[rsp]
  0006f	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR stream_flags$[rsp]
  00077	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0007c	f3 a4		 rep movsb
  0007e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR s$33135[rsp]
  00083	48 8d 74 24 30	 lea	 rsi, QWORD PTR $T82735[rsp]
  00088	48 83 c7 68	 add	 rdi, 104		; 00000068H
  0008c	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00091	f3 a4		 rep movsb

; 619  :   }
; 620  : 
; 621  : 	return LZMA_OK;

  00093	33 c0		 xor	 eax, eax
$LN7@lzma_index@5:

; 622  : }

  00095	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00099	5f		 pop	 rdi
  0009a	5e		 pop	 rsi
  0009b	c3		 ret	 0
lzma_index_stream_flags ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$index_file_size DD imagerel index_file_size
	DD	imagerel index_file_size+178
	DD	imagerel $unwind$index_file_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_file_size DD 011801H
	DD	06218H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT index_file_size
_TEXT	SEGMENT
file_size$ = 32
$T82749 = 40
compressed_base$ = 64
unpadded_sum$ = 72
record_count$ = 80
index_list_size$ = 88
stream_padding$ = 96
index_file_size PROC					; COMDAT

; 545  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 546  : 	// Earlier Streams and Stream Paddings + Stream Header
; 547  : 	// + Blocks + Index + Stream Footer + Stream Padding
; 548  : 	//
; 549  : 	// This might go over LZMA_VLI_MAX due to too big unpadded_sum
; 550  : 	// when this function is used in lzma_index_append().
; 551  : 	lzma_vli file_size = compressed_base + 2 * LZMA_STREAM_HEADER_SIZE
; 552  : 			+ stream_padding + vli_ceil4(unpadded_sum);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR compressed_base$[rsp]
  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR stream_padding$[rsp]
  00022	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unpadded_sum$[rsp]
  0002c	48 83 c1 03	 add	 rcx, 3
  00030	48 83 e1 fc	 and	 rcx, -4
  00034	48 03 c1	 add	 rax, rcx
  00037	48 89 44 24 20	 mov	 QWORD PTR file_size$[rsp], rax

; 553  : 	if (file_size > LZMA_VLI_MAX)

  0003c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00046	48 39 44 24 20	 cmp	 QWORD PTR file_size$[rsp], rax
  0004b	76 09		 jbe	 SHORT $LN2@index_file

; 554  : 		return LZMA_VLI_UNKNOWN;

  0004d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00054	eb 57		 jmp	 SHORT $LN3@index_file
$LN2@index_file:

; 555  : 
; 556  : 	// The same applies here.
; 557  : 	file_size += index_size(record_count, index_list_size);

  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR record_count$[rsp]
  0005b	e8 00 00 00 00	 call	 lzma_vli_size
  00060	83 c0 01	 add	 eax, 1
  00063	8b c8		 mov	 ecx, eax
  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR index_list_size$[rsp]
  0006a	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0006f	48 89 44 24 28	 mov	 QWORD PTR $T82749[rsp], rax
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T82749[rsp]
  00079	48 83 c1 03	 add	 rcx, 3
  0007d	48 83 e1 fc	 and	 rcx, -4
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR file_size$[rsp]
  00086	48 03 c1	 add	 rax, rcx
  00089	48 89 44 24 20	 mov	 QWORD PTR file_size$[rsp], rax

; 558  : 	if (file_size > LZMA_VLI_MAX)

  0008e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00098	48 39 44 24 20	 cmp	 QWORD PTR file_size$[rsp], rax
  0009d	76 09		 jbe	 SHORT $LN1@index_file

; 559  : 		return LZMA_VLI_UNKNOWN;

  0009f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000a6	eb 05		 jmp	 SHORT $LN3@index_file
$LN1@index_file:

; 560  : 
; 561  : 	return file_size;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR file_size$[rsp]
$LN3@index_file:

; 562  : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
index_file_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_size
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_size DD imagerel $LN9
	DD	imagerel $LN9+85
	DD	imagerel $unwind$lzma_index_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_size DD 010901H
	DD	08209H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT lzma_index_size
_TEXT	SEGMENT
$T82768 = 32
$T82778 = 40
$T82779 = 48
i$ = 80
lzma_index_size PROC					; COMDAT

; 519  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 520  : 	return index_size(i->record_count, i->index_list_size);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 89 44 24 30	 mov	 QWORD PTR $T82779[rsp], rax
  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0001c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00020	48 89 44 24 28	 mov	 QWORD PTR $T82778[rsp], rax
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T82778[rsp]
  0002a	e8 00 00 00 00	 call	 lzma_vli_size
  0002f	83 c0 01	 add	 eax, 1
  00032	8b c8		 mov	 ecx, eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR $T82779[rsp]
  00039	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0003e	48 89 44 24 20	 mov	 QWORD PTR $T82768[rsp], rax
  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR $T82768[rsp]
  00048	48 83 c0 03	 add	 rax, 3
  0004c	48 83 e0 fc	 and	 rax, -4

; 521  : }

  00050	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00054	c3		 ret	 0
lzma_index_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_init DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$lzma_index_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_init DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_init
_TEXT	SEGMENT
i$ = 48
s$33024 = 56
allocator$ = 80
lzma_index_init PROC					; COMDAT

; 403  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 404  : 	lzma_index *i = index_init_plain(allocator);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR allocator$[rsp]
  0000e	e8 00 00 00 00	 call	 index_init_plain
  00013	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 405  : 	if (i == NULL)

  00018	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN2@lzma_index@6

; 406  : 		return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 50		 jmp	 SHORT $LN3@lzma_index@6
$LN2@lzma_index@6:

; 407  : 
; 408  :   {
; 409  : 	index_stream *s = index_stream_init(0, 0, 1, 0, allocator);

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR allocator$[rsp]
  00029	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002e	45 33 c9	 xor	 r9d, r9d
  00031	41 b8 01 00 00
	00		 mov	 r8d, 1
  00037	33 d2		 xor	 edx, edx
  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 index_stream_init
  00040	48 89 44 24 38	 mov	 QWORD PTR s$33024[rsp], rax

; 410  : 	if (s == NULL) {

  00045	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$33024[rsp], 0
  0004b	75 13		 jne	 SHORT $LN1@lzma_index@6

; 411  : 		lzma_free(i, allocator);

  0004d	48 8b 54 24 50	 mov	 rdx, QWORD PTR allocator$[rsp]
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00057	e8 00 00 00 00	 call	 lzma_free

; 412  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	eb 14		 jmp	 SHORT $LN3@lzma_index@6
$LN1@lzma_index@6:

; 413  : 	}
; 414  : 
; 415  : 	index_tree_append(&i->streams, &s->node);

  00060	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$33024[rsp]
  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0006a	e8 00 00 00 00	 call	 index_tree_append

; 416  :   }
; 417  : 
; 418  : 	return i;

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
$LN3@lzma_index@6:

; 419  : }

  00074	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00078	c3		 ret	 0
lzma_index_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_stream_end DD imagerel index_stream_end
	DD	imagerel index_stream_end+70
	DD	imagerel $unwind$index_stream_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_stream_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_stream_end
_TEXT	SEGMENT
s$ = 32
node$ = 64
allocator$ = 72
index_stream_end PROC					; COMDAT

; 375  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 376  : 	index_stream *s = node;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 377  : 	index_tree_end(&s->groups, allocator, &lzma_free);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	48 83 c1 38	 add	 rcx, 56			; 00000038H
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:lzma_free
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002d	e8 00 00 00 00	 call	 index_tree_end

; 378  : 	lzma_free(s, allocator);

  00032	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0003c	e8 00 00 00 00	 call	 lzma_free

; 379  : 	return;
; 380  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
index_stream_end ENDP
PUBLIC	lzma_index_iter_next
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_iter_next DD imagerel $LN31
	DD	imagerel $LN31+596
	DD	imagerel $unwind$lzma_index_iter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_iter_next DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_iter_next
_TEXT	SEGMENT
stream$33346 = 32
i$33345 = 40
group$33347 = 48
record$33349 = 56
tv78 = 64
iter$ = 96
mode$ = 104
lzma_index_iter_next PROC				; COMDAT

; 1137 : {

$LN31:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1138 : 	// Catch unsupported mode values.
; 1139 : 	if ((unsigned int)(mode) > LZMA_INDEX_ITER_NONEMPTY_BLOCK)

  0000d	83 7c 24 68 03	 cmp	 DWORD PTR mode$[rsp], 3
  00012	76 07		 jbe	 SHORT $LN27@lzma_index@7

; 1140 : 		return true;

  00014	b0 01		 mov	 al, 1
  00016	e9 34 02 00 00	 jmp	 $LN28@lzma_index@7
$LN27@lzma_index@7:

; 1141 : 
; 1142 :   {
; 1143 : 	const lzma_index *i = iter->internal[ITER_INDEX].p;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR iter$[rsp]
  00020	48 8b 80 00 01
	00 00		 mov	 rax, QWORD PTR [rax+256]
  00027	48 89 44 24 28	 mov	 QWORD PTR i$33345[rsp], rax

; 1144 : 	const index_stream *stream = iter->internal[ITER_STREAM].p;

  0002c	48 8b 44 24 60	 mov	 rax, QWORD PTR iter$[rsp]
  00031	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  00038	48 89 44 24 20	 mov	 QWORD PTR stream$33346[rsp], rax

; 1145 : 	const index_group *group = NULL;

  0003d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR group$33347[rsp], 0

; 1146 : 	size_t record = iter->internal[ITER_RECORD].s;

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR iter$[rsp]
  0004b	48 8b 80 18 01
	00 00		 mov	 rax, QWORD PTR [rax+280]
  00052	48 89 44 24 38	 mov	 QWORD PTR record$33349[rsp], rax

; 1147 : 
; 1148 : 	// If we are being asked for the next Stream, leave group to NULL
; 1149 : 	// so that the rest of the this function thinks that this Stream
; 1150 : 	// has no groups and will thus go to the next Stream.
; 1151 : 	if (mode != LZMA_INDEX_ITER_STREAM) {

  00057	83 7c 24 68 01	 cmp	 DWORD PTR mode$[rsp], 1
  0005c	74 64		 je	 SHORT $LN26@lzma_index@7

; 1152 : 		// Get the pointer to the current group. See iter_set_inf()
; 1153 : 		// for explanation.
; 1154 : 		switch (iter->internal[ITER_METHOD].s) {

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR iter$[rsp]
  00063	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  0006a	48 89 44 24 40	 mov	 QWORD PTR tv78[rsp], rax
  0006f	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00075	74 12		 je	 SHORT $LN23@lzma_index@7
  00077	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv78[rsp], 1
  0007d	74 1d		 je	 SHORT $LN22@lzma_index@7
  0007f	48 83 7c 24 40
	02		 cmp	 QWORD PTR tv78[rsp], 2
  00085	74 2d		 je	 SHORT $LN21@lzma_index@7
  00087	eb 39		 jmp	 SHORT $LN24@lzma_index@7
$LN23@lzma_index@7:

; 1155 : 		case ITER_METHOD_NORMAL:
; 1156 : 			group = iter->internal[ITER_GROUP].p;

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR iter$[rsp]
  0008e	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00095	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax

; 1157 : 			break;

  0009a	eb 26		 jmp	 SHORT $LN24@lzma_index@7
$LN22@lzma_index@7:

; 1158 : 
; 1159 : 		case ITER_METHOD_NEXT:
; 1160 : 			group = index_tree_next(iter->internal[ITER_GROUP].p);

  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iter$[rsp]
  000a1	48 8b 89 10 01
	00 00		 mov	 rcx, QWORD PTR [rcx+272]
  000a8	e8 00 00 00 00	 call	 index_tree_next
  000ad	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax

; 1161 : 			break;

  000b2	eb 0e		 jmp	 SHORT $LN24@lzma_index@7
$LN21@lzma_index@7:

; 1162 : 
; 1163 : 		case ITER_METHOD_LEFTMOST:
; 1164 : 			group = (const index_group *)(
; 1165 : 					stream->groups.leftmost);

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  000b9	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000bd	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax
$LN24@lzma_index@7:
$LN26@lzma_index@7:
$LN30@lzma_index@7:
$again$33359:

; 1166 : 			break;
; 1167 : 		}
; 1168 : 	}
; 1169 : 
; 1170 : again:
; 1171 : 	if (stream == NULL) {

  000c2	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$33346[rsp], 0
  000c8	75 5d		 jne	 SHORT $LN20@lzma_index@7

; 1172 : 		// We at the beginning of the lzma_index.
; 1173 : 		// Locate the first Stream.
; 1174 : 		stream = (const index_stream *)(i->streams.leftmost);

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR i$33345[rsp]
  000cf	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d3	48 89 44 24 20	 mov	 QWORD PTR stream$33346[rsp], rax

; 1175 : 		if (mode >= LZMA_INDEX_ITER_BLOCK) {

  000d8	83 7c 24 68 02	 cmp	 DWORD PTR mode$[rsp], 2
  000dd	7c 2c		 jl	 SHORT $LN19@lzma_index@7
$LN18@lzma_index@7:

; 1176 : 			// Since we are being asked to return information
; 1177 : 			// about the first a Block, skip Streams that have
; 1178 : 			// no Blocks.
; 1179 : 			while (stream->groups.leftmost == NULL) {

  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  000e4	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000e9	75 20		 jne	 SHORT $LN17@lzma_index@7

; 1180 : 				stream = index_tree_next(&stream->node);

  000eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$33346[rsp]
  000f0	e8 00 00 00 00	 call	 index_tree_next
  000f5	48 89 44 24 20	 mov	 QWORD PTR stream$33346[rsp], rax

; 1181 : 				if (stream == NULL)

  000fa	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$33346[rsp], 0
  00100	75 07		 jne	 SHORT $LN16@lzma_index@7

; 1182 : 					return true;

  00102	b0 01		 mov	 al, 1
  00104	e9 46 01 00 00	 jmp	 $LN28@lzma_index@7
$LN16@lzma_index@7:

; 1183 : 			}

  00109	eb d4		 jmp	 SHORT $LN18@lzma_index@7
$LN17@lzma_index@7:
$LN19@lzma_index@7:

; 1184 : 		}
; 1185 : 
; 1186 : 		// Start from the first Record in the Stream.
; 1187 : 		group = (const index_group *)(stream->groups.leftmost);

  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  00110	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00114	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax

; 1188 : 		record = 0;

  00119	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR record$33349[rsp], 0
  00122	e9 8f 00 00 00	 jmp	 $LN15@lzma_index@7
$LN20@lzma_index@7:

; 1189 : 
; 1190 : 	} else if (group != NULL && record < group->last) {

  00127	48 83 7c 24 30
	00		 cmp	 QWORD PTR group$33347[rsp], 0
  0012d	74 20		 je	 SHORT $LN14@lzma_index@7
  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR group$33347[rsp]
  00134	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00138	48 39 44 24 38	 cmp	 QWORD PTR record$33349[rsp], rax
  0013d	73 10		 jae	 SHORT $LN14@lzma_index@7

; 1191 : 		// The next Record is in the same group.
; 1192 : 		++record;

  0013f	48 8b 44 24 38	 mov	 rax, QWORD PTR record$33349[rsp]
  00144	48 83 c0 01	 add	 rax, 1
  00148	48 89 44 24 38	 mov	 QWORD PTR record$33349[rsp], rax

; 1193 : 
; 1194 : 	} else {

  0014d	eb 67		 jmp	 SHORT $LN13@lzma_index@7
$LN14@lzma_index@7:

; 1195 : 		// This group has no more Records or this Stream has
; 1196 : 		// no Blocks at all.
; 1197 : 		record = 0;

  0014f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR record$33349[rsp], 0

; 1198 : 
; 1199 : 		// If group is not NULL, this Stream has at least one Block
; 1200 : 		// and thus at least one group. Find the next group.
; 1201 : 		if (group != NULL)

  00158	48 83 7c 24 30
	00		 cmp	 QWORD PTR group$33347[rsp], 0
  0015e	74 0f		 je	 SHORT $LN12@lzma_index@7

; 1202 : 			group = index_tree_next(&group->node);

  00160	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$33347[rsp]
  00165	e8 00 00 00 00	 call	 index_tree_next
  0016a	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax
$LN12@lzma_index@7:

; 1203 : 
; 1204 : 		if (group == NULL) {

  0016f	48 83 7c 24 30
	00		 cmp	 QWORD PTR group$33347[rsp], 0
  00175	75 3f		 jne	 SHORT $LN11@lzma_index@7
$LN10@lzma_index@7:

; 1205 : 			// This Stream has no more Records. Find the next
; 1206 : 			// Stream. If we are being asked to return information
; 1207 : 			// about a Block, we skip empty Streams.
; 1208 : 			do {
; 1209 : 				stream = index_tree_next(&stream->node);

  00177	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$33346[rsp]
  0017c	e8 00 00 00 00	 call	 index_tree_next
  00181	48 89 44 24 20	 mov	 QWORD PTR stream$33346[rsp], rax

; 1210 : 				if (stream == NULL)

  00186	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$33346[rsp], 0
  0018c	75 07		 jne	 SHORT $LN7@lzma_index@7

; 1211 : 					return true;

  0018e	b0 01		 mov	 al, 1
  00190	e9 ba 00 00 00	 jmp	 $LN28@lzma_index@7
$LN7@lzma_index@7:

; 1212 : 			} while (mode >= LZMA_INDEX_ITER_BLOCK
; 1213 : 					&& stream->groups.leftmost == NULL);

  00195	83 7c 24 68 02	 cmp	 DWORD PTR mode$[rsp], 2
  0019a	7c 0c		 jl	 SHORT $LN6@lzma_index@7
  0019c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  001a1	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  001a6	74 cf		 je	 SHORT $LN10@lzma_index@7
$LN6@lzma_index@7:

; 1214 : 
; 1215 : 			group = (const index_group *)(
; 1216 : 					stream->groups.leftmost);

  001a8	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  001ad	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001b1	48 89 44 24 30	 mov	 QWORD PTR group$33347[rsp], rax
$LN11@lzma_index@7:
$LN13@lzma_index@7:
$LN15@lzma_index@7:

; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	if (mode == LZMA_INDEX_ITER_NONEMPTY_BLOCK) {

  001b6	83 7c 24 68 03	 cmp	 DWORD PTR mode$[rsp], 3
  001bb	75 53		 jne	 SHORT $LN5@lzma_index@7

; 1221 : 		// We need to look for the next Block again if this Block
; 1222 : 		// is empty.
; 1223 : 		if (record == 0) {

  001bd	48 83 7c 24 38
	00		 cmp	 QWORD PTR record$33349[rsp], 0
  001c3	75 1a		 jne	 SHORT $LN4@lzma_index@7

; 1224 : 			if (group->node.uncompressed_base
; 1225 : 					== group->records[0].uncompressed_sum)

  001c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$33347[rsp]
  001ca	48 8b 44 24 30	 mov	 rax, QWORD PTR group$33347[rsp]
  001cf	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001d3	48 39 01	 cmp	 QWORD PTR [rcx], rax
  001d6	75 05		 jne	 SHORT $LN3@lzma_index@7

; 1226 : 				goto again;

  001d8	e9 e5 fe ff ff	 jmp	 $again$33359
$LN3@lzma_index@7:

; 1227 : 		} else if (group->records[record - 1].uncompressed_sum

  001dd	eb 31		 jmp	 SHORT $LN2@lzma_index@7
$LN4@lzma_index@7:

; 1228 : 				== group->records[record].uncompressed_sum) {

  001df	4c 8b 44 24 38	 mov	 r8, QWORD PTR record$33349[rsp]
  001e4	49 83 e8 01	 sub	 r8, 1
  001e8	4d 6b c0 10	 imul	 r8, 16
  001ec	48 8b 54 24 38	 mov	 rdx, QWORD PTR record$33349[rsp]
  001f1	48 6b d2 10	 imul	 rdx, 16
  001f5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR group$33347[rsp]
  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR group$33347[rsp]
  001ff	48 8b 44 10 40	 mov	 rax, QWORD PTR [rax+rdx+64]
  00204	4a 39 44 01 40	 cmp	 QWORD PTR [rcx+r8+64], rax
  00209	75 05		 jne	 SHORT $LN1@lzma_index@7

; 1229 : 			goto again;

  0020b	e9 b2 fe ff ff	 jmp	 $LN30@lzma_index@7
$LN1@lzma_index@7:
$LN2@lzma_index@7:
$LN5@lzma_index@7:

; 1230 : 		}
; 1231 : 	}
; 1232 : 
; 1233 : 	iter->internal[ITER_STREAM].p = stream;

  00210	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iter$[rsp]
  00215	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$33346[rsp]
  0021a	48 89 81 08 01
	00 00		 mov	 QWORD PTR [rcx+264], rax

; 1234 : 	iter->internal[ITER_GROUP].p = group;

  00221	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iter$[rsp]
  00226	48 8b 44 24 30	 mov	 rax, QWORD PTR group$33347[rsp]
  0022b	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 1235 : 	iter->internal[ITER_RECORD].s = record;

  00232	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iter$[rsp]
  00237	48 8b 44 24 38	 mov	 rax, QWORD PTR record$33349[rsp]
  0023c	48 89 81 18 01
	00 00		 mov	 QWORD PTR [rcx+280], rax

; 1236 : 
; 1237 : 	iter_set_info(iter);

  00243	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iter$[rsp]
  00248	e8 00 00 00 00	 call	 iter_set_info

; 1238 :   }
; 1239 : 
; 1240 : 	return false;

  0024d	32 c0		 xor	 al, al
$LN28@lzma_index@7:

; 1241 : }

  0024f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00253	c3		 ret	 0
lzma_index_iter_next ENDP
_TEXT	ENDS
PUBLIC	lzma_index_append
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_append DD imagerel $LN24
	DD	imagerel $LN24+987
	DD	imagerel $unwind$lzma_index_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_append DD 021c01H
	DD	03015f21cH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT lzma_index_append
_TEXT	SEGMENT
compressed_base$33165 = 48
index_list_size_add$33169 = 56
s$33161 = 64
uncompressed_base$33167 = 72
g$33163 = 80
$T83407 = 88
$T83417 = 96
$T83418 = 104
tv78 = 112
tv84 = 120
i$ = 144
allocator$ = 152
unpadded_size$ = 160
uncompressed_size$ = 168
lzma_index_append PROC					; COMDAT

; 653  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 654  : 	// Validate.
; 655  : 	if (i == NULL || unpadded_size < UNPADDED_SIZE_MIN
; 656  : 			|| unpadded_size > UNPADDED_SIZE_MAX
; 657  : 			|| uncompressed_size > LZMA_VLI_MAX)

  0001c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  00025	74 33		 je	 SHORT $LN6@lzma_index@8
  00027	48 83 bc 24 a0
	00 00 00 05	 cmp	 QWORD PTR unpadded_size$[rsp], 5
  00030	72 28		 jb	 SHORT $LN6@lzma_index@8
  00032	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  0003c	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR unpadded_size$[rsp], rax
  00044	77 14		 ja	 SHORT $LN6@lzma_index@8
  00046	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00050	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR uncompressed_size$[rsp], rax
  00058	76 0a		 jbe	 SHORT $LN7@lzma_index@8
$LN6@lzma_index@8:

; 658  : 		return LZMA_PROG_ERROR;

  0005a	b8 0b 00 00 00	 mov	 eax, 11
  0005f	e9 6e 03 00 00	 jmp	 $LN8@lzma_index@8
$LN7@lzma_index@8:

; 659  : 
; 660  :   {
; 661  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0006c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00070	48 89 44 24 40	 mov	 QWORD PTR s$33161[rsp], rax

; 662  : 	index_group *g = (index_group *)(s->groups.rightmost);

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  0007a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0007e	48 89 44 24 50	 mov	 QWORD PTR g$33163[rsp], rax

; 663  : 
; 664  : 	const lzma_vli compressed_base = g == NULL ? 0
; 665  : 			: vli_ceil4(g->records[g->last].unpadded_sum);

  00083	48 83 7c 24 50
	00		 cmp	 QWORD PTR g$33163[rsp], 0
  00089	75 0b		 jne	 SHORT $LN10@lzma_index@8
  0008b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv78[rsp], 0
  00094	eb 24		 jmp	 SHORT $LN11@lzma_index@8
$LN10@lzma_index@8:
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  0009b	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0009f	48 6b c9 10	 imul	 rcx, 16
  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  000a8	48 8b 44 08 48	 mov	 rax, QWORD PTR [rax+rcx+72]
  000ad	48 83 c0 03	 add	 rax, 3
  000b1	48 83 e0 fc	 and	 rax, -4
  000b5	48 89 44 24 70	 mov	 QWORD PTR tv78[rsp], rax
$LN11@lzma_index@8:
  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR tv78[rsp]
  000bf	48 89 44 24 30	 mov	 QWORD PTR compressed_base$33165[rsp], rax

; 666  : 	const lzma_vli uncompressed_base = g == NULL ? 0
; 667  : 			: g->records[g->last].uncompressed_sum;

  000c4	48 83 7c 24 50
	00		 cmp	 QWORD PTR g$33163[rsp], 0
  000ca	75 0b		 jne	 SHORT $LN12@lzma_index@8
  000cc	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
  000d5	eb 1c		 jmp	 SHORT $LN13@lzma_index@8
$LN12@lzma_index@8:
  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  000dc	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000e0	48 6b c9 10	 imul	 rcx, 16
  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  000e9	48 8b 44 08 40	 mov	 rax, QWORD PTR [rax+rcx+64]
  000ee	48 89 44 24 78	 mov	 QWORD PTR tv84[rsp], rax
$LN13@lzma_index@8:
  000f3	48 8b 44 24 78	 mov	 rax, QWORD PTR tv84[rsp]
  000f8	48 89 44 24 48	 mov	 QWORD PTR uncompressed_base$33167[rsp], rax

; 668  : 	const uint32_t index_list_size_add = lzma_vli_size(unpadded_size)
; 669  : 			+ lzma_vli_size(uncompressed_size);

  000fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR unpadded_size$[rsp]
  00105	e8 00 00 00 00	 call	 lzma_vli_size
  0010a	8b d8		 mov	 ebx, eax
  0010c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR uncompressed_size$[rsp]
  00114	e8 00 00 00 00	 call	 lzma_vli_size
  00119	44 8b d8	 mov	 r11d, eax
  0011c	8b c3		 mov	 eax, ebx
  0011e	41 03 c3	 add	 eax, r11d
  00121	89 44 24 38	 mov	 DWORD PTR index_list_size_add$33169[rsp], eax

; 670  : 
; 671  : 	// Check that the file size will stay within limits.
; 672  : 	if (index_file_size(s->node.compressed_base,
; 673  : 			compressed_base + unpadded_size, s->record_count + 1,
; 674  : 			s->index_list_size + index_list_size_add,
; 675  : 			s->stream_padding) == LZMA_VLI_UNKNOWN)

  00125	44 8b 4c 24 38	 mov	 r9d, DWORD PTR index_list_size_add$33169[rsp]
  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  0012f	4c 03 48 60	 add	 r9, QWORD PTR [rax+96]
  00133	4c 8b 44 24 40	 mov	 r8, QWORD PTR s$33161[rsp]
  00138	4d 8b 40 58	 mov	 r8, QWORD PTR [r8+88]
  0013c	49 83 c0 01	 add	 r8, 1
  00140	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR unpadded_size$[rsp]
  00148	48 8b 54 24 30	 mov	 rdx, QWORD PTR compressed_base$33165[rsp]
  0014d	48 03 d0	 add	 rdx, rax
  00150	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  00155	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$33161[rsp]
  00166	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0016a	e8 00 00 00 00	 call	 index_file_size
  0016f	48 83 f8 ff	 cmp	 rax, -1
  00173	75 0a		 jne	 SHORT $LN5@lzma_index@8

; 676  : 		return LZMA_DATA_ERROR;

  00175	b8 09 00 00 00	 mov	 eax, 9
  0017a	e9 53 02 00 00	 jmp	 $LN8@lzma_index@8
$LN5@lzma_index@8:

; 677  : 
; 678  : 	// The size of the Index field must not exceed the maximum value
; 679  : 	// that can be stored in the Backward Size field.
; 680  : 	if (index_size(i->record_count + 1,
; 681  : 			i->index_list_size + index_list_size_add)
; 682  : 			> LZMA_BACKWARD_SIZE_MAX)

  0017f	8b 44 24 38	 mov	 eax, DWORD PTR index_list_size_add$33169[rsp]
  00183	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  0018b	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  0018f	48 89 44 24 68	 mov	 QWORD PTR $T83418[rsp], rax
  00194	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0019c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001a0	48 83 c0 01	 add	 rax, 1
  001a4	48 89 44 24 60	 mov	 QWORD PTR $T83417[rsp], rax
  001a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T83417[rsp]
  001ae	e8 00 00 00 00	 call	 lzma_vli_size
  001b3	83 c0 01	 add	 eax, 1
  001b6	8b c8		 mov	 ecx, eax
  001b8	48 8b 44 24 68	 mov	 rax, QWORD PTR $T83418[rsp]
  001bd	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  001c2	48 89 44 24 58	 mov	 QWORD PTR $T83407[rsp], rax
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T83407[rsp]
  001cc	48 83 c1 03	 add	 rcx, 3
  001d0	48 83 e1 fc	 and	 rcx, -4
  001d4	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  001de	48 3b c8	 cmp	 rcx, rax
  001e1	76 0a		 jbe	 SHORT $LN4@lzma_index@8

; 683  : 		return LZMA_DATA_ERROR;

  001e3	b8 09 00 00 00	 mov	 eax, 9
  001e8	e9 e5 01 00 00	 jmp	 $LN8@lzma_index@8
$LN4@lzma_index@8:

; 684  : 
; 685  : 	if (g != NULL && g->last + 1 < g->allocated) {

  001ed	48 83 7c 24 50
	00		 cmp	 QWORD PTR g$33163[rsp], 0
  001f3	74 33		 je	 SHORT $LN3@lzma_index@8
  001f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  001fa	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001fe	48 83 c1 01	 add	 rcx, 1
  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  00207	48 3b 48 30	 cmp	 rcx, QWORD PTR [rax+48]
  0020b	73 1b		 jae	 SHORT $LN3@lzma_index@8

; 686  : 		// There is space in the last group at least for one Record.
; 687  : 		++g->last;

  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  00212	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00216	48 83 c1 01	 add	 rcx, 1
  0021a	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  0021f	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 688  : 	} else {

  00223	e9 ae 00 00 00	 jmp	 $LN2@lzma_index@8
$LN3@lzma_index@8:

; 689  : 		// We need to allocate a new group.
; 690  : 		g = lzma_alloc(sizeof(index_group)
; 691  : 				+ i->prealloc * sizeof(index_record),
; 692  : 				allocator);

  00228	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  00230	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00234	48 6b c9 10	 imul	 rcx, 16
  00238	48 83 c1 40	 add	 rcx, 64			; 00000040H
  0023c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00244	e8 00 00 00 00	 call	 lzma_alloc
  00249	48 89 44 24 50	 mov	 QWORD PTR g$33163[rsp], rax

; 693  : 		if (g == NULL)

  0024e	48 83 7c 24 50
	00		 cmp	 QWORD PTR g$33163[rsp], 0
  00254	75 0a		 jne	 SHORT $LN1@lzma_index@8

; 694  : 			return LZMA_MEM_ERROR;

  00256	b8 05 00 00 00	 mov	 eax, 5
  0025b	e9 72 01 00 00	 jmp	 $LN8@lzma_index@8
$LN1@lzma_index@8:

; 695  : 
; 696  : 		g->last = 0;

  00260	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  00265	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 697  : 		g->allocated = i->prealloc;

  0026d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  00272	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0027a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0027e	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 698  : 
; 699  : 		// Reset prealloc so that if the application happens to
; 700  : 		// add new Records, the allocation size will be sane.
; 701  : 		i->prealloc = INDEX_GROUP_SIZE;

  00282	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0028a	48 c7 40 40 00
	02 00 00	 mov	 QWORD PTR [rax+64], 512	; 00000200H

; 702  : 
; 703  : 		// Set the start offsets of this group.
; 704  : 		g->node.uncompressed_base = uncompressed_base;

  00292	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  00297	48 8b 44 24 48	 mov	 rax, QWORD PTR uncompressed_base$33167[rsp]
  0029c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 705  : 		g->node.compressed_base = compressed_base;

  0029f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  002a4	48 8b 44 24 30	 mov	 rax, QWORD PTR compressed_base$33165[rsp]
  002a9	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 706  : 		g->number_base = s->record_count + 1;

  002ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$33161[rsp]
  002b2	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  002b6	48 83 c1 01	 add	 rcx, 1
  002ba	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  002bf	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 707  : 
; 708  : 		// Add the new group to the Stream.
; 709  : 		index_tree_append(&s->groups, &g->node);

  002c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$33161[rsp]
  002c8	48 83 c1 38	 add	 rcx, 56			; 00000038H
  002cc	48 8b 54 24 50	 mov	 rdx, QWORD PTR g$33163[rsp]
  002d1	e8 00 00 00 00	 call	 index_tree_append
$LN2@lzma_index@8:

; 710  : 	}
; 711  : 
; 712  : 	// Add the new Record to the group.
; 713  : 	g->records[g->last].uncompressed_sum
; 714  : 			= uncompressed_base + uncompressed_size;

  002d6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR uncompressed_size$[rsp]
  002de	48 8b 54 24 48	 mov	 rdx, QWORD PTR uncompressed_base$33167[rsp]
  002e3	48 03 d0	 add	 rdx, rax
  002e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  002eb	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  002ef	48 6b c9 10	 imul	 rcx, 16
  002f3	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  002f8	48 89 54 08 40	 mov	 QWORD PTR [rax+rcx+64], rdx

; 715  : 	g->records[g->last].unpadded_sum
; 716  : 			= compressed_base + unpadded_size;

  002fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR unpadded_size$[rsp]
  00305	48 8b 54 24 30	 mov	 rdx, QWORD PTR compressed_base$33165[rsp]
  0030a	48 03 d0	 add	 rdx, rax
  0030d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$33163[rsp]
  00312	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00316	48 6b c9 10	 imul	 rcx, 16
  0031a	48 8b 44 24 50	 mov	 rax, QWORD PTR g$33163[rsp]
  0031f	48 89 54 08 48	 mov	 QWORD PTR [rax+rcx+72], rdx

; 717  : 
; 718  : 	// Update the totals.
; 719  : 	++s->record_count;

  00324	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$33161[rsp]
  00329	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0032d	48 83 c1 01	 add	 rcx, 1
  00331	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  00336	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 720  : 	s->index_list_size += index_list_size_add;

  0033a	8b 4c 24 38	 mov	 ecx, DWORD PTR index_list_size_add$33169[rsp]
  0033e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  00343	48 03 48 60	 add	 rcx, QWORD PTR [rax+96]
  00347	48 8b 44 24 40	 mov	 rax, QWORD PTR s$33161[rsp]
  0034c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 721  : 
; 722  : 	i->total_size += vli_ceil4(unpadded_size);

  00350	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR unpadded_size$[rsp]
  00358	48 83 c1 03	 add	 rcx, 3
  0035c	48 83 e1 fc	 and	 rcx, -4
  00360	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00368	48 03 48 28	 add	 rcx, QWORD PTR [rax+40]
  0036c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00374	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 723  : 	i->uncompressed_size += uncompressed_size;

  00378	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  00380	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00384	48 03 8c 24 a8
	00 00 00	 add	 rcx, QWORD PTR uncompressed_size$[rsp]
  0038c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00394	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 724  : 	++i->record_count;

  00398	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  003a0	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  003a4	48 83 c1 01	 add	 rcx, 1
  003a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003b0	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 725  : 	i->index_list_size += index_list_size_add;

  003b4	8b 4c 24 38	 mov	 ecx, DWORD PTR index_list_size_add$33169[rsp]
  003b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003c0	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  003c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003cc	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 726  :   }
; 727  : 
; 728  : 	return LZMA_OK;

  003d0	33 c0		 xor	 eax, eax
$LN8@lzma_index@8:

; 729  : }

  003d2	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  003d9	5b		 pop	 rbx
  003da	c3		 ret	 0
lzma_index_append ENDP
_TEXT	ENDS
PUBLIC	lzma_index_file_size
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_file_size DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$lzma_index_file_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_file_size DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_file_size
_TEXT	SEGMENT
s$ = 48
g$ = 56
tv79 = 64
i$ = 96
lzma_index_file_size PROC				; COMDAT

; 567  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 568  : 	const index_stream *s = (const index_stream *)(i->streams.rightmost);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  0000e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00012	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 569  : 	const index_group *g = (const index_group *)(s->groups.rightmost);

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0001c	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00020	48 89 44 24 38	 mov	 QWORD PTR g$[rsp], rax

; 570  : 	return index_file_size(s->node.compressed_base,
; 571  : 			g == NULL ? 0 : g->records[g->last].unpadded_sum,
; 572  : 			s->record_count, s->index_list_size,
; 573  : 			s->stream_padding);

  00025	48 83 7c 24 38
	00		 cmp	 QWORD PTR g$[rsp], 0
  0002b	75 0b		 jne	 SHORT $LN3@lzma_index@9
  0002d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  00036	eb 1c		 jmp	 SHORT $LN4@lzma_index@9
$LN3@lzma_index@9:
  00038	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$[rsp]
  0003d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00041	48 6b c9 10	 imul	 rcx, 16
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR g$[rsp]
  0004a	48 8b 44 08 48	 mov	 rax, QWORD PTR [rax+rcx+72]
  0004f	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
$LN4@lzma_index@9:
  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00059	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	4c 8b 4c 24 30	 mov	 r9, QWORD PTR s$[rsp]
  0006a	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  0006e	4c 8b 44 24 30	 mov	 r8, QWORD PTR s$[rsp]
  00073	4d 8b 40 58	 mov	 r8, QWORD PTR [r8+88]
  00077	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv79[rsp]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00081	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00085	e8 00 00 00 00	 call	 index_file_size

; 574  : }

  0008a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0008e	c3		 ret	 0
lzma_index_file_size ENDP
_TEXT	ENDS
PUBLIC	lzma_index_end
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_end DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$lzma_index_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_end DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_end
_TEXT	SEGMENT
i$ = 48
allocator$ = 56
lzma_index_end PROC					; COMDAT

; 424  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 425  : 	// NOTE: If you modify this function, check also the bottom
; 426  : 	// of lzma_index_cat().
; 427  : 	if (i != NULL) {

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	74 25		 je	 SHORT $LN1@lzma_index@10

; 428  : 		index_tree_end(&i->streams, allocator, &index_stream_end);

  00016	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:index_stream_end
  0001d	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00027	e8 00 00 00 00	 call	 index_tree_end

; 429  : 		lzma_free(i, allocator);

  0002c	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00036	e8 00 00 00 00	 call	 lzma_free
$LN1@lzma_index@10:

; 430  : 	}
; 431  : 
; 432  : 	return;
; 433  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
lzma_index_end ENDP
PUBLIC	$T83841
PUBLIC	lzma_index_cat
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.h
pdata	SEGMENT
$pdata$lzma_index_cat DD imagerel $LN17
	DD	imagerel $LN17+1026
	DD	imagerel $unwind$lzma_index_cat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_cat DD 041801H
	DD	0190118H
	DD	060107011H
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index.c
xdata	ENDS
;	COMDAT lzma_index_cat
_TEXT	SEGMENT
dest_file_size$ = 32
src_size$33211 = 40
dest_size$33210 = 48
s$33213 = 56
g$33215 = 64
newg$33221 = 72
info$33233 = 80
$T83831 = 120
$T83832 = 128
$T83836 = 136
$T83837 = 144
$T83841 = 152
dest$ = 224
src$ = 232
allocator$ = 240
lzma_index_cat PROC					; COMDAT

; 782  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 783  : 	const lzma_vli dest_file_size = lzma_index_file_size(dest);

  00018	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00020	e8 00 00 00 00	 call	 lzma_index_file_size
  00025	48 89 44 24 20	 mov	 QWORD PTR dest_file_size$[rsp], rax

; 784  : 
; 785  : 	// Check that we don't exceed the file size limits.
; 786  : 	if (dest_file_size + lzma_index_file_size(src) > LZMA_VLI_MAX
; 787  : 			|| dest->uncompressed_size + src->uncompressed_size
; 788  : 				> LZMA_VLI_MAX)

  0002a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  00032	e8 00 00 00 00	 call	 lzma_index_file_size
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest_file_size$[rsp]
  0003c	48 03 c8	 add	 rcx, rax
  0003f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00049	48 3b c8	 cmp	 rcx, rax
  0004c	77 27		 ja	 SHORT $LN7@lzma_index@11
  0004e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00056	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0005a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00062	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00066	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00070	48 3b c8	 cmp	 rcx, rax
  00073	76 0a		 jbe	 SHORT $LN8@lzma_index@11
$LN7@lzma_index@11:

; 789  : 		return LZMA_DATA_ERROR;

  00075	b8 09 00 00 00	 mov	 eax, 9
  0007a	e9 79 03 00 00	 jmp	 $LN9@lzma_index@11
$LN8@lzma_index@11:

; 790  : 
; 791  : 	// Check that the encoded size of the combined lzma_indexes stays
; 792  : 	// within limits. In theory, this should be done only if we know
; 793  : 	// that the user plans to actually combine the Streams and thus
; 794  : 	// construct a single Index (probably rare). However, exceeding
; 795  : 	// this limit is quite theoretical, so we do this check always
; 796  : 	// to simplify things elsewhere.
; 797  : 	{
; 798  : 		const lzma_vli dest_size = index_size_unpadded(
; 799  : 				dest->record_count, dest->index_list_size);

  0007f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00087	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T83832[rsp], rax
  00093	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0009b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0009f	48 89 44 24 78	 mov	 QWORD PTR $T83831[rsp], rax
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T83831[rsp]
  000a9	e8 00 00 00 00	 call	 lzma_vli_size
  000ae	83 c0 01	 add	 eax, 1
  000b1	8b c8		 mov	 ecx, eax
  000b3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T83832[rsp]
  000bb	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  000c0	48 89 44 24 30	 mov	 QWORD PTR dest_size$33210[rsp], rax

; 800  : 		const lzma_vli src_size = index_size_unpadded(
; 801  : 				src->record_count, src->index_list_size);

  000c5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  000cd	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T83837[rsp], rax
  000d9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  000e1	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000e5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T83836[rsp], rax
  000ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T83836[rsp]
  000f5	e8 00 00 00 00	 call	 lzma_vli_size
  000fa	83 c0 01	 add	 eax, 1
  000fd	8b c8		 mov	 ecx, eax
  000ff	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T83837[rsp]
  00107	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0010c	48 89 44 24 28	 mov	 QWORD PTR src_size$33211[rsp], rax

; 802  : 		if (vli_ceil4(dest_size + src_size) > LZMA_BACKWARD_SIZE_MAX)

  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest_size$33210[rsp]
  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR src_size$33211[rsp]
  0011b	48 8d 4c 01 03	 lea	 rcx, QWORD PTR [rcx+rax+3]
  00120	48 83 e1 fc	 and	 rcx, -4
  00124	48 b8 00 00 00
	00 04 00 00 00	 mov	 rax, 17179869184	; 0000000400000000H
  0012e	48 3b c8	 cmp	 rcx, rax
  00131	76 0a		 jbe	 SHORT $LN6@lzma_index@11

; 803  : 			return LZMA_DATA_ERROR;

  00133	b8 09 00 00 00	 mov	 eax, 9
  00138	e9 bb 02 00 00	 jmp	 $LN9@lzma_index@11
$LN6@lzma_index@11:

; 804  : 	}
; 805  : 
; 806  : 	// Optimize the last group to minimize memory usage. Allocation has
; 807  : 	// to be done before modifying dest or src.
; 808  : 	{
; 809  : 		index_stream *s = (index_stream *)(dest->streams.rightmost);

  0013d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00145	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00149	48 89 44 24 38	 mov	 QWORD PTR s$33213[rsp], rax

; 810  : 		index_group *g = (index_group *)(s->groups.rightmost);

  0014e	48 8b 44 24 38	 mov	 rax, QWORD PTR s$33213[rsp]
  00153	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00157	48 89 44 24 40	 mov	 QWORD PTR g$33215[rsp], rax

; 811  : 		if (g != NULL && g->last + 1 < g->allocated) {

  0015c	48 83 7c 24 40
	00		 cmp	 QWORD PTR g$33215[rsp], 0
  00162	0f 84 55 01 00
	00		 je	 $LN5@lzma_index@11
  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33215[rsp]
  0016d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00171	48 83 c1 01	 add	 rcx, 1
  00175	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33215[rsp]
  0017a	48 3b 48 30	 cmp	 rcx, QWORD PTR [rax+48]
  0017e	0f 83 39 01 00
	00		 jae	 $LN5@lzma_index@11

; 812  : 			assert(g->node.left == NULL);
; 813  : 			assert(g->node.right == NULL);
; 814  : 
; 815  : 		  {
; 816  : 			index_group *newg = lzma_alloc(sizeof(index_group)
; 817  : 					+ (g->last + 1)
; 818  : 					* sizeof(index_record),
; 819  : 					allocator);

  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33215[rsp]
  00189	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0018d	48 83 c1 01	 add	 rcx, 1
  00191	48 6b c9 10	 imul	 rcx, 16
  00195	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00199	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001a1	e8 00 00 00 00	 call	 lzma_alloc
  001a6	48 89 44 24 48	 mov	 QWORD PTR newg$33221[rsp], rax

; 820  : 			if (newg == NULL)

  001ab	48 83 7c 24 48
	00		 cmp	 QWORD PTR newg$33221[rsp], 0
  001b1	75 0a		 jne	 SHORT $LN4@lzma_index@11

; 821  : 				return LZMA_MEM_ERROR;

  001b3	b8 05 00 00 00	 mov	 eax, 5
  001b8	e9 3b 02 00 00	 jmp	 $LN9@lzma_index@11
$LN4@lzma_index@11:

; 822  : 
; 823  : 			newg->node = g->node;

  001bd	48 8d bc 24 98
	00 00 00	 lea	 rdi, QWORD PTR $T83841[rsp]
  001c5	48 8b 74 24 40	 mov	 rsi, QWORD PTR g$33215[rsp]
  001ca	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  001cf	f3 a4		 rep movsb
  001d1	48 8d b4 24 98
	00 00 00	 lea	 rsi, QWORD PTR $T83841[rsp]
  001d9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR newg$33221[rsp]
  001de	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  001e3	f3 a4		 rep movsb

; 824  : 			newg->allocated = g->last + 1;

  001e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33215[rsp]
  001ea	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001ee	48 83 c1 01	 add	 rcx, 1
  001f2	48 8b 44 24 48	 mov	 rax, QWORD PTR newg$33221[rsp]
  001f7	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 825  : 			newg->last = g->last;

  001fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newg$33221[rsp]
  00200	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33215[rsp]
  00205	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00209	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 826  : 			newg->number_base = g->number_base;

  0020d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newg$33221[rsp]
  00212	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33215[rsp]
  00217	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0021b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 827  : 
; 828  : 			memcpy(newg->records, g->records, newg->allocated
; 829  : 					* sizeof(index_record));

  0021f	4c 8b 44 24 48	 mov	 r8, QWORD PTR newg$33221[rsp]
  00224	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00228	4d 6b c0 10	 imul	 r8, 16
  0022c	48 8b 54 24 40	 mov	 rdx, QWORD PTR g$33215[rsp]
  00231	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00235	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newg$33221[rsp]
  0023a	48 83 c1 40	 add	 rcx, 64			; 00000040H
  0023e	e8 00 00 00 00	 call	 memcpy

; 830  : 
; 831  : 			if (g->node.parent != NULL) {

  00243	48 8b 54 24 40	 mov	 rdx, QWORD PTR g$33215[rsp]
  00248	48 83 7a 10 00	 cmp	 QWORD PTR [rdx+16], 0
  0024d	74 12		 je	 SHORT $LN3@lzma_index@11

; 832  : 				assert(g->node.parent->right == &g->node);
; 833  : 				g->node.parent->right = &newg->node;

  0024f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33215[rsp]
  00254	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00258	48 8b 44 24 48	 mov	 rax, QWORD PTR newg$33221[rsp]
  0025d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN3@lzma_index@11:

; 834  : 			}
; 835  : 
; 836  : 			if (s->groups.leftmost == &g->node) {

  00261	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$33213[rsp]
  00266	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33215[rsp]
  0026b	48 39 41 40	 cmp	 QWORD PTR [rcx+64], rax
  0026f	75 1c		 jne	 SHORT $LN2@lzma_index@11

; 837  : 				assert(s->groups.root == &g->node);
; 838  : 				s->groups.leftmost = &newg->node;

  00271	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$33213[rsp]
  00276	48 8b 44 24 48	 mov	 rax, QWORD PTR newg$33221[rsp]
  0027b	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 839  : 				s->groups.root = &newg->node;

  0027f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$33213[rsp]
  00284	48 8b 44 24 48	 mov	 rax, QWORD PTR newg$33221[rsp]
  00289	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@lzma_index@11:

; 840  : 			}
; 841  : 
; 842  : 			if (s->groups.rightmost == &g->node)

  0028d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$33213[rsp]
  00292	48 8b 44 24 40	 mov	 rax, QWORD PTR g$33215[rsp]
  00297	48 39 41 48	 cmp	 QWORD PTR [rcx+72], rax
  0029b	75 0e		 jne	 SHORT $LN1@lzma_index@11

; 843  : 				s->groups.rightmost = &newg->node;

  0029d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$33213[rsp]
  002a2	48 8b 44 24 48	 mov	 rax, QWORD PTR newg$33221[rsp]
  002a7	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN1@lzma_index@11:

; 844  : 
; 845  : 			lzma_free(g, allocator);

  002ab	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  002b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$33215[rsp]
  002b8	e8 00 00 00 00	 call	 lzma_free
$LN5@lzma_index@11:

; 846  : 
; 847  : 			// NOTE: newg isn't leaked here because
; 848  : 			// newg == (void *)&newg->node.
; 849  : 		  }
; 850  : 		}
; 851  : 	}
; 852  : 
; 853  : 	// Add all the Streams from src to dest. Update the base offsets
; 854  : 	// of each Stream from src.
; 855  : 	{ //MiSt
; 856  : 	/*
; 857  : 	const index_cat_info info = {
; 858  : 		.uncompressed_size = dest->uncompressed_size,
; 859  : 		.file_size = dest_file_size,
; 860  : 		.stream_number_add = dest->streams.count,
; 861  : 		.block_number_add = dest->record_count,
; 862  : 		.streams = &dest->streams,
; 863  : 	};
; 864  : 	*/
; 865  : 	index_cat_info info;
; 866  : 	memset (&info, 0, sizeof(info));

  002bd	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  002c3	33 d2		 xor	 edx, edx
  002c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR info$33233[rsp]
  002ca	e8 00 00 00 00	 call	 memset

; 867  : 	info.uncompressed_size = dest->uncompressed_size;

  002cf	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  002d7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002db	48 89 44 24 50	 mov	 QWORD PTR info$33233[rsp], rax

; 868  : 	info.file_size = dest_file_size;

  002e0	48 8b 44 24 20	 mov	 rax, QWORD PTR dest_file_size$[rsp]
  002e5	48 89 44 24 58	 mov	 QWORD PTR info$33233[rsp+8], rax

; 869  : 	info.stream_number_add = dest->streams.count;

  002ea	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  002f2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002f5	89 44 24 68	 mov	 DWORD PTR info$33233[rsp+24], eax

; 870  : 	info.block_number_add = dest->record_count;

  002f9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00301	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00305	48 89 44 24 60	 mov	 QWORD PTR info$33233[rsp+16], rax

; 871  : 	info.streams = &dest->streams;

  0030a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00312	48 89 44 24 70	 mov	 QWORD PTR info$33233[rsp+32], rax

; 872  : 
; 873  : 	index_cat_helper(&info, (index_stream *)(src->streams.root));

  00317	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0031f	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00322	48 8d 4c 24 50	 lea	 rcx, QWORD PTR info$33233[rsp]
  00327	e8 00 00 00 00	 call	 index_cat_helper

; 874  : 
; 875  : 	// Update info about all the combined Streams.
; 876  : 	dest->uncompressed_size += src->uncompressed_size;

  0032c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00334	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00338	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00340	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00344	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0034c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 877  : 	dest->total_size += src->total_size;

  00350	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00358	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0035c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00364	48 03 48 28	 add	 rcx, QWORD PTR [rax+40]
  00368	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00370	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 878  : 	dest->record_count += src->record_count;

  00374	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  0037c	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00380	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00388	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  0038c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00394	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 879  : 	dest->index_list_size += src->index_list_size;

  00398	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  003a0	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  003a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  003ac	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  003b0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  003b8	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 880  : 	dest->checks = lzma_index_checks(dest) | src->checks;

  003bc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  003c4	e8 00 00 00 00	 call	 lzma_index_checks
  003c9	8b c8		 mov	 ecx, eax
  003cb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  003d3	0b 48 48	 or	 ecx, DWORD PTR [rax+72]
  003d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  003de	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 881  : 
; 882  : 	// There's nothing else left in src than the base structure.
; 883  : 	lzma_free(src, allocator);

  003e1	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  003f1	e8 00 00 00 00	 call	 lzma_free

; 884  : 	}
; 885  : 
; 886  : 	return LZMA_OK;

  003f6	33 c0		 xor	 eax, eax
$LN9@lzma_index@11:

; 887  : }

  003f8	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003ff	5f		 pop	 rdi
  00400	5e		 pop	 rsi
  00401	c3		 ret	 0
lzma_index_cat ENDP
_TEXT	ENDS
PUBLIC	lzma_index_stream_padding
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_stream_padding DD imagerel $LN6
	DD	imagerel $LN6+188
	DD	imagerel $unwind$lzma_index_stream_padding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_stream_padding DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_stream_padding
_TEXT	SEGMENT
s$33145 = 32
old_stream_padding$33147 = 40
i$ = 64
stream_padding$ = 72
lzma_index_stream_padding PROC				; COMDAT

; 627  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 628  : 	if (i == NULL || stream_padding > LZMA_VLI_MAX
; 629  : 			|| (stream_padding & 3) != 0)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	74 1f		 je	 SHORT $LN2@lzma_index@12
  00016	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00020	48 39 44 24 48	 cmp	 QWORD PTR stream_padding$[rsp], rax
  00025	77 0e		 ja	 SHORT $LN2@lzma_index@12
  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR stream_padding$[rsp]
  0002c	48 83 e0 03	 and	 rax, 3
  00030	48 85 c0	 test	 rax, rax
  00033	74 07		 je	 SHORT $LN3@lzma_index@12
$LN2@lzma_index@12:

; 630  : 		return LZMA_PROG_ERROR;

  00035	b8 0b 00 00 00	 mov	 eax, 11
  0003a	eb 7b		 jmp	 SHORT $LN4@lzma_index@12
$LN3@lzma_index@12:

; 631  : 
; 632  :   {
; 633  : 	index_stream *s = (index_stream *)(i->streams.rightmost);

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	48 89 44 24 20	 mov	 QWORD PTR s$33145[rsp], rax

; 634  : 
; 635  : 	// Check that the new value won't make the file grow too big.
; 636  : 	const lzma_vli old_stream_padding = s->stream_padding;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$33145[rsp]
  0004f	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00056	48 89 44 24 28	 mov	 QWORD PTR old_stream_padding$33147[rsp], rax

; 637  : 	s->stream_padding = 0;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$33145[rsp]
  00060	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 638  : 	if (lzma_index_file_size(i) + stream_padding > LZMA_VLI_MAX) {

  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00070	e8 00 00 00 00	 call	 lzma_index_file_size
  00075	48 8b c8	 mov	 rcx, rax
  00078	48 03 4c 24 48	 add	 rcx, QWORD PTR stream_padding$[rsp]
  0007d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00087	48 3b c8	 cmp	 rcx, rax
  0008a	76 18		 jbe	 SHORT $LN1@lzma_index@12

; 639  : 		s->stream_padding = old_stream_padding;

  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$33145[rsp]
  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR old_stream_padding$33147[rsp]
  00096	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 640  : 		return LZMA_DATA_ERROR;

  0009d	b8 09 00 00 00	 mov	 eax, 9
  000a2	eb 13		 jmp	 SHORT $LN4@lzma_index@12
$LN1@lzma_index@12:

; 641  : 	}
; 642  : 
; 643  : 	s->stream_padding = stream_padding;

  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$33145[rsp]
  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR stream_padding$[rsp]
  000ae	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 644  :   }
; 645  : 
; 646  : 	return LZMA_OK;

  000b5	33 c0		 xor	 eax, eax
$LN4@lzma_index@12:

; 647  : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
lzma_index_stream_padding ENDP
END
