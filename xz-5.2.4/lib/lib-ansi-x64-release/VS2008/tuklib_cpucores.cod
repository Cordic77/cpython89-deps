; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzmatuklib_cpucores
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_cpucores.c
pdata	SEGMENT
$pdata$lzmatuklib_cpucores DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$lzmatuklib_cpucores
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzmatuklib_cpucores DD 010401H
	DD	0c204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzmatuklib_cpucores
_TEXT	SEGMENT
sysinfo$ = 32
ret$ = 80
lzmatuklib_cpucores PROC				; COMDAT

; 48   : {

$LN3:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 49   : 	uint32_t ret = 0;

  00004	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 50   : 
; 51   : #if defined(_WIN32) || defined(__CYGWIN__)
; 52   : 	SYSTEM_INFO sysinfo;
; 53   : 	GetSystemInfo(&sysinfo);

  0000c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR sysinfo$[rsp]
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemInfo

; 54   : 	ret = sysinfo.dwNumberOfProcessors;

  00017	44 8b 5c 24 40	 mov	 r11d, DWORD PTR sysinfo$[rsp+32]
  0001c	44 89 5c 24 50	 mov	 DWORD PTR ret$[rsp], r11d

; 55   : 
; 56   : #elif defined(TUKLIB_CPUCORES_SCHED_GETAFFINITY)
; 57   : 	cpu_set_t cpu_mask;
; 58   : 	if (sched_getaffinity(0, sizeof(cpu_mask), &cpu_mask) == 0)
; 59   : 		ret = CPU_COUNT(&cpu_mask);
; 60   : 
; 61   : #elif defined(TUKLIB_CPUCORES_CPUSET)
; 62   : 	cpuset_t set;
; 63   : 	if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,
; 64   : 			sizeof(set), &set) == 0) {
; 65   : #	ifdef CPU_COUNT
; 66   : 		ret = CPU_COUNT(&set);
; 67   : #	else
; 68   : 		for (unsigned i = 0; i < CPU_SETSIZE; ++i)
; 69   : 			if (CPU_ISSET(i, &set))
; 70   : 				++ret;
; 71   : #	endif
; 72   : 	}
; 73   : 
; 74   : #elif defined(TUKLIB_CPUCORES_SYSCTL)
; 75   : 	int name[2] = { CTL_HW, HW_NCPU };
; 76   : 	int cpus;
; 77   : 	size_t cpus_size = sizeof(cpus);
; 78   : 	if (sysctl(name, 2, &cpus, &cpus_size, NULL, 0) != -1
; 79   : 			&& cpus_size == sizeof(cpus) && cpus > 0)
; 80   : 		ret = cpus;
; 81   : 
; 82   : #elif defined(TUKLIB_CPUCORES_SYSCONF)
; 83   : #	ifdef _SC_NPROCESSORS_ONLN
; 84   : 	// Most systems
; 85   : 	const long cpus = sysconf(_SC_NPROCESSORS_ONLN);
; 86   : #	else
; 87   : 	// IRIX
; 88   : 	const long cpus = sysconf(_SC_NPROC_ONLN);
; 89   : #	endif
; 90   : 	if (cpus > 0)
; 91   : 		ret = cpus;
; 92   : 
; 93   : #elif defined(TUKLIB_CPUCORES_PSTAT_GETDYNAMIC)
; 94   : 	struct pst_dynamic pst;
; 95   : 	if (pstat_getdynamic(&pst, sizeof(pst), 1, 0) != -1)
; 96   : 		ret = pst.psd_proc_cnt;
; 97   : #endif
; 98   : 
; 99   : 	return ret;

  00021	8b 44 24 50	 mov	 eax, DWORD PTR ret$[rsp]

; 100  : }

  00025	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00029	c3		 ret	 0
lzmatuklib_cpucores ENDP
END
