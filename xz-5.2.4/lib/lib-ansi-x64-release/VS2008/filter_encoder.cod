; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

encoders DQ	4000000000000001H
	DQ	FLAT:lzma_lzma_encoder_init
	DQ	FLAT:lzma_lzma_encoder_memusage
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	05H
	ORG $+4
	DQ	FLAT:lzma_lzma_props_encode
	DQ	0000000000000021H
	DQ	FLAT:lzma_lzma2_encoder_init
	DQ	FLAT:lzma_lzma2_encoder_memusage
	DQ	FLAT:lzma_lzma2_block_size
	DQ	0000000000000000H
	DD	01H
	ORG $+4
	DQ	FLAT:lzma_lzma2_props_encode
	DQ	0000000000000004H
	DQ	FLAT:lzma_simple_x86_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000005H
	DQ	FLAT:lzma_simple_powerpc_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000006H
	DQ	FLAT:lzma_simple_ia64_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000007H
	DQ	FLAT:lzma_simple_arm_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000008H
	DQ	FLAT:lzma_simple_armthumb_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000009H
	DQ	FLAT:lzma_simple_sparc_encoder_init
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lzma_simple_props_size
	DD	00H
	ORG $+4
	DQ	FLAT:lzma_simple_props_encode
	DQ	0000000000000003H
	DQ	FLAT:lzma_delta_encoder_init
	DQ	FLAT:lzma_delta_coder_memusage
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	01H
	ORG $+4
	DQ	FLAT:lzma_delta_props_encode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\filter_encoder.c
pdata	SEGMENT
$pdata$encoder_find DD imagerel encoder_find
	DD	imagerel encoder_find+93
	DD	imagerel $unwind$encoder_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_find DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT encoder_find
_TEXT	SEGMENT
i$ = 0
id$ = 32
encoder_find PROC					; COMDAT

; 266  : {	size_t i;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 267  : 
; 268  : 	for (i = 0; i < ARRAY_SIZE(encoders); ++i)

  00009	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00011	eb 0c		 jmp	 SHORT $LN4@encoder_fi
$LN3@encoder_fi:
  00013	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00017	48 83 c0 01	 add	 rax, 1
  0001b	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN4@encoder_fi:
  0001f	48 83 3c 24 09	 cmp	 QWORD PTR i$[rsp], 9
  00024	73 30		 jae	 SHORT $LN2@encoder_fi

; 269  : 		if (encoders[i].id == id)

  00026	48 8b 14 24	 mov	 rdx, QWORD PTR i$[rsp]
  0002a	48 6b d2 38	 imul	 rdx, 56			; 00000038H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:encoders
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
  0003a	48 39 04 11	 cmp	 QWORD PTR [rcx+rdx], rax
  0003e	75 14		 jne	 SHORT $LN1@encoder_fi

; 270  : 			return encoders + i;

  00040	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00044	48 6b c9 38	 imul	 rcx, 56			; 00000038H
  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:encoders
  0004f	48 03 c1	 add	 rax, rcx
  00052	eb 04		 jmp	 SHORT $LN5@encoder_fi
$LN1@encoder_fi:

; 271  : 
; 272  : 	return NULL;

  00054	eb bd		 jmp	 SHORT $LN3@encoder_fi
$LN2@encoder_fi:
  00056	33 c0		 xor	 eax, eax
$LN5@encoder_fi:

; 273  : }

  00058	48 83 c4 18	 add	 rsp, 24
  0005c	c3		 ret	 0
encoder_find ENDP
PUBLIC	lzma_properties_encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_properties_encode DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$lzma_properties_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_properties_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_properties_encode
_TEXT	SEGMENT
fe$ = 32
filter$ = 64
props$ = 72
lzma_properties_encode PROC				; COMDAT

; 395  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 396  : 	const lzma_filter_encoder *const fe = encoder_find(filter->id);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filter$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	e8 00 00 00 00	 call	 encoder_find
  0001b	48 89 44 24 20	 mov	 QWORD PTR fe$[rsp], rax

; 397  : 	if (fe == NULL)

  00020	48 83 7c 24 20
	00		 cmp	 QWORD PTR fe$[rsp], 0
  00026	75 07		 jne	 SHORT $LN2@lzma_prope

; 398  : 		return LZMA_PROG_ERROR;

  00028	b8 0b 00 00 00	 mov	 eax, 11
  0002d	eb 26		 jmp	 SHORT $LN3@lzma_prope
$LN2@lzma_prope:

; 399  : 
; 400  : 	if (fe->props_encode == NULL)

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR fe$[rsp]
  00034	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00039	75 04		 jne	 SHORT $LN1@lzma_prope

; 401  : 		return LZMA_OK;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 16		 jmp	 SHORT $LN3@lzma_prope
$LN1@lzma_prope:

; 402  : 
; 403  : 	return fe->props_encode(filter->options, props);

  0003f	48 8b 54 24 48	 mov	 rdx, QWORD PTR props$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filter$[rsp]
  00049	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR fe$[rsp]
  00052	ff 50 30	 call	 QWORD PTR [rax+48]
$LN3@lzma_prope:

; 404  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
lzma_properties_encode ENDP
_TEXT	ENDS
PUBLIC	lzma_properties_size
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_properties_size DD imagerel $LN7
	DD	imagerel $LN7+142
	DD	imagerel $unwind$lzma_properties_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_properties_size DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_properties_size
_TEXT	SEGMENT
fe$ = 32
tv68 = 40
size$ = 64
filter$ = 72
lzma_properties_size PROC				; COMDAT

; 372  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 373  : 	const lzma_filter_encoder *const fe = encoder_find(filter->id);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filter$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	e8 00 00 00 00	 call	 encoder_find
  0001b	48 89 44 24 20	 mov	 QWORD PTR fe$[rsp], rax

; 374  : 	if (fe == NULL) {

  00020	48 83 7c 24 20
	00		 cmp	 QWORD PTR fe$[rsp], 0
  00026	75 2c		 jne	 SHORT $LN2@lzma_prope@2

; 375  : 		// Unknown filter - if the Filter ID is a proper VLI,
; 376  : 		// return LZMA_OPTIONS_ERROR instead of LZMA_PROG_ERROR,
; 377  : 		// because it's possible that we just don't have support
; 378  : 		// compiled in for the requested filter.
; 379  : 		return filter->id <= LZMA_VLI_MAX
; 380  : 				? LZMA_OPTIONS_ERROR : LZMA_PROG_ERROR;

  00028	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filter$[rsp]
  0002d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00037	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003a	77 0a		 ja	 SHORT $LN5@lzma_prope@2
  0003c	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR tv68[rsp], 8
  00044	eb 08		 jmp	 SHORT $LN6@lzma_prope@2
$LN5@lzma_prope@2:
  00046	c7 44 24 28 0b
	00 00 00	 mov	 DWORD PTR tv68[rsp], 11
$LN6@lzma_prope@2:
  0004e	8b 44 24 28	 mov	 eax, DWORD PTR tv68[rsp]
  00052	eb 35		 jmp	 SHORT $LN3@lzma_prope@2
$LN2@lzma_prope@2:

; 381  : 	}
; 382  : 
; 383  : 	if (fe->props_size_get == NULL) {

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR fe$[rsp]
  00059	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0005e	75 13		 jne	 SHORT $LN1@lzma_prope@2

; 384  : 		// No props_size_get() function, use props_size_fixed.
; 385  : 		*size = fe->props_size_fixed;

  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR fe$[rsp]
  0006a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0006d	89 01		 mov	 DWORD PTR [rcx], eax

; 386  : 		return LZMA_OK;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 16		 jmp	 SHORT $LN3@lzma_prope@2
$LN1@lzma_prope@2:

; 387  : 	}
; 388  : 
; 389  : 	return fe->props_size_get(size, filter->options);

  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR filter$[rsp]
  00078	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR fe$[rsp]
  00086	ff 50 20	 call	 QWORD PTR [rax+32]
$LN3@lzma_prope@2:

; 390  : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
lzma_properties_size ENDP
_TEXT	ENDS
PUBLIC	lzma_mt_block_size
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_mt_block_size DD imagerel $LN9
	DD	imagerel $LN9+185
	DD	imagerel $unwind$lzma_mt_block_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_mt_block_size DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_mt_block_size
_TEXT	SEGMENT
i$ = 32
max$ = 40
fe$33104 = 48
size$33107 = 56
filters$ = 80
lzma_mt_block_size PROC					; COMDAT

; 348  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 349  : 	uint64_t max = 0;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR max$[rsp], 0

; 350  : 	size_t i;
; 351  : 
; 352  : 	for (i = 0; filters[i].id != LZMA_VLI_UNKNOWN; ++i) {

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001b	eb 0e		 jmp	 SHORT $LN6@lzma_mt_bl
$LN5@lzma_mt_bl:
  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00022	48 83 c0 01	 add	 rax, 1
  00026	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@lzma_mt_bl:
  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00030	48 6b c9 10	 imul	 rcx, 16
  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR filters$[rsp]
  00039	48 83 3c 08 ff	 cmp	 QWORD PTR [rax+rcx], -1
  0003e	74 6f		 je	 SHORT $LN4@lzma_mt_bl

; 353  : 		const lzma_filter_encoder *const fe
; 354  : 				= encoder_find(filters[i].id);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00045	48 6b c0 10	 imul	 rax, 16
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filters$[rsp]
  0004e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00052	e8 00 00 00 00	 call	 encoder_find
  00057	48 89 44 24 30	 mov	 QWORD PTR fe$33104[rsp], rax

; 355  : 		if (fe->block_size != NULL) {

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR fe$33104[rsp]
  00061	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00066	74 42		 je	 SHORT $LN3@lzma_mt_bl

; 356  : 			const uint64_t size
; 357  : 					= fe->block_size(filters[i].options);

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006d	48 6b c0 10	 imul	 rax, 16
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filters$[rsp]
  00076	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR fe$33104[rsp]
  00080	ff 50 18	 call	 QWORD PTR [rax+24]
  00083	48 89 44 24 38	 mov	 QWORD PTR size$33107[rsp], rax

; 358  : 			if (size == 0)

  00088	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$33107[rsp], 0
  0008e	75 04		 jne	 SHORT $LN2@lzma_mt_bl

; 359  : 				return 0;

  00090	33 c0		 xor	 eax, eax
  00092	eb 20		 jmp	 SHORT $LN7@lzma_mt_bl
$LN2@lzma_mt_bl:

; 360  : 
; 361  : 			if (size > max)

  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR max$[rsp]
  00099	48 39 44 24 38	 cmp	 QWORD PTR size$33107[rsp], rax
  0009e	76 0a		 jbe	 SHORT $LN1@lzma_mt_bl

; 362  : 				max = size;

  000a0	48 8b 44 24 38	 mov	 rax, QWORD PTR size$33107[rsp]
  000a5	48 89 44 24 28	 mov	 QWORD PTR max$[rsp], rax
$LN1@lzma_mt_bl:
$LN3@lzma_mt_bl:

; 363  : 		}
; 364  : 	}

  000aa	e9 6e ff ff ff	 jmp	 $LN5@lzma_mt_bl
$LN4@lzma_mt_bl:

; 365  : 
; 366  : 	return max;

  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR max$[rsp]
$LN7@lzma_mt_bl:

; 367  : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
lzma_mt_block_size ENDP
_TEXT	ENDS
PUBLIC	lzma_raw_encoder_memusage
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_raw_encoder_memusage DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$lzma_raw_encoder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_raw_encoder_memusage DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_raw_encoder_memusage
_TEXT	SEGMENT
filters$ = 48
lzma_raw_encoder_memusage PROC				; COMDAT

; 340  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 341  : 	return lzma_raw_coder_memusage(
; 342  : 			(lzma_filter_find)(&encoder_find), filters);

  00009	48 8b 54 24 30	 mov	 rdx, QWORD PTR filters$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:encoder_find
  00015	e8 00 00 00 00	 call	 lzma_raw_coder_memusage

; 343  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
lzma_raw_encoder_memusage ENDP
PUBLIC	lzma_raw_encoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_raw_encoder_init DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$lzma_raw_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_raw_encoder_init DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_raw_encoder_init
_TEXT	SEGMENT
next$ = 64
allocator$ = 72
options$ = 80
lzma_raw_encoder_init PROC				; COMDAT

; 318  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 319  : 	return lzma_raw_coder_init(next, allocator,
; 320  : 			options, (lzma_filter_find)(&encoder_find), true);

  00013	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00018	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:encoder_find
  0001f	4c 8b 44 24 50	 mov	 r8, QWORD PTR options$[rsp]
  00024	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next$[rsp]
  0002e	e8 00 00 00 00	 call	 lzma_raw_coder_init

; 321  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
lzma_raw_encoder_init ENDP
PUBLIC	lzma_raw_encoder
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_raw_encoder DD imagerel $LN11
	DD	imagerel $LN11+166
	DD	imagerel $unwind$lzma_raw_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_raw_encoder DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_raw_encoder
_TEXT	SEGMENT
ret_$33087 = 48
ret_$33089 = 52
strm$ = 80
options$ = 88
lzma_raw_encoder PROC					; COMDAT

; 326  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN8@lzma_raw_e:
$LN5@lzma_raw_e:

; 327  : 	lzma_next_strm_init(lzma_raw_coder_init, strm, options,
; 328  : 			(lzma_filter_find)(&encoder_find), true);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_strm_init
  00018	89 44 24 30	 mov	 DWORD PTR ret_$33087[rsp], eax
  0001c	83 7c 24 30 00	 cmp	 DWORD PTR ret_$33087[rsp], 0
  00021	74 06		 je	 SHORT $LN2@lzma_raw_e
  00023	8b 44 24 30	 mov	 eax, DWORD PTR ret_$33087[rsp]
  00027	eb 78		 jmp	 SHORT $LN9@lzma_raw_e
$LN2@lzma_raw_e:
  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 df		 jne	 SHORT $LN5@lzma_raw_e
  0002f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00034	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:encoder_find
  0003b	4c 8b 44 24 58	 mov	 r8, QWORD PTR options$[rsp]
  00040	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  00045	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0004e	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00052	e8 00 00 00 00	 call	 lzma_raw_coder_init
  00057	89 44 24 34	 mov	 DWORD PTR ret_$33089[rsp], eax
  0005b	83 7c 24 34 00	 cmp	 DWORD PTR ret_$33089[rsp], 0
  00060	74 10		 je	 SHORT $LN1@lzma_raw_e
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00067	e8 00 00 00 00	 call	 lzma_end
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR ret_$33089[rsp]
  00070	eb 2f		 jmp	 SHORT $LN9@lzma_raw_e
$LN1@lzma_raw_e:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 96		 jne	 SHORT $LN8@lzma_raw_e

; 329  : 
; 330  : 	strm->internal->supported_actions[LZMA_RUN] = true;

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00081	c6 40 58 01	 mov	 BYTE PTR [rax+88], 1

; 331  : 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;

  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0008a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008e	c6 40 59 01	 mov	 BYTE PTR [rax+89], 1

; 332  : 	strm->internal->supported_actions[LZMA_FINISH] = true;

  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00097	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009b	c6 40 5b 01	 mov	 BYTE PTR [rax+91], 1

; 333  : 
; 334  : 	return LZMA_OK;

  0009f	33 c0		 xor	 eax, eax
$LN9@lzma_raw_e:

; 335  : }

  000a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a5	c3		 ret	 0
lzma_raw_encoder ENDP
END
