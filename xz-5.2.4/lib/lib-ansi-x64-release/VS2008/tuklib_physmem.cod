; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@	; `string'
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GlobalMemoryStatus:PROC
EXTRN	__imp_GetModuleHandleA:PROC
;	COMDAT ??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@
CONST	SEGMENT
??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@ DB 'GlobalMemoryStatusEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@ DB 'kernel32.dll', 00H ; `string'
PUBLIC	lzmatuklib_physmem
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_physmem.c
pdata	SEGMENT
$pdata$lzmatuklib_physmem DD imagerel $LN8
	DD	imagerel $LN8+188
	DD	imagerel $unwind$lzmatuklib_physmem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzmatuklib_physmem DD 020701H
	DD	0190107H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzmatuklib_physmem
_TEXT	SEGMENT
ret$ = 32
kernel32$73529 = 40
gmse$73535 = 48
meminfo$73540 = 64
meminfo$73543 = 128
lzmatuklib_physmem PROC					; COMDAT

; 78   : {

$LN8:
  00000	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 79   : 	uint64_t ret = 0;

  00007	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ret$[rsp], 0

; 80   : 
; 81   : #if defined(_WIN32) || defined(__CYGWIN__)
; 82   :   #if 0  /*Mist: from Windows 8.1 onwards GetVersion() and GetVersionEx() have been deprecated!*/
; 83   :   if ((GetVersion () & 0xFF) >= 5) {
; 84   :   #else
; 85   :   extern LONG GetWindowsVer (void);
; 86   : 
; 87   :   #if !defined(MAJOR_VERSION)
; 88   :   #define MAJOR_VERSION(packvers)     HIWORD(packvers)
; 89   :   #endif
; 90   :   #if !defined(MINOR_VERSION)
; 91   :   #define MINOR_VERSION(packvers)     LOWORD(packvers)
; 92   :   #endif
; 93   : 
; 94   :   if (MAJOR_VERSION (GetWindowsVer ()) >= 5) {

  00010	e8 00 00 00 00	 call	 GetWindowsVer
  00015	48 98		 cdqe
  00017	48 c1 e8 10	 shr	 rax, 16
  0001b	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00021	0f b7 c0	 movzx	 eax, ax
  00024	83 f8 05	 cmp	 eax, 5
  00027	7c 58		 jl	 SHORT $LN5@lzmatuklib

; 95   :   #endif
; 96   : 		// Windows 2000 and later have GlobalMemoryStatusEx() which
; 97   : 		// supports reporting values greater than 4 GiB. To keep the
; 98   : 		// code working also on older Windows versions, use
; 99   : 		// GlobalMemoryStatusEx() conditionally.
; 100  : 		HMODULE kernel32 = GetModuleHandle("kernel32.dll");

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00036	48 89 44 24 28	 mov	 QWORD PTR kernel32$73529[rsp], rax

; 101  : 		if (kernel32 != NULL) {

  0003b	48 83 7c 24 28
	00		 cmp	 QWORD PTR kernel32$73529[rsp], 0
  00041	74 3e		 je	 SHORT $LN4@lzmatuklib

; 102  : 			typedef BOOL (WINAPI *gmse_type)(LPMEMORYSTATUSEX);
; 103  : 			gmse_type gmse = (gmse_type)GetProcAddress(
; 104  : 					kernel32, "GlobalMemoryStatusEx");

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@PJNLIDED@GlobalMemoryStatusEx?$AA@
  0004a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR kernel32$73529[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00055	48 89 44 24 30	 mov	 QWORD PTR gmse$73535[rsp], rax

; 105  : 			if (gmse != NULL) {

  0005a	48 83 7c 24 30
	00		 cmp	 QWORD PTR gmse$73535[rsp], 0
  00060	74 1f		 je	 SHORT $LN3@lzmatuklib

; 106  : 				MEMORYSTATUSEX meminfo;
; 107  : 				meminfo.dwLength = sizeof(meminfo);

  00062	c7 44 24 40 40
	00 00 00	 mov	 DWORD PTR meminfo$73540[rsp], 64 ; 00000040H

; 108  : 				if (gmse(&meminfo))

  0006a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR meminfo$73540[rsp]
  0006f	ff 54 24 30	 call	 QWORD PTR gmse$73535[rsp]
  00073	85 c0		 test	 eax, eax
  00075	74 0a		 je	 SHORT $LN2@lzmatuklib

; 109  : 					ret = meminfo.ullTotalPhys;

  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR meminfo$73540[rsp+8]
  0007c	48 89 44 24 20	 mov	 QWORD PTR ret$[rsp], rax
$LN2@lzmatuklib:
$LN3@lzmatuklib:
$LN4@lzmatuklib:
$LN5@lzmatuklib:

; 110  : 			}
; 111  : 		}
; 112  : 	}
; 113  : 
; 114  : 	if (ret == 0) {

  00081	48 83 7c 24 20
	00		 cmp	 QWORD PTR ret$[rsp], 0
  00087	75 26		 jne	 SHORT $LN1@lzmatuklib

; 115  : 		// GlobalMemoryStatus() is supported by Windows 95 and later,
; 116  : 		// so it is fine to link against it unconditionally. Note that
; 117  : 		// GlobalMemoryStatus() has no return value.
; 118  : 		MEMORYSTATUS meminfo;
; 119  : 		meminfo.dwLength = sizeof(meminfo);

  00089	c7 84 24 80 00
	00 00 38 00 00
	00		 mov	 DWORD PTR meminfo$73543[rsp], 56 ; 00000038H

; 120  : 		GlobalMemoryStatus(&meminfo);

  00094	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR meminfo$73543[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GlobalMemoryStatus

; 121  : 		ret = meminfo.dwTotalPhys;

  000a2	4c 8b 9c 24 88
	00 00 00	 mov	 r11, QWORD PTR meminfo$73543[rsp+8]
  000aa	4c 89 5c 24 20	 mov	 QWORD PTR ret$[rsp], r11
$LN1@lzmatuklib:

; 122  : 	}
; 123  : 
; 124  : #elif defined(__OS2__)
; 125  : 	unsigned long mem;
; 126  : 	if (DosQuerySysInfo(QSV_TOTPHYSMEM, QSV_TOTPHYSMEM,
; 127  : 			&mem, sizeof(mem)) == 0)
; 128  : 		ret = mem;
; 129  : 
; 130  : #elif defined(__DJGPP__)
; 131  : 	__dpmi_free_mem_info meminfo;
; 132  : 	if (__dpmi_get_free_memory_information(&meminfo) == 0
; 133  : 			&& meminfo.total_number_of_physical_pages
; 134  : 				!= (unsigned long)-1)
; 135  : 		ret = (uint64_t)meminfo.total_number_of_physical_pages * 4096;
; 136  : 
; 137  : #elif defined(__VMS)
; 138  : 	int vms_mem;
; 139  : 	int val = SYI$_MEMSIZE;
; 140  : 	if (LIB$GETSYI(&val, &vms_mem, 0, 0, 0, 0) == SS$_NORMAL)
; 141  : 		ret = (uint64_t)vms_mem * 8192;
; 142  : 
; 143  : #elif defined(AMIGA) || defined(__AROS__)
; 144  : 	ret = AvailMem(MEMF_TOTAL);
; 145  : 
; 146  : #elif defined(__QNX__)
; 147  : 	const struct asinfo_entry *entries = SYSPAGE_ENTRY(asinfo);
; 148  : 	size_t count = SYSPAGE_ENTRY_SIZE(asinfo) / sizeof(struct asinfo_entry);
; 149  : 	const char *strings = SYSPAGE_ENTRY(strings)->data;
; 150  : 
; 151  : 	for (size_t i = 0; i < count; ++i)
; 152  : 		if (strcmp(strings + entries[i].name, "ram") == 0)
; 153  : 			ret += entries[i].end - entries[i].start + 1;
; 154  : 
; 155  : #elif defined(TUKLIB_PHYSMEM_AIX)
; 156  : 	ret = _system_configuration.physmem;
; 157  : 
; 158  : #elif defined(TUKLIB_PHYSMEM_SYSCONF)
; 159  : 	const long pagesize = sysconf(_SC_PAGESIZE);
; 160  : 	const long pages = sysconf(_SC_PHYS_PAGES);
; 161  : 	if (pagesize != -1 && pages != -1)
; 162  : 		// According to docs, pagesize * pages can overflow.
; 163  : 		// Simple case is 32-bit box with 4 GiB or more RAM,
; 164  : 		// which may report exactly 4 GiB of RAM, and "long"
; 165  : 		// being 32-bit will overflow. Casting to uint64_t
; 166  : 		// hopefully avoids overflows in the near future.
; 167  : 		ret = (uint64_t)pagesize * (uint64_t)pages;
; 168  : 
; 169  : #elif defined(TUKLIB_PHYSMEM_SYSCTL)
; 170  : 	int name[2] = {
; 171  : 		CTL_HW,
; 172  : #ifdef HW_PHYSMEM64
; 173  : 		HW_PHYSMEM64
; 174  : #else
; 175  : 		HW_PHYSMEM
; 176  : #endif
; 177  : 	};
; 178  : 	union {
; 179  : 		uint32_t u32;
; 180  : 		uint64_t u64;
; 181  : 	} mem;
; 182  : 	size_t mem_ptr_size = sizeof(mem.u64);
; 183  : 	if (sysctl(name, 2, &mem.u64, &mem_ptr_size, NULL, 0) != -1) {
; 184  : 		// IIRC, 64-bit "return value" is possible on some 64-bit
; 185  : 		// BSD systems even with HW_PHYSMEM (instead of HW_PHYSMEM64),
; 186  : 		// so support both.
; 187  : 		if (mem_ptr_size == sizeof(mem.u64))
; 188  : 			ret = mem.u64;
; 189  : 		else if (mem_ptr_size == sizeof(mem.u32))
; 190  : 			ret = mem.u32;
; 191  : 	}
; 192  : 
; 193  : #elif defined(TUKLIB_PHYSMEM_GETSYSINFO)
; 194  : 	// Docs are unclear if "start" is needed, but it doesn't hurt
; 195  : 	// much to have it.
; 196  : 	int memkb;
; 197  : 	int start = 0;
; 198  : 	if (getsysinfo(GSI_PHYSMEM, (caddr_t)&memkb, sizeof(memkb), &start)
; 199  : 			!= -1)
; 200  : 		ret = (uint64_t)memkb * 1024;
; 201  : 
; 202  : #elif defined(TUKLIB_PHYSMEM_PSTAT_GETSTATIC)
; 203  : 	struct pst_static pst;
; 204  : 	if (pstat_getstatic(&pst, sizeof(pst), 1, 0) != -1)
; 205  : 		ret = (uint64_t)pst.physical_memory * (uint64_t)pst.page_size;
; 206  : 
; 207  : #elif defined(TUKLIB_PHYSMEM_GETINVENT_R)
; 208  : 	inv_state_t *st = NULL;
; 209  : 	if (setinvent_r(&st) != -1) {
; 210  : 		inventory_t *i;
; 211  : 		while ((i = getinvent_r(st)) != NULL) {
; 212  : 			if (i->inv_class == INV_MEMORY
; 213  : 					&& i->inv_type == INV_MAIN_MB) {
; 214  : 				ret = (uint64_t)i->inv_state << 20;
; 215  : 				break;
; 216  : 			}
; 217  : 		}
; 218  : 
; 219  : 		endinvent_r(st);
; 220  : 	}
; 221  : 
; 222  : #elif defined(TUKLIB_PHYSMEM_SYSINFO)
; 223  : 	struct sysinfo si;
; 224  : 	if (sysinfo(&si) == 0)
; 225  : 		ret = (uint64_t)si.totalram * si.mem_unit;
; 226  : #endif
; 227  : 
; 228  : 	return ret;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR ret$[rsp]

; 229  : }

  000b4	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  000bb	c3		 ret	 0
lzmatuklib_physmem ENDP
END
