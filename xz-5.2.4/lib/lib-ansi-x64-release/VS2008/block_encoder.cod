; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_encoder.c
pdata	SEGMENT
$pdata$block_encoder_update DD imagerel block_encoder_update
	DD	imagerel block_encoder_update+77
	DD	imagerel $unwind$block_encoder_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encoder_update DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encoder_update
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
filters$ = 80
reversed_filters$ = 88
block_encoder_update PROC				; COMDAT

; 152  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  : 	lzma_block_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 154  : 
; 155  : 	if (coder->sequence != SEQ_CODE)

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00027	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0002b	74 07		 je	 SHORT $LN1@block_enco

; 156  : 		return LZMA_PROG_ERROR;

  0002d	b8 0b 00 00 00	 mov	 eax, 11
  00032	eb 14		 jmp	 SHORT $LN2@block_enco
$LN1@block_enco:

; 157  : 
; 158  : 	return lzma_next_filter_update(
; 159  : 			&coder->next, allocator, reversed_filters);

  00034	4c 8b 44 24 58	 mov	 r8, QWORD PTR reversed_filters$[rsp]
  00039	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00043	e8 00 00 00 00	 call	 lzma_next_filter_update
$LN2@block_enco:

; 160  : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
block_encoder_update ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_encoder_end DD imagerel block_encoder_end
	DD	imagerel block_encoder_end+59
	DD	imagerel $unwind$block_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
block_encoder_end PROC					; COMDAT

; 140  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 141  : 	lzma_block_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 142  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 143  : 	lzma_free(coder, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_free

; 144  : 	return;
; 145  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
block_encoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_encode DD imagerel block_encode
	DD	imagerel block_encode+905
	DD	imagerel $unwind$block_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_encode DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_encode
_TEXT	SEGMENT
coder$ = 80
in_used$32918 = 88
out_start$32916 = 96
out_used$32919 = 104
ret$32917 = 112
in_start$32915 = 120
check_size$32932 = 128
tv69 = 136
coder_ptr$ = 160
allocator$ = 168
in$ = 176
in_pos$ = 184
in_size$ = 192
out$ = 200
out_pos$ = 208
out_size$ = 216
action$ = 224
block_encode PROC					; COMDAT

; 52   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 53   : 	lzma_block_coder *coder = coder_ptr;

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 54   : 
; 55   : 	// Check that our amount of input stays in proper limits.
; 56   : 	if (LZMA_VLI_MAX - coder->uncompressed_size < in_size - *in_pos)

  00028	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00037	48 2b 50 60	 sub	 rdx, QWORD PTR [rax+96]
  0003b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00043	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00046	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0004e	48 2b c1	 sub	 rax, rcx
  00051	48 3b d0	 cmp	 rdx, rax
  00054	73 0a		 jae	 SHORT $LN14@block_enco@4

; 57   : 		return LZMA_DATA_ERROR;

  00056	b8 09 00 00 00	 mov	 eax, 9
  0005b	e9 21 03 00 00	 jmp	 $LN15@block_enco@4
$LN14@block_enco@4:

; 58   : 
; 59   : 	switch (coder->sequence) {

  00060	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00065	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00068	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv69[rsp], eax
  0006f	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv69[rsp], 0
  00077	74 21		 je	 SHORT $LN11@block_enco@4
  00079	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR tv69[rsp], 1
  00081	0f 84 a1 01 00
	00		 je	 $LN7@block_enco@4
  00087	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR tv69[rsp], 2
  0008f	0f 84 4a 02 00
	00		 je	 $LN2@block_enco@4
  00095	e9 e2 02 00 00	 jmp	 $LN12@block_enco@4
$LN11@block_enco@4:

; 60   : 	case SEQ_CODE: {
; 61   : 		const size_t in_start = *in_pos;

  0009a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 44 24 78	 mov	 QWORD PTR in_start$32915[rsp], rax

; 62   : 		const size_t out_start = *out_pos;

  000aa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b5	48 89 44 24 60	 mov	 QWORD PTR out_start$32916[rsp], rax

; 63   : 
; 64   : 		const lzma_ret ret = coder->next.code(coder->next.coder,
; 65   : 				allocator, in, in_pos, in_size,
; 66   : 				out, out_pos, out_size, action);

  000ba	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  000c1	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000c5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000cd	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000da	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ec	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f9	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  00101	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  00109	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00116	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00119	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0011e	ff 50 18	 call	 QWORD PTR [rax+24]
  00121	89 44 24 70	 mov	 DWORD PTR ret$32917[rsp], eax

; 67   : 
; 68   : 		const size_t in_used = *in_pos - in_start;

  00125	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in_start$32915[rsp]
  00132	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00135	48 2b c1	 sub	 rax, rcx
  00138	48 89 44 24 58	 mov	 QWORD PTR in_used$32918[rsp], rax

; 69   : 		const size_t out_used = *out_pos - out_start;

  0013d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR out_start$32916[rsp]
  0014a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014d	48 2b c1	 sub	 rax, rcx
  00150	48 89 44 24 68	 mov	 QWORD PTR out_used$32919[rsp], rax

; 70   : 
; 71   : 		if (COMPRESSED_SIZE_MAX - coder->compressed_size < out_used)

  00155	48 b8 bc fb ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854774716 ; 7ffffffffffffbbcH
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00164	48 2b 41 58	 sub	 rax, QWORD PTR [rcx+88]
  00168	48 3b 44 24 68	 cmp	 rax, QWORD PTR out_used$32919[rsp]
  0016d	73 0a		 jae	 SHORT $LN10@block_enco@4

; 72   : 			return LZMA_DATA_ERROR;

  0016f	b8 09 00 00 00	 mov	 eax, 9
  00174	e9 08 02 00 00	 jmp	 $LN15@block_enco@4
$LN10@block_enco@4:

; 73   : 
; 74   : 		coder->compressed_size += out_used;

  00179	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0017e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00182	48 03 4c 24 68	 add	 rcx, QWORD PTR out_used$32919[rsp]
  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0018c	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 75   : 
; 76   : 		// No need to check for overflow because we have already
; 77   : 		// checked it at the beginning of this function.
; 78   : 		coder->uncompressed_size += in_used;

  00190	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00195	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00199	48 03 4c 24 58	 add	 rcx, QWORD PTR in_used$32918[rsp]
  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001a3	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 79   : 
; 80   : 		lzma_check_update(&coder->check, coder->block->check,
; 81   : 				in + in_start, in_used);

  001a7	48 8b 44 24 78	 mov	 rax, QWORD PTR in_start$32915[rsp]
  001ac	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  001b4	4c 03 c0	 add	 r8, rax
  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001bc	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  001c5	48 83 c1 70	 add	 rcx, 112		; 00000070H
  001c9	4c 8b 4c 24 58	 mov	 r9, QWORD PTR in_used$32918[rsp]
  001ce	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  001d1	e8 00 00 00 00	 call	 lzma_check_update

; 82   : 
; 83   : 		if (ret != LZMA_STREAM_END || action == LZMA_SYNC_FLUSH)

  001d6	83 7c 24 70 01	 cmp	 DWORD PTR ret$32917[rsp], 1
  001db	75 0a		 jne	 SHORT $LN8@block_enco@4
  001dd	83 bc 24 e0 00
	00 00 01	 cmp	 DWORD PTR action$[rsp], 1
  001e5	75 09		 jne	 SHORT $LN9@block_enco@4
$LN8@block_enco@4:

; 84   : 			return ret;

  001e7	8b 44 24 70	 mov	 eax, DWORD PTR ret$32917[rsp]
  001eb	e9 91 01 00 00	 jmp	 $LN15@block_enco@4
$LN9@block_enco@4:

; 85   : 
; 86   : 		assert(*in_pos == in_size);
; 87   : 		assert(action == LZMA_FINISH);
; 88   : 
; 89   : 		// Copy the values into coder->block. The caller
; 90   : 		// may use this information to construct Index.
; 91   : 		coder->block->compressed_size = coder->compressed_size;

  001f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  001f5	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001f9	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00202	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 92   : 		coder->block->uncompressed_size = coder->uncompressed_size;

  00206	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0020b	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00214	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00218	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 93   : 
; 94   : 		coder->sequence = SEQ_PADDING;

  0021c	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00221	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1
$LN7@block_enco@4:
$LN6@block_enco@4:

; 95   : 	}
; 96   : 
; 97   : 	// Fall through
; 98   : 
; 99   : 	case SEQ_PADDING:
; 100  : 		// Pad Compressed Data to a multiple of four bytes. We can
; 101  : 		// use coder->compressed_size for this since we don't need
; 102  : 		// it for anything else anymore.
; 103  : 		while (coder->compressed_size & 3) {

  00228	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0022d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00231	48 83 e0 03	 and	 rax, 3
  00235	48 85 c0	 test	 rax, rax
  00238	74 65		 je	 SHORT $LN5@block_enco@4

; 104  : 			if (*out_pos >= out_size)

  0023a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00242	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0024a	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0024d	72 07		 jb	 SHORT $LN4@block_enco@4

; 105  : 				return LZMA_OK;

  0024f	33 c0		 xor	 eax, eax
  00251	e9 2b 01 00 00	 jmp	 $LN15@block_enco@4
$LN4@block_enco@4:

; 106  : 
; 107  : 			out[*out_pos] = 0x00;

  00256	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0025e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00261	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00269	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 108  : 			++*out_pos;

  0026d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00275	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00278	48 83 c1 01	 add	 rcx, 1
  0027c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00284	48 89 08	 mov	 QWORD PTR [rax], rcx

; 109  : 			++coder->compressed_size;

  00287	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0028c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00290	48 83 c1 01	 add	 rcx, 1
  00294	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00299	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 110  : 		}

  0029d	eb 89		 jmp	 SHORT $LN6@block_enco@4
$LN5@block_enco@4:

; 111  : 
; 112  : 		if (coder->block->check == LZMA_CHECK_NONE)

  0029f	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002a4	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  002a8	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002ac	75 0a		 jne	 SHORT $LN3@block_enco@4

; 113  : 			return LZMA_STREAM_END;

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	e9 c9 00 00 00	 jmp	 $LN15@block_enco@4
$LN3@block_enco@4:

; 114  : 
; 115  : 		lzma_check_finish(&coder->check, coder->block->check);

  002b8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002bd	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  002c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002c6	48 83 c1 70	 add	 rcx, 112		; 00000070H
  002ca	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  002cd	e8 00 00 00 00	 call	 lzma_check_finish

; 116  : 
; 117  : 		coder->sequence = SEQ_CHECK;

  002d2	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  002d7	41 c7 43 50 02
	00 00 00	 mov	 DWORD PTR [r11+80], 2
$LN2@block_enco@4:

; 118  : 
; 119  : 	// Fall through
; 120  : 
; 121  : 	case SEQ_CHECK: {
; 122  : 		const size_t check_size = lzma_check_size(coder->block->check);

  002df	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002e4	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  002e8	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  002eb	e8 00 00 00 00	 call	 lzma_check_size
  002f0	8b c0		 mov	 eax, eax
  002f2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR check_size$32932[rsp], rax

; 123  : 		lzma_bufcpy(coder->check.buffer.u8, &coder->pos, check_size,
; 124  : 				out, out_pos, out_size);

  002fa	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  002ff	48 83 c2 68	 add	 rdx, 104		; 00000068H
  00303	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00308	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0030c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00314	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00319	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00321	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00326	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  0032e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR check_size$32932[rsp]
  00336	e8 00 00 00 00	 call	 lzma_bufcpy

; 125  : 		if (coder->pos < check_size)

  0033b	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  00340	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR check_size$32932[rsp]
  00348	49 39 43 68	 cmp	 QWORD PTR [r11+104], rax
  0034c	73 04		 jae	 SHORT $LN1@block_enco@4

; 126  : 			return LZMA_OK;

  0034e	33 c0		 xor	 eax, eax
  00350	eb 2f		 jmp	 SHORT $LN15@block_enco@4
$LN1@block_enco@4:

; 127  : 
; 128  : 		memcpy(coder->block->raw_check, coder->check.buffer.u8,
; 129  : 				check_size);

  00352	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00357	48 83 c2 70	 add	 rdx, 112		; 00000070H
  0035b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00360	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00364	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00368	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR check_size$32932[rsp]
  00370	e8 00 00 00 00	 call	 memcpy

; 130  : 		return LZMA_STREAM_END;

  00375	b8 01 00 00 00	 mov	 eax, 1
  0037a	eb 05		 jmp	 SHORT $LN15@block_enco@4
$LN12@block_enco@4:

; 131  : 	}
; 132  : 	}
; 133  : 
; 134  : 	return LZMA_PROG_ERROR;

  0037c	b8 0b 00 00 00	 mov	 eax, 11
$LN15@block_enco@4:

; 135  : }

  00381	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00388	c3		 ret	 0
block_encode ENDP
PUBLIC	lzma_block_encoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_encoder_init DD imagerel $LN13
	DD	imagerel $LN13+422
	DD	imagerel $unwind$lzma_block_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_encoder_init DD 031501H
	DD	070116215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_encoder_init
_TEXT	SEGMENT
coder$32972 = 32
next$ = 80
allocator$ = 88
block$ = 96
lzma_block_encoder_init PROC				; COMDAT

; 166  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN10@lzma_block@8:

; 167  : 	lzma_next_coder_init(&lzma_block_encoder_init, next, allocator);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_block_encoder_init
  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00021	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00025	74 0f		 je	 SHORT $LN7@lzma_block@8
  00027	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_next_end
$LN7@lzma_block@8:
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_block_encoder_init
  00042	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 c9		 jne	 SHORT $LN10@lzma_block@8

; 168  : 
; 169  : 	if (block == NULL)

  0004c	48 83 7c 24 60
	00		 cmp	 QWORD PTR block$[rsp], 0
  00052	75 0a		 jne	 SHORT $LN6@lzma_block@8

; 170  : 		return LZMA_PROG_ERROR;

  00054	b8 0b 00 00 00	 mov	 eax, 11
  00059	e9 41 01 00 00	 jmp	 $LN11@lzma_block@8
$LN6@lzma_block@8:

; 171  : 
; 172  : 	// The contents of the structure may depend on the version so
; 173  : 	// check the version first.
; 174  : 	if (block->version > 1)

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR block$[rsp]
  00063	83 38 01	 cmp	 DWORD PTR [rax], 1
  00066	76 0a		 jbe	 SHORT $LN5@lzma_block@8

; 175  : 		return LZMA_OPTIONS_ERROR;

  00068	b8 08 00 00 00	 mov	 eax, 8
  0006d	e9 2d 01 00 00	 jmp	 $LN11@lzma_block@8
$LN5@lzma_block@8:

; 176  : 
; 177  : 	// If the Check ID is not supported, we cannot calculate the check and
; 178  : 	// thus not create a proper Block.
; 179  : 	if ((unsigned int)(block->check) > LZMA_CHECK_ID_MAX)

  00072	48 8b 44 24 60	 mov	 rax, QWORD PTR block$[rsp]
  00077	83 78 08 0f	 cmp	 DWORD PTR [rax+8], 15
  0007b	76 0a		 jbe	 SHORT $LN4@lzma_block@8

; 180  : 		return LZMA_PROG_ERROR;

  0007d	b8 0b 00 00 00	 mov	 eax, 11
  00082	e9 18 01 00 00	 jmp	 $LN11@lzma_block@8
$LN4@lzma_block@8:

; 181  : 
; 182  : 	if (!lzma_check_is_supported(block->check))

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR block$[rsp]
  0008c	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0008f	e8 00 00 00 00	 call	 lzma_check_is_supported
  00094	0f b6 c0	 movzx	 eax, al
  00097	85 c0		 test	 eax, eax
  00099	75 0a		 jne	 SHORT $LN3@lzma_block@8

; 183  : 		return LZMA_UNSUPPORTED_CHECK;

  0009b	b8 03 00 00 00	 mov	 eax, 3
  000a0	e9 fa 00 00 00	 jmp	 $LN11@lzma_block@8
$LN3@lzma_block@8:

; 184  : 
; 185  : 	// Allocate and initialize *next->coder if needed.
; 186  :   {
; 187  : 	lzma_block_coder *coder = next->coder;

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  000aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ad	48 89 44 24 20	 mov	 QWORD PTR coder$32972[rsp], rax

; 188  : 	if (coder == NULL) {

  000b2	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32972[rsp], 0
  000b8	75 76		 jne	 SHORT $LN2@lzma_block@8

; 189  : 		coder = lzma_alloc(sizeof(lzma_block_coder), allocator);

  000ba	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  000bf	b9 d8 00 00 00	 mov	 ecx, 216		; 000000d8H
  000c4	e8 00 00 00 00	 call	 lzma_alloc
  000c9	48 89 44 24 20	 mov	 QWORD PTR coder$32972[rsp], rax

; 190  : 		if (coder == NULL)

  000ce	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32972[rsp], 0
  000d4	75 0a		 jne	 SHORT $LN1@lzma_block@8

; 191  : 			return LZMA_MEM_ERROR;

  000d6	b8 05 00 00 00	 mov	 eax, 5
  000db	e9 bf 00 00 00	 jmp	 $LN11@lzma_block@8
$LN1@lzma_block@8:

; 192  : 
; 193  : 		next->coder = coder;

  000e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32972[rsp]
  000ea	48 89 01	 mov	 QWORD PTR [rcx], rax

; 194  : 		next->code = &block_encode;

  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:block_encode
  000f9	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 195  : 		next->end = &block_encoder_end;

  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00102	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:block_encoder_end
  00109	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 196  : 		next->update = &block_encoder_update;

  0010d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:block_encoder_update
  00119	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 197  : 		coder->next = LZMA_NEXT_CODER_INIT;

  0011d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  00124	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32972[rsp]
  00129	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0012e	f3 a4		 rep movsb
$LN2@lzma_block@8:

; 198  : 	}
; 199  : 
; 200  : 	// Basic initializations
; 201  : 	coder->sequence = SEQ_CODE;

  00130	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32972[rsp]
  00135	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 202  : 	coder->block = block;

  0013c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32972[rsp]
  00141	48 8b 44 24 60	 mov	 rax, QWORD PTR block$[rsp]
  00146	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 203  : 	coder->compressed_size = 0;

  0014a	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32972[rsp]
  0014f	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 204  : 	coder->uncompressed_size = 0;

  00157	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32972[rsp]
  0015c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 205  : 	coder->pos = 0;

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32972[rsp]
  00169	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 206  : 
; 207  : 	// Initialize the check
; 208  : 	lzma_check_init(&coder->check, block->check);

  00171	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32972[rsp]
  00176	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0017a	48 8b 44 24 60	 mov	 rax, QWORD PTR block$[rsp]
  0017f	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00182	e8 00 00 00 00	 call	 lzma_check_init

; 209  : 
; 210  : 	// Initialize the requested filters.
; 211  : 	return lzma_raw_encoder_init(&coder->next, allocator, block->filters);

  00187	4c 8b 44 24 60	 mov	 r8, QWORD PTR block$[rsp]
  0018c	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00190	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00195	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32972[rsp]
  0019a	e8 00 00 00 00	 call	 lzma_raw_encoder_init
$LN11@lzma_block@8:

; 212  :   }
; 213  : }

  0019f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a3	5f		 pop	 rdi
  001a4	5e		 pop	 rsi
  001a5	c3		 ret	 0
lzma_block_encoder_init ENDP
END
