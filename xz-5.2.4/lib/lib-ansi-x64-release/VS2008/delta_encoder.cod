; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_delta_props_encode
PUBLIC	lzma_delta_encoder_init
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\delta\delta_encoder.c
pdata	SEGMENT
$pdata$encode_in_place DD imagerel encode_in_place
	DD	imagerel encode_in_place+217
	DD	imagerel $unwind$encode_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_in_place DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT encode_in_place
_TEXT	SEGMENT
i$ = 0
distance$ = 8
tmp$32865 = 16
coder$ = 48
buffer$ = 56
size$ = 64
encode_in_place PROC					; COMDAT

; 40   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 41   : 	const size_t distance = coder->distance;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00018	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0001c	48 89 44 24 08	 mov	 QWORD PTR distance$[rsp], rax

; 42   : 	size_t i;
; 43   : 
; 44   : 	for (i = 0; i < size; ++i) {

  00021	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00029	eb 0c		 jmp	 SHORT $LN3@encode_in_
$LN2@encode_in_:
  0002b	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  0002f	48 83 c0 01	 add	 rax, 1
  00033	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@encode_in_:
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR size$[rsp]
  0003c	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00040	0f 83 8e 00 00
	00		 jae	 $LN1@encode_in_

; 45   : 		const uint8_t tmp = coder->history[
; 46   : 				(distance + coder->pos) & 0xFF];

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0004b	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  0004f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR distance$[rsp]
  00054	48 03 c8	 add	 rcx, rax
  00057	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00063	0f b6 44 08 51	 movzx	 eax, BYTE PTR [rax+rcx+81]
  00068	88 44 24 10	 mov	 BYTE PTR tmp$32865[rsp], al

; 47   : 		coder->history[coder->pos-- & 0xFF] = buffer[i];

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00071	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  00075	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007a	48 63 d0	 movsxd	 rdx, eax
  0007d	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00081	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  00086	48 03 c1	 add	 rax, rcx
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  0008e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00091	88 44 11 51	 mov	 BYTE PTR [rcx+rdx+81], al
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0009a	0f b6 48 50	 movzx	 ecx, BYTE PTR [rax+80]
  0009e	80 e9 01	 sub	 cl, 1
  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000a6	88 48 50	 mov	 BYTE PTR [rax+80], cl

; 48   : 		buffer[i] -= tmp;

  000a9	44 0f b6 44 24
	10		 movzx	 r8d, BYTE PTR tmp$32865[rsp]
  000af	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000b3	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000b8	48 03 c1	 add	 rax, rcx
  000bb	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000be	41 2b d0	 sub	 edx, r8d
  000c1	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000c5	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  000ca	48 03 c1	 add	 rax, rcx
  000cd	88 10		 mov	 BYTE PTR [rax], dl

; 49   : 	}

  000cf	e9 57 ff ff ff	 jmp	 $LN2@encode_in_
$LN1@encode_in_:

; 50   : }

  000d4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d8	c3		 ret	 0
encode_in_place ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_and_encode DD imagerel copy_and_encode
	DD	imagerel copy_and_encode+220
	DD	imagerel $unwind$copy_and_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_and_encode DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT copy_and_encode
_TEXT	SEGMENT
i$ = 0
distance$ = 8
tmp$32851 = 16
coder$ = 48
in$ = 56
out$ = 64
size$ = 72
copy_and_encode PROC					; COMDAT

; 23   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 24   : 	const size_t distance = coder->distance;

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0001d	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00021	48 89 44 24 08	 mov	 QWORD PTR distance$[rsp], rax

; 25   : 	size_t i;
; 26   : 
; 27   : 	for (i = 0; i < size; ++i) {

  00026	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0002e	eb 0c		 jmp	 SHORT $LN3@copy_and_e
$LN2@copy_and_e:
  00030	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00034	48 83 c0 01	 add	 rax, 1
  00038	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@copy_and_e:
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  00041	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00045	0f 83 8c 00 00
	00		 jae	 $LN1@copy_and_e

; 28   : 		const uint8_t tmp = coder->history[
; 29   : 				(distance + coder->pos) & 0xFF];

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00050	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  00054	48 8b 4c 24 08	 mov	 rcx, QWORD PTR distance$[rsp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00068	0f b6 44 08 51	 movzx	 eax, BYTE PTR [rax+rcx+81]
  0006d	88 44 24 10	 mov	 BYTE PTR tmp$32851[rsp], al

; 30   : 		coder->history[coder->pos-- & 0xFF] = in[i];

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00076	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  0007a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007f	48 63 d0	 movsxd	 rdx, eax
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  0008b	48 03 c1	 add	 rax, rcx
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00096	88 44 11 51	 mov	 BYTE PTR [rcx+rdx+81], al
  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  0009f	0f b6 48 50	 movzx	 ecx, BYTE PTR [rax+80]
  000a3	80 e9 01	 sub	 cl, 1
  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  000ab	88 48 50	 mov	 BYTE PTR [rax+80], cl

; 31   : 		out[i] = in[i] - tmp;

  000ae	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000b2	48 8b 44 24 38	 mov	 rax, QWORD PTR in$[rsp]
  000b7	48 03 c1	 add	 rax, rcx
  000ba	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000bd	0f b6 44 24 10	 movzx	 eax, BYTE PTR tmp$32851[rsp]
  000c2	2b d0		 sub	 edx, eax
  000c4	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  000cd	48 03 c1	 add	 rax, rcx
  000d0	88 10		 mov	 BYTE PTR [rax], dl

; 32   : 	}

  000d2	e9 59 ff ff ff	 jmp	 $LN2@copy_and_e
$LN1@copy_and_e:

; 33   : }

  000d7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000db	c3		 ret	 0
copy_and_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_delta_props_encode DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$lzma_delta_props_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_delta_props_encode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_delta_props_encode
_TEXT	SEGMENT
opt$32919 = 32
options$ = 64
out$ = 72
lzma_delta_props_encode PROC				; COMDAT

; 117  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 118  : 	// The caller must have already validated the options, so it's
; 119  : 	// LZMA_PROG_ERROR if they are invalid.
; 120  : 	if (lzma_delta_coder_memusage(options) == UINT64_MAX)

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  00013	e8 00 00 00 00	 call	 lzma_delta_coder_memusage
  00018	48 83 f8 ff	 cmp	 rax, -1
  0001c	75 07		 jne	 SHORT $LN1@lzma_delta@2

; 121  : 		return LZMA_PROG_ERROR;

  0001e	b8 0b 00 00 00	 mov	 eax, 11
  00023	eb 1e		 jmp	 SHORT $LN2@lzma_delta@2
$LN1@lzma_delta@2:

; 122  : 
; 123  :   {
; 124  : 	const lzma_options_delta *opt = options;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  0002a	48 89 44 24 20	 mov	 QWORD PTR opt$32919[rsp], rax

; 125  : 	out[0] = opt->dist - LZMA_DELTA_DIST_MIN;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR opt$32919[rsp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00037	83 e9 01	 sub	 ecx, 1
  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
  0003f	88 08		 mov	 BYTE PTR [rax], cl

; 126  :   }
; 127  : 
; 128  : 	return LZMA_OK;

  00041	33 c0		 xor	 eax, eax
$LN2@lzma_delta@2:

; 129  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
lzma_delta_props_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_encoder_update DD imagerel delta_encoder_update
	DD	imagerel delta_encoder_update+63
	DD	imagerel $unwind$delta_encoder_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_encoder_update DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_encoder_update
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
filters_null$ = 80
reversed_filters$ = 88
delta_encoder_update PROC				; COMDAT

; 94   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 95   : 	lzma_delta_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 96   : 
; 97   : 	// Delta doesn't and will never support changing the options in
; 98   : 	// the middle of encoding. If the app tries to change them, we
; 99   : 	// simply ignore them.
; 100  : 	return lzma_next_filter_update(
; 101  : 			&coder->next, allocator, reversed_filters + 1);

  00022	4c 8b 44 24 58	 mov	 r8, QWORD PTR reversed_filters$[rsp]
  00027	49 83 c0 10	 add	 r8, 16
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_next_filter_update

; 102  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
delta_encoder_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_encode DD imagerel delta_encode
	DD	imagerel delta_encode+527
	DD	imagerel $unwind$delta_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_encode DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_encode
_TEXT	SEGMENT
ret$ = 80
coder$ = 88
out_avail$32891 = 96
in_avail$32890 = 104
size$32892 = 112
out_start$32894 = 120
tv69 = 128
tv80 = 136
coder_ptr$ = 160
allocator$ = 168
in$ = 176
in_pos$ = 184
in_size$ = 192
out$ = 200
out_pos$ = 208
out_size$ = 216
action$ = 224
delta_encode PROC					; COMDAT

; 58   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 59   : 	lzma_delta_coder *coder = coder_ptr;

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 58	 mov	 QWORD PTR coder$[rsp], rax

; 60   : 
; 61   : 	lzma_ret ret;
; 62   : 
; 63   : 	if (coder->next.code == NULL) {

  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00032	0f 85 23 01 00
	00		 jne	 $LN2@delta_enco

; 64   : 		const size_t in_avail = in_size - *in_pos;

  00038	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00040	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00043	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0004b	48 2b c1	 sub	 rax, rcx
  0004e	48 89 44 24 68	 mov	 QWORD PTR in_avail$32890[rsp], rax

; 65   : 		const size_t out_avail = out_size - *out_pos;

  00053	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0005b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00066	48 2b c1	 sub	 rax, rcx
  00069	48 89 44 24 60	 mov	 QWORD PTR out_avail$32891[rsp], rax

; 66   : 		const size_t size = my_min(in_avail, out_avail);

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR out_avail$32891[rsp]
  00073	48 39 44 24 68	 cmp	 QWORD PTR in_avail$32890[rsp], rax
  00078	73 0f		 jae	 SHORT $LN5@delta_enco
  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR in_avail$32890[rsp]
  0007f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  00087	eb 0d		 jmp	 SHORT $LN6@delta_enco
$LN5@delta_enco:
  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR out_avail$32891[rsp]
  0008e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN6@delta_enco:
  00096	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  0009e	48 89 44 24 70	 mov	 QWORD PTR size$32892[rsp], rax

; 67   : 
; 68   : 		copy_and_encode(coder, in + *in_pos, out + *out_pos, size);

  000a3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000ab	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ae	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR out$[rsp]
  000b6	4c 03 c0	 add	 r8, rax
  000b9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c4	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR in$[rsp]
  000cc	48 03 d0	 add	 rdx, rax
  000cf	4c 8b 4c 24 70	 mov	 r9, QWORD PTR size$32892[rsp]
  000d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR coder$[rsp]
  000d9	e8 00 00 00 00	 call	 copy_and_encode

; 69   : 
; 70   : 		*in_pos += size;

  000de	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 03 4c 24 70	 add	 rcx, QWORD PTR size$32892[rsp]
  000ee	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000f6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   : 		*out_pos += size;

  000f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00101	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00104	48 03 4c 24 70	 add	 rcx, QWORD PTR size$32892[rsp]
  00109	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00111	48 89 08	 mov	 QWORD PTR [rax], rcx

; 72   : 
; 73   : 		ret = action != LZMA_RUN && *in_pos == in_size
; 74   : 				? LZMA_STREAM_END : LZMA_OK;

  00114	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR action$[rsp], 0
  0011c	74 22		 je	 SHORT $LN7@delta_enco
  0011e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00126	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0012e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00131	75 0d		 jne	 SHORT $LN7@delta_enco
  00133	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv80[rsp], 1
  0013e	eb 0b		 jmp	 SHORT $LN8@delta_enco
$LN7@delta_enco:
  00140	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
$LN8@delta_enco:
  0014b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv80[rsp]
  00152	89 44 24 50	 mov	 DWORD PTR ret$[rsp], eax

; 75   : 
; 76   : 	} else {

  00156	e9 a8 00 00 00	 jmp	 $LN1@delta_enco
$LN2@delta_enco:

; 77   : 		const size_t out_start = *out_pos;

  0015b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00163	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00166	48 89 44 24 78	 mov	 QWORD PTR out_start$32894[rsp], rax

; 78   : 
; 79   : 		ret = coder->next.code(coder->next.coder, allocator,
; 80   : 				in, in_pos, in_size, out, out_pos, out_size,
; 81   : 				action);

  0016b	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00172	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00176	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0017e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00183	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0018b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00190	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00198	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001aa	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  001b2	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  001ba	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR coder$[rsp]
  001c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ca	48 8b 44 24 58	 mov	 rax, QWORD PTR coder$[rsp]
  001cf	ff 50 18	 call	 QWORD PTR [rax+24]
  001d2	89 44 24 50	 mov	 DWORD PTR ret$[rsp], eax

; 82   : 
; 83   : 		encode_in_place(coder, out + out_start, *out_pos - out_start);

  001d6	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR out_pos$[rsp]
  001de	48 8b 44 24 78	 mov	 rax, QWORD PTR out_start$32894[rsp]
  001e3	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  001e6	4c 2b c0	 sub	 r8, rax
  001e9	48 8b 44 24 78	 mov	 rax, QWORD PTR out_start$32894[rsp]
  001ee	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001f6	48 03 d0	 add	 rdx, rax
  001f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR coder$[rsp]
  001fe	e8 00 00 00 00	 call	 encode_in_place
$LN1@delta_enco:

; 84   : 	}
; 85   : 
; 86   : 	return ret;

  00203	8b 44 24 50	 mov	 eax, DWORD PTR ret$[rsp]

; 87   : }

  00207	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0020e	c3		 ret	 0
delta_encode ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_delta_encoder_init DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$lzma_delta_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_delta_encoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_delta_encoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
filters$ = 64
lzma_delta_encoder_init PROC				; COMDAT

; 108  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 109  : 	next->code = &delta_encode;

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:delta_encode
  0001f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 110  : 	next->update = &delta_encoder_update;

  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:delta_encoder_update
  0002f	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 111  : 	return lzma_delta_coder_init(next, allocator, filters);

  00033	4c 8b 44 24 40	 mov	 r8, QWORD PTR filters$[rsp]
  00038	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00042	e8 00 00 00 00	 call	 lzma_delta_coder_init

; 112  : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
lzma_delta_encoder_init ENDP
END
