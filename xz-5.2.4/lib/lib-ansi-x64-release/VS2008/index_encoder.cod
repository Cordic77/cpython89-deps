; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\index_encoder.c
pdata	SEGMENT
$pdata$index_encoder_reset DD imagerel index_encoder_reset
	DD	imagerel index_encoder_reset+95
	DD	imagerel $unwind$index_encoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_encoder_reset DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_encoder_reset
_TEXT	SEGMENT
coder$ = 48
i$ = 56
index_encoder_reset PROC				; COMDAT

; 173  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 174  : 	lzma_index_iter_init(&coder->iter, i);

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00013	48 83 c1 10	 add	 rcx, 16
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  0001c	e8 00 00 00 00	 call	 lzma_index_iter_init

; 175  : 
; 176  : 	coder->sequence = SEQ_INDICATOR;

  00021	4c 8b 5c 24 30	 mov	 r11, QWORD PTR coder$[rsp]
  00026	41 c7 03 00 00
	00 00		 mov	 DWORD PTR [r11], 0

; 177  : 	coder->index = i;

  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00037	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 178  : 	coder->pos = 0;

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00040	48 c7 80 40 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+320], 0

; 179  : 	coder->crc32 = 0;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR coder$[rsp]
  00050	c7 80 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+328], 0

; 180  : 
; 181  : 	return;
; 182  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
index_encoder_reset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_encoder_end DD imagerel index_encoder_end
	DD	imagerel index_encoder_end+34
	DD	imagerel $unwind$index_encoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_encoder_end DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_encoder_end
_TEXT	SEGMENT
coder$ = 48
allocator$ = 56
index_encoder_end PROC					; COMDAT

; 165  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 166  : 	lzma_free(coder, allocator);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR coder$[rsp]
  00018	e8 00 00 00 00	 call	 lzma_free

; 167  : 	return;
; 168  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
index_encoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$index_encode DD imagerel index_encode
	DD	imagerel index_encode+1032
	DD	imagerel $unwind$index_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$index_encode DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT index_encode
_TEXT	SEGMENT
out_start$ = 48
ret$ = 56
coder$ = 64
count$32945 = 72
size$32952 = 80
tv65 = 88
tv94 = 96
coder_ptr$ = 128
allocator$ = 136
in$ = 144
in_pos$ = 152
in_size$ = 160
out$ = 168
out_pos$ = 176
out_size$ = 184
action$ = 192
index_encode PROC					; COMDAT

; 52   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 53   : 	lzma_index_coder *coder = coder_ptr;

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00020	48 89 44 24 40	 mov	 QWORD PTR coder$[rsp], rax

; 54   : 
; 55   : 	// Position where to start calculating CRC32. The idea is that we
; 56   : 	// need to call lzma_crc32() only once per call to index_encode().
; 57   : 	const size_t out_start = *out_pos;

  00025	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 30	 mov	 QWORD PTR out_start$[rsp], rax

; 58   : 
; 59   : 	// Return value to use if we return at the end of this function.
; 60   : 	// We use "goto out" to jump out of the while-switch construct
; 61   : 	// instead of returning directly, because that way we don't need
; 62   : 	// to copypaste the lzma_crc32() call to many places.
; 63   : 	lzma_ret ret = LZMA_OK;

  00035	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN19@index_enco:

; 64   : 
; 65   : 	while (*out_pos < out_size)

  0003d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00045	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0004d	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00050	0f 83 47 03 00
	00		 jae	 $LN18@index_enco

; 66   : 	switch (coder->sequence) {

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0005b	8b 00		 mov	 eax, DWORD PTR [rax]
  0005d	89 44 24 58	 mov	 DWORD PTR tv65[rsp], eax
  00061	83 7c 24 58 06	 cmp	 DWORD PTR tv65[rsp], 6
  00066	0f 87 25 03 00
	00		 ja	 $LN1@index_enco
  0006c	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv65[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00078	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN24@index_enco[rcx+rax*4]
  0007f	48 03 c1	 add	 rax, rcx
  00082	ff e0		 jmp	 rax
$LN15@index_enco:

; 67   : 	case SEQ_INDICATOR:
; 68   : 		out[*out_pos] = 0x00;

  00084	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0008c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00097	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 69   : 		++*out_pos;

  0009b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a6	48 83 c1 01	 add	 rcx, 1
  000aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000b2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 70   : 		coder->sequence = SEQ_COUNT;

  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  000ba	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 71   : 		break;

  000c0	e9 d3 02 00 00	 jmp	 $LN16@index_enco
$LN14@index_enco:

; 72   : 
; 73   : 	case SEQ_COUNT: {
; 74   : 		const lzma_vli count = lzma_index_block_count(coder->index);

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  000ca	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ce	e8 00 00 00 00	 call	 lzma_index_block_count
  000d3	48 89 44 24 48	 mov	 QWORD PTR count$32945[rsp], rax

; 75   : 		ret = lzma_vli_encode(count, &coder->pos,
; 76   : 				out, out_pos, out_size);

  000d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  000dd	48 81 c2 40 01
	00 00		 add	 rdx, 320		; 00000140H
  000e4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f1	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR out_pos$[rsp]
  000f9	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR out$[rsp]
  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR count$32945[rsp]
  00106	e8 00 00 00 00	 call	 lzma_vli_encode
  0010b	89 44 24 38	 mov	 DWORD PTR ret$[rsp], eax

; 77   : 		if (ret != LZMA_STREAM_END)

  0010f	83 7c 24 38 01	 cmp	 DWORD PTR ret$[rsp], 1
  00114	74 05		 je	 SHORT $LN13@index_enco

; 78   : 			goto out;

  00116	e9 82 02 00 00	 jmp	 $out$32947
$LN13@index_enco:

; 79   : 
; 80   : 		ret = LZMA_OK;

  0011b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 81   : 		coder->pos = 0;

  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00128	48 c7 80 40 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+320], 0

; 82   : 		coder->sequence = SEQ_NEXT;

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00138	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 83   : 		break;

  0013e	e9 55 02 00 00	 jmp	 $LN16@index_enco
$LN12@index_enco:

; 84   : 	}
; 85   : 
; 86   : 	case SEQ_NEXT:
; 87   : 		if (lzma_index_iter_next(
; 88   : 				&coder->iter, LZMA_INDEX_ITER_BLOCK)) {

  00143	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00148	48 83 c1 10	 add	 rcx, 16
  0014c	ba 02 00 00 00	 mov	 edx, 2
  00151	e8 00 00 00 00	 call	 lzma_index_iter_next
  00156	0f b6 c0	 movzx	 eax, al
  00159	85 c0		 test	 eax, eax
  0015b	74 2c		 je	 SHORT $LN11@index_enco

; 89   : 			// Get the size of the Index Padding field.
; 90   : 			coder->pos = lzma_index_padding_size(coder->index);

  0015d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00162	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00166	e8 00 00 00 00	 call	 lzma_index_padding_size
  0016b	8b c8		 mov	 ecx, eax
  0016d	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00172	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 91   : 			assert(coder->pos <= 3);
; 92   : 			coder->sequence = SEQ_PADDING;

  00179	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0017e	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5

; 93   : 			break;

  00184	e9 0f 02 00 00	 jmp	 $LN16@index_enco
$LN11@index_enco:

; 94   : 		}
; 95   : 
; 96   : 		coder->sequence = SEQ_UNPADDED;

  00189	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0018e	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN10@index_enco:

; 97   : 
; 98   : 	// Fall through
; 99   : 
; 100  : 	case SEQ_UNPADDED:
; 101  : 	case SEQ_UNCOMPRESSED: {
; 102  : 		const lzma_vli size = coder->sequence == SEQ_UNPADDED
; 103  : 				? coder->iter.block.unpadded_size
; 104  : 				: coder->iter.block.uncompressed_size;

  00194	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00199	83 38 02	 cmp	 DWORD PTR [rax], 2
  0019c	75 13		 jne	 SHORT $LN22@index_enco
  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001aa	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
  001af	eb 11		 jmp	 SHORT $LN23@index_enco
$LN22@index_enco:
  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  001b6	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  001bd	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
$LN23@index_enco:
  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR tv94[rsp]
  001c7	48 89 44 24 50	 mov	 QWORD PTR size$32952[rsp], rax

; 105  : 
; 106  : 		ret = lzma_vli_encode(size, &coder->pos,
; 107  : 				out, out_pos, out_size);

  001cc	48 8b 54 24 40	 mov	 rdx, QWORD PTR coder$[rsp]
  001d1	48 81 c2 40 01
	00 00		 add	 rdx, 320		; 00000140H
  001d8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR out_pos$[rsp]
  001ed	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR out$[rsp]
  001f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$32952[rsp]
  001fa	e8 00 00 00 00	 call	 lzma_vli_encode
  001ff	89 44 24 38	 mov	 DWORD PTR ret$[rsp], eax

; 108  : 		if (ret != LZMA_STREAM_END)

  00203	83 7c 24 38 01	 cmp	 DWORD PTR ret$[rsp], 1
  00208	74 05		 je	 SHORT $LN9@index_enco

; 109  : 			goto out;

  0020a	e9 8e 01 00 00	 jmp	 $out$32947
$LN9@index_enco:

; 110  : 
; 111  : 		ret = LZMA_OK;

  0020f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 112  : 		coder->pos = 0;

  00217	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0021c	48 c7 80 40 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+320], 0

; 113  : 
; 114  : 		// Advance to SEQ_UNCOMPRESSED or SEQ_NEXT.
; 115  : 		++coder->sequence;

  00227	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0022e	83 c1 01	 add	 ecx, 1
  00231	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00236	89 08		 mov	 DWORD PTR [rax], ecx

; 116  : 		break;

  00238	e9 5b 01 00 00	 jmp	 $LN16@index_enco
$LN8@index_enco:

; 117  : 	}
; 118  : 
; 119  : 	case SEQ_PADDING:
; 120  : 		if (coder->pos > 0) {

  0023d	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00242	48 83 b8 40 01
	00 00 00	 cmp	 QWORD PTR [rax+320], 0
  0024a	76 52		 jbe	 SHORT $LN7@index_enco

; 121  : 			--coder->pos;

  0024c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00251	48 8b 89 40 01
	00 00		 mov	 rcx, QWORD PTR [rcx+320]
  00258	48 83 e9 01	 sub	 rcx, 1
  0025c	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00261	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 122  : 			out[(*out_pos)++] = 0x00;

  00268	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00270	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00273	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0027b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  0027f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00287	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0028a	48 83 c1 01	 add	 rcx, 1
  0028e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00296	48 89 08	 mov	 QWORD PTR [rax], rcx

; 123  : 			break;

  00299	e9 fa 00 00 00	 jmp	 $LN16@index_enco
$LN7@index_enco:

; 124  : 		}
; 125  : 
; 126  : 		// Finish the CRC32 calculation.
; 127  : 		coder->crc32 = lzma_crc32(out + out_start,
; 128  : 				*out_pos - out_start, coder->crc32);

  0029e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR out_pos$[rsp]
  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR out_start$[rsp]
  002ab	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  002ae	48 2b d0	 sub	 rdx, rax
  002b1	48 8b 44 24 30	 mov	 rax, QWORD PTR out_start$[rsp]
  002b6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  002be	48 03 c8	 add	 rcx, rax
  002c1	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  002c6	44 8b 80 48 01
	00 00		 mov	 r8d, DWORD PTR [rax+328]
  002cd	e8 00 00 00 00	 call	 lzma_crc32
  002d2	44 8b d8	 mov	 r11d, eax
  002d5	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  002da	44 89 98 48 01
	00 00		 mov	 DWORD PTR [rax+328], r11d

; 129  : 
; 130  : 		coder->sequence = SEQ_CRC32;

  002e1	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  002e6	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN6@index_enco:
$LN5@index_enco:

; 131  : 
; 132  : 	// Fall through
; 133  : 
; 134  : 	case SEQ_CRC32:
; 135  : 		// We don't use the main loop, because we don't want
; 136  : 		// coder->crc32 to be touched anymore.
; 137  : 		do {
; 138  : 			if (*out_pos == out_size)

  002ec	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  002f4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  002fc	48 39 01	 cmp	 QWORD PTR [rcx], rax
  002ff	75 07		 jne	 SHORT $LN2@index_enco

; 139  : 				return LZMA_OK;

  00301	33 c0		 xor	 eax, eax
  00303	e9 dc 00 00 00	 jmp	 $LN20@index_enco
$LN2@index_enco:

; 140  : 
; 141  : 			out[*out_pos] = (coder->crc32 >> (coder->pos * 8))
; 142  : 					& 0xFF;

  00308	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  0030d	48 8b 89 40 01
	00 00		 mov	 rcx, QWORD PTR [rcx+320]
  00314	48 c1 e1 03	 shl	 rcx, 3
  00318	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0031d	8b 90 48 01 00
	00		 mov	 edx, DWORD PTR [rax+328]
  00323	d3 ea		 shr	 edx, cl
  00325	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0032b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00333	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00336	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0033e	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 143  : 			++*out_pos;

  00341	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00349	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0034c	48 83 c1 01	 add	 rcx, 1
  00350	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00358	48 89 08	 mov	 QWORD PTR [rax], rcx

; 144  : 
; 145  : 		} while (++coder->pos < 4);

  0035b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR coder$[rsp]
  00360	48 8b 89 40 01
	00 00		 mov	 rcx, QWORD PTR [rcx+320]
  00367	48 83 c1 01	 add	 rcx, 1
  0036b	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  00370	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx
  00377	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  0037c	48 83 b8 40 01
	00 00 04	 cmp	 QWORD PTR [rax+320], 4
  00384	0f 82 62 ff ff
	ff		 jb	 $LN5@index_enco

; 146  : 
; 147  : 		return LZMA_STREAM_END;

  0038a	b8 01 00 00 00	 mov	 eax, 1
  0038f	eb 53		 jmp	 SHORT $LN20@index_enco
$LN1@index_enco:

; 148  : 
; 149  : 	default:
; 150  : 		assert(0);
; 151  : 		return LZMA_PROG_ERROR;

  00391	b8 0b 00 00 00	 mov	 eax, 11
  00396	eb 4c		 jmp	 SHORT $LN20@index_enco
$LN16@index_enco:

; 152  : 	}

  00398	e9 a0 fc ff ff	 jmp	 $LN19@index_enco
$LN18@index_enco:
$out$32947:

; 153  : 
; 154  : out:
; 155  : 	// Update the CRC32.
; 156  : 	coder->crc32 = lzma_crc32(out + out_start,
; 157  : 			*out_pos - out_start, coder->crc32);

  0039d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR out_pos$[rsp]
  003a5	48 8b 44 24 30	 mov	 rax, QWORD PTR out_start$[rsp]
  003aa	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  003ad	48 2b d0	 sub	 rdx, rax
  003b0	48 8b 44 24 30	 mov	 rax, QWORD PTR out_start$[rsp]
  003b5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  003bd	48 03 c8	 add	 rcx, rax
  003c0	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  003c5	44 8b 80 48 01
	00 00		 mov	 r8d, DWORD PTR [rax+328]
  003cc	e8 00 00 00 00	 call	 lzma_crc32
  003d1	44 8b d8	 mov	 r11d, eax
  003d4	48 8b 44 24 40	 mov	 rax, QWORD PTR coder$[rsp]
  003d9	44 89 98 48 01
	00 00		 mov	 DWORD PTR [rax+328], r11d

; 158  : 
; 159  : 	return ret;

  003e0	8b 44 24 38	 mov	 eax, DWORD PTR ret$[rsp]
$LN20@index_enco:

; 160  : }

  003e4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003e8	c3		 ret	 0
  003e9	0f 1f 00	 npad	 3
$LN24@index_enco:
  003ec	00 00 00 00	 DD	 $LN15@index_enco
  003f0	00 00 00 00	 DD	 $LN14@index_enco
  003f4	00 00 00 00	 DD	 $LN10@index_enco
  003f8	00 00 00 00	 DD	 $LN10@index_enco
  003fc	00 00 00 00	 DD	 $LN12@index_enco
  00400	00 00 00 00	 DD	 $LN8@index_enco
  00404	00 00 00 00	 DD	 $LN6@index_enco
index_encode ENDP
PUBLIC	lzma_index_encoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_index_encoder_init DD imagerel $LN10
	DD	imagerel $LN10+201
	DD	imagerel $unwind$lzma_index_encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_index_encoder_init DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_index_encoder_init
_TEXT	SEGMENT
next$ = 48
allocator$ = 56
i$ = 64
lzma_index_encoder_init PROC				; COMDAT

; 188  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN7@lzma_index@15:

; 189  : 	lzma_next_coder_init(&lzma_index_encoder_init, next, allocator);

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_index_encoder_init
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  0001f	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00023	74 0f		 je	 SHORT $LN4@lzma_index@15
  00025	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  0002f	e8 00 00 00 00	 call	 lzma_next_end
$LN4@lzma_index@15:
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_index_encoder_init
  00040	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00044	33 c0		 xor	 eax, eax
  00046	85 c0		 test	 eax, eax
  00048	75 c9		 jne	 SHORT $LN7@lzma_index@15

; 190  : 
; 191  : 	if (i == NULL)

  0004a	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00050	75 07		 jne	 SHORT $LN3@lzma_index@15

; 192  : 		return LZMA_PROG_ERROR;

  00052	b8 0b 00 00 00	 mov	 eax, 11
  00057	eb 6b		 jmp	 SHORT $LN8@lzma_index@15
$LN3@lzma_index@15:

; 193  : 
; 194  : 	if (next->coder == NULL) {

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  0005e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00062	75 4c		 jne	 SHORT $LN2@lzma_index@15

; 195  : 		next->coder = lzma_alloc(sizeof(lzma_index_coder), allocator);

  00064	48 8b 54 24 38	 mov	 rdx, QWORD PTR allocator$[rsp]
  00069	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  0006e	e8 00 00 00 00	 call	 lzma_alloc
  00073	4c 8b d8	 mov	 r11, rax
  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  0007b	4c 89 18	 mov	 QWORD PTR [rax], r11

; 196  : 		if (next->coder == NULL)

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  00083	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00087	75 07		 jne	 SHORT $LN1@lzma_index@15

; 197  : 			return LZMA_MEM_ERROR;

  00089	b8 05 00 00 00	 mov	 eax, 5
  0008e	eb 34		 jmp	 SHORT $LN8@lzma_index@15
$LN1@lzma_index@15:

; 198  : 
; 199  : 		next->code = &index_encode;

  00090	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_encode
  0009c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 200  : 		next->end = &index_encoder_end;

  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:index_encoder_end
  000ac	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN2@lzma_index@15:

; 201  : 	}
; 202  : 
; 203  : 	index_encoder_reset(next->coder, i);

  000b0	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  000b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  000ba	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000bd	e8 00 00 00 00	 call	 index_encoder_reset

; 204  : 
; 205  : 	return LZMA_OK;

  000c2	33 c0		 xor	 eax, eax
$LN8@lzma_index@15:

; 206  : }

  000c4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c8	c3		 ret	 0
lzma_index_encoder_init ENDP
END
