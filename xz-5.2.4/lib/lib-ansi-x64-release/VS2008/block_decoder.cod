; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\block_decoder.c
pdata	SEGMENT
$pdata$is_size_valid DD imagerel is_size_valid
	DD	imagerel is_size_valid+58
	DD	imagerel $unwind$is_size_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_size_valid DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_size_valid
_TEXT	SEGMENT
tv66 = 0
size$ = 32
reference$ = 40
is_size_valid PROC					; COMDAT

; 71   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 72   : 	return reference == LZMA_VLI_UNKNOWN || reference == size;

  0000e	48 83 7c 24 28
	ff		 cmp	 QWORD PTR reference$[rsp], -1
  00014	74 15		 je	 SHORT $LN3@is_size_va
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  0001b	48 39 44 24 28	 cmp	 QWORD PTR reference$[rsp], rax
  00020	74 09		 je	 SHORT $LN3@is_size_va
  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
  00029	eb 07		 jmp	 SHORT $LN4@is_size_va
$LN3@is_size_va:
  0002b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
$LN4@is_size_va:
  00032	8a 04 24	 mov	 al, BYTE PTR tv66[rsp]

; 73   : }

  00035	48 83 c4 18	 add	 rsp, 24
  00039	c3		 ret	 0
is_size_valid ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT update_size
_TEXT	SEGMENT
size$ = 8
add$ = 16
limit$ = 24
update_size PROC					; COMDAT

; 56   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 57   : 	if (limit > LZMA_VLI_MAX)

  0000f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00019	48 39 44 24 18	 cmp	 QWORD PTR limit$[rsp], rax
  0001e	76 0f		 jbe	 SHORT $LN3@update_siz

; 58   : 		limit = LZMA_VLI_MAX;

  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	48 89 44 24 18	 mov	 QWORD PTR limit$[rsp], rax
$LN3@update_siz:

; 59   : 
; 60   : 	if (limit < *size || limit - *size < add)

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 39 44 24 18	 cmp	 QWORD PTR limit$[rsp], rax
  0003c	72 17		 jb	 SHORT $LN1@update_siz
  0003e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR size$[rsp]
  00043	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00046	48 8b 44 24 18	 mov	 rax, QWORD PTR limit$[rsp]
  0004b	48 2b c1	 sub	 rax, rcx
  0004e	48 3b 44 24 10	 cmp	 rax, QWORD PTR add$[rsp]
  00053	73 04		 jae	 SHORT $LN2@update_siz
$LN1@update_siz:

; 61   : 		return true;

  00055	b0 01		 mov	 al, 1
  00057	eb 17		 jmp	 SHORT $LN4@update_siz
$LN2@update_siz:

; 62   : 
; 63   : 	*size += add;

  00059	48 8b 4c 24 08	 mov	 rcx, QWORD PTR size$[rsp]
  0005e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00061	48 03 4c 24 10	 add	 rcx, QWORD PTR add$[rsp]
  00066	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  0006b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 64   : 
; 65   : 	return false;

  0006e	32 c0		 xor	 al, al
$LN4@update_siz:

; 66   : }

  00070	f3 c3		 fatret	 0
update_size ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_decoder_end DD imagerel block_decoder_end
	DD	imagerel block_decoder_end+63
	DD	imagerel $unwind$block_decoder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_decoder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_decoder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
block_decoder_end PROC					; COMDAT

; 183  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 184  : 	lzma_block_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 185  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  0001d	48 83 c1 08	 add	 rcx, 8
  00021	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00026	e8 00 00 00 00	 call	 lzma_next_end

; 186  : 	lzma_free(coder, allocator);

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_free

; 187  : 	return;
; 188  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
block_decoder_end ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$block_decode DD imagerel block_decode
	DD	imagerel block_decode+1418
	DD	imagerel $unwind$block_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$block_decode DD 021b01H
	DD	01d011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT block_decode
_TEXT	SEGMENT
coder$ = 80
in_used$32933 = 88
out_start$32931 = 96
out_used$32934 = 104
ret$32932 = 112
in_start$32930 = 120
check_size$32950 = 128
$T37669 = 136
$T37670 = 144
$T37671 = 152
$T37678 = 160
$T37679 = 168
$T37680 = 176
$T37688 = 184
$T37696 = 192
tv64 = 200
tv93 = 204
tv228 = 208
coder_ptr$ = 240
allocator$ = 248
in$ = 256
in_pos$ = 264
in_size$ = 272
out$ = 280
out_pos$ = 288
out_size$ = 296
action$ = 304
block_decode PROC					; COMDAT

; 81   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 82   : 	lzma_block_coder *coder = coder_ptr;

  0001b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 83   : 
; 84   : 	switch (coder->sequence) {

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0002d	8b 00		 mov	 eax, DWORD PTR [rax]
  0002f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv64[rsp], eax
  00036	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 0
  0003e	74 21		 je	 SHORT $LN17@block_deco
  00040	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR tv64[rsp], 1
  00048	0f 84 85 03 00
	00		 je	 $LN10@block_deco
  0004e	83 bc 24 c8 00
	00 00 02	 cmp	 DWORD PTR tv64[rsp], 2
  00056	0f 84 4d 04 00
	00		 je	 $LN3@block_deco
  0005c	e9 1c 05 00 00	 jmp	 $LN18@block_deco
$LN17@block_deco:

; 85   : 	case SEQ_CODE: {
; 86   : 		const size_t in_start = *in_pos;

  00061	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 89 44 24 78	 mov	 QWORD PTR in_start$32930[rsp], rax

; 87   : 		const size_t out_start = *out_pos;

  00071	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 89 44 24 60	 mov	 QWORD PTR out_start$32931[rsp], rax

; 88   : 
; 89   : 		const lzma_ret ret = coder->next.code(coder->next.coder,
; 90   : 				allocator, in, in_pos, in_size,
; 91   : 				out, out_pos, out_size, action);

  00081	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  00088	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0008c	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00094	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00099	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000a1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000a6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c0	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  000c8	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR in$[rsp]
  000d0	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000dd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000e6	ff 50 20	 call	 QWORD PTR [rax+32]
  000e9	89 44 24 70	 mov	 DWORD PTR ret$32932[rsp], eax

; 92   : 
; 93   : 		const size_t in_used = *in_pos - in_start;

  000ed	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  000f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in_start$32930[rsp]
  000fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fd	48 2b c1	 sub	 rax, rcx
  00100	48 89 44 24 58	 mov	 QWORD PTR in_used$32933[rsp], rax

; 94   : 		const size_t out_used = *out_pos - out_start;

  00105	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR out_start$32931[rsp]
  00112	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00115	48 2b c1	 sub	 rax, rcx
  00118	48 89 44 24 68	 mov	 QWORD PTR out_used$32934[rsp], rax

; 95   : 
; 96   : 		// NOTE: We compare to compressed_limit here, which prevents
; 97   : 		// the total size of the Block growing past LZMA_VLI_MAX.
; 98   : 		if (update_size(&coder->compressed_size, in_used,
; 99   : 					coder->compressed_limit)
; 100  : 				|| update_size(&coder->uncompressed_size,
; 101  : 					out_used,
; 102  : 					coder->block->uncompressed_size))

  0011d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00122	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00126	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T37670[rsp], rax
  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00133	48 83 c0 58	 add	 rax, 88			; 00000058H
  00137	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T37669[rsp], rax
  0013f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00149	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR $T37670[rsp], rax
  00151	76 12		 jbe	 SHORT $LN24@block_deco
  00153	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0015d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T37670[rsp], rax
$LN24@block_deco:
  00165	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T37669[rsp]
  0016d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00170	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR $T37670[rsp], rax
  00178	72 1d		 jb	 SHORT $LN22@block_deco
  0017a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T37669[rsp]
  00182	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00185	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T37670[rsp]
  0018d	48 2b c1	 sub	 rax, rcx
  00190	48 3b 44 24 58	 cmp	 rax, QWORD PTR in_used$32933[rsp]
  00195	73 0a		 jae	 SHORT $LN23@block_deco
$LN22@block_deco:
  00197	c6 84 24 98 00
	00 00 01	 mov	 BYTE PTR $T37671[rsp], 1
  0019f	eb 23		 jmp	 SHORT $LN25@block_deco
$LN23@block_deco:
  001a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T37669[rsp]
  001a9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ac	48 03 4c 24 58	 add	 rcx, QWORD PTR in_used$32933[rsp]
  001b1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T37669[rsp]
  001b9	48 89 08	 mov	 QWORD PTR [rax], rcx
  001bc	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR $T37671[rsp], 0
$LN25@block_deco:
  001c4	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR $T37671[rsp]
  001cc	85 c0		 test	 eax, eax
  001ce	0f 85 b7 00 00
	00		 jne	 $LN15@block_deco
  001d4	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001d9	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001dd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001e1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T37679[rsp], rax
  001e9	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  001ee	48 83 c0 60	 add	 rax, 96			; 00000060H
  001f2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T37678[rsp], rax
  001fa	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00204	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR $T37679[rsp], rax
  0020c	76 12		 jbe	 SHORT $LN29@block_deco
  0020e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00218	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T37679[rsp], rax
$LN29@block_deco:
  00220	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T37678[rsp]
  00228	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022b	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR $T37679[rsp], rax
  00233	72 1d		 jb	 SHORT $LN27@block_deco
  00235	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR $T37678[rsp]
  0023d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00240	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR $T37679[rsp]
  00248	48 2b c1	 sub	 rax, rcx
  0024b	48 3b 44 24 68	 cmp	 rax, QWORD PTR out_used$32934[rsp]
  00250	73 0a		 jae	 SHORT $LN28@block_deco
$LN27@block_deco:
  00252	c6 84 24 b0 00
	00 00 01	 mov	 BYTE PTR $T37680[rsp], 1
  0025a	eb 23		 jmp	 SHORT $LN30@block_deco
$LN28@block_deco:
  0025c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR $T37678[rsp]
  00264	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00267	48 03 4c 24 68	 add	 rcx, QWORD PTR out_used$32934[rsp]
  0026c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T37678[rsp]
  00274	48 89 08	 mov	 QWORD PTR [rax], rcx
  00277	c6 84 24 b0 00
	00 00 00	 mov	 BYTE PTR $T37680[rsp], 0
$LN30@block_deco:
  0027f	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR $T37680[rsp]
  00287	85 c0		 test	 eax, eax
  00289	74 0a		 je	 SHORT $LN16@block_deco
$LN15@block_deco:

; 103  : 			return LZMA_DATA_ERROR;

  0028b	b8 09 00 00 00	 mov	 eax, 9
  00290	e9 ed 02 00 00	 jmp	 $LN20@block_deco
$LN16@block_deco:

; 104  : 
; 105  : 		if (!coder->ignore_check)

  00295	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0029a	0f b6 80 e0 00
	00 00		 movzx	 eax, BYTE PTR [rax+224]
  002a1	85 c0		 test	 eax, eax
  002a3	75 2f		 jne	 SHORT $LN14@block_deco

; 106  : 			lzma_check_update(&coder->check, coder->block->check,
; 107  : 					out + out_start, out_used);

  002a5	48 8b 44 24 60	 mov	 rax, QWORD PTR out_start$32931[rsp]
  002aa	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR out$[rsp]
  002b2	4c 03 c0	 add	 r8, rax
  002b5	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002ba	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002c3	48 83 c1 78	 add	 rcx, 120		; 00000078H
  002c7	4c 8b 4c 24 68	 mov	 r9, QWORD PTR out_used$32934[rsp]
  002cc	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  002cf	e8 00 00 00 00	 call	 lzma_check_update
$LN14@block_deco:

; 108  : 
; 109  : 		if (ret != LZMA_STREAM_END)

  002d4	83 7c 24 70 01	 cmp	 DWORD PTR ret$32932[rsp], 1
  002d9	74 09		 je	 SHORT $LN13@block_deco

; 110  : 			return ret;

  002db	8b 44 24 70	 mov	 eax, DWORD PTR ret$32932[rsp]
  002df	e9 9e 02 00 00	 jmp	 $LN20@block_deco
$LN13@block_deco:

; 111  : 
; 112  : 		// Compressed and Uncompressed Sizes are now at their final
; 113  : 		// values. Verify that they match the values given to us.
; 114  : 		if (!is_size_valid(coder->compressed_size,
; 115  : 					coder->block->compressed_size)
; 116  : 				|| !is_size_valid(coder->uncompressed_size,
; 117  : 					coder->block->uncompressed_size))

  002e4	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002e9	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002ed	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002f1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR $T37688[rsp], rax
  002f9	48 83 bc 24 b8
	00 00 00 ff	 cmp	 QWORD PTR $T37688[rsp], -1
  00302	74 20		 je	 SHORT $LN34@block_deco
  00304	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00309	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0030d	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR $T37688[rsp], rax
  00315	74 0d		 je	 SHORT $LN34@block_deco
  00317	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv93[rsp], 0
  00322	eb 0b		 jmp	 SHORT $LN35@block_deco
$LN34@block_deco:
  00324	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv93[rsp], 1
$LN35@block_deco:
  0032f	0f b6 84 24 cc
	00 00 00	 movzx	 eax, BYTE PTR tv93[rsp]
  00337	85 c0		 test	 eax, eax
  00339	74 57		 je	 SHORT $LN11@block_deco
  0033b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00340	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00344	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00348	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR $T37696[rsp], rax
  00350	48 83 bc 24 c0
	00 00 00 ff	 cmp	 QWORD PTR $T37696[rsp], -1
  00359	74 20		 je	 SHORT $LN38@block_deco
  0035b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00360	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00364	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR $T37696[rsp], rax
  0036c	74 0d		 je	 SHORT $LN38@block_deco
  0036e	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
  00379	eb 0b		 jmp	 SHORT $LN39@block_deco
$LN38@block_deco:
  0037b	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv228[rsp], 1
$LN39@block_deco:
  00386	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR tv228[rsp]
  0038e	85 c0		 test	 eax, eax
  00390	75 0a		 jne	 SHORT $LN12@block_deco
$LN11@block_deco:

; 118  : 			return LZMA_DATA_ERROR;

  00392	b8 09 00 00 00	 mov	 eax, 9
  00397	e9 e6 01 00 00	 jmp	 $LN20@block_deco
$LN12@block_deco:

; 119  : 
; 120  : 		// Copy the values into coder->block. The caller
; 121  : 		// may use this information to construct Index.
; 122  : 		coder->block->compressed_size = coder->compressed_size;

  0039c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003a1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  003a5	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  003aa	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003ae	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 123  : 		coder->block->uncompressed_size = coder->uncompressed_size;

  003b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003b7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  003bb	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  003c0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003c4	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 124  : 
; 125  : 		coder->sequence = SEQ_PADDING;

  003c8	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  003cd	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN10@block_deco:
$LN9@block_deco:

; 126  : 	}
; 127  : 
; 128  : 	// Fall through
; 129  : 
; 130  : 	case SEQ_PADDING:
; 131  : 		// Compressed Data is padded to a multiple of four bytes.
; 132  : 		while (coder->compressed_size & 3) {

  003d3	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  003d8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003dc	48 83 e0 03	 and	 rax, 3
  003e0	48 85 c0	 test	 rax, rax
  003e3	74 76		 je	 SHORT $LN8@block_deco

; 133  : 			if (*in_pos >= in_size)

  003e5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  003ed	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  003f5	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003f8	72 07		 jb	 SHORT $LN7@block_deco

; 134  : 				return LZMA_OK;

  003fa	33 c0		 xor	 eax, eax
  003fc	e9 81 01 00 00	 jmp	 $LN20@block_deco
$LN7@block_deco:

; 135  : 
; 136  : 			// We use compressed_size here just get the Padding
; 137  : 			// right. The actual Compressed Size was stored to
; 138  : 			// coder->block already, and won't be modified by
; 139  : 			// us anymore.
; 140  : 			++coder->compressed_size;

  00401	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00406	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0040a	48 83 c1 01	 add	 rcx, 1
  0040e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00413	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 141  : 
; 142  : 			if (in[(*in_pos)++] != 0x00)

  00417	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0041f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00422	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0042a	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0042e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00436	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00439	48 83 c1 01	 add	 rcx, 1
  0043d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR in_pos$[rsp]
  00445	48 89 08	 mov	 QWORD PTR [rax], rcx
  00448	85 d2		 test	 edx, edx
  0044a	74 0a		 je	 SHORT $LN6@block_deco

; 143  : 				return LZMA_DATA_ERROR;

  0044c	b8 09 00 00 00	 mov	 eax, 9
  00451	e9 2c 01 00 00	 jmp	 $LN20@block_deco
$LN6@block_deco:

; 144  : 		}

  00456	e9 78 ff ff ff	 jmp	 $LN9@block_deco
$LN8@block_deco:

; 145  : 
; 146  : 		if (coder->block->check == LZMA_CHECK_NONE)

  0045b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00460	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00464	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00468	75 0a		 jne	 SHORT $LN5@block_deco

; 147  : 			return LZMA_STREAM_END;

  0046a	b8 01 00 00 00	 mov	 eax, 1
  0046f	e9 0e 01 00 00	 jmp	 $LN20@block_deco
$LN5@block_deco:

; 148  : 
; 149  : 		if (!coder->ignore_check)

  00474	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00479	0f b6 80 e0 00
	00 00		 movzx	 eax, BYTE PTR [rax+224]
  00480	85 c0		 test	 eax, eax
  00482	75 1a		 jne	 SHORT $LN4@block_deco

; 150  : 			lzma_check_finish(&coder->check, coder->block->check);

  00484	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00489	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0048d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00492	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00496	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00499	e8 00 00 00 00	 call	 lzma_check_finish
$LN4@block_deco:

; 151  : 
; 152  : 		coder->sequence = SEQ_CHECK;

  0049e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  004a3	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN3@block_deco:

; 153  : 
; 154  : 	// Fall through
; 155  : 
; 156  : 	case SEQ_CHECK: {
; 157  : 		const size_t check_size = lzma_check_size(coder->block->check);

  004a9	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  004ae	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  004b2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  004b5	e8 00 00 00 00	 call	 lzma_check_size
  004ba	8b c0		 mov	 eax, eax
  004bc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR check_size$32950[rsp], rax

; 158  : 		lzma_bufcpy(in, in_pos, in_size, coder->block->raw_check,
; 159  : 				&coder->check_pos, check_size);

  004c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  004c9	48 83 c1 70	 add	 rcx, 112		; 00000070H
  004cd	4c 8b 4c 24 50	 mov	 r9, QWORD PTR coder$[rsp]
  004d2	4d 8b 49 50	 mov	 r9, QWORD PTR [r9+80]
  004d6	49 83 c1 28	 add	 r9, 40			; 00000028H
  004da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR check_size$32950[rsp]
  004e2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004ec	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  004f4	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  004fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00504	e8 00 00 00 00	 call	 lzma_bufcpy

; 160  : 		if (coder->check_pos < check_size)

  00509	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  0050e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR check_size$32950[rsp]
  00516	49 39 43 70	 cmp	 QWORD PTR [r11+112], rax
  0051a	73 04		 jae	 SHORT $LN2@block_deco

; 161  : 			return LZMA_OK;

  0051c	33 c0		 xor	 eax, eax
  0051e	eb 62		 jmp	 SHORT $LN20@block_deco
$LN2@block_deco:

; 162  : 
; 163  : 		// Validate the Check only if we support it.
; 164  : 		// coder->check.buffer may be uninitialized
; 165  : 		// when the Check ID is not supported.
; 166  : 		if (!coder->ignore_check
; 167  : 				&& lzma_check_is_supported(coder->block->check)
; 168  : 				&& memcmp(coder->block->raw_check,
; 169  : 					coder->check.buffer.u8,
; 170  : 					check_size) != 0)

  00520	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00525	0f b6 80 e0 00
	00 00		 movzx	 eax, BYTE PTR [rax+224]
  0052c	85 c0		 test	 eax, eax
  0052e	75 46		 jne	 SHORT $LN1@block_deco
  00530	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00535	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00539	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0053c	e8 00 00 00 00	 call	 lzma_check_is_supported
  00541	0f b6 c0	 movzx	 eax, al
  00544	85 c0		 test	 eax, eax
  00546	74 2e		 je	 SHORT $LN1@block_deco
  00548	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  0054d	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00551	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00556	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0055a	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0055e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR check_size$32950[rsp]
  00566	e8 00 00 00 00	 call	 memcmp
  0056b	85 c0		 test	 eax, eax
  0056d	74 07		 je	 SHORT $LN1@block_deco

; 171  : 			return LZMA_DATA_ERROR;

  0056f	b8 09 00 00 00	 mov	 eax, 9
  00574	eb 0c		 jmp	 SHORT $LN20@block_deco
$LN1@block_deco:

; 172  : 
; 173  : 		return LZMA_STREAM_END;

  00576	b8 01 00 00 00	 mov	 eax, 1
  0057b	eb 05		 jmp	 SHORT $LN20@block_deco
$LN18@block_deco:

; 174  : 	}
; 175  : 	}
; 176  : 
; 177  : 	return LZMA_PROG_ERROR;

  0057d	b8 0b 00 00 00	 mov	 eax, 11
$LN20@block_deco:

; 178  : }

  00582	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00589	c3		 ret	 0
block_decode ENDP
PUBLIC	lzma_block_decoder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_block_decoder_init DD imagerel $LN15
	DD	imagerel $LN15+523
	DD	imagerel $unwind$lzma_block_decoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_block_decoder_init DD 031501H
	DD	070118215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_block_decoder_init
_TEXT	SEGMENT
coder$32975 = 32
tv132 = 40
tv142 = 48
next$ = 96
allocator$ = 104
block$ = 112
lzma_block_decoder_init PROC				; COMDAT

; 194  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN8@lzma_block@3:

; 195  : 	lzma_next_coder_init(&lzma_block_decoder_init, next, allocator);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_block_decoder_init
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR next$[rsp]
  00021	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00025	74 0f		 je	 SHORT $LN5@lzma_block@3
  00027	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR next$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_next_end
$LN5@lzma_block@3:
  00036	48 8b 4c 24 60	 mov	 rcx, QWORD PTR next$[rsp]
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_block_decoder_init
  00042	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 c9		 jne	 SHORT $LN8@lzma_block@3

; 196  : 
; 197  : 	// Validate the options. lzma_block_unpadded_size() does that for us
; 198  : 	// except for Uncompressed Size and filters. Filters are validated
; 199  : 	// by the raw decoder.
; 200  : 	if (lzma_block_unpadded_size(block) == 0
; 201  : 			|| !lzma_vli_is_valid(block->uncompressed_size))

  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  00051	e8 00 00 00 00	 call	 lzma_block_unpadded_size
  00056	48 85 c0	 test	 rax, rax
  00059	74 21		 je	 SHORT $LN3@lzma_block@3
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR block$[rsp]
  00060	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0006a	48 39 41 18	 cmp	 QWORD PTR [rcx+24], rax
  0006e	76 16		 jbe	 SHORT $LN4@lzma_block@3
  00070	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00075	48 83 78 18 ff	 cmp	 QWORD PTR [rax+24], -1
  0007a	74 0a		 je	 SHORT $LN4@lzma_block@3
$LN3@lzma_block@3:

; 202  : 		return LZMA_PROG_ERROR;

  0007c	b8 0b 00 00 00	 mov	 eax, 11
  00081	e9 7e 01 00 00	 jmp	 $LN9@lzma_block@3
$LN4@lzma_block@3:

; 203  : 
; 204  : 	// Allocate *next->coder if needed.
; 205  :   {
; 206  : 	lzma_block_coder *coder = next->coder;

  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR next$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 89 44 24 20	 mov	 QWORD PTR coder$32975[rsp], rax

; 207  : 	if (coder == NULL) {

  00093	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32975[rsp], 0
  00099	75 6a		 jne	 SHORT $LN2@lzma_block@3

; 208  : 		coder = lzma_alloc(sizeof(lzma_block_coder), allocator);

  0009b	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  000a0	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  000a5	e8 00 00 00 00	 call	 lzma_alloc
  000aa	48 89 44 24 20	 mov	 QWORD PTR coder$32975[rsp], rax

; 209  : 		if (coder == NULL)

  000af	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$32975[rsp], 0
  000b5	75 0a		 jne	 SHORT $LN1@lzma_block@3

; 210  : 			return LZMA_MEM_ERROR;

  000b7	b8 05 00 00 00	 mov	 eax, 5
  000bc	e9 43 01 00 00	 jmp	 $LN9@lzma_block@3
$LN1@lzma_block@3:

; 211  : 
; 212  : 		next->coder = coder;

  000c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR next$[rsp]
  000c6	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32975[rsp]
  000cb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 213  : 		next->code = &block_decode;

  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR next$[rsp]
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:block_decode
  000da	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 214  : 		next->end = &block_decoder_end;

  000de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR next$[rsp]
  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:block_decoder_end
  000ea	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 215  : 		coder->next = LZMA_NEXT_CODER_INIT;

  000ee	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$32975[rsp]
  000f3	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000fa	48 83 c7 08	 add	 rdi, 8
  000fe	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00103	f3 a4		 rep movsb
$LN2@lzma_block@3:

; 216  : 	}
; 217  : 
; 218  : 	// Basic initializations
; 219  : 	coder->sequence = SEQ_CODE;

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32975[rsp]
  0010a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 220  : 	coder->block = block;

  00110	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32975[rsp]
  00115	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0011a	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 221  : 	coder->compressed_size = 0;

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32975[rsp]
  00123	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 222  : 	coder->uncompressed_size = 0;

  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32975[rsp]
  00130	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 223  : 
; 224  : 	// If Compressed Size is not known, we calculate the maximum allowed
; 225  : 	// value so that encoded size of the Block (including Block Padding)
; 226  : 	// is still a valid VLI and a multiple of four.
; 227  : 	coder->compressed_limit
; 228  : 			= block->compressed_size == LZMA_VLI_UNKNOWN
; 229  : 				? (LZMA_VLI_MAX & ~LZMA_VLI_C(3))
; 230  : 					- block->header_size
; 231  : 					- lzma_check_size(block->check)
; 232  : 				: block->compressed_size;

  00138	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0013d	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  00142	75 31		 jne	 SHORT $LN11@lzma_block@3
  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  00149	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0014c	48 bf fc ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775804 ; 7ffffffffffffffcH
  00156	48 2b f8	 sub	 rdi, rax
  00159	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0015e	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00161	e8 00 00 00 00	 call	 lzma_check_size
  00166	8b c8		 mov	 ecx, eax
  00168	48 8b c7	 mov	 rax, rdi
  0016b	48 2b c1	 sub	 rax, rcx
  0016e	48 89 44 24 28	 mov	 QWORD PTR tv132[rsp], rax
  00173	eb 0e		 jmp	 SHORT $LN12@lzma_block@3
$LN11@lzma_block@3:
  00175	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  0017a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0017e	48 89 44 24 28	 mov	 QWORD PTR tv132[rsp], rax
$LN12@lzma_block@3:
  00183	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32975[rsp]
  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  0018d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 233  : 
; 234  : 	// Initialize the check. It's caller's problem if the Check ID is not
; 235  : 	// supported, and the Block decoder cannot verify the Check field.
; 236  : 	// Caller can test lzma_check_is_supported(block->check).
; 237  : 	coder->check_pos = 0;

  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$32975[rsp]
  00196	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 238  : 	lzma_check_init(&coder->check, block->check);

  0019e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32975[rsp]
  001a3	48 83 c1 78	 add	 rcx, 120		; 00000078H
  001a7	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  001ac	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  001af	e8 00 00 00 00	 call	 lzma_check_init

; 239  : 
; 240  : 	coder->ignore_check = block->version >= 1
; 241  : 			? block->ignore_check : false;

  001b4	48 8b 54 24 70	 mov	 rdx, QWORD PTR block$[rsp]
  001b9	83 3a 01	 cmp	 DWORD PTR [rdx], 1
  001bc	72 12		 jb	 SHORT $LN13@lzma_block@3
  001be	48 8b 44 24 70	 mov	 rax, QWORD PTR block$[rsp]
  001c3	0f b6 80 c8 00
	00 00		 movzx	 eax, BYTE PTR [rax+200]
  001ca	89 44 24 30	 mov	 DWORD PTR tv142[rsp], eax
  001ce	eb 08		 jmp	 SHORT $LN14@lzma_block@3
$LN13@lzma_block@3:
  001d0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN14@lzma_block@3:
  001d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32975[rsp]
  001dd	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv142[rsp]
  001e2	88 81 e0 00 00
	00		 mov	 BYTE PTR [rcx+224], al

; 242  : 
; 243  : 	// Initialize the filter chain.
; 244  : 	return lzma_raw_decoder_init(&coder->next, allocator,
; 245  : 			block->filters);

  001e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$32975[rsp]
  001ed	48 83 c1 08	 add	 rcx, 8
  001f1	4c 8b 44 24 70	 mov	 r8, QWORD PTR block$[rsp]
  001f6	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  001fa	48 8b 54 24 68	 mov	 rdx, QWORD PTR allocator$[rsp]
  001ff	e8 00 00 00 00	 call	 lzma_raw_decoder_init
$LN9@lzma_block@3:

; 246  :   }
; 247  : }

  00204	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00208	5f		 pop	 rdi
  00209	5e		 pop	 rsi
  0020a	c3		 ret	 0
lzma_block_decoder_init ENDP
END
