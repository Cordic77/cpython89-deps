; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_vli_decode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\vli_decoder.c
pdata	SEGMENT
$pdata$lzma_vli_decode DD imagerel $LN20
	DD	imagerel $LN20+448
	DD	imagerel $unwind$lzma_vli_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_vli_decode DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_vli_decode
_TEXT	SEGMENT
vli_pos_internal$ = 0
byte$32828 = 8
tv88 = 12
tv92 = 16
vli$ = 48
vli_pos$ = 56
in$ = 64
in_pos$ = 72
in_size$ = 80
lzma_vli_decode PROC					; COMDAT

; 20   : {

$LN20:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 21   : 	// If we haven't been given vli_pos, work in single-call mode.
; 22   : 	size_t vli_pos_internal = 0;

  00018	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR vli_pos_internal$[rsp], 0

; 23   : 	if (vli_pos == NULL) {

  00020	48 83 7c 24 38
	00		 cmp	 QWORD PTR vli_pos$[rsp], 0
  00026	75 30		 jne	 SHORT $LN13@lzma_vli_d

; 24   : 		vli_pos = &vli_pos_internal;

  00028	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  0002c	48 89 44 24 38	 mov	 QWORD PTR vli_pos$[rsp], rax

; 25   : 		*vli = 0;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR vli$[rsp]
  00036	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 26   : 
; 27   : 		// If there's no input, use LZMA_DATA_ERROR. This way it is
; 28   : 		// easy to decode VLIs from buffers that have known size,
; 29   : 		// and get the correct error code in case the buffer is
; 30   : 		// too short.
; 31   : 		if (*in_pos >= in_size)

  0003d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR in_size$[rsp]
  00047	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0004a	72 0a		 jb	 SHORT $LN12@lzma_vli_d

; 32   : 			return LZMA_DATA_ERROR;

  0004c	b8 09 00 00 00	 mov	 eax, 9
  00051	e9 65 01 00 00	 jmp	 $LN14@lzma_vli_d
$LN12@lzma_vli_d:

; 33   : 
; 34   : 	} else {

  00056	eb 61		 jmp	 SHORT $LN11@lzma_vli_d
$LN13@lzma_vli_d:

; 35   : 		// Initialize *vli when starting to decode a new integer.
; 36   : 		if (*vli_pos == 0)

  00058	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  0005d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00061	75 0c		 jne	 SHORT $LN10@lzma_vli_d

; 37   : 			*vli = 0;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR vli$[rsp]
  00068	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN10@lzma_vli_d:

; 38   : 
; 39   : 		// Validate the arguments.
; 40   : 		if (*vli_pos >= LZMA_VLI_BYTES_MAX
; 41   : 				|| (*vli >> (*vli_pos * 7)) != 0)

  0006f	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  00074	48 83 38 09	 cmp	 QWORD PTR [rax], 9
  00078	73 1c		 jae	 SHORT $LN8@lzma_vli_d
  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vli_pos$[rsp]
  0007f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00082	48 6b c9 07	 imul	 rcx, 7
  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR vli$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 d3 e8	 shr	 rax, cl
  00091	48 85 c0	 test	 rax, rax
  00094	74 0a		 je	 SHORT $LN9@lzma_vli_d
$LN8@lzma_vli_d:

; 42   : 			return LZMA_PROG_ERROR;;

  00096	b8 0b 00 00 00	 mov	 eax, 11
  0009b	e9 1b 01 00 00	 jmp	 $LN14@lzma_vli_d
$LN9@lzma_vli_d:

; 43   : 
; 44   : 		if (*in_pos >= in_size)

  000a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR in_size$[rsp]
  000aa	48 39 01	 cmp	 QWORD PTR [rcx], rax
  000ad	72 0a		 jb	 SHORT $LN7@lzma_vli_d

; 45   : 			return LZMA_BUF_ERROR;

  000af	b8 0a 00 00 00	 mov	 eax, 10
  000b4	e9 02 01 00 00	 jmp	 $LN14@lzma_vli_d
$LN7@lzma_vli_d:
$LN11@lzma_vli_d:
$LN6@lzma_vli_d:

; 46   : 	}
; 47   : 
; 48   : 	do {
; 49   : 		// Read the next byte. Use a temporary variable so that we
; 50   : 		// can update *in_pos immediately.
; 51   : 		const uint8_t byte = in[*in_pos];

  000b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000be	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR in$[rsp]
  000c6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ca	88 44 24 08	 mov	 BYTE PTR byte$32828[rsp], al

; 52   : 		++*in_pos;

  000ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_pos$[rsp]
  000d3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d6	48 83 c1 01	 add	 rcx, 1
  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR in_pos$[rsp]
  000df	48 89 08	 mov	 QWORD PTR [rax], rcx

; 53   : 
; 54   : 		// Add the newly read byte to *vli.
; 55   : 		*vli += (lzma_vli)(byte & 0x7F) << (*vli_pos * 7);

  000e2	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$32828[rsp]
  000e7	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ea	48 63 d0	 movsxd	 rdx, eax
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  000f2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f5	48 6b c0 07	 imul	 rax, 7
  000f9	0f b6 c8	 movzx	 ecx, al
  000fc	48 8b c2	 mov	 rax, rdx
  000ff	48 d3 e0	 shl	 rax, cl
  00102	48 8b c8	 mov	 rcx, rax
  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR vli$[rsp]
  0010a	48 03 08	 add	 rcx, QWORD PTR [rax]
  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR vli$[rsp]
  00112	48 89 08	 mov	 QWORD PTR [rax], rcx

; 56   : 		++*vli_pos;

  00115	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vli_pos$[rsp]
  0011a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0011d	48 83 c1 01	 add	 rcx, 1
  00121	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  00126	48 89 08	 mov	 QWORD PTR [rax], rcx

; 57   : 
; 58   : 		// Check if this is the last byte of a multibyte integer.
; 59   : 		if ((byte & 0x80) == 0) {

  00129	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$32828[rsp]
  0012e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00133	85 c0		 test	 eax, eax
  00135	75 3e		 jne	 SHORT $LN3@lzma_vli_d

; 60   : 			// We don't allow using variable-length integers as
; 61   : 			// padding i.e. the encoding must use the most the
; 62   : 			// compact form.
; 63   : 			if (byte == 0x00 && *vli_pos > 1)

  00137	0f b6 44 24 08	 movzx	 eax, BYTE PTR byte$32828[rsp]
  0013c	85 c0		 test	 eax, eax
  0013e	75 12		 jne	 SHORT $LN2@lzma_vli_d
  00140	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  00145	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00149	76 07		 jbe	 SHORT $LN2@lzma_vli_d

; 64   : 				return LZMA_DATA_ERROR;

  0014b	b8 09 00 00 00	 mov	 eax, 9
  00150	eb 69		 jmp	 SHORT $LN14@lzma_vli_d
$LN2@lzma_vli_d:

; 65   : 
; 66   : 			return vli_pos == &vli_pos_internal
; 67   : 					? LZMA_OK : LZMA_STREAM_END;

  00152	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  00156	48 39 44 24 38	 cmp	 QWORD PTR vli_pos$[rsp], rax
  0015b	75 0a		 jne	 SHORT $LN16@lzma_vli_d
  0015d	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
  00165	eb 08		 jmp	 SHORT $LN17@lzma_vli_d
$LN16@lzma_vli_d:
  00167	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
$LN17@lzma_vli_d:
  0016f	8b 44 24 0c	 mov	 eax, DWORD PTR tv88[rsp]
  00173	eb 46		 jmp	 SHORT $LN14@lzma_vli_d
$LN3@lzma_vli_d:

; 68   : 		}
; 69   : 
; 70   : 		// There is at least one more byte coming. If we have already
; 71   : 		// read maximum number of bytes, the integer is considered
; 72   : 		// corrupt.
; 73   : 		//
; 74   : 		// If we need bigger integers in future, old versions liblzma
; 75   : 		// will confusingly indicate the file being corrupt istead of
; 76   : 		// unsupported. I suppose it's still better this way, because
; 77   : 		// in the foreseeable future (writing this in 2008) the only
; 78   : 		// reason why files would appear having over 63-bit integers
; 79   : 		// is that the files are simply corrupt.
; 80   : 		if (*vli_pos == LZMA_VLI_BYTES_MAX)

  00175	48 8b 44 24 38	 mov	 rax, QWORD PTR vli_pos$[rsp]
  0017a	48 83 38 09	 cmp	 QWORD PTR [rax], 9
  0017e	75 07		 jne	 SHORT $LN1@lzma_vli_d

; 81   : 			return LZMA_DATA_ERROR;

  00180	b8 09 00 00 00	 mov	 eax, 9
  00185	eb 34		 jmp	 SHORT $LN14@lzma_vli_d
$LN1@lzma_vli_d:

; 82   : 
; 83   : 	} while (*in_pos < in_size);

  00187	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_pos$[rsp]
  0018c	48 8b 44 24 50	 mov	 rax, QWORD PTR in_size$[rsp]
  00191	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00194	0f 82 1f ff ff
	ff		 jb	 $LN6@lzma_vli_d

; 84   : 
; 85   : 	return vli_pos == &vli_pos_internal ? LZMA_DATA_ERROR : LZMA_OK;

  0019a	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  0019e	48 39 44 24 38	 cmp	 QWORD PTR vli_pos$[rsp], rax
  001a3	75 0a		 jne	 SHORT $LN18@lzma_vli_d
  001a5	c7 44 24 10 09
	00 00 00	 mov	 DWORD PTR tv92[rsp], 9
  001ad	eb 08		 jmp	 SHORT $LN19@lzma_vli_d
$LN18@lzma_vli_d:
  001af	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN19@lzma_vli_d:
  001b7	8b 44 24 10	 mov	 eax, DWORD PTR tv92[rsp]
$LN14@lzma_vli_d:

; 86   : }

  001bb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001bf	c3		 ret	 0
lzma_vli_decode ENDP
END
