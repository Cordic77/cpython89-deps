; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_decoder.c
;	COMDAT stream_flags_decode
_TEXT	SEGMENT
options$ = 8
in$ = 16
stream_flags_decode PROC				; COMDAT

; 18   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 19   : 	// Reserved bits must be unset.
; 20   : 	if (in[0] != 0x00 || (in[1] & 0xF0))

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR in$[rsp]
  0000f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00012	85 c0		 test	 eax, eax
  00014	75 12		 jne	 SHORT $LN1@stream_fla
  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR in$[rsp]
  0001b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00024	85 c0		 test	 eax, eax
  00026	74 04		 je	 SHORT $LN2@stream_fla
$LN1@stream_fla:

; 21   : 		return true;

  00028	b0 01		 mov	 al, 1
  0002a	eb 21		 jmp	 SHORT $LN3@stream_fla
$LN2@stream_fla:

; 22   : 
; 23   : 	options->version = 0;

  0002c	48 8b 44 24 08	 mov	 rax, QWORD PTR options$[rsp]
  00031	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 24   : 	options->check = in[1] & 0x0F;

  00037	48 8b 44 24 10	 mov	 rax, QWORD PTR in$[rsp]
  0003c	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00040	83 e1 0f	 and	 ecx, 15
  00043	48 8b 44 24 08	 mov	 rax, QWORD PTR options$[rsp]
  00048	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 25   : 
; 26   : 	return false;

  0004b	32 c0		 xor	 al, al
$LN3@stream_fla:

; 27   : }

  0004d	f3 c3		 fatret	 0
stream_flags_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$read32le DD imagerel read32le
	DD	imagerel read32le+27
	DD	imagerel $unwind$read32le
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read32le DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read32le
_TEXT	SEGMENT
num$ = 0
buf$ = 32
read32le PROC						; COMDAT

; 220  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 221  : 	uint32_t num = *(const uint32_t *)buf;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR num$[rsp], eax

; 222  : 	return conv32le(num);

  00013	8b 04 24	 mov	 eax, DWORD PTR num$[rsp]

; 223  : }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
read32le ENDP
PUBLIC	lzma_stream_footer_decode
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_stream_footer_decode DD imagerel $LN10
	DD	imagerel $LN10+200
	DD	imagerel $unwind$lzma_stream_footer_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_footer_decode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_decoder.c
xdata	ENDS
;	COMDAT lzma_stream_footer_decode
_TEXT	SEGMENT
crc$32836 = 32
num$37147 = 36
num$37151 = 40
options$ = 64
in$ = 72
lzma_stream_footer_decode PROC				; COMDAT

; 63   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 64   : 	// Magic
; 65   : 	if (memcmp(in + sizeof(uint32_t) * 2 + LZMA_STREAM_FLAGS_SIZE,
; 66   : 			lzma_footer_magic, sizeof(lzma_footer_magic)) != 0)

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  00013	48 83 c1 0a	 add	 rcx, 10
  00017	41 b8 02 00 00
	00		 mov	 r8d, 2
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_footer_magic
  00024	e8 00 00 00 00	 call	 memcmp
  00029	85 c0		 test	 eax, eax
  0002b	74 0a		 je	 SHORT $LN3@lzma_strea

; 67   : 		return LZMA_FORMAT_ERROR;

  0002d	b8 07 00 00 00	 mov	 eax, 7
  00032	e9 8c 00 00 00	 jmp	 $LN4@lzma_strea
$LN3@lzma_strea:

; 68   : 
; 69   : 	// CRC32
; 70   :   {
; 71   : 	const uint32_t crc = lzma_crc32(in + sizeof(uint32_t),
; 72   : 			sizeof(uint32_t) + LZMA_STREAM_FLAGS_SIZE, 0);

  00037	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  0003c	48 83 c1 04	 add	 rcx, 4
  00040	45 33 c0	 xor	 r8d, r8d
  00043	ba 06 00 00 00	 mov	 edx, 6
  00048	e8 00 00 00 00	 call	 lzma_crc32
  0004d	89 44 24 20	 mov	 DWORD PTR crc$32836[rsp], eax

; 73   : 	if (crc != unaligned_read32le(in))

  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR in$[rsp]
  00056	8b 00		 mov	 eax, DWORD PTR [rax]
  00058	89 44 24 24	 mov	 DWORD PTR num$37147[rsp], eax
  0005c	8b 44 24 24	 mov	 eax, DWORD PTR num$37147[rsp]
  00060	39 44 24 20	 cmp	 DWORD PTR crc$32836[rsp], eax
  00064	74 07		 je	 SHORT $LN2@lzma_strea

; 74   : 		return LZMA_DATA_ERROR;

  00066	b8 09 00 00 00	 mov	 eax, 9
  0006b	eb 56		 jmp	 SHORT $LN4@lzma_strea
$LN2@lzma_strea:

; 75   :   }
; 76   : 
; 77   : 	// Stream Flags
; 78   : 	if (stream_flags_decode(options, in + sizeof(uint32_t) * 2))

  0006d	48 8b 54 24 48	 mov	 rdx, QWORD PTR in$[rsp]
  00072	48 83 c2 08	 add	 rdx, 8
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  0007b	e8 00 00 00 00	 call	 stream_flags_decode
  00080	0f b6 c0	 movzx	 eax, al
  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN1@lzma_strea

; 79   : 		return LZMA_OPTIONS_ERROR;

  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	eb 35		 jmp	 SHORT $LN4@lzma_strea
$LN1@lzma_strea:

; 80   : 
; 81   : 	// Backward Size
; 82   : 	options->backward_size = unaligned_read32le(in + sizeof(uint32_t));

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR in$[rsp]
  00093	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00096	89 44 24 28	 mov	 DWORD PTR num$37151[rsp], eax
  0009a	8b 4c 24 28	 mov	 ecx, DWORD PTR num$37151[rsp]
  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  000a3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 83   : 	options->backward_size = (options->backward_size + 1) * 4;

  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  000ac	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b0	48 8d 0c 8d 04
	00 00 00	 lea	 rcx, QWORD PTR [rcx*4+4]
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  000bd	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 84   : 
; 85   : 	return LZMA_OK;

  000c1	33 c0		 xor	 eax, eax
$LN4@lzma_strea:

; 86   : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
lzma_stream_footer_decode ENDP
_TEXT	ENDS
PUBLIC	lzma_stream_header_decode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\common\tuklib_integer.h
pdata	SEGMENT
$pdata$lzma_stream_header_decode DD imagerel $LN8
	DD	imagerel $LN8+156
	DD	imagerel $unwind$lzma_stream_header_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_stream_header_decode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\stream_flags_decoder.c
xdata	ENDS
;	COMDAT lzma_stream_header_decode
_TEXT	SEGMENT
crc$32826 = 32
num$37161 = 36
options$ = 64
in$ = 72
lzma_stream_header_decode PROC				; COMDAT

; 32   : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 33   : 	// Magic
; 34   : 	if (memcmp(in, lzma_header_magic, sizeof(lzma_header_magic)) != 0)

  0000e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_header_magic
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  00020	e8 00 00 00 00	 call	 memcmp
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN3@lzma_strea@2

; 35   : 		return LZMA_FORMAT_ERROR;

  00029	b8 07 00 00 00	 mov	 eax, 7
  0002e	eb 67		 jmp	 SHORT $LN4@lzma_strea@2
$LN3@lzma_strea@2:

; 36   : 
; 37   : 	// Verify the CRC32 so we can distinguish between corrupt
; 38   : 	// and unsupported files.
; 39   :   {
; 40   : 	const uint32_t crc = lzma_crc32(in + sizeof(lzma_header_magic),
; 41   : 			LZMA_STREAM_FLAGS_SIZE, 0);

  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  00035	48 83 c1 06	 add	 rcx, 6
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	ba 02 00 00 00	 mov	 edx, 2
  00041	e8 00 00 00 00	 call	 lzma_crc32
  00046	89 44 24 20	 mov	 DWORD PTR crc$32826[rsp], eax

; 42   : 	if (crc != unaligned_read32le(in + sizeof(lzma_header_magic)
; 43   : 			+ LZMA_STREAM_FLAGS_SIZE))

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR in$[rsp]
  0004f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00052	89 44 24 24	 mov	 DWORD PTR num$37161[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR num$37161[rsp]
  0005a	39 44 24 20	 cmp	 DWORD PTR crc$32826[rsp], eax
  0005e	74 07		 je	 SHORT $LN2@lzma_strea@2

; 44   : 		return LZMA_DATA_ERROR;

  00060	b8 09 00 00 00	 mov	 eax, 9
  00065	eb 30		 jmp	 SHORT $LN4@lzma_strea@2
$LN2@lzma_strea@2:

; 45   :   }
; 46   : 
; 47   : 	// Stream Flags
; 48   : 	if (stream_flags_decode(options, in + sizeof(lzma_header_magic)))

  00067	48 8b 54 24 48	 mov	 rdx, QWORD PTR in$[rsp]
  0006c	48 83 c2 06	 add	 rdx, 6
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR options$[rsp]
  00075	e8 00 00 00 00	 call	 stream_flags_decode
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	85 c0		 test	 eax, eax
  0007f	74 07		 je	 SHORT $LN1@lzma_strea@2

; 49   : 		return LZMA_OPTIONS_ERROR;

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	eb 0f		 jmp	 SHORT $LN4@lzma_strea@2
$LN1@lzma_strea@2:

; 50   : 
; 51   : 	// Set Backward Size to indicate unknown value. That way
; 52   : 	// lzma_stream_flags_compare() can be used to compare Stream Header
; 53   : 	// and Stream Footer while keeping it useful also for comparing
; 54   : 	// two Stream Footers.
; 55   : 	options->backward_size = LZMA_VLI_UNKNOWN;

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR options$[rsp]
  0008d	48 c7 40 08 ff
	ff ff ff	 mov	 QWORD PTR [rax+8], -1

; 56   : 
; 57   : 	return LZMA_OK;

  00095	33 c0		 xor	 eax, eax
$LN4@lzma_strea@2:

; 58   : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
lzma_stream_header_decode ENDP
END
