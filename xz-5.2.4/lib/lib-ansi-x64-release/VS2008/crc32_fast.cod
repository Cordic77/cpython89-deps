; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_crc32
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\check\crc32_fast.c
pdata	SEGMENT
$pdata$lzma_crc32 DD imagerel $LN10
	DD	imagerel $LN10+570
	DD	imagerel $unwind$lzma_crc32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_crc32 DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_crc32
_TEXT	SEGMENT
limit$32869 = 0
tmp$32876 = 8
buf$ = 32
size$ = 40
crc$ = 48
lzma_crc32 PROC						; COMDAT

; 31   : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 32   : 	crc = ~crc;

  00013	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  00017	f7 d0		 not	 eax
  00019	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax

; 33   : 
; 34   : #ifdef WORDS_BIGENDIAN
; 35   : 	crc = bswap32(crc);
; 36   : #endif
; 37   : 
; 38   : 	if (size > 8) {

  0001d	48 83 7c 24 28
	08		 cmp	 QWORD PTR size$[rsp], 8
  00023	0f 86 b1 01 00
	00		 jbe	 $LN7@lzma_crc32
$LN6@lzma_crc32:

; 39   : 		// Fix the alignment, if needed. The if statement above
; 40   : 		// ensures that this won't read past the end of buf[].
; 41   : 		while ((uintptr_t)(buf) & 7) {

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  0002e	48 83 e0 07	 and	 rax, 7
  00032	48 85 c0	 test	 rax, rax
  00035	74 4b		 je	 SHORT $LN5@lzma_crc32

; 42   : 			crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	8b 4c 24 30	 mov	 ecx, DWORD PTR crc$[rsp]
  00043	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00049	33 c1		 xor	 eax, ecx
  0004b	8b d0		 mov	 edx, eax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  00054	8b 4c 24 30	 mov	 ecx, DWORD PTR crc$[rsp]
  00058	c1 e9 08	 shr	 ecx, 8
  0005b	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  0005e	33 c1		 xor	 eax, ecx
  00060	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  00069	48 83 c0 01	 add	 rax, 1
  0006d	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 43   : 			--size;

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00077	48 83 e8 01	 sub	 rax, 1
  0007b	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 44   : 		}

  00080	eb a7		 jmp	 SHORT $LN6@lzma_crc32
$LN5@lzma_crc32:

; 45   : 
; 46   : 		// Calculate the position where to stop.
; 47   : 	  {
; 48   : 		const uint8_t *const limit = buf + (size & ~(size_t)(7));

  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  00087	48 83 e1 f8	 and	 rcx, -8
  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  00090	48 03 c1	 add	 rax, rcx
  00093	48 89 04 24	 mov	 QWORD PTR limit$32869[rsp], rax

; 49   : 
; 50   : 		// Calculate how many bytes must be calculated separately
; 51   : 		// before returning the result.
; 52   : 		size &= (size_t)(7);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  0009c	48 83 e0 07	 and	 rax, 7
  000a0	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
$LN4@lzma_crc32:

; 53   : 
; 54   : 		// Calculate the CRC32 using the slice-by-eight algorithm.
; 55   : 		while (buf < limit) {

  000a5	48 8b 04 24	 mov	 rax, QWORD PTR limit$32869[rsp]
  000a9	48 39 44 24 20	 cmp	 QWORD PTR buf$[rsp], rax
  000ae	0f 83 26 01 00
	00		 jae	 $LN3@lzma_crc32

; 56   : 			crc ^= *(const uint32_t *)(buf);

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  000b9	8b 08		 mov	 ecx, DWORD PTR [rax]
  000bb	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  000bf	33 c1		 xor	 eax, ecx
  000c1	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax

; 57   : 			buf += 4;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  000ca	48 83 c0 04	 add	 rax, 4
  000ce	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 58   : 
; 59   : 			crc = lzma_crc32_table[7][A(crc)]
; 60   : 			    ^ lzma_crc32_table[6][B(crc)]
; 61   : 			    ^ lzma_crc32_table[5][C(crc)]
; 62   : 			    ^ lzma_crc32_table[4][D(crc)];

  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:lzma_crc32_table
  000da	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  000de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000e3	8b d0		 mov	 edx, eax
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_crc32_table
  000ec	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  000f0	c1 e8 08	 shr	 eax, 8
  000f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f8	8b c0		 mov	 eax, eax
  000fa	8b 84 81 00 18
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+6144]
  00101	45 8b 84 90 00
	1c 00 00	 mov	 r8d, DWORD PTR [r8+rdx*4+7168]
  00109	44 33 c0	 xor	 r8d, eax
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_crc32_table
  00113	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  00117	c1 e8 10	 shr	 eax, 16
  0011a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0011f	8b c0		 mov	 eax, eax
  00121	44 33 84 81 00
	14 00 00	 xor	 r8d, DWORD PTR [rcx+rax*4+5120]
  00129	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lzma_crc32_table
  00130	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  00134	c1 e8 18	 shr	 eax, 24
  00137	8b c8		 mov	 ecx, eax
  00139	41 8b c0	 mov	 eax, r8d
  0013c	33 84 8a 00 10
	00 00		 xor	 eax, DWORD PTR [rdx+rcx*4+4096]
  00143	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax

; 63   : 
; 64   : 		  {
; 65   : 			const uint32_t tmp = *(const uint32_t *)(buf);

  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  0014c	8b 00		 mov	 eax, DWORD PTR [rax]
  0014e	89 44 24 08	 mov	 DWORD PTR tmp$32876[rsp], eax

; 66   : 			buf += 4;

  00152	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  00157	48 83 c0 04	 add	 rax, 4
  0015b	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 67   : 
; 68   : 			// At least with some compilers, it is critical for
; 69   : 			// performance, that the crc variable is XORed
; 70   : 			// between the two table-lookup pairs.
; 71   : 			crc = lzma_crc32_table[3][A(tmp)]
; 72   : 			    ^ lzma_crc32_table[2][B(tmp)]
; 73   : 			    ^ crc
; 74   : 			    ^ lzma_crc32_table[1][C(tmp)]
; 75   : 			    ^ lzma_crc32_table[0][D(tmp)];

  00160	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:lzma_crc32_table
  00167	8b 44 24 08	 mov	 eax, DWORD PTR tmp$32876[rsp]
  0016b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00170	8b d0		 mov	 edx, eax
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_crc32_table
  00179	8b 44 24 08	 mov	 eax, DWORD PTR tmp$32876[rsp]
  0017d	c1 e8 08	 shr	 eax, 8
  00180	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00185	8b c0		 mov	 eax, eax
  00187	8b 84 81 00 08
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+2048]
  0018e	45 8b 84 90 00
	0c 00 00	 mov	 r8d, DWORD PTR [r8+rdx*4+3072]
  00196	44 33 c0	 xor	 r8d, eax
  00199	44 33 44 24 30	 xor	 r8d, DWORD PTR crc$[rsp]
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_crc32_table
  001a5	8b 44 24 08	 mov	 eax, DWORD PTR tmp$32876[rsp]
  001a9	c1 e8 10	 shr	 eax, 16
  001ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b1	8b c0		 mov	 eax, eax
  001b3	44 33 84 81 00
	04 00 00	 xor	 r8d, DWORD PTR [rcx+rax*4+1024]
  001bb	8b 44 24 08	 mov	 eax, DWORD PTR tmp$32876[rsp]
  001bf	c1 e8 18	 shr	 eax, 24
  001c2	8b d0		 mov	 edx, eax
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lzma_crc32_table
  001cb	41 8b c0	 mov	 eax, r8d
  001ce	33 04 91	 xor	 eax, DWORD PTR [rcx+rdx*4]
  001d1	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax

; 76   : 		  }
; 77   : 		}

  001d5	e9 cb fe ff ff	 jmp	 $LN4@lzma_crc32
$LN3@lzma_crc32:
$LN7@lzma_crc32:
$LN2@lzma_crc32:

; 78   : 	  }
; 79   : 	}
; 80   : 
; 81   : 	while (size-- != 0)

  001da	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  001df	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  001e4	48 83 e8 01	 sub	 rax, 1
  001e8	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  001ed	48 85 c9	 test	 rcx, rcx
  001f0	74 3d		 je	 SHORT $LN1@lzma_crc32

; 82   : 		crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);

  001f2	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  001f7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fa	8b 4c 24 30	 mov	 ecx, DWORD PTR crc$[rsp]
  001fe	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00204	33 c1		 xor	 eax, ecx
  00206	8b d0		 mov	 edx, eax
  00208	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lzma_crc32_table
  0020f	8b 4c 24 30	 mov	 ecx, DWORD PTR crc$[rsp]
  00213	c1 e9 08	 shr	 ecx, 8
  00216	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00219	33 c1		 xor	 eax, ecx
  0021b	89 44 24 30	 mov	 DWORD PTR crc$[rsp], eax
  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR buf$[rsp]
  00224	48 83 c0 01	 add	 rax, 1
  00228	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax
  0022d	eb ab		 jmp	 SHORT $LN2@lzma_crc32
$LN1@lzma_crc32:

; 83   : 
; 84   : #ifdef WORDS_BIGENDIAN
; 85   : 	crc = bswap32(crc);
; 86   : #endif
; 87   : 
; 88   : 	return ~crc;

  0022f	8b 44 24 30	 mov	 eax, DWORD PTR crc$[rsp]
  00233	f7 d0		 not	 eax

; 89   : }

  00235	48 83 c4 18	 add	 rsp, 24
  00239	c3		 ret	 0
lzma_crc32 ENDP
END
