; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_delta_coder_memusage
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\delta\delta_common.c
pdata	SEGMENT
$pdata$lzma_delta_coder_memusage DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$lzma_delta_coder_memusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_delta_coder_memusage DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_delta_coder_memusage
_TEXT	SEGMENT
opt$ = 0
options$ = 32
lzma_delta_coder_memusage PROC				; COMDAT

; 66   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 67   : 	const lzma_options_delta *opt = options;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR options$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR opt$[rsp], rax

; 68   : 
; 69   : 	if (opt == NULL || opt->type != LZMA_DELTA_TYPE_BYTE
; 70   : 			|| opt->dist < LZMA_DELTA_DIST_MIN
; 71   : 			|| opt->dist > LZMA_DELTA_DIST_MAX)

  00012	48 83 3c 24 00	 cmp	 QWORD PTR opt$[rsp], 0
  00017	74 20		 je	 SHORT $LN1@lzma_delta
  00019	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  0001d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00020	75 17		 jne	 SHORT $LN1@lzma_delta
  00022	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00026	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  0002a	72 0d		 jb	 SHORT $LN1@lzma_delta
  0002c	48 8b 04 24	 mov	 rax, QWORD PTR opt$[rsp]
  00030	81 78 04 00 01
	00 00		 cmp	 DWORD PTR [rax+4], 256	; 00000100H
  00037	76 09		 jbe	 SHORT $LN2@lzma_delta
$LN1@lzma_delta:

; 72   : 		return UINT64_MAX;

  00039	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00040	eb 0a		 jmp	 SHORT $LN3@lzma_delta
$LN2@lzma_delta:

; 73   : 
; 74   : 	return sizeof(lzma_delta_coder);

  00042	48 b8 58 01 00
	00 00 00 00 00	 mov	 rax, 344		; 00000158H
$LN3@lzma_delta:

; 75   : }

  0004c	48 83 c4 18	 add	 rsp, 24
  00050	c3		 ret	 0
lzma_delta_coder_memusage ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_coder_end DD imagerel delta_coder_end
	DD	imagerel delta_coder_end+59
	DD	imagerel $unwind$delta_coder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_coder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_coder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
delta_coder_end PROC					; COMDAT

; 19   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   : 	lzma_delta_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 21   : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 22   : 	lzma_free(coder, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	e8 00 00 00 00	 call	 lzma_free

; 23   : 	return;
; 24   : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
delta_coder_end ENDP
PUBLIC	lzma_delta_coder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_delta_coder_init DD imagerel $LN6
	DD	imagerel $LN6+248
	DD	imagerel $unwind$lzma_delta_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_delta_coder_init DD 031501H
	DD	070116215H
	DD	06010H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_delta_coder_init
_TEXT	SEGMENT
coder$ = 32
opt$32844 = 40
next$ = 80
allocator$ = 88
filters$ = 96
lzma_delta_coder_init PROC				; COMDAT

; 30   : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 31   : 	// Allocate memory for the decoder if needed.
; 32   : 	lzma_delta_coder *coder = next->coder;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 33   : 	if (coder == NULL) {

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00028	75 56		 jne	 SHORT $LN3@lzma_delta@3

; 34   : 		coder = lzma_alloc(sizeof(lzma_delta_coder), allocator);

  0002a	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002f	b9 58 01 00 00	 mov	 ecx, 344		; 00000158H
  00034	e8 00 00 00 00	 call	 lzma_alloc
  00039	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 35   : 		if (coder == NULL)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00044	75 0a		 jne	 SHORT $LN2@lzma_delta@3

; 36   : 			return LZMA_MEM_ERROR;

  00046	b8 05 00 00 00	 mov	 eax, 5
  0004b	e9 a1 00 00 00	 jmp	 $LN4@lzma_delta@3
$LN2@lzma_delta@3:

; 37   : 
; 38   : 		next->coder = coder;

  00050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0005a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 39   : 
; 40   : 		// End function is the same for encoder and decoder.
; 41   : 		next->end = &delta_coder_end;

  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:delta_coder_end
  00069	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 42   : 		coder->next = LZMA_NEXT_CODER_INIT;

  0006d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  00074	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  00079	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0007e	f3 a4		 rep movsb
$LN3@lzma_delta@3:

; 43   : 	}
; 44   : 
; 45   : 	// Validate the options.
; 46   : 	if (lzma_delta_coder_memusage(filters[0].options) == UINT64_MAX)

  00080	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filters$[rsp]
  00085	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00089	e8 00 00 00 00	 call	 lzma_delta_coder_memusage
  0008e	48 83 f8 ff	 cmp	 rax, -1
  00092	75 07		 jne	 SHORT $LN1@lzma_delta@3

; 47   : 		return LZMA_OPTIONS_ERROR;

  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	eb 56		 jmp	 SHORT $LN4@lzma_delta@3
$LN1@lzma_delta@3:

; 48   : 
; 49   : 	// Set the delta distance.
; 50   :   {
; 51   :   const lzma_options_delta *opt = filters[0].options;

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR filters$[rsp]
  000a0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a4	48 89 44 24 28	 mov	 QWORD PTR opt$32844[rsp], rax

; 52   : 	coder->distance = opt->dist;

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR opt$32844[rsp]
  000ae	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000b6	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 53   :   }
; 54   : 
; 55   : 	// Initialize the rest of the variables.
; 56   : 	coder->pos = 0;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000bf	c6 40 50 00	 mov	 BYTE PTR [rax+80], 0

; 57   : 	memzero(coder->history, LZMA_DELTA_DIST_MAX);

  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000c8	48 83 c1 51	 add	 rcx, 81			; 00000051H
  000cc	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000d2	33 d2		 xor	 edx, edx
  000d4	e8 00 00 00 00	 call	 memset

; 58   : 
; 59   : 	// Initialize the next decoder in the chain, if any.
; 60   : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  000d9	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  000de	49 83 c0 18	 add	 r8, 24
  000e2	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  000e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  000ec	e8 00 00 00 00	 call	 lzma_next_filter_init
$LN4@lzma_delta@3:

; 61   : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	5f		 pop	 rdi
  000f6	5e		 pop	 rsi
  000f7	c3		 ret	 0
lzma_delta_coder_init ENDP
END
