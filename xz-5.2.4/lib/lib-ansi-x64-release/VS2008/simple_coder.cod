; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\simple\simple_coder.c
pdata	SEGMENT
$pdata$call_filter DD imagerel call_filter
	DD	imagerel call_filter+105
	DD	imagerel $unwind$call_filter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_filter DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT call_filter
_TEXT	SEGMENT
filtered$ = 48
coder$ = 80
buffer$ = 88
size$ = 96
call_filter PROC					; COMDAT

; 59   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 60   : 	const size_t filtered = coder->filter(coder->simple,
; 61   : 			coder->now_pos, coder->is_encoder,
; 62   : 			buffer, size);

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR size$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	4c 8b 4c 24 58	 mov	 r9, QWORD PTR buffer$[rsp]
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00027	44 0f b6 40 49	 movzx	 r8d, BYTE PTR [rax+73]
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00031	8b 50 60	 mov	 edx, DWORD PTR [rax+96]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00039	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00042	ff 50 50	 call	 QWORD PTR [rax+80]
  00045	48 89 44 24 30	 mov	 QWORD PTR filtered$[rsp], rax

; 63   : //W coder->now_pos += filtered;
; 64   :     coder->now_pos = (uint32_t)(coder->now_pos + filtered);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0004f	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00052	48 03 4c 24 30	 add	 rcx, QWORD PTR filtered$[rsp]
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0005c	89 48 60	 mov	 DWORD PTR [rax+96], ecx

; 65   : 	return filtered;

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR filtered$[rsp]

; 66   : }

  00064	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00068	c3		 ret	 0
call_filter ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$simple_coder_update DD imagerel simple_coder_update
	DD	imagerel simple_coder_update+63
	DD	imagerel $unwind$simple_coder_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$simple_coder_update DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT simple_coder_update
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
filters_null$ = 80
reversed_filters$ = 88
simple_coder_update PROC				; COMDAT

; 222  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 223  : 	lzma_simple_coder *coder = coder_ptr;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 224  : 
; 225  : 	// No update support, just call the next filter in the chain.
; 226  : 	return lzma_next_filter_update(
; 227  : 			&coder->next, allocator, reversed_filters + 1);

  00022	4c 8b 44 24 58	 mov	 r8, QWORD PTR reversed_filters$[rsp]
  00027	49 83 c0 10	 add	 r8, 16
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00035	e8 00 00 00 00	 call	 lzma_next_filter_update

; 228  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
simple_coder_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_or_code DD imagerel copy_or_code
	DD	imagerel copy_or_code+300
	DD	imagerel $unwind$copy_or_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_or_code DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT copy_or_code
_TEXT	SEGMENT
ret$32966 = 80
coder$ = 112
allocator$ = 120
in$ = 128
in_pos$ = 136
in_size$ = 144
out$ = 152
out_pos$ = 160
out_size$ = 168
action$ = 176
copy_or_code PROC					; COMDAT

; 25   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 26   : 	assert(!coder->end_was_reached);
; 27   : 
; 28   : 	if (coder->next.code == NULL) {

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  0001d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00022	75 7a		 jne	 SHORT $LN6@copy_or_co

; 29   : 		lzma_bufcpy(in, in_pos, in_size, out, out_pos, out_size);

  00024	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  00046	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR in_size$[rsp]
  0004e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR in_pos$[rsp]
  00056	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  0005e	e8 00 00 00 00	 call	 lzma_bufcpy

; 30   : 
; 31   : 		// Check if end of stream was reached.
; 32   : 		if (coder->is_encoder && action == LZMA_FINISH
; 33   : 				&& *in_pos == in_size)

  00063	4c 8b 5c 24 70	 mov	 r11, QWORD PTR coder$[rsp]
  00068	41 0f b6 43 49	 movzx	 eax, BYTE PTR [r11+73]
  0006d	85 c0		 test	 eax, eax
  0006f	74 28		 je	 SHORT $LN5@copy_or_co
  00071	83 bc 24 b0 00
	00 00 03	 cmp	 DWORD PTR action$[rsp], 3
  00079	75 1e		 jne	 SHORT $LN5@copy_or_co
  0007b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR in_pos$[rsp]
  00083	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  0008b	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0008e	75 09		 jne	 SHORT $LN5@copy_or_co

; 34   : 			coder->end_was_reached = true;

  00090	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00095	c6 40 48 01	 mov	 BYTE PTR [rax+72], 1
$LN5@copy_or_co:

; 35   : 
; 36   : 	} else {

  00099	e9 87 00 00 00	 jmp	 $LN4@copy_or_co
$LN6@copy_or_co:

; 37   : 		// Call the next coder in the chain to provide us some data.
; 38   : 		const lzma_ret ret = coder->next.code(
; 39   : 				coder->next.coder, allocator,
; 40   : 				in, in_pos, in_size,
; 41   : 				out, out_pos, out_size, action);

  0009e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  000a5	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000a9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000b1	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  000be	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  000e5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  000ed	48 8b 54 24 78	 mov	 rdx, QWORD PTR allocator$[rsp]
  000f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR coder$[rsp]
  000f7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fa	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  000ff	ff 50 18	 call	 QWORD PTR [rax+24]
  00102	89 44 24 50	 mov	 DWORD PTR ret$32966[rsp], eax

; 42   : 
; 43   : 		if (ret == LZMA_STREAM_END) {

  00106	83 7c 24 50 01	 cmp	 DWORD PTR ret$32966[rsp], 1
  0010b	75 0b		 jne	 SHORT $LN3@copy_or_co

; 44   : 			assert(!coder->is_encoder
; 45   : 					|| action == LZMA_FINISH);
; 46   : 			coder->end_was_reached = true;

  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR coder$[rsp]
  00112	c6 40 48 01	 mov	 BYTE PTR [rax+72], 1
  00116	eb 0d		 jmp	 SHORT $LN2@copy_or_co
$LN3@copy_or_co:

; 47   : 
; 48   : 		} else if (ret != LZMA_OK) {

  00118	83 7c 24 50 00	 cmp	 DWORD PTR ret$32966[rsp], 0
  0011d	74 06		 je	 SHORT $LN1@copy_or_co

; 49   : 			return ret;

  0011f	8b 44 24 50	 mov	 eax, DWORD PTR ret$32966[rsp]
  00123	eb 02		 jmp	 SHORT $LN7@copy_or_co
$LN1@copy_or_co:
$LN2@copy_or_co:
$LN4@copy_or_co:

; 50   : 		}
; 51   : 	}
; 52   : 
; 53   : 	return LZMA_OK;

  00125	33 c0		 xor	 eax, eax
$LN7@copy_or_co:

; 54   : }

  00127	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0012b	c3		 ret	 0
copy_or_code ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$simple_coder_end DD imagerel simple_coder_end
	DD	imagerel simple_coder_end+78
	DD	imagerel $unwind$simple_coder_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$simple_coder_end DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT simple_coder_end
_TEXT	SEGMENT
coder$ = 32
coder_ptr$ = 64
allocator$ = 72
simple_coder_end PROC					; COMDAT

; 209  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 210  : 	lzma_simple_coder *coder = coder_ptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 211  : 	lzma_next_end(&coder->next, allocator);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00022	e8 00 00 00 00	 call	 lzma_next_end

; 212  : 	lzma_free(coder->simple, allocator);

  00027	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00031	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00035	e8 00 00 00 00	 call	 lzma_free

; 213  : 	lzma_free(coder, allocator);

  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR allocator$[rsp]
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00044	e8 00 00 00 00	 call	 lzma_free

; 214  : 	return;
; 215  : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
simple_coder_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$simple_code DD imagerel simple_code
	DD	imagerel simple_code+1214
	DD	imagerel $unwind$simple_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$simple_code DD 021b01H
	DD	015011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT simple_code
_TEXT	SEGMENT
coder$ = 80
out_avail$33008 = 88
buf_avail$33009 = 96
out_start$33012 = 104
ret$33013 = 112
filtered$33017 = 120
size$33016 = 128
unfiltered$33018 = 136
ret$33027 = 144
coder_ptr$ = 176
allocator$ = 184
in$ = 192
in_pos$ = 200
in_size$ = 208
out$ = 216
out_pos$ = 224
out_size$ = 232
action$ = 240
simple_code PROC					; COMDAT

; 74   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 75   : 	lzma_simple_coder *coder = coder_ptr;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR coder_ptr$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR coder$[rsp], rax

; 76   : 
; 77   : 	// TODO: Add partial support for LZMA_SYNC_FLUSH. We can support it
; 78   : 	// in cases when the filter is able to filter everything. With most
; 79   : 	// simple filters it can be done at offset that is a multiple of 2,
; 80   : 	// 4, or 16. With x86 filter, it needs good luck, and thus cannot
; 81   : 	// be made to work predictably.
; 82   : 	if (action == LZMA_SYNC_FLUSH)

  00028	83 bc 24 f0 00
	00 00 01	 cmp	 DWORD PTR action$[rsp], 1
  00030	75 0a		 jne	 SHORT $LN16@simple_cod

; 83   : 		return LZMA_OPTIONS_ERROR;

  00032	b8 08 00 00 00	 mov	 eax, 8
  00037	e9 7a 04 00 00	 jmp	 $LN17@simple_cod
$LN16@simple_cod:

; 84   : 
; 85   : 	// Flush already filtered data from coder->buffer[] to out[].
; 86   : 	if (coder->pos < coder->filtered) {

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00046	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0004a	48 39 41 70	 cmp	 QWORD PTR [rcx+112], rax
  0004e	73 77		 jae	 SHORT $LN15@simple_cod

; 87   : 		lzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,
; 88   : 				out, out_pos, out_size);

  00050	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00055	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0005e	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00065	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  0006d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00072	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  00087	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  0008c	4d 8b 40 78	 mov	 r8, QWORD PTR [r8+120]
  00090	e8 00 00 00 00	 call	 lzma_bufcpy

; 89   : 
; 90   : 		// If we couldn't flush all the filtered data, return to
; 91   : 		// application immediately.
; 92   : 		if (coder->pos < coder->filtered)

  00095	4c 8b 5c 24 50	 mov	 r11, QWORD PTR coder$[rsp]
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0009f	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000a3	49 39 43 70	 cmp	 QWORD PTR [r11+112], rax
  000a7	73 07		 jae	 SHORT $LN14@simple_cod

; 93   : 			return LZMA_OK;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 06 04 00 00	 jmp	 $LN17@simple_cod
$LN14@simple_cod:

; 94   : 
; 95   : 		if (coder->end_was_reached) {

  000b0	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000b5	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  000b9	85 c0		 test	 eax, eax
  000bb	74 0a		 je	 SHORT $LN13@simple_cod

; 96   : 			assert(coder->filtered == coder->size);
; 97   : 			return LZMA_STREAM_END;

  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	e9 ef 03 00 00	 jmp	 $LN17@simple_cod
$LN13@simple_cod:
$LN15@simple_cod:

; 98   : 		}
; 99   : 	}
; 100  : 
; 101  : 	// If we get here, there is no filtered data left in the buffer.
; 102  : 	coder->filtered = 0;

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000cc	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 103  : 
; 104  : 	assert(!coder->end_was_reached);
; 105  : 
; 106  : 	// If there is more output space left than there is unfiltered data
; 107  : 	// in coder->buffer[], flush coder->buffer[] to out[], and copy/code
; 108  : 	// more data to out[] hopefully filling it completely. Then filter
; 109  : 	// the data in out[]. This step is where most of the data gets
; 110  : 	// filtered if the buffer sizes used by the application are reasonable.
; 111  :   {
; 112  : 	const size_t out_avail = out_size - *out_pos;

  000d4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000dc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000df	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  000e7	48 2b c1	 sub	 rax, rcx
  000ea	48 89 44 24 58	 mov	 QWORD PTR out_avail$33008[rsp], rax

; 113  : 	const size_t buf_avail = coder->size - coder->pos;

  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  000f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  000f9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000fd	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00104	48 2b c1	 sub	 rax, rcx
  00107	48 89 44 24 60	 mov	 QWORD PTR buf_avail$33009[rsp], rax

; 114  : 	if (out_avail > buf_avail || buf_avail == 0) {

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR buf_avail$33009[rsp]
  00111	48 39 44 24 58	 cmp	 QWORD PTR out_avail$33008[rsp], rax
  00116	77 0c		 ja	 SHORT $LN11@simple_cod
  00118	48 83 7c 24 60
	00		 cmp	 QWORD PTR buf_avail$33009[rsp], 0
  0011e	0f 85 cd 01 00
	00		 jne	 $LN12@simple_cod
$LN11@simple_cod:

; 115  : 		// Store the old position so that we know from which byte
; 116  : 		// to start filtering.
; 117  : 		const size_t out_start = *out_pos;

  00124	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0012c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012f	48 89 44 24 68	 mov	 QWORD PTR out_start$33012[rsp], rax

; 118  : 
; 119  : 		// Flush data from coder->buffer[] to out[], but don't reset
; 120  : 		// coder->pos and coder->size yet. This way the coder can be
; 121  : 		// restarted if the next filter in the chain returns e.g.
; 122  : 		// LZMA_MEM_ERROR.
; 123  : 		memcpy(out + *out_pos, coder->buffer + coder->pos, buf_avail);

  00134	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00139	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00142	48 8d 94 08 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx+136]
  0014a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00152	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00155	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0015d	48 03 c8	 add	 rcx, rax
  00160	4c 8b 44 24 60	 mov	 r8, QWORD PTR buf_avail$33009[rsp]
  00165	e8 00 00 00 00	 call	 memcpy

; 124  : 		*out_pos += buf_avail;

  0016a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00172	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00175	48 03 4c 24 60	 add	 rcx, QWORD PTR buf_avail$33009[rsp]
  0017a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00182	48 89 08	 mov	 QWORD PTR [rax], rcx

; 125  : 
; 126  : 		// Copy/Encode/Decode more data to out[].
; 127  : 		{
; 128  : 			const lzma_ret ret = copy_or_code(coder, allocator,
; 129  : 					in, in_pos, in_size,
; 130  : 					out, out_pos, out_size, action);

  00185	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  0018c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00190	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00198	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0019d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  001a5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001aa	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  001b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  001bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c4	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  001cc	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  001d4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  001e1	e8 00 00 00 00	 call	 copy_or_code
  001e6	89 44 24 70	 mov	 DWORD PTR ret$33013[rsp], eax

; 131  : 			assert(ret != LZMA_STREAM_END);
; 132  : 			if (ret != LZMA_OK)

  001ea	83 7c 24 70 00	 cmp	 DWORD PTR ret$33013[rsp], 0
  001ef	74 09		 je	 SHORT $LN10@simple_cod

; 133  : 				return ret;

  001f1	8b 44 24 70	 mov	 eax, DWORD PTR ret$33013[rsp]
  001f5	e9 bc 02 00 00	 jmp	 $LN17@simple_cod
$LN10@simple_cod:

; 134  : 		}
; 135  : 
; 136  : 		// Filter out[].
; 137  :       {
; 138  : 		const size_t size = *out_pos - out_start;

  001fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  00202	48 8b 4c 24 68	 mov	 rcx, QWORD PTR out_start$33012[rsp]
  00207	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020a	48 2b c1	 sub	 rax, rcx
  0020d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$33016[rsp], rax

; 139  : 		const size_t filtered = call_filter(
; 140  : 				coder, out + out_start, size);

  00215	48 8b 44 24 68	 mov	 rax, QWORD PTR out_start$33012[rsp]
  0021a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00222	48 03 d0	 add	 rdx, rax
  00225	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR size$33016[rsp]
  0022d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00232	e8 00 00 00 00	 call	 call_filter
  00237	48 89 44 24 78	 mov	 QWORD PTR filtered$33017[rsp], rax

; 141  : 
; 142  : 		const size_t unfiltered = size - filtered;

  0023c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR filtered$33017[rsp]
  00241	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR size$33016[rsp]
  00249	48 2b c1	 sub	 rax, rcx
  0024c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR unfiltered$33018[rsp], rax

; 143  : 		assert(unfiltered <= coder->allocated / 2);
; 144  : 
; 145  : 		// Now we can update coder->pos and coder->size, because
; 146  : 		// the next coder in the chain (if any) was successful.
; 147  : 		coder->pos = 0;

  00254	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00259	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 148  : 		coder->size = unfiltered;

  00261	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00266	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unfiltered$33018[rsp]
  0026e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 149  : 
; 150  : 		if (coder->end_was_reached) {

  00275	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0027a	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  0027e	85 c0		 test	 eax, eax
  00280	74 12		 je	 SHORT $LN9@simple_cod

; 151  : 			// The last byte has been copied to out[] already.
; 152  : 			// They are left as is.
; 153  : 			coder->size = 0;

  00282	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00287	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  00292	eb 5b		 jmp	 SHORT $LN8@simple_cod
$LN9@simple_cod:

; 154  : 
; 155  : 		} else if (unfiltered > 0) {

  00294	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR unfiltered$33018[rsp], 0
  0029d	76 50		 jbe	 SHORT $LN7@simple_cod

; 156  : 			// There is unfiltered data left in out[]. Copy it to
; 157  : 			// coder->buffer[] and rewind *out_pos appropriately.
; 158  : 			*out_pos -= unfiltered;

  0029f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR out_pos$[rsp]
  002a7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unfiltered$33018[rsp]
  002af	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002b2	48 2b c8	 sub	 rcx, rax
  002b5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  002bd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 159  : 			memcpy(coder->buffer, out + *out_pos, unfiltered);

  002c0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  002c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002cb	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  002d3	48 03 d0	 add	 rdx, rax
  002d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  002db	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  002e2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unfiltered$33018[rsp]
  002ea	e8 00 00 00 00	 call	 memcpy
$LN7@simple_cod:
$LN8@simple_cod:

; 160  : 		}

  002ef	eb 69		 jmp	 SHORT $LN6@simple_cod
$LN12@simple_cod:

; 161  : 	  }
; 162  : 	} else if (coder->pos > 0) {

  002f1	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  002f6	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  002fb	76 5d		 jbe	 SHORT $LN5@simple_cod

; 163  : 		memmove(coder->buffer, coder->buffer + coder->pos, buf_avail);

  002fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00302	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00306	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0030b	48 8d 94 08 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx+136]
  00313	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00318	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  0031f	4c 8b 44 24 60	 mov	 r8, QWORD PTR buf_avail$33009[rsp]
  00324	e8 00 00 00 00	 call	 memmove

; 164  : 		coder->size -= coder->pos;

  00329	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0032e	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00333	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00337	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0033e	48 2b c8	 sub	 rcx, rax
  00341	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00346	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 165  : 		coder->pos = 0;

  0034d	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00352	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
$LN5@simple_cod:
$LN6@simple_cod:

; 166  : 	}
; 167  :   }
; 168  : 
; 169  : 	assert(coder->pos == 0);
; 170  : 
; 171  : 	// If coder->buffer[] isn't empty, try to fill it by copying/decoding
; 172  : 	// more data. Then filter coder->buffer[] and copy the successfully
; 173  : 	// filtered data to out[]. It is probable, that some filtered and
; 174  : 	// unfiltered data will be left to coder->buffer[].
; 175  : 	if (coder->size > 0) {

  0035a	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0035f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00367	0f 86 1c 01 00
	00		 jbe	 $LN4@simple_cod

; 176  : 		{
; 177  : 			const lzma_ret ret = copy_or_code(coder, allocator,
; 178  : 					in, in_pos, in_size,
; 179  : 					coder->buffer, &coder->size,
; 180  : 					coder->allocated, action);

  0036d	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00372	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  00379	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0037e	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00385	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR action$[rsp]
  0038c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00390	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00395	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00399	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0039e	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  003a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR in_size$[rsp]
  003b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b5	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR in_pos$[rsp]
  003bd	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR in$[rsp]
  003c5	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR allocator$[rsp]
  003cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  003d2	e8 00 00 00 00	 call	 copy_or_code
  003d7	89 84 24 90 00
	00 00		 mov	 DWORD PTR ret$33027[rsp], eax

; 181  : 			assert(ret != LZMA_STREAM_END);
; 182  : 			if (ret != LZMA_OK)

  003de	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR ret$33027[rsp], 0
  003e6	74 0c		 je	 SHORT $LN3@simple_cod

; 183  : 				return ret;

  003e8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ret$33027[rsp]
  003ef	e9 c2 00 00 00	 jmp	 $LN17@simple_cod
$LN3@simple_cod:

; 184  : 		}
; 185  : 
; 186  : 		coder->filtered = call_filter(
; 187  : 				coder, coder->buffer, coder->size);

  003f4	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  003f9	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  00400	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  00405	4d 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [r8+128]
  0040c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00411	e8 00 00 00 00	 call	 call_filter
  00416	4c 8b d8	 mov	 r11, rax
  00419	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0041e	4c 89 58 78	 mov	 QWORD PTR [rax+120], r11

; 188  : 
; 189  : 		// Everything is considered to be filtered if coder->buffer[]
; 190  : 		// contains the last bytes of the data.
; 191  : 		if (coder->end_was_reached)

  00422	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00427	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  0042b	85 c0		 test	 eax, eax
  0042d	74 15		 je	 SHORT $LN2@simple_cod

; 192  : 			coder->filtered = coder->size;

  0042f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00434	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  00439	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00440	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
$LN2@simple_cod:

; 193  : 
; 194  : 		// Flush as much as possible.
; 195  : 		lzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,
; 196  : 				out, out_pos, out_size);

  00444	48 8b 54 24 50	 mov	 rdx, QWORD PTR coder$[rsp]
  00449	48 83 c2 70	 add	 rdx, 112		; 00000070H
  0044d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  00452	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00459	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR out_size$[rsp]
  00461	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00466	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR out_pos$[rsp]
  0046e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00473	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR out$[rsp]
  0047b	4c 8b 44 24 50	 mov	 r8, QWORD PTR coder$[rsp]
  00480	4d 8b 40 78	 mov	 r8, QWORD PTR [r8+120]
  00484	e8 00 00 00 00	 call	 lzma_bufcpy
$LN4@simple_cod:

; 197  : 	}
; 198  : 
; 199  : 	// Check if we got everything done.
; 200  : 	if (coder->end_was_reached && coder->pos == coder->size)

  00489	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  0048e	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  00492	85 c0		 test	 eax, eax
  00494	74 1e		 je	 SHORT $LN1@simple_cod
  00496	48 8b 4c 24 50	 mov	 rcx, QWORD PTR coder$[rsp]
  0049b	48 8b 44 24 50	 mov	 rax, QWORD PTR coder$[rsp]
  004a0	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  004a7	48 39 41 70	 cmp	 QWORD PTR [rcx+112], rax
  004ab	75 07		 jne	 SHORT $LN1@simple_cod

; 201  : 		return LZMA_STREAM_END;

  004ad	b8 01 00 00 00	 mov	 eax, 1
  004b2	eb 02		 jmp	 SHORT $LN17@simple_cod
$LN1@simple_cod:

; 202  : 
; 203  : 	return LZMA_OK;

  004b4	33 c0		 xor	 eax, eax
$LN17@simple_cod:

; 204  : }

  004b6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004bd	c3		 ret	 0
simple_code ENDP
PUBLIC	lzma_simple_coder_init
;	COMDAT pdata
pdata	SEGMENT
$pdata$lzma_simple_coder_init DD imagerel $LN11
	DD	imagerel $LN11+464
	DD	imagerel $unwind$lzma_simple_coder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_simple_coder_init DD 031a01H
	DD	07016621aH
	DD	06015H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_simple_coder_init
_TEXT	SEGMENT
coder$ = 32
simple$33090 = 40
next$ = 80
allocator$ = 88
filters$ = 96
filter$ = 104
simple_size$ = 112
unfiltered_max$ = 120
alignment$ = 128
is_encoder$ = 136
lzma_simple_coder_init PROC				; COMDAT

; 238  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 239  : 	// Allocate memory for the lzma_simple_coder structure if needed.
; 240  : 	lzma_simple_coder *coder = next->coder;

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 241  : 	if (coder == NULL) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  0002d	0f 85 e5 00 00
	00		 jne	 $LN8@lzma_simpl@2

; 242  : 		// Here we allocate space also for the temporary buffer. We
; 243  : 		// need twice the size of unfiltered_max, because then it
; 244  : 		// is always possible to filter at least unfiltered_max bytes
; 245  : 		// more data in coder->buffer[] if it can be filled completely.
; 246  : 		coder = lzma_alloc(sizeof(lzma_simple_coder)
; 247  : 				+ 2 * unfiltered_max, allocator);

  00033	48 8b 4c 24 78	 mov	 rcx, QWORD PTR unfiltered_max$[rsp]
  00038	48 8d 8c 09 88
	00 00 00	 lea	 rcx, QWORD PTR [rcx+rcx+136]
  00040	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  00045	e8 00 00 00 00	 call	 lzma_alloc
  0004a	48 89 44 24 20	 mov	 QWORD PTR coder$[rsp], rax

; 248  : 		if (coder == NULL)

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR coder$[rsp], 0
  00055	75 0a		 jne	 SHORT $LN7@lzma_simpl@2

; 249  : 			return LZMA_MEM_ERROR;

  00057	b8 05 00 00 00	 mov	 eax, 5
  0005c	e9 68 01 00 00	 jmp	 $LN9@lzma_simpl@2
$LN7@lzma_simpl@2:

; 250  : 
; 251  : 		next->coder = coder;

  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0006b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 252  : 		next->code = &simple_code;

  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:simple_code
  0007a	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 253  : 		next->end = &simple_coder_end;

  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:simple_coder_end
  0008a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 254  : 		next->update = &simple_coder_update;

  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:simple_coder_update
  0009a	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 255  : 
; 256  : 		coder->next = LZMA_NEXT_CODER_INIT;

  0009e	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:LZMA_NEXT_CODER_INIT
  000a5	48 8b 7c 24 20	 mov	 rdi, QWORD PTR coder$[rsp]
  000aa	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  000af	f3 a4		 rep movsb

; 257  : 		coder->filter = filter;

  000b1	48 8b 54 24 20	 mov	 rdx, QWORD PTR coder$[rsp]
  000b6	48 8b 44 24 68	 mov	 rax, QWORD PTR filter$[rsp]
  000bb	48 89 42 50	 mov	 QWORD PTR [rdx+80], rax

; 258  : 		coder->allocated = 2 * unfiltered_max;

  000bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR unfiltered_max$[rsp]
  000c4	48 d1 e1	 shl	 rcx, 1
  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000cc	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 259  : 
; 260  : 		// Allocate memory for filter-specific data structure.
; 261  : 		if (simple_size > 0) {

  000d0	48 83 7c 24 70
	00		 cmp	 QWORD PTR simple_size$[rsp], 0
  000d6	76 33		 jbe	 SHORT $LN6@lzma_simpl@2

; 262  : 			coder->simple = lzma_alloc(simple_size, allocator);

  000d8	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  000dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR simple_size$[rsp]
  000e2	e8 00 00 00 00	 call	 lzma_alloc
  000e7	48 8b d0	 mov	 rdx, rax
  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000ef	48 89 50 58	 mov	 QWORD PTR [rax+88], rdx

; 263  : 			if (coder->simple == NULL)

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  000f8	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  000fd	75 0a		 jne	 SHORT $LN5@lzma_simpl@2

; 264  : 				return LZMA_MEM_ERROR;

  000ff	b8 05 00 00 00	 mov	 eax, 5
  00104	e9 c0 00 00 00	 jmp	 $LN9@lzma_simpl@2
$LN5@lzma_simpl@2:

; 265  : 		} else {

  00109	eb 0d		 jmp	 SHORT $LN4@lzma_simpl@2
$LN6@lzma_simpl@2:

; 266  : 			coder->simple = NULL;

  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00110	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0
$LN4@lzma_simpl@2:
$LN8@lzma_simpl@2:

; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	if (filters[0].options != NULL) {

  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR filters$[rsp]
  0011d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00122	74 3e		 je	 SHORT $LN3@lzma_simpl@2

; 271  : 		const lzma_options_bcj *simple = filters[0].options;

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR filters$[rsp]
  00129	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012d	48 89 44 24 28	 mov	 QWORD PTR simple$33090[rsp], rax

; 272  : 		coder->now_pos = simple->start_offset;

  00132	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR simple$33090[rsp]
  0013c	8b 00		 mov	 eax, DWORD PTR [rax]
  0013e	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 273  : 		if (coder->now_pos & (alignment - 1))

  00141	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR alignment$[rsp]
  00148	83 e9 01	 sub	 ecx, 1
  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00150	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00153	23 c1		 and	 eax, ecx
  00155	85 c0		 test	 eax, eax
  00157	74 07		 je	 SHORT $LN2@lzma_simpl@2

; 274  : 			return LZMA_OPTIONS_ERROR;

  00159	b8 08 00 00 00	 mov	 eax, 8
  0015e	eb 69		 jmp	 SHORT $LN9@lzma_simpl@2
$LN2@lzma_simpl@2:

; 275  : 	} else {

  00160	eb 0c		 jmp	 SHORT $LN1@lzma_simpl@2
$LN3@lzma_simpl@2:

; 276  : 		coder->now_pos = 0;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00167	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0
$LN1@lzma_simpl@2:

; 277  : 	}
; 278  : 
; 279  : 	// Reset variables.
; 280  : 	coder->is_encoder = is_encoder;

  0016e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  00173	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR is_encoder$[rsp]
  0017b	88 41 49	 mov	 BYTE PTR [rcx+73], al

; 281  : 	coder->end_was_reached = false;

  0017e	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00183	c6 40 48 00	 mov	 BYTE PTR [rax+72], 0

; 282  : 	coder->pos = 0;

  00187	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  0018c	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 283  : 	coder->filtered = 0;

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  00199	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 284  : 	coder->size = 0;

  001a1	48 8b 44 24 20	 mov	 rax, QWORD PTR coder$[rsp]
  001a6	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 285  : 
; 286  : 	return lzma_next_filter_init(&coder->next, allocator, filters + 1);

  001b1	4c 8b 44 24 60	 mov	 r8, QWORD PTR filters$[rsp]
  001b6	49 83 c0 18	 add	 r8, 24
  001ba	48 8b 54 24 58	 mov	 rdx, QWORD PTR allocator$[rsp]
  001bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR coder$[rsp]
  001c4	e8 00 00 00 00	 call	 lzma_next_filter_init
$LN9@lzma_simpl@2:

; 287  : }

  001c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001cd	5f		 pop	 rdi
  001ce	5e		 pop	 rsi
  001cf	c3		 ret	 0
lzma_simple_coder_init ENDP
END
