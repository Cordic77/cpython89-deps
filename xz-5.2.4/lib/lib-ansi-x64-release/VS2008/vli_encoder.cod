; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzma_vli_encode
;	COMDAT pdata
; File d:\sdk\c\library\algorithms\information theory and signal processing\coding theory\lossless compression algorithms\dictionary coders\lempel–ziv\lempel–ziv–markov chain (lzma)\xz\src\c89\liblzma\common\vli_encoder.c
pdata	SEGMENT
$pdata$lzma_vli_encode DD imagerel $LN16
	DD	imagerel $LN16+417
	DD	imagerel $unwind$lzma_vli_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lzma_vli_encode DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lzma_vli_encode
_TEXT	SEGMENT
vli_pos_internal$ = 0
tv81 = 8
tv86 = 12
vli$ = 32
vli_pos$ = 40
out$ = 48
out_pos$ = 56
out_size$ = 64
lzma_vli_encode PROC					; COMDAT

; 20   : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 21   : 	// If we haven't been given vli_pos, work in single-call mode.
; 22   : 	size_t vli_pos_internal = 0;

  00018	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR vli_pos_internal$[rsp], 0

; 23   : 	if (vli_pos == NULL) {

  00020	48 83 7c 24 28
	00		 cmp	 QWORD PTR vli_pos$[rsp], 0
  00026	75 24		 jne	 SHORT $LN9@lzma_vli_e

; 24   : 		vli_pos = &vli_pos_internal;

  00028	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR vli_pos$[rsp], rax

; 25   : 
; 26   : 		// In single-call mode, we expect that the caller has
; 27   : 		// reserved enough output space.
; 28   : 		if (*out_pos >= out_size)

  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR out_size$[rsp]
  0003b	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003e	72 0a		 jb	 SHORT $LN8@lzma_vli_e

; 29   : 			return LZMA_PROG_ERROR;

  00040	b8 0b 00 00 00	 mov	 eax, 11
  00045	e9 52 01 00 00	 jmp	 $LN10@lzma_vli_e
$LN8@lzma_vli_e:

; 30   : 	} else {

  0004a	eb 19		 jmp	 SHORT $LN7@lzma_vli_e
$LN9@lzma_vli_e:

; 31   : 		// This never happens when we are called by liblzma, but
; 32   : 		// may happen if called directly from an application.
; 33   : 		if (*out_pos >= out_size)

  0004c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR out_size$[rsp]
  00056	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00059	72 0a		 jb	 SHORT $LN6@lzma_vli_e

; 34   : 			return LZMA_BUF_ERROR;

  0005b	b8 0a 00 00 00	 mov	 eax, 10
  00060	e9 37 01 00 00	 jmp	 $LN10@lzma_vli_e
$LN6@lzma_vli_e:
$LN7@lzma_vli_e:

; 35   : 	}
; 36   : 
; 37   : 	// Validate the arguments.
; 38   : 	if (*vli_pos >= LZMA_VLI_BYTES_MAX || vli > LZMA_VLI_MAX)

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR vli_pos$[rsp]
  0006a	48 83 38 09	 cmp	 QWORD PTR [rax], 9
  0006e	73 11		 jae	 SHORT $LN4@lzma_vli_e
  00070	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007a	48 39 44 24 20	 cmp	 QWORD PTR vli$[rsp], rax
  0007f	76 0a		 jbe	 SHORT $LN5@lzma_vli_e
$LN4@lzma_vli_e:

; 39   : 		return LZMA_PROG_ERROR;

  00081	b8 0b 00 00 00	 mov	 eax, 11
  00086	e9 11 01 00 00	 jmp	 $LN10@lzma_vli_e
$LN5@lzma_vli_e:

; 40   : 
; 41   : 	// Shift vli so that the next bits to encode are the lowest. In
; 42   : 	// single-call mode this never changes vli since *vli_pos is zero.
; 43   : 	vli >>= *vli_pos * 7;

  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR vli_pos$[rsp]
  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	48 6b c0 07	 imul	 rax, 7
  00097	0f b6 c8	 movzx	 ecx, al
  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR vli$[rsp]
  0009f	48 d3 e8	 shr	 rax, cl
  000a2	48 89 44 24 20	 mov	 QWORD PTR vli$[rsp], rax
$LN3@lzma_vli_e:

; 44   : 
; 45   : 	// Write the non-last bytes in a loop.
; 46   : 	while (vli >= 0x80) {

  000a7	48 81 7c 24 20
	80 00 00 00	 cmp	 QWORD PTR vli$[rsp], 128 ; 00000080H
  000b0	0f 82 88 00 00
	00		 jb	 $LN2@lzma_vli_e

; 47   : 		// We don't need *vli_pos during this function call anymore,
; 48   : 		// but update it here so that it is ready if we need to
; 49   : 		// return before the whole integer has been decoded.
; 50   : 		++*vli_pos;

  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vli_pos$[rsp]
  000bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000be	48 83 c1 01	 add	 rcx, 1
  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR vli_pos$[rsp]
  000c7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 51   : 		assert(*vli_pos < LZMA_VLI_BYTES_MAX);
; 52   : 
; 53   : 		// Write the next byte.
; 54   : 		out[*out_pos] = (uint8_t)(vli) | 0x80;

  000ca	0f b6 54 24 20	 movzx	 edx, BYTE PTR vli$[rsp]
  000cf	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000e2	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 55   : 		vli >>= 7;

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR vli$[rsp]
  000ea	48 c1 e8 07	 shr	 rax, 7
  000ee	48 89 44 24 20	 mov	 QWORD PTR vli$[rsp], rax

; 56   : 
; 57   : 		if (++*out_pos == out_size)

  000f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  000f8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fb	48 83 c1 01	 add	 rcx, 1
  000ff	48 8b 44 24 38	 mov	 rax, QWORD PTR out_pos$[rsp]
  00104	48 89 08	 mov	 QWORD PTR [rax], rcx
  00107	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR out_size$[rsp]
  00111	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00114	75 23		 jne	 SHORT $LN1@lzma_vli_e

; 58   : 			return vli_pos == &vli_pos_internal
; 59   : 					? LZMA_PROG_ERROR : LZMA_OK;

  00116	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  0011a	48 39 44 24 28	 cmp	 QWORD PTR vli_pos$[rsp], rax
  0011f	75 0a		 jne	 SHORT $LN12@lzma_vli_e
  00121	c7 44 24 08 0b
	00 00 00	 mov	 DWORD PTR tv81[rsp], 11
  00129	eb 08		 jmp	 SHORT $LN13@lzma_vli_e
$LN12@lzma_vli_e:
  0012b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN13@lzma_vli_e:
  00133	8b 44 24 08	 mov	 eax, DWORD PTR tv81[rsp]
  00137	eb 63		 jmp	 SHORT $LN10@lzma_vli_e
$LN1@lzma_vli_e:

; 60   : 	}

  00139	e9 69 ff ff ff	 jmp	 $LN3@lzma_vli_e
$LN2@lzma_vli_e:

; 61   : 
; 62   : 	// Write the last byte.
; 63   : 	out[*out_pos] = (uint8_t)(vli);

  0013e	48 8b 54 24 38	 mov	 rdx, QWORD PTR out_pos$[rsp]
  00143	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00146	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0014b	0f b6 44 24 20	 movzx	 eax, BYTE PTR vli$[rsp]
  00150	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 64   : 	++*out_pos;

  00153	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out_pos$[rsp]
  00158	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0015b	48 83 c1 01	 add	 rcx, 1
  0015f	48 8b 44 24 38	 mov	 rax, QWORD PTR out_pos$[rsp]
  00164	48 89 08	 mov	 QWORD PTR [rax], rcx

; 65   : 	++*vli_pos;

  00167	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vli_pos$[rsp]
  0016c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0016f	48 83 c1 01	 add	 rcx, 1
  00173	48 8b 44 24 28	 mov	 rax, QWORD PTR vli_pos$[rsp]
  00178	48 89 08	 mov	 QWORD PTR [rax], rcx

; 66   : 
; 67   : 	return vli_pos == &vli_pos_internal ? LZMA_OK : LZMA_STREAM_END;

  0017b	48 8d 04 24	 lea	 rax, QWORD PTR vli_pos_internal$[rsp]
  0017f	48 39 44 24 28	 cmp	 QWORD PTR vli_pos$[rsp], rax
  00184	75 0a		 jne	 SHORT $LN14@lzma_vli_e
  00186	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  0018e	eb 08		 jmp	 SHORT $LN15@lzma_vli_e
$LN14@lzma_vli_e:
  00190	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
$LN15@lzma_vli_e:
  00198	8b 44 24 0c	 mov	 eax, DWORD PTR tv86[rsp]
$LN10@lzma_vli_e:

; 68   : 
; 69   : }

  0019c	48 83 c4 18	 add	 rsp, 24
  001a0	c3		 ret	 0
lzma_vli_encode ENDP
END
